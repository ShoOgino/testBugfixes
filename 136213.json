{"path":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReaderOrig();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReaderOrig();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb10b6bcde550b87d8f10e5f010bd8f3021023b6","date":1274974592,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReaderOrig();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReaderOrig();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c740bdcaf9781b9822969a3305e51cfa4eaaf673","date":1280775080,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReaderOrig();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReaderOrig();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90dd9e0118d85e8451e26b0e3c18172a42d673ce","date":1280782731,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReaderOrig();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReaderOrig();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f367dfb9086b92a13c77e2d31112c715cd4502c","date":1290190924,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReaderOrig();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReaderOrig();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e1cbd7e289dc1243c7a59e1a83d078163a147fe","date":1292268032,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n    hasVectors = true;\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e06c9d5fba0a2f937941d199d64ccb32aac502d1","date":1292411167,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n    hasVectors = true;\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter =\n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n\n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReaderOrig();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3e06be49006ecac364d39d12b9c9f74882f9b9f","date":1304289513,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter =\n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n\n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter =\n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n\n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter =\n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n\n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = \n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n          \n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"639c36565ce03aed5b0fce7c9e4448e53a1f7efd","date":1308580104,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    //nocommit Putting MERGE context here would lead to assert error. What should MergeInfo be initialized with here?\n    TermVectorsWriter termVectorsWriter =\n      new TermVectorsWriter(directory, segment, fieldInfos, new IOContext(Context.DEFAULT));\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n\n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter =\n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n\n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6f9be74ca7baaef11857ad002cad40419979516","date":1309449808,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter =\n      new TermVectorsWriter(directory, segment, fieldInfos, context);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n\n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    //nocommit Putting MERGE context here would lead to assert error. What should MergeInfo be initialized with here?\n    TermVectorsWriter termVectorsWriter =\n      new TermVectorsWriter(directory, segment, fieldInfos, new IOContext(Context.DEFAULT));\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n\n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddc4c914be86e34b54f70023f45a60fa7f04e929","date":1310115160,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter =\n      new TermVectorsWriter(directory, segment, fieldInfos, context);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n\n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter =\n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n\n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d004d0e0b3f65bb40da76d476d659d7888270e8","date":1310158940,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter =\n      new TermVectorsWriter(directory, segment, fieldInfos, context);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n\n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter =\n      new TermVectorsWriter(directory, segment, fieldInfos);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n\n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0061262413ecc163d6eebba1b5c43ab91a0c2dc5","date":1311195279,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = new TermVectorsWriter(directory, segment, fieldInfos, context);\n\n    try {\n      int idx = 0;\n      for (final MergeState.IndexReaderAndLiveDocs reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.liveDocs != null) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter =\n      new TermVectorsWriter(directory, segment, fieldInfos, context);\n\n    try {\n      int idx = 0;\n      for (final IndexReader reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.hasDeletions()) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n\n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06584e6e98d592b34e1329b384182f368d2025e8","date":1320850353,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors(SegmentWriteState).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors(SegmentWriteState segmentWriteState) throws IOException {\n    TermVectorsWriter termVectorsWriter = new TermVectorsWriter(directory, segment, mergeState.fieldInfos, context);\n    // Used for bulk-reading raw bytes for term vectors\n    int rawDocLengths[] = new int[MAX_RAW_MERGE_DOCS];\n    int rawDocLengths2[] = new int[MAX_RAW_MERGE_DOCS];\n    try {\n      int idx = 0;\n      for (final MergeState.IndexReaderAndLiveDocs reader : mergeState.readers) {\n        final SegmentReader matchingSegmentReader = mergeState.matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.liveDocs != null) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader, rawDocLengths, rawDocLengths2);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader, rawDocLengths, rawDocLengths2);\n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n    final int mergedDocs = segmentWriteState.numDocs;\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = new TermVectorsWriter(directory, segment, fieldInfos, context);\n\n    try {\n      int idx = 0;\n      for (final MergeState.IndexReaderAndLiveDocs reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.liveDocs != null) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc749c053615f5871f3b95715fe292f34e70a53","date":1321470575,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final int mergeVectors() throws IOException {\n    final TermVectorsWriter termVectorsWriter = codec.termVectorsFormat().vectorsWriter(directory, segment, context);\n    \n    try {\n      return termVectorsWriter.merge(mergeState);\n    } finally {\n      termVectorsWriter.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final int mergeVectors() throws IOException {\n    final TermVectorsWriter termVectorsWriter = codec.termVectorsFormat().vectorsWriter(directory, segment, context);\n    \n    try {\n      return termVectorsWriter.merge(mergeState);\n    } finally {\n      termVectorsWriter.close();\n    }\n  }\n\n","sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final int mergeVectors() throws IOException {\n    final TermVectorsWriter termVectorsWriter = codec.termVectorsFormat().vectorsWriter(directory, segment, context);\n    \n    try {\n      return termVectorsWriter.merge(mergeState);\n    } finally {\n      termVectorsWriter.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"e06c9d5fba0a2f937941d199d64ccb32aac502d1":["7e1cbd7e289dc1243c7a59e1a83d078163a147fe"],"0061262413ecc163d6eebba1b5c43ab91a0c2dc5":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["3cc749c053615f5871f3b95715fe292f34e70a53"],"06584e6e98d592b34e1329b384182f368d2025e8":["0061262413ecc163d6eebba1b5c43ab91a0c2dc5"],"c740bdcaf9781b9822969a3305e51cfa4eaaf673":["fb10b6bcde550b87d8f10e5f010bd8f3021023b6"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["3bb13258feba31ab676502787ab2e1779f129b7a","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"3cc749c053615f5871f3b95715fe292f34e70a53":["06584e6e98d592b34e1329b384182f368d2025e8"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["e06c9d5fba0a2f937941d199d64ccb32aac502d1","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["fb10b6bcde550b87d8f10e5f010bd8f3021023b6","e06c9d5fba0a2f937941d199d64ccb32aac502d1"],"7f367dfb9086b92a13c77e2d31112c715cd4502c":["90dd9e0118d85e8451e26b0e3c18172a42d673ce"],"fb10b6bcde550b87d8f10e5f010bd8f3021023b6":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"90dd9e0118d85e8451e26b0e3c18172a42d673ce":["c740bdcaf9781b9822969a3305e51cfa4eaaf673"],"a3776dccca01c11e7046323cfad46a3b4a471233":["e06c9d5fba0a2f937941d199d64ccb32aac502d1","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b6f9be74ca7baaef11857ad002cad40419979516":["639c36565ce03aed5b0fce7c9e4448e53a1f7efd"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":["a3776dccca01c11e7046323cfad46a3b4a471233","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["b3e06be49006ecac364d39d12b9c9f74882f9b9f","b6f9be74ca7baaef11857ad002cad40419979516"],"7e1cbd7e289dc1243c7a59e1a83d078163a147fe":["7f367dfb9086b92a13c77e2d31112c715cd4502c"],"3bb13258feba31ab676502787ab2e1779f129b7a":["90dd9e0118d85e8451e26b0e3c18172a42d673ce","7f367dfb9086b92a13c77e2d31112c715cd4502c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"e06c9d5fba0a2f937941d199d64ccb32aac502d1":["b3e06be49006ecac364d39d12b9c9f74882f9b9f","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","a3776dccca01c11e7046323cfad46a3b4a471233"],"0061262413ecc163d6eebba1b5c43ab91a0c2dc5":["06584e6e98d592b34e1329b384182f368d2025e8"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"06584e6e98d592b34e1329b384182f368d2025e8":["3cc749c053615f5871f3b95715fe292f34e70a53"],"c740bdcaf9781b9822969a3305e51cfa4eaaf673":["90dd9e0118d85e8451e26b0e3c18172a42d673ce"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":[],"3cc749c053615f5871f3b95715fe292f34e70a53":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["135621f3a0670a9394eb563224a3b76cc4dddc0f","639c36565ce03aed5b0fce7c9e4448e53a1f7efd","a3776dccca01c11e7046323cfad46a3b4a471233","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["b6f9be74ca7baaef11857ad002cad40419979516"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"7f367dfb9086b92a13c77e2d31112c715cd4502c":["7e1cbd7e289dc1243c7a59e1a83d078163a147fe","3bb13258feba31ab676502787ab2e1779f129b7a"],"fb10b6bcde550b87d8f10e5f010bd8f3021023b6":["c740bdcaf9781b9822969a3305e51cfa4eaaf673","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"90dd9e0118d85e8451e26b0e3c18172a42d673ce":["7f367dfb9086b92a13c77e2d31112c715cd4502c","3bb13258feba31ab676502787ab2e1779f129b7a"],"a3776dccca01c11e7046323cfad46a3b4a471233":["5d004d0e0b3f65bb40da76d476d659d7888270e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"b6f9be74ca7baaef11857ad002cad40419979516":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":[],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["0061262413ecc163d6eebba1b5c43ab91a0c2dc5","5d004d0e0b3f65bb40da76d476d659d7888270e8"],"7e1cbd7e289dc1243c7a59e1a83d078163a147fe":["e06c9d5fba0a2f937941d199d64ccb32aac502d1"],"3bb13258feba31ab676502787ab2e1779f129b7a":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["fb10b6bcde550b87d8f10e5f010bd8f3021023b6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["135621f3a0670a9394eb563224a3b76cc4dddc0f","5d004d0e0b3f65bb40da76d476d659d7888270e8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}