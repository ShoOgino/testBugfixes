{"path":"sandbox/contributions/webcrawler-LARM/src/HTTPClient/HTTPConnection#enableSSLTunneling(Socket[],Request,int).mjava","commits":[{"id":"05d36e0b328ec96237035fbcca240e73631396e5","date":1020520725,"type":0,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"sandbox/contributions/webcrawler-LARM/src/HTTPClient/HTTPConnection#enableSSLTunneling(Socket[],Request,int).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Enable SSL Tunneling if we're talking to a proxy. See ietf draft\n     * draft-luotonen-ssl-tunneling-03 for more info.\n     *\n     * @param sock                 the socket\n     * @param req                  the request initiating this connection\n     * @param timeout              the timeout\n     * @return                     the proxy's last response if unsuccessful, or\n     *      null if tunnel successfuly established\n     * @exception IOException\n     * @exception ModuleException\n     */\n    private Response enableSSLTunneling(Socket[] sock, Request req, int timeout)\n        throws IOException, ModuleException\n    {\n        // copy User-Agent and Proxy-Auth headers from request\n\n        Vector hdrs = new Vector();\n        for (int idx = 0; idx < req.getHeaders().length; idx++)\n        {\n            String name = req.getHeaders()[idx].getName();\n            if (name.equalsIgnoreCase(\"User-Agent\") ||\n                    name.equalsIgnoreCase(\"Proxy-Authorization\"))\n            {\n                hdrs.addElement(req.getHeaders()[idx]);\n            }\n        }\n\n        // create initial CONNECT subrequest\n\n        NVPair[] h = new NVPair[hdrs.size()];\n        hdrs.copyInto(h);\n        Request connect = new Request(this, \"CONNECT\", Host + \":\" + Port, h,\n                null, null, req.allowUI());\n        connect.internal_subrequest = true;\n\n        ByteArrayOutputStream hdr_buf = new ByteArrayOutputStream(600);\n        HTTPResponse r = new HTTPResponse(gen_mod_insts(), timeout, connect, defaultIncrement);\n\n        // send and handle CONNECT request until successful or tired\n\n        Response resp = null;\n\n        while (true)\n        {\n            handleRequest(connect, r, resp, true);\n\n            hdr_buf.reset();\n            assembleHeaders(connect, hdr_buf);\n\n            Log.write(Log.CONN, \"Conn:  Sending SSL-Tunneling Subrequest: \",\n                    hdr_buf);\n\n            // send CONNECT\n\n            hdr_buf.writeTo(sock[0].getOutputStream());\n\n            // return if successful\n\n            resp = new Response(connect, sock[0].getInputStream());\n            if (resp.getStatusCode() == 200)\n            {\n                return null;\n            }\n\n            // failed!\n\n            // make life easy: read data and close socket\n\n            try\n            {\n                resp.getData();\n            }\n            catch (IOException ioe)\n            {\n            }\n            try\n            {\n                sock[0].close();\n            }\n            catch (IOException ioe)\n            {\n            }\n\n            // handle response\n\n            r.set(connect, resp);\n            if (!r.handleResponse())\n            {\n                return resp;\n            }\n\n            sock[0] = getSocket(timeout);\n        }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"afc16d717d9ed1a8e45371668ca6de674164d624","date":1103345442,"type":4,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"/dev/null","pathOld":"sandbox/contributions/webcrawler-LARM/src/HTTPClient/HTTPConnection#enableSSLTunneling(Socket[],Request,int).mjava","sourceNew":null,"sourceOld":"    /**\n     * Enable SSL Tunneling if we're talking to a proxy. See ietf draft\n     * draft-luotonen-ssl-tunneling-03 for more info.\n     *\n     * @param sock                 the socket\n     * @param req                  the request initiating this connection\n     * @param timeout              the timeout\n     * @return                     the proxy's last response if unsuccessful, or\n     *      null if tunnel successfuly established\n     * @exception IOException\n     * @exception ModuleException\n     */\n    private Response enableSSLTunneling(Socket[] sock, Request req, int timeout)\n        throws IOException, ModuleException\n    {\n        // copy User-Agent and Proxy-Auth headers from request\n\n        Vector hdrs = new Vector();\n        for (int idx = 0; idx < req.getHeaders().length; idx++)\n        {\n            String name = req.getHeaders()[idx].getName();\n            if (name.equalsIgnoreCase(\"User-Agent\") ||\n                    name.equalsIgnoreCase(\"Proxy-Authorization\"))\n            {\n                hdrs.addElement(req.getHeaders()[idx]);\n            }\n        }\n\n        // create initial CONNECT subrequest\n\n        NVPair[] h = new NVPair[hdrs.size()];\n        hdrs.copyInto(h);\n        Request connect = new Request(this, \"CONNECT\", Host + \":\" + Port, h,\n                null, null, req.allowUI());\n        connect.internal_subrequest = true;\n\n        ByteArrayOutputStream hdr_buf = new ByteArrayOutputStream(600);\n        HTTPResponse r = new HTTPResponse(gen_mod_insts(), timeout, connect, defaultIncrement);\n\n        // send and handle CONNECT request until successful or tired\n\n        Response resp = null;\n\n        while (true)\n        {\n            handleRequest(connect, r, resp, true);\n\n            hdr_buf.reset();\n            assembleHeaders(connect, hdr_buf);\n\n            Log.write(Log.CONN, \"Conn:  Sending SSL-Tunneling Subrequest: \",\n                    hdr_buf);\n\n            // send CONNECT\n\n            hdr_buf.writeTo(sock[0].getOutputStream());\n\n            // return if successful\n\n            resp = new Response(connect, sock[0].getInputStream());\n            if (resp.getStatusCode() == 200)\n            {\n                return null;\n            }\n\n            // failed!\n\n            // make life easy: read data and close socket\n\n            try\n            {\n                resp.getData();\n            }\n            catch (IOException ioe)\n            {\n            }\n            try\n            {\n                sock[0].close();\n            }\n            catch (IOException ioe)\n            {\n            }\n\n            // handle response\n\n            r.set(connect, resp);\n            if (!r.handleResponse())\n            {\n                return resp;\n            }\n\n            sock[0] = getSocket(timeout);\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"afc16d717d9ed1a8e45371668ca6de674164d624":["05d36e0b328ec96237035fbcca240e73631396e5"],"05d36e0b328ec96237035fbcca240e73631396e5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["afc16d717d9ed1a8e45371668ca6de674164d624"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["05d36e0b328ec96237035fbcca240e73631396e5"],"afc16d717d9ed1a8e45371668ca6de674164d624":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"05d36e0b328ec96237035fbcca240e73631396e5":["afc16d717d9ed1a8e45371668ca6de674164d624"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}