{"path":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","commits":[{"id":"2f8247163846f78e14d325499507cc0a7d5821e2","date":1353984869,"type":1,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,Filter,Collector).mjava","sourceNew":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(final Query query, \n                                     final ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    Filter luceneFilter = filter.filter;\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, luceneFilter, collector);\n    } catch (TimeLimitingCollector.TimeExceededException x) {\n      partialResults = true;\n      logger.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","sourceOld":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(final Query query, final Filter luceneFilter, Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    try {\n      searcher.search(query, luceneFilter, collector);\n    } catch (TimeLimitingCollector.TimeExceededException x) {\n      partialResults = true;\n      logger.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(final Query query, \n                                     final ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    Filter luceneFilter = filter.filter;\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, luceneFilter, collector);\n    } catch (TimeLimitingCollector.TimeExceededException x) {\n      partialResults = true;\n      logger.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f001da93ec624cbfbf3655c529836b5b1ec1aa46","date":1412885266,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","sourceNew":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(final Query query, \n                                     final ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    Filter luceneFilter = filter.filter;\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, luceneFilter, collector);\n    } catch (TimeLimitingCollector.TimeExceededException x) {\n      partialResults = true;\n      logger.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n    } catch (ExitableDirectoryReader.ExitingReaderException e) {\n      partialResults = true;\n      logger.warn( \"Query: \" + query + \"; \" + e.getMessage() );\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","sourceOld":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(final Query query, \n                                     final ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    Filter luceneFilter = filter.filter;\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, luceneFilter, collector);\n    } catch (TimeLimitingCollector.TimeExceededException x) {\n      partialResults = true;\n      logger.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","sourceNew":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(final Query query, \n                                     final ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    Filter luceneFilter = filter.filter;\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, luceneFilter, collector);\n    } catch (TimeLimitingCollector.TimeExceededException x) {\n      partialResults = true;\n      logger.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n    } catch (ExitableDirectoryReader.ExitingReaderException e) {\n      partialResults = true;\n      logger.warn( \"Query: \" + query + \"; \" + e.getMessage() );\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","sourceOld":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(final Query query, \n                                     final ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    Filter luceneFilter = filter.filter;\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, luceneFilter, collector);\n    } catch (TimeLimitingCollector.TimeExceededException x) {\n      partialResults = true;\n      logger.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6e1dc1bb4254226c8d7151b596cc1be40671751","date":1421876355,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","sourceNew":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(final Query query, \n                                     final ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    Filter luceneFilter = filter.filter;\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, luceneFilter, collector);\n    } catch (TimeLimitingCollector.TimeExceededException | ExitableDirectoryReader.ExitingReaderException x) {\n      partialResults = true;\n      logger.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","sourceOld":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(final Query query, \n                                     final ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    Filter luceneFilter = filter.filter;\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, luceneFilter, collector);\n    } catch (TimeLimitingCollector.TimeExceededException x) {\n      partialResults = true;\n      logger.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n    } catch (ExitableDirectoryReader.ExitingReaderException e) {\n      partialResults = true;\n      logger.warn( \"Query: \" + query + \"; \" + e.getMessage() );\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc","date":1424799790,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","sourceNew":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(Query query, \n                                     ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    if (filter.filter != null) {\n      query = new FilteredQuery(query, filter.filter);\n    }\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, collector);\n    } catch (TimeLimitingCollector.TimeExceededException | ExitableDirectoryReader.ExitingReaderException x) {\n      partialResults = true;\n      logger.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","sourceOld":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(final Query query, \n                                     final ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    Filter luceneFilter = filter.filter;\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, luceneFilter, collector);\n    } catch (TimeLimitingCollector.TimeExceededException | ExitableDirectoryReader.ExitingReaderException x) {\n      partialResults = true;\n      logger.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1db68e96dd908fcd79ef809095822736aa601d08","date":1434630596,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","sourceNew":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(Query query, \n                                     ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    if (filter.filter != null) {\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(filter.filter, Occur.FILTER)\n          .build();\n    }\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, collector);\n    } catch (TimeLimitingCollector.TimeExceededException | ExitableDirectoryReader.ExitingReaderException x) {\n      partialResults = true;\n      logger.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","sourceOld":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(Query query, \n                                     ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    if (filter.filter != null) {\n      query = new FilteredQuery(query, filter.filter);\n    }\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, collector);\n    } catch (TimeLimitingCollector.TimeExceededException | ExitableDirectoryReader.ExitingReaderException x) {\n      partialResults = true;\n      logger.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c80f6f4fe2e841ba56e6ce200951063ab91196d3","date":1533052731,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","sourceNew":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(Query query, \n                                     ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    if (filter.filter != null) {\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(filter.filter, Occur.FILTER)\n          .build();\n    }\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, collector);\n    } catch (TimeLimitingCollector.TimeExceededException | ExitableDirectoryReader.ExitingReaderException x) {\n      partialResults = true;\n      log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","sourceOld":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(Query query, \n                                     ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    if (filter.filter != null) {\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(filter.filter, Occur.FILTER)\n          .build();\n    }\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, collector);\n    } catch (TimeLimitingCollector.TimeExceededException | ExitableDirectoryReader.ExitingReaderException x) {\n      partialResults = true;\n      logger.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c4d4ec3bca82c8eac712592ab518cd082026f34","date":1585956055,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","sourceNew":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(Query query, \n                                     ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    query = QueryUtils.combineQueryAndFilter(query, filter.filter);\n\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, collector);\n    } catch (TimeLimitingCollector.TimeExceededException | ExitableDirectoryReader.ExitingReaderException x) {\n      partialResults = true;\n      log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","sourceOld":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(Query query, \n                                     ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    if (filter.filter != null) {\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(filter.filter, Occur.FILTER)\n          .build();\n    }\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, collector);\n    } catch (TimeLimitingCollector.TimeExceededException | ExitableDirectoryReader.ExitingReaderException x) {\n      partialResults = true;\n      log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54faedfb0e03479a38f5ee82f2dfaeea536e9404","date":1587251295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","sourceNew":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(Query query, \n                                     ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    query = QueryUtils.combineQueryAndFilter(query, filter.filter);\n\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, collector);\n    } catch (TimeLimitingCollector.TimeExceededException | ExitableDirectoryReader.ExitingReaderException x) {\n      partialResults = true;\n      if (log.isWarnEnabled()) {\n        log.warn(\"Query: {}; {}\", query, x.getMessage());\n      }\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","sourceOld":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(Query query, \n                                     ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    query = QueryUtils.combineQueryAndFilter(query, filter.filter);\n\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, collector);\n    } catch (TimeLimitingCollector.TimeExceededException | ExitableDirectoryReader.ExitingReaderException x) {\n      partialResults = true;\n      log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","sourceNew":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(Query query, \n                                     ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    query = QueryUtils.combineQueryAndFilter(query, filter.filter);\n\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, collector);\n    } catch (TimeLimitingCollector.TimeExceededException | ExitableDirectoryReader.ExitingReaderException x) {\n      partialResults = true;\n      log.warn(\"Query: {}; {}\", query, x.getMessage());\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","sourceOld":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(Query query, \n                                     ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    query = QueryUtils.combineQueryAndFilter(query, filter.filter);\n\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, collector);\n    } catch (TimeLimitingCollector.TimeExceededException | ExitableDirectoryReader.ExitingReaderException x) {\n      partialResults = true;\n      if (log.isWarnEnabled()) {\n        log.warn(\"Query: {}; {}\", query, x.getMessage());\n      }\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57c238f5fb83803b49b37b3a1a12224a64d47542","date":1593655679,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/CommandHandler#searchWithTimeLimiter(Query,ProcessedFilter,Collector).mjava","sourceNew":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(Query query, \n                                     ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    query = QueryUtils.combineQueryAndFilter(query, filter.filter);\n\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, collector);\n    } catch (TimeLimitingCollector.TimeExceededException | ExitableDirectoryReader.ExitingReaderException x) {\n      partialResults = true;\n      log.warn(\"Query: {}; \", query, x);\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","sourceOld":"  /**\n   * Invokes search with the specified filter and collector.  \n   * If a time limit has been specified then wrap the collector in the TimeLimitingCollector\n   */\n  private void searchWithTimeLimiter(Query query, \n                                     ProcessedFilter filter, \n                                     Collector collector) throws IOException {\n    if (queryCommand.getTimeAllowed() > 0 ) {\n      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), queryCommand.getTimeAllowed());\n    }\n\n    TotalHitCountCollector hitCountCollector = new TotalHitCountCollector();\n    if (includeHitCount) {\n      collector = MultiCollector.wrap(collector, hitCountCollector);\n    }\n\n    query = QueryUtils.combineQueryAndFilter(query, filter.filter);\n\n    if (filter.postFilter != null) {\n      filter.postFilter.setLastDelegate(collector);\n      collector = filter.postFilter;\n    }\n\n    try {\n      searcher.search(query, collector);\n    } catch (TimeLimitingCollector.TimeExceededException | ExitableDirectoryReader.ExitingReaderException x) {\n      partialResults = true;\n      log.warn(\"Query: {}; {}\", query, x.getMessage());\n    }\n\n    if (includeHitCount) {\n      totalHitCount = hitCountCollector.getTotalHits();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c6e1dc1bb4254226c8d7151b596cc1be40671751":["f001da93ec624cbfbf3655c529836b5b1ec1aa46"],"55980207f1977bd1463465de1659b821347e2fa8":["2f8247163846f78e14d325499507cc0a7d5821e2","f001da93ec624cbfbf3655c529836b5b1ec1aa46"],"407687e67faf6e1f02a211ca078d8e3eed631027":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2f8247163846f78e14d325499507cc0a7d5821e2"],"57c238f5fb83803b49b37b3a1a12224a64d47542":["575e66bd4b2349209027f6801184da7fc3cba13f"],"575e66bd4b2349209027f6801184da7fc3cba13f":["54faedfb0e03479a38f5ee82f2dfaeea536e9404"],"2f8247163846f78e14d325499507cc0a7d5821e2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c80f6f4fe2e841ba56e6ce200951063ab91196d3":["1db68e96dd908fcd79ef809095822736aa601d08"],"54faedfb0e03479a38f5ee82f2dfaeea536e9404":["5c4d4ec3bca82c8eac712592ab518cd082026f34"],"1db68e96dd908fcd79ef809095822736aa601d08":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["c6e1dc1bb4254226c8d7151b596cc1be40671751"],"f001da93ec624cbfbf3655c529836b5b1ec1aa46":["2f8247163846f78e14d325499507cc0a7d5821e2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5c4d4ec3bca82c8eac712592ab518cd082026f34":["c80f6f4fe2e841ba56e6ce200951063ab91196d3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["57c238f5fb83803b49b37b3a1a12224a64d47542"]},"commit2Childs":{"c6e1dc1bb4254226c8d7151b596cc1be40671751":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"55980207f1977bd1463465de1659b821347e2fa8":[],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"57c238f5fb83803b49b37b3a1a12224a64d47542":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"575e66bd4b2349209027f6801184da7fc3cba13f":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"2f8247163846f78e14d325499507cc0a7d5821e2":["55980207f1977bd1463465de1659b821347e2fa8","407687e67faf6e1f02a211ca078d8e3eed631027","f001da93ec624cbfbf3655c529836b5b1ec1aa46"],"c80f6f4fe2e841ba56e6ce200951063ab91196d3":["5c4d4ec3bca82c8eac712592ab518cd082026f34"],"54faedfb0e03479a38f5ee82f2dfaeea536e9404":["575e66bd4b2349209027f6801184da7fc3cba13f"],"1db68e96dd908fcd79ef809095822736aa601d08":["c80f6f4fe2e841ba56e6ce200951063ab91196d3"],"f001da93ec624cbfbf3655c529836b5b1ec1aa46":["c6e1dc1bb4254226c8d7151b596cc1be40671751","55980207f1977bd1463465de1659b821347e2fa8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["407687e67faf6e1f02a211ca078d8e3eed631027","2f8247163846f78e14d325499507cc0a7d5821e2"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["1db68e96dd908fcd79ef809095822736aa601d08"],"5c4d4ec3bca82c8eac712592ab518cd082026f34":["54faedfb0e03479a38f5ee82f2dfaeea536e9404"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["55980207f1977bd1463465de1659b821347e2fa8","407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}