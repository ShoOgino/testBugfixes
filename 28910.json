{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testTwoThreadsInterruptDeadlock().mjava","commits":[{"id":"8513e9b4abbea20a66169369bb7c9ea1f9365def","date":1369253402,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testTwoThreadsInterruptDeadlock().mjava","pathOld":"/dev/null","sourceNew":"  /** testThreadInterruptDeadlock but with 2 indexer threads */\n  public void testTwoThreadsInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t1 = new IndexerThreadInterrupt();\n    t1.setDaemon(true);\n    t1.start();\n    \n    IndexerThreadInterrupt t2 = new IndexerThreadInterrupt();\n    t2.setDaemon(true);\n    t2.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(300);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      IndexerThreadInterrupt t = random().nextBoolean() ? t1 : t2;\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t1.isAlive() && !t2.isAlive()) {\n        break;\n      }\n    }\n    t1.finish = true;\n    t2.finish = true;\n    t1.join();\n    t2.join();\n    assertFalse(t1.failed);\n    assertFalse(t2.failed);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13","date":1409346855,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testTwoThreadsInterruptDeadlock().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testTwoThreadsInterruptDeadlock().mjava","sourceNew":"  /** testThreadInterruptDeadlock but with 2 indexer threads */\n  public void testTwoThreadsInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t1 = new IndexerThreadInterrupt(1);\n    t1.setDaemon(true);\n    t1.start();\n    \n    IndexerThreadInterrupt t2 = new IndexerThreadInterrupt(2);\n    t2.setDaemon(true);\n    t2.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(300);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      IndexerThreadInterrupt t = random().nextBoolean() ? t1 : t2;\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t1.isAlive() && !t2.isAlive()) {\n        break;\n      }\n    }\n    t1.finish = true;\n    t2.finish = true;\n    t1.join();\n    t2.join();\n    if (t1.failed) {\n      System.out.println(\"Thread1 failed:\\n\" + new String(t1.bytesLog.toString(\"UTF-8\")));\n    }\n    if (t2.failed) {\n      System.out.println(\"Thread2 failed:\\n\" + new String(t2.bytesLog.toString(\"UTF-8\")));\n    }\n    assertFalse(t1.failed || t2.failed);\n  }\n\n","sourceOld":"  /** testThreadInterruptDeadlock but with 2 indexer threads */\n  public void testTwoThreadsInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t1 = new IndexerThreadInterrupt();\n    t1.setDaemon(true);\n    t1.start();\n    \n    IndexerThreadInterrupt t2 = new IndexerThreadInterrupt();\n    t2.setDaemon(true);\n    t2.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(300);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      IndexerThreadInterrupt t = random().nextBoolean() ? t1 : t2;\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t1.isAlive() && !t2.isAlive()) {\n        break;\n      }\n    }\n    t1.finish = true;\n    t2.finish = true;\n    t1.join();\n    t2.join();\n    assertFalse(t1.failed);\n    assertFalse(t2.failed);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ae6725e6ae382af525653dca26303eb0661c71f","date":1417051373,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter#testTwoThreadsInterruptDeadlock().mjava","sourceNew":null,"sourceOld":"  /** testThreadInterruptDeadlock but with 2 indexer threads */\n  public void testTwoThreadsInterruptDeadlock() throws Exception {\n    IndexerThreadInterrupt t1 = new IndexerThreadInterrupt(1);\n    t1.setDaemon(true);\n    t1.start();\n    \n    IndexerThreadInterrupt t2 = new IndexerThreadInterrupt(2);\n    t2.setDaemon(true);\n    t2.start();\n\n    // Force class loader to load ThreadInterruptedException\n    // up front... else we can see a false failure if 2nd\n    // interrupt arrives while class loader is trying to\n    // init this class (in servicing a first interrupt):\n    assertTrue(new ThreadInterruptedException(new InterruptedException()).getCause() instanceof InterruptedException);\n\n    // issue 300 interrupts to child thread\n    final int numInterrupts = atLeast(300);\n    int i = 0;\n    while(i < numInterrupts) {\n      // TODO: would be nice to also sometimes interrupt the\n      // CMS merge threads too ...\n      Thread.sleep(10);\n      IndexerThreadInterrupt t = random().nextBoolean() ? t1 : t2;\n      if (t.allowInterrupt) {\n        i++;\n        t.interrupt();\n      }\n      if (!t1.isAlive() && !t2.isAlive()) {\n        break;\n      }\n    }\n    t1.finish = true;\n    t2.finish = true;\n    t1.join();\n    t2.join();\n    if (t1.failed) {\n      System.out.println(\"Thread1 failed:\\n\" + new String(t1.bytesLog.toString(\"UTF-8\")));\n    }\n    if (t2.failed) {\n      System.out.println(\"Thread2 failed:\\n\" + new String(t2.bytesLog.toString(\"UTF-8\")));\n    }\n    assertFalse(t1.failed || t2.failed);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9ae6725e6ae382af525653dca26303eb0661c71f":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["8513e9b4abbea20a66169369bb7c9ea1f9365def"],"8513e9b4abbea20a66169369bb7c9ea1f9365def":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9ae6725e6ae382af525653dca26303eb0661c71f"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8513e9b4abbea20a66169369bb7c9ea1f9365def"],"9ae6725e6ae382af525653dca26303eb0661c71f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["9ae6725e6ae382af525653dca26303eb0661c71f"],"8513e9b4abbea20a66169369bb7c9ea1f9365def":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}