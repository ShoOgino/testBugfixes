{"path":"solr/core/src/test/org/apache/solr/search/TestRankQueryPlugin.TestMergeStrategy#merge(ResponseBuilder,ShardRequest).mjava","commits":[{"id":"6c70567cc1ae757045c80cb458b0b2a2ffcf0141","date":1400098332,"type":0,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRankQueryPlugin.TestMergeStrategy#merge(ResponseBuilder,ShardRequest).mjava","pathOld":"/dev/null","sourceNew":"    public void merge(ResponseBuilder rb, ShardRequest sreq) {\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n\n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      List<ShardDoc> shardDocs = new ArrayList();\n\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n\n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n          shardDocs.add(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n      Collections.sort(shardDocs, new Comparator<ShardDoc>() {\n        @Override\n        public int compare(ShardDoc o1, ShardDoc o2) {\n          if(o1.score < o2.score) {\n            return 1;\n          } else if (o1.score > o2.score) {\n            return -1;\n          } else {\n            return 0;  //To change body of implemented methods use File | Settings | File Templates.\n          }\n        }\n      });\n\n      int resultSize = shardDocs.size();\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=0; i<shardDocs.size(); i++) {\n        ShardDoc shardDoc = shardDocs.get(i);\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(0);\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ccc69a67d5c846a04c7f71e28cb1914e3af895f3","date":1400252660,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRankQueryPlugin.TestMergeStrategy#merge(ResponseBuilder,ShardRequest).mjava","pathOld":"/dev/null","sourceNew":"    public void merge(ResponseBuilder rb, ShardRequest sreq) {\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n\n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      List<ShardDoc> shardDocs = new ArrayList();\n\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n\n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n          shardDocs.add(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n      Collections.sort(shardDocs, new Comparator<ShardDoc>() {\n        @Override\n        public int compare(ShardDoc o1, ShardDoc o2) {\n          if(o1.score < o2.score) {\n            return 1;\n          } else if (o1.score > o2.score) {\n            return -1;\n          } else {\n            return 0;  //To change body of implemented methods use File | Settings | File Templates.\n          }\n        }\n      });\n\n      int resultSize = shardDocs.size();\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=0; i<shardDocs.size(); i++) {\n        ShardDoc shardDoc = shardDocs.get(i);\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(0);\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83b038ad0480d5e81e058bf9fafb2dd85399985d","date":1450812495,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRankQueryPlugin.TestMergeStrategy#merge(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRankQueryPlugin.TestMergeStrategy#merge(ResponseBuilder,ShardRequest).mjava","sourceNew":"    public void merge(ResponseBuilder rb, ShardRequest sreq) {\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n\n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      List<ShardDoc> shardDocs = new ArrayList();\n\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n\n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n          partialResults = true;\n        }\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n          shardDocs.add(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n      Collections.sort(shardDocs, new Comparator<ShardDoc>() {\n        @Override\n        public int compare(ShardDoc o1, ShardDoc o2) {\n          if(o1.score < o2.score) {\n            return 1;\n          } else if (o1.score > o2.score) {\n            return -1;\n          } else {\n            return 0;  //To change body of implemented methods use File | Settings | File Templates.\n          }\n        }\n      });\n\n      int resultSize = shardDocs.size();\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=0; i<shardDocs.size(); i++) {\n        ShardDoc shardDoc = shardDocs.get(i);\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(0);\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE );\n      }\n    }\n\n","sourceOld":"    public void merge(ResponseBuilder rb, ShardRequest sreq) {\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n\n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      List<ShardDoc> shardDocs = new ArrayList();\n\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n\n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(\"partialResults\"))) {\n          partialResults = true;\n        }\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n          shardDocs.add(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n      Collections.sort(shardDocs, new Comparator<ShardDoc>() {\n        @Override\n        public int compare(ShardDoc o1, ShardDoc o2) {\n          if(o1.score < o2.score) {\n            return 1;\n          } else if (o1.score > o2.score) {\n            return -1;\n          } else {\n            return 0;  //To change body of implemented methods use File | Settings | File Templates.\n          }\n        }\n      });\n\n      int resultSize = shardDocs.size();\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=0; i<shardDocs.size(); i++) {\n        ShardDoc shardDoc = shardDocs.get(i);\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(0);\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add( \"partialResults\", Boolean.TRUE );\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a0c04b71951333291abc7f317109a6a5957bd28","date":1457097827,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestRankQueryPlugin.TestMergeStrategy#merge(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRankQueryPlugin.TestMergeStrategy#merge(ResponseBuilder,ShardRequest).mjava","sourceNew":"    public void merge(ResponseBuilder rb, ShardRequest sreq) {\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n\n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      List<ShardDoc> shardDocs = new ArrayList();\n\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n\n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n          partialResults = true;\n        }\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n          shardDocs.add(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n      Collections.sort(shardDocs, (o1, o2) -> {\n        if (o1.score < o2.score) {\n          return 1;\n        } else if (o1.score > o2.score) {\n          return -1;\n        } else {\n          return 0;  //To change body of implemented methods use File | Settings | File Templates.\n        }\n      });\n\n      int resultSize = shardDocs.size();\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=0; i<shardDocs.size(); i++) {\n        ShardDoc shardDoc = shardDocs.get(i);\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(0);\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE );\n      }\n    }\n\n","sourceOld":"    public void merge(ResponseBuilder rb, ShardRequest sreq) {\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n\n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      List<ShardDoc> shardDocs = new ArrayList();\n\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n\n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n          partialResults = true;\n        }\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n          shardDocs.add(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n      Collections.sort(shardDocs, new Comparator<ShardDoc>() {\n        @Override\n        public int compare(ShardDoc o1, ShardDoc o2) {\n          if(o1.score < o2.score) {\n            return 1;\n          } else if (o1.score > o2.score) {\n            return -1;\n          } else {\n            return 0;  //To change body of implemented methods use File | Settings | File Templates.\n          }\n        }\n      });\n\n      int resultSize = shardDocs.size();\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=0; i<shardDocs.size(); i++) {\n        ShardDoc shardDoc = shardDocs.get(i);\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(0);\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE );\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd81b9f1e22432a668756e938bfb0835c1abb11b","date":1546254331,"type":5,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/RankQueryTestPlugin.TestMergeStrategy#merge(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestRankQueryPlugin.TestMergeStrategy#merge(ResponseBuilder,ShardRequest).mjava","sourceNew":"    public void merge(ResponseBuilder rb, ShardRequest sreq) {\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n\n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      List<ShardDoc> shardDocs = new ArrayList();\n\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n\n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n          partialResults = true;\n        }\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n          shardDocs.add(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n      Collections.sort(shardDocs, (o1, o2) -> {\n        if (o1.score < o2.score) {\n          return 1;\n        } else if (o1.score > o2.score) {\n          return -1;\n        } else {\n          return 0;  //To change body of implemented methods use File | Settings | File Templates.\n        }\n      });\n\n      int resultSize = shardDocs.size();\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=0; i<shardDocs.size(); i++) {\n        ShardDoc shardDoc = shardDocs.get(i);\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(0);\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE );\n      }\n    }\n\n","sourceOld":"    public void merge(ResponseBuilder rb, ShardRequest sreq) {\n\n      // id to shard mapping, to eliminate any accidental dups\n      HashMap<Object,String> uniqueDoc = new HashMap<>();\n\n\n      NamedList<Object> shardInfo = null;\n      if(rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n        shardInfo = new SimpleOrderedMap<>();\n        rb.rsp.getValues().add(ShardParams.SHARDS_INFO,shardInfo);\n      }\n\n      IndexSchema schema = rb.req.getSchema();\n      SchemaField uniqueKeyField = schema.getUniqueKeyField();\n\n      long numFound = 0;\n      Float maxScore=null;\n      boolean partialResults = false;\n      List<ShardDoc> shardDocs = new ArrayList();\n\n      for (ShardResponse srsp : sreq.responses) {\n        SolrDocumentList docs = null;\n\n        if(shardInfo!=null) {\n          SimpleOrderedMap<Object> nl = new SimpleOrderedMap<>();\n\n          if (srsp.getException() != null) {\n            Throwable t = srsp.getException();\n            if(t instanceof SolrServerException) {\n              t = ((SolrServerException)t).getCause();\n            }\n            nl.add(\"error\", t.toString() );\n            StringWriter trace = new StringWriter();\n            t.printStackTrace(new PrintWriter(trace));\n            nl.add(\"trace\", trace.toString() );\n            if (srsp.getShardAddress() != null) {\n              nl.add(\"shardAddress\", srsp.getShardAddress());\n            }\n          }\n          else {\n            docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n            nl.add(\"numFound\", docs.getNumFound());\n            nl.add(\"maxScore\", docs.getMaxScore());\n            nl.add(\"shardAddress\", srsp.getShardAddress());\n          }\n          if(srsp.getSolrResponse()!=null) {\n            nl.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n          }\n\n          shardInfo.add(srsp.getShard(), nl);\n        }\n        // now that we've added the shard info, let's only proceed if we have no error.\n        if (srsp.getException() != null) {\n          partialResults = true;\n          continue;\n        }\n\n        if (docs == null) { // could have been initialized in the shards info block above\n          docs = (SolrDocumentList)srsp.getSolrResponse().getResponse().get(\"response\");\n        }\n\n        NamedList<?> responseHeader = (NamedList<?>)srsp.getSolrResponse().getResponse().get(\"responseHeader\");\n        if (responseHeader != null && Boolean.TRUE.equals(responseHeader.get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY))) {\n          partialResults = true;\n        }\n\n        // calculate global maxScore and numDocsFound\n        if (docs.getMaxScore() != null) {\n          maxScore = maxScore==null ? docs.getMaxScore() : Math.max(maxScore, docs.getMaxScore());\n        }\n        numFound += docs.getNumFound();\n\n\n        for (int i=0; i<docs.size(); i++) {\n          SolrDocument doc = docs.get(i);\n          Object id = doc.getFieldValue(uniqueKeyField.getName());\n\n          String prevShard = uniqueDoc.put(id, srsp.getShard());\n          if (prevShard != null) {\n            // duplicate detected\n            numFound--;\n\n            // For now, just always use the first encountered since we can't currently\n            // remove the previous one added to the priority queue.  If we switched\n            // to the Java5 PriorityQueue, this would be easier.\n            continue;\n            // make which duplicate is used deterministic based on shard\n            // if (prevShard.compareTo(srsp.shard) >= 0) {\n            //  TODO: remove previous from priority queue\n            //  continue;\n            // }\n          }\n\n          ShardDoc shardDoc = new ShardDoc();\n          shardDoc.id = id;\n          shardDoc.shard = srsp.getShard();\n          shardDoc.orderInShard = i;\n          Object scoreObj = doc.getFieldValue(\"score\");\n          if (scoreObj != null) {\n            if (scoreObj instanceof String) {\n              shardDoc.score = Float.parseFloat((String)scoreObj);\n            } else {\n              shardDoc.score = (Float)scoreObj;\n            }\n          }\n          shardDocs.add(shardDoc);\n        } // end for-each-doc-in-response\n      } // end for-each-response\n\n      Collections.sort(shardDocs, (o1, o2) -> {\n        if (o1.score < o2.score) {\n          return 1;\n        } else if (o1.score > o2.score) {\n          return -1;\n        } else {\n          return 0;  //To change body of implemented methods use File | Settings | File Templates.\n        }\n      });\n\n      int resultSize = shardDocs.size();\n\n      Map<Object,ShardDoc> resultIds = new HashMap<>();\n      for (int i=0; i<shardDocs.size(); i++) {\n        ShardDoc shardDoc = shardDocs.get(i);\n        shardDoc.positionInResponse = i;\n        // Need the toString() for correlation with other lists that must\n        // be strings (like keys in highlighting, explain, etc)\n        resultIds.put(shardDoc.id.toString(), shardDoc);\n      }\n\n      // Add hits for distributed requests\n      // https://issues.apache.org/jira/browse/SOLR-3518\n      rb.rsp.addToLog(\"hits\", numFound);\n\n      SolrDocumentList responseDocs = new SolrDocumentList();\n      if (maxScore!=null) responseDocs.setMaxScore(maxScore);\n      responseDocs.setNumFound(numFound);\n      responseDocs.setStart(0);\n      // size appropriately\n      for (int i=0; i<resultSize; i++) responseDocs.add(null);\n\n      // save these results in a private area so we can access them\n      // again when retrieving stored fields.\n      // TODO: use ResponseBuilder (w/ comments) or the request context?\n      rb.resultIds = resultIds;\n      rb.setResponseDocs(responseDocs);\n\n      if (partialResults) {\n        rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE );\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bd81b9f1e22432a668756e938bfb0835c1abb11b":["3a0c04b71951333291abc7f317109a6a5957bd28"],"6c70567cc1ae757045c80cb458b0b2a2ffcf0141":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3a0c04b71951333291abc7f317109a6a5957bd28":["83b038ad0480d5e81e058bf9fafb2dd85399985d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bd81b9f1e22432a668756e938bfb0835c1abb11b"],"83b038ad0480d5e81e058bf9fafb2dd85399985d":["6c70567cc1ae757045c80cb458b0b2a2ffcf0141"],"ccc69a67d5c846a04c7f71e28cb1914e3af895f3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6c70567cc1ae757045c80cb458b0b2a2ffcf0141"]},"commit2Childs":{"bd81b9f1e22432a668756e938bfb0835c1abb11b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6c70567cc1ae757045c80cb458b0b2a2ffcf0141":["83b038ad0480d5e81e058bf9fafb2dd85399985d","ccc69a67d5c846a04c7f71e28cb1914e3af895f3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6c70567cc1ae757045c80cb458b0b2a2ffcf0141","ccc69a67d5c846a04c7f71e28cb1914e3af895f3"],"3a0c04b71951333291abc7f317109a6a5957bd28":["bd81b9f1e22432a668756e938bfb0835c1abb11b"],"83b038ad0480d5e81e058bf9fafb2dd85399985d":["3a0c04b71951333291abc7f317109a6a5957bd28"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"ccc69a67d5c846a04c7f71e28cb1914e3af895f3":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","ccc69a67d5c846a04c7f71e28cb1914e3af895f3"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}