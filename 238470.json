{"path":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestStandardAnalyzer#testLargePartiallyMatchingToken().mjava","commits":[{"id":"3c00ffa555aa637d932f7d491038cf9992403994","date":1408702746,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestStandardAnalyzer#testLargePartiallyMatchingToken().mjava","pathOld":"/dev/null","sourceNew":"  // LUCENE-5897: slow tokenization of strings of the form (\\p{WB:ExtendNumLet}[\\p{WB:Format}\\p{WB:Extend}]*)+\n  public void testLargePartiallyMatchingToken() throws Exception {\n    // TODO: get these lists of chars matching a property from ICU4J\n    // http://www.unicode.org/Public/6.3.0/ucd/auxiliary/WordBreakProperty.txt\n    char[] WordBreak_ExtendNumLet_chars = \"_\\u203f\\u2040\\u2054\\ufe33\\ufe34\\ufe4d\\ufe4e\\ufe4f\\uff3f\".toCharArray();\n\n    // http://www.unicode.org/Public/6.3.0/ucd/auxiliary/WordBreakProperty.txt\n    int[] WordBreak_Format_chars // only the first char in ranges \n        = { 0xAD, 0x600, 0x61C, 0x6DD, 0x70F, 0x180E, 0x200E, 0x202A, 0x2060, 0x2066, 0xFEFF,\n            0xFFF9, 0x110BD, 0x1D173, 0xE0001, 0xE0020 };\n\n    // http://www.unicode.org/Public/6.3.0/ucd/auxiliary/WordBreakProperty.txt\n    int[] WordBreak_Extend_chars // only the first char in ranges\n        = { 0x300, 0x483, 0x591, 0x5bf, 0x5c1, 0x5c4, 0x5c7, 0x610, 0x64b, 0x670, 0x6d6, 0x6df,\n            0x6e7, 0x6ea, 0x711, 0x730, 0x7a6, 0x7eb, 0x816, 0x81b, 0x825, 0x829, 0x859, 0x8e4,\n            0x900, 0x93a, 0x93e, 0x951, 0x962, 0x981, 0x9bc, 0x9be, 0x9c7, 0x9cb, 0x9d7, 0x9e2,\n            0xa01, 0xa3c, 0xa3e, 0xa47, 0xa4b, 0xa51, 0xa70, 0xa75, 0xa81, 0xabc, 0xabe, 0xac7,\n            0xacb, 0xae2, 0xb01, 0xb3c, 0xb3e, 0xb47, 0xb4b, 0xb56, 0xb62, 0xb82, 0xbbe, 0xbc6,\n            0xbca, 0xbd7, 0xc01, 0xc3e, 0xc46, 0xc4a, 0xc55, 0xc62, 0xc82, 0xcbc, 0xcbe, 0xcc6,\n            0xcca, 0xcd5, 0xce2, 0xd02, 0xd3e, 0xd46, 0xd4a, 0xd57, 0xd62, 0xd82, 0xdca, 0xdcf,\n            0xdd6, 0xdd8, 0xdf2, 0xe31, 0xe34, 0xe47, 0xeb1, 0xeb4, 0xebb, 0xec8, 0xf18, 0xf35,\n            0xf37, 0xf39, 0xf3e, 0xf71, 0xf86, 0xf8d, 0xf99, 0xfc6, 0x102b, 0x1056, 0x105e, 0x1062,\n            0x1067, 0x1071, 0x1082, 0x108f, 0x109a, 0x135d, 0x1712, 0x1732, 0x1752, 0x1772, 0x17b4, \n            0x17dd, 0x180b, 0x18a9, 0x1920, 0x1930, 0x19b0, 0x19c8, 0x1a17, 0x1a55, 0x1a60, 0x1a7f,\n            0x1b00, 0x1b34, 0x1b6b, 0x1b80, 0x1ba1, 0x1be6, 0x1c24, 0x1cd0, 0x1cd4, 0x1ced, 0x1cf2, \n            0x1dc0, 0x1dfc, 0x200c, 0x20d0, 0x2cef, 0x2d7f, 0x2de0, 0x302a, 0x3099, 0xa66f, 0xa674,\n            0xa69f, 0xa6f0, 0xa802, 0xa806, 0xa80b, 0xa823, 0xa880, 0xa8b4, 0xa8e0, 0xa926, 0xa947, \n            0xa980, 0xa9b3, 0xaa29, 0xaa43, 0xaa4c, 0xaa7b, 0xaab0, 0xaab2, 0xaab7, 0xaabe, 0xaac1,\n            0xaaeb, 0xaaf5, 0xabe3, 0xabec, 0xfb1e, 0xfe00, 0xfe20, 0xff9e, 0x101fd, 0x10a01,\n            0x10a05, 0x10a0C, 0x10a38, 0x10a3F, 0x11000, 0x11001, 0x11038, 0x11080, 0x11082,\n            0x110b0, 0x110b3, 0x110b7, 0x110b9, 0x11100, 0x11127, 0x1112c, 0x11180, 0x11182,\n            0x111b3, 0x111b6, 0x111bF, 0x116ab, 0x116ac, 0x116b0, 0x116b6, 0x16f51, 0x16f8f,\n            0x1d165, 0x1d167, 0x1d16d, 0x1d17b, 0x1d185, 0x1d1aa, 0x1d242, 0xe0100 }; \n        \n    StringBuilder builder = new StringBuilder();\n    int numChars = TestUtil.nextInt(random(), 100 * 1024, 1024 * 1024);\n    for (int i = 0 ; i < numChars ; ) {\n      builder.append(WordBreak_ExtendNumLet_chars[random().nextInt(WordBreak_ExtendNumLet_chars.length)]);\n      ++i;\n      if (random().nextBoolean()) {\n        int numFormatExtendChars = TestUtil.nextInt(random(), 1, 8);\n        for (int j = 0; j < numFormatExtendChars; ++j) {\n          int codepoint;\n          if (random().nextBoolean()) {\n            codepoint = WordBreak_Format_chars[random().nextInt(WordBreak_Format_chars.length)];\n          } else {\n            codepoint = WordBreak_Extend_chars[random().nextInt(WordBreak_Extend_chars.length)];\n          }\n          char[] chars = Character.toChars(codepoint);\n          builder.append(chars);\n          i += chars.length;\n        }\n      }\n    }\n    StandardTokenizer ts = new StandardTokenizer();\n    ts.setReader(new StringReader(builder.toString()));\n    ts.reset();\n    while (ts.incrementToken()) { }\n    ts.end();\n    ts.close();\n\n    int newBufferSize = TestUtil.nextInt(random(), 200, 8192);\n    ts.setMaxTokenLength(newBufferSize); // try a different buffer size\n    ts.setReader(new StringReader(builder.toString()));\n    ts.reset();\n    while (ts.incrementToken()) { }\n    ts.end();\n    ts.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91a5e37a1dee5ad8d3fe6d55228839d5d0412999","date":1412798723,"type":5,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/standard/TestStandardAnalyzer#testLargePartiallyMatchingToken().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestStandardAnalyzer#testLargePartiallyMatchingToken().mjava","sourceNew":"  // LUCENE-5897: slow tokenization of strings of the form (\\p{WB:ExtendNumLet}[\\p{WB:Format}\\p{WB:Extend}]*)+\n  public void testLargePartiallyMatchingToken() throws Exception {\n    // TODO: get these lists of chars matching a property from ICU4J\n    // http://www.unicode.org/Public/6.3.0/ucd/auxiliary/WordBreakProperty.txt\n    char[] WordBreak_ExtendNumLet_chars = \"_\\u203f\\u2040\\u2054\\ufe33\\ufe34\\ufe4d\\ufe4e\\ufe4f\\uff3f\".toCharArray();\n\n    // http://www.unicode.org/Public/6.3.0/ucd/auxiliary/WordBreakProperty.txt\n    int[] WordBreak_Format_chars // only the first char in ranges \n        = { 0xAD, 0x600, 0x61C, 0x6DD, 0x70F, 0x180E, 0x200E, 0x202A, 0x2060, 0x2066, 0xFEFF,\n            0xFFF9, 0x110BD, 0x1D173, 0xE0001, 0xE0020 };\n\n    // http://www.unicode.org/Public/6.3.0/ucd/auxiliary/WordBreakProperty.txt\n    int[] WordBreak_Extend_chars // only the first char in ranges\n        = { 0x300, 0x483, 0x591, 0x5bf, 0x5c1, 0x5c4, 0x5c7, 0x610, 0x64b, 0x670, 0x6d6, 0x6df,\n            0x6e7, 0x6ea, 0x711, 0x730, 0x7a6, 0x7eb, 0x816, 0x81b, 0x825, 0x829, 0x859, 0x8e4,\n            0x900, 0x93a, 0x93e, 0x951, 0x962, 0x981, 0x9bc, 0x9be, 0x9c7, 0x9cb, 0x9d7, 0x9e2,\n            0xa01, 0xa3c, 0xa3e, 0xa47, 0xa4b, 0xa51, 0xa70, 0xa75, 0xa81, 0xabc, 0xabe, 0xac7,\n            0xacb, 0xae2, 0xb01, 0xb3c, 0xb3e, 0xb47, 0xb4b, 0xb56, 0xb62, 0xb82, 0xbbe, 0xbc6,\n            0xbca, 0xbd7, 0xc01, 0xc3e, 0xc46, 0xc4a, 0xc55, 0xc62, 0xc82, 0xcbc, 0xcbe, 0xcc6,\n            0xcca, 0xcd5, 0xce2, 0xd02, 0xd3e, 0xd46, 0xd4a, 0xd57, 0xd62, 0xd82, 0xdca, 0xdcf,\n            0xdd6, 0xdd8, 0xdf2, 0xe31, 0xe34, 0xe47, 0xeb1, 0xeb4, 0xebb, 0xec8, 0xf18, 0xf35,\n            0xf37, 0xf39, 0xf3e, 0xf71, 0xf86, 0xf8d, 0xf99, 0xfc6, 0x102b, 0x1056, 0x105e, 0x1062,\n            0x1067, 0x1071, 0x1082, 0x108f, 0x109a, 0x135d, 0x1712, 0x1732, 0x1752, 0x1772, 0x17b4, \n            0x17dd, 0x180b, 0x18a9, 0x1920, 0x1930, 0x19b0, 0x19c8, 0x1a17, 0x1a55, 0x1a60, 0x1a7f,\n            0x1b00, 0x1b34, 0x1b6b, 0x1b80, 0x1ba1, 0x1be6, 0x1c24, 0x1cd0, 0x1cd4, 0x1ced, 0x1cf2, \n            0x1dc0, 0x1dfc, 0x200c, 0x20d0, 0x2cef, 0x2d7f, 0x2de0, 0x302a, 0x3099, 0xa66f, 0xa674,\n            0xa69f, 0xa6f0, 0xa802, 0xa806, 0xa80b, 0xa823, 0xa880, 0xa8b4, 0xa8e0, 0xa926, 0xa947, \n            0xa980, 0xa9b3, 0xaa29, 0xaa43, 0xaa4c, 0xaa7b, 0xaab0, 0xaab2, 0xaab7, 0xaabe, 0xaac1,\n            0xaaeb, 0xaaf5, 0xabe3, 0xabec, 0xfb1e, 0xfe00, 0xfe20, 0xff9e, 0x101fd, 0x10a01,\n            0x10a05, 0x10a0C, 0x10a38, 0x10a3F, 0x11000, 0x11001, 0x11038, 0x11080, 0x11082,\n            0x110b0, 0x110b3, 0x110b7, 0x110b9, 0x11100, 0x11127, 0x1112c, 0x11180, 0x11182,\n            0x111b3, 0x111b6, 0x111bF, 0x116ab, 0x116ac, 0x116b0, 0x116b6, 0x16f51, 0x16f8f,\n            0x1d165, 0x1d167, 0x1d16d, 0x1d17b, 0x1d185, 0x1d1aa, 0x1d242, 0xe0100 }; \n        \n    StringBuilder builder = new StringBuilder();\n    int numChars = TestUtil.nextInt(random(), 100 * 1024, 1024 * 1024);\n    for (int i = 0 ; i < numChars ; ) {\n      builder.append(WordBreak_ExtendNumLet_chars[random().nextInt(WordBreak_ExtendNumLet_chars.length)]);\n      ++i;\n      if (random().nextBoolean()) {\n        int numFormatExtendChars = TestUtil.nextInt(random(), 1, 8);\n        for (int j = 0; j < numFormatExtendChars; ++j) {\n          int codepoint;\n          if (random().nextBoolean()) {\n            codepoint = WordBreak_Format_chars[random().nextInt(WordBreak_Format_chars.length)];\n          } else {\n            codepoint = WordBreak_Extend_chars[random().nextInt(WordBreak_Extend_chars.length)];\n          }\n          char[] chars = Character.toChars(codepoint);\n          builder.append(chars);\n          i += chars.length;\n        }\n      }\n    }\n    StandardTokenizer ts = new StandardTokenizer();\n    ts.setReader(new StringReader(builder.toString()));\n    ts.reset();\n    while (ts.incrementToken()) { }\n    ts.end();\n    ts.close();\n\n    int newBufferSize = TestUtil.nextInt(random(), 200, 8192);\n    ts.setMaxTokenLength(newBufferSize); // try a different buffer size\n    ts.setReader(new StringReader(builder.toString()));\n    ts.reset();\n    while (ts.incrementToken()) { }\n    ts.end();\n    ts.close();\n  }\n\n","sourceOld":"  // LUCENE-5897: slow tokenization of strings of the form (\\p{WB:ExtendNumLet}[\\p{WB:Format}\\p{WB:Extend}]*)+\n  public void testLargePartiallyMatchingToken() throws Exception {\n    // TODO: get these lists of chars matching a property from ICU4J\n    // http://www.unicode.org/Public/6.3.0/ucd/auxiliary/WordBreakProperty.txt\n    char[] WordBreak_ExtendNumLet_chars = \"_\\u203f\\u2040\\u2054\\ufe33\\ufe34\\ufe4d\\ufe4e\\ufe4f\\uff3f\".toCharArray();\n\n    // http://www.unicode.org/Public/6.3.0/ucd/auxiliary/WordBreakProperty.txt\n    int[] WordBreak_Format_chars // only the first char in ranges \n        = { 0xAD, 0x600, 0x61C, 0x6DD, 0x70F, 0x180E, 0x200E, 0x202A, 0x2060, 0x2066, 0xFEFF,\n            0xFFF9, 0x110BD, 0x1D173, 0xE0001, 0xE0020 };\n\n    // http://www.unicode.org/Public/6.3.0/ucd/auxiliary/WordBreakProperty.txt\n    int[] WordBreak_Extend_chars // only the first char in ranges\n        = { 0x300, 0x483, 0x591, 0x5bf, 0x5c1, 0x5c4, 0x5c7, 0x610, 0x64b, 0x670, 0x6d6, 0x6df,\n            0x6e7, 0x6ea, 0x711, 0x730, 0x7a6, 0x7eb, 0x816, 0x81b, 0x825, 0x829, 0x859, 0x8e4,\n            0x900, 0x93a, 0x93e, 0x951, 0x962, 0x981, 0x9bc, 0x9be, 0x9c7, 0x9cb, 0x9d7, 0x9e2,\n            0xa01, 0xa3c, 0xa3e, 0xa47, 0xa4b, 0xa51, 0xa70, 0xa75, 0xa81, 0xabc, 0xabe, 0xac7,\n            0xacb, 0xae2, 0xb01, 0xb3c, 0xb3e, 0xb47, 0xb4b, 0xb56, 0xb62, 0xb82, 0xbbe, 0xbc6,\n            0xbca, 0xbd7, 0xc01, 0xc3e, 0xc46, 0xc4a, 0xc55, 0xc62, 0xc82, 0xcbc, 0xcbe, 0xcc6,\n            0xcca, 0xcd5, 0xce2, 0xd02, 0xd3e, 0xd46, 0xd4a, 0xd57, 0xd62, 0xd82, 0xdca, 0xdcf,\n            0xdd6, 0xdd8, 0xdf2, 0xe31, 0xe34, 0xe47, 0xeb1, 0xeb4, 0xebb, 0xec8, 0xf18, 0xf35,\n            0xf37, 0xf39, 0xf3e, 0xf71, 0xf86, 0xf8d, 0xf99, 0xfc6, 0x102b, 0x1056, 0x105e, 0x1062,\n            0x1067, 0x1071, 0x1082, 0x108f, 0x109a, 0x135d, 0x1712, 0x1732, 0x1752, 0x1772, 0x17b4, \n            0x17dd, 0x180b, 0x18a9, 0x1920, 0x1930, 0x19b0, 0x19c8, 0x1a17, 0x1a55, 0x1a60, 0x1a7f,\n            0x1b00, 0x1b34, 0x1b6b, 0x1b80, 0x1ba1, 0x1be6, 0x1c24, 0x1cd0, 0x1cd4, 0x1ced, 0x1cf2, \n            0x1dc0, 0x1dfc, 0x200c, 0x20d0, 0x2cef, 0x2d7f, 0x2de0, 0x302a, 0x3099, 0xa66f, 0xa674,\n            0xa69f, 0xa6f0, 0xa802, 0xa806, 0xa80b, 0xa823, 0xa880, 0xa8b4, 0xa8e0, 0xa926, 0xa947, \n            0xa980, 0xa9b3, 0xaa29, 0xaa43, 0xaa4c, 0xaa7b, 0xaab0, 0xaab2, 0xaab7, 0xaabe, 0xaac1,\n            0xaaeb, 0xaaf5, 0xabe3, 0xabec, 0xfb1e, 0xfe00, 0xfe20, 0xff9e, 0x101fd, 0x10a01,\n            0x10a05, 0x10a0C, 0x10a38, 0x10a3F, 0x11000, 0x11001, 0x11038, 0x11080, 0x11082,\n            0x110b0, 0x110b3, 0x110b7, 0x110b9, 0x11100, 0x11127, 0x1112c, 0x11180, 0x11182,\n            0x111b3, 0x111b6, 0x111bF, 0x116ab, 0x116ac, 0x116b0, 0x116b6, 0x16f51, 0x16f8f,\n            0x1d165, 0x1d167, 0x1d16d, 0x1d17b, 0x1d185, 0x1d1aa, 0x1d242, 0xe0100 }; \n        \n    StringBuilder builder = new StringBuilder();\n    int numChars = TestUtil.nextInt(random(), 100 * 1024, 1024 * 1024);\n    for (int i = 0 ; i < numChars ; ) {\n      builder.append(WordBreak_ExtendNumLet_chars[random().nextInt(WordBreak_ExtendNumLet_chars.length)]);\n      ++i;\n      if (random().nextBoolean()) {\n        int numFormatExtendChars = TestUtil.nextInt(random(), 1, 8);\n        for (int j = 0; j < numFormatExtendChars; ++j) {\n          int codepoint;\n          if (random().nextBoolean()) {\n            codepoint = WordBreak_Format_chars[random().nextInt(WordBreak_Format_chars.length)];\n          } else {\n            codepoint = WordBreak_Extend_chars[random().nextInt(WordBreak_Extend_chars.length)];\n          }\n          char[] chars = Character.toChars(codepoint);\n          builder.append(chars);\n          i += chars.length;\n        }\n      }\n    }\n    StandardTokenizer ts = new StandardTokenizer();\n    ts.setReader(new StringReader(builder.toString()));\n    ts.reset();\n    while (ts.incrementToken()) { }\n    ts.end();\n    ts.close();\n\n    int newBufferSize = TestUtil.nextInt(random(), 200, 8192);\n    ts.setMaxTokenLength(newBufferSize); // try a different buffer size\n    ts.setReader(new StringReader(builder.toString()));\n    ts.reset();\n    while (ts.incrementToken()) { }\n    ts.end();\n    ts.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/analysis/common/src/test/org/apache/lucene/analysis/standard/TestStandardAnalyzer#testLargePartiallyMatchingToken().mjava","pathOld":"lucene/analysis/common/src/test/org/apache/lucene/analysis/core/TestStandardAnalyzer#testLargePartiallyMatchingToken().mjava","sourceNew":"  // LUCENE-5897: slow tokenization of strings of the form (\\p{WB:ExtendNumLet}[\\p{WB:Format}\\p{WB:Extend}]*)+\n  public void testLargePartiallyMatchingToken() throws Exception {\n    // TODO: get these lists of chars matching a property from ICU4J\n    // http://www.unicode.org/Public/6.3.0/ucd/auxiliary/WordBreakProperty.txt\n    char[] WordBreak_ExtendNumLet_chars = \"_\\u203f\\u2040\\u2054\\ufe33\\ufe34\\ufe4d\\ufe4e\\ufe4f\\uff3f\".toCharArray();\n\n    // http://www.unicode.org/Public/6.3.0/ucd/auxiliary/WordBreakProperty.txt\n    int[] WordBreak_Format_chars // only the first char in ranges \n        = { 0xAD, 0x600, 0x61C, 0x6DD, 0x70F, 0x180E, 0x200E, 0x202A, 0x2060, 0x2066, 0xFEFF,\n            0xFFF9, 0x110BD, 0x1D173, 0xE0001, 0xE0020 };\n\n    // http://www.unicode.org/Public/6.3.0/ucd/auxiliary/WordBreakProperty.txt\n    int[] WordBreak_Extend_chars // only the first char in ranges\n        = { 0x300, 0x483, 0x591, 0x5bf, 0x5c1, 0x5c4, 0x5c7, 0x610, 0x64b, 0x670, 0x6d6, 0x6df,\n            0x6e7, 0x6ea, 0x711, 0x730, 0x7a6, 0x7eb, 0x816, 0x81b, 0x825, 0x829, 0x859, 0x8e4,\n            0x900, 0x93a, 0x93e, 0x951, 0x962, 0x981, 0x9bc, 0x9be, 0x9c7, 0x9cb, 0x9d7, 0x9e2,\n            0xa01, 0xa3c, 0xa3e, 0xa47, 0xa4b, 0xa51, 0xa70, 0xa75, 0xa81, 0xabc, 0xabe, 0xac7,\n            0xacb, 0xae2, 0xb01, 0xb3c, 0xb3e, 0xb47, 0xb4b, 0xb56, 0xb62, 0xb82, 0xbbe, 0xbc6,\n            0xbca, 0xbd7, 0xc01, 0xc3e, 0xc46, 0xc4a, 0xc55, 0xc62, 0xc82, 0xcbc, 0xcbe, 0xcc6,\n            0xcca, 0xcd5, 0xce2, 0xd02, 0xd3e, 0xd46, 0xd4a, 0xd57, 0xd62, 0xd82, 0xdca, 0xdcf,\n            0xdd6, 0xdd8, 0xdf2, 0xe31, 0xe34, 0xe47, 0xeb1, 0xeb4, 0xebb, 0xec8, 0xf18, 0xf35,\n            0xf37, 0xf39, 0xf3e, 0xf71, 0xf86, 0xf8d, 0xf99, 0xfc6, 0x102b, 0x1056, 0x105e, 0x1062,\n            0x1067, 0x1071, 0x1082, 0x108f, 0x109a, 0x135d, 0x1712, 0x1732, 0x1752, 0x1772, 0x17b4, \n            0x17dd, 0x180b, 0x18a9, 0x1920, 0x1930, 0x19b0, 0x19c8, 0x1a17, 0x1a55, 0x1a60, 0x1a7f,\n            0x1b00, 0x1b34, 0x1b6b, 0x1b80, 0x1ba1, 0x1be6, 0x1c24, 0x1cd0, 0x1cd4, 0x1ced, 0x1cf2, \n            0x1dc0, 0x1dfc, 0x200c, 0x20d0, 0x2cef, 0x2d7f, 0x2de0, 0x302a, 0x3099, 0xa66f, 0xa674,\n            0xa69f, 0xa6f0, 0xa802, 0xa806, 0xa80b, 0xa823, 0xa880, 0xa8b4, 0xa8e0, 0xa926, 0xa947, \n            0xa980, 0xa9b3, 0xaa29, 0xaa43, 0xaa4c, 0xaa7b, 0xaab0, 0xaab2, 0xaab7, 0xaabe, 0xaac1,\n            0xaaeb, 0xaaf5, 0xabe3, 0xabec, 0xfb1e, 0xfe00, 0xfe20, 0xff9e, 0x101fd, 0x10a01,\n            0x10a05, 0x10a0C, 0x10a38, 0x10a3F, 0x11000, 0x11001, 0x11038, 0x11080, 0x11082,\n            0x110b0, 0x110b3, 0x110b7, 0x110b9, 0x11100, 0x11127, 0x1112c, 0x11180, 0x11182,\n            0x111b3, 0x111b6, 0x111bF, 0x116ab, 0x116ac, 0x116b0, 0x116b6, 0x16f51, 0x16f8f,\n            0x1d165, 0x1d167, 0x1d16d, 0x1d17b, 0x1d185, 0x1d1aa, 0x1d242, 0xe0100 }; \n        \n    StringBuilder builder = new StringBuilder();\n    int numChars = TestUtil.nextInt(random(), 100 * 1024, 1024 * 1024);\n    for (int i = 0 ; i < numChars ; ) {\n      builder.append(WordBreak_ExtendNumLet_chars[random().nextInt(WordBreak_ExtendNumLet_chars.length)]);\n      ++i;\n      if (random().nextBoolean()) {\n        int numFormatExtendChars = TestUtil.nextInt(random(), 1, 8);\n        for (int j = 0; j < numFormatExtendChars; ++j) {\n          int codepoint;\n          if (random().nextBoolean()) {\n            codepoint = WordBreak_Format_chars[random().nextInt(WordBreak_Format_chars.length)];\n          } else {\n            codepoint = WordBreak_Extend_chars[random().nextInt(WordBreak_Extend_chars.length)];\n          }\n          char[] chars = Character.toChars(codepoint);\n          builder.append(chars);\n          i += chars.length;\n        }\n      }\n    }\n    StandardTokenizer ts = new StandardTokenizer();\n    ts.setReader(new StringReader(builder.toString()));\n    ts.reset();\n    while (ts.incrementToken()) { }\n    ts.end();\n    ts.close();\n\n    int newBufferSize = TestUtil.nextInt(random(), 200, 8192);\n    ts.setMaxTokenLength(newBufferSize); // try a different buffer size\n    ts.setReader(new StringReader(builder.toString()));\n    ts.reset();\n    while (ts.incrementToken()) { }\n    ts.end();\n    ts.close();\n  }\n\n","sourceOld":"  // LUCENE-5897: slow tokenization of strings of the form (\\p{WB:ExtendNumLet}[\\p{WB:Format}\\p{WB:Extend}]*)+\n  public void testLargePartiallyMatchingToken() throws Exception {\n    // TODO: get these lists of chars matching a property from ICU4J\n    // http://www.unicode.org/Public/6.3.0/ucd/auxiliary/WordBreakProperty.txt\n    char[] WordBreak_ExtendNumLet_chars = \"_\\u203f\\u2040\\u2054\\ufe33\\ufe34\\ufe4d\\ufe4e\\ufe4f\\uff3f\".toCharArray();\n\n    // http://www.unicode.org/Public/6.3.0/ucd/auxiliary/WordBreakProperty.txt\n    int[] WordBreak_Format_chars // only the first char in ranges \n        = { 0xAD, 0x600, 0x61C, 0x6DD, 0x70F, 0x180E, 0x200E, 0x202A, 0x2060, 0x2066, 0xFEFF,\n            0xFFF9, 0x110BD, 0x1D173, 0xE0001, 0xE0020 };\n\n    // http://www.unicode.org/Public/6.3.0/ucd/auxiliary/WordBreakProperty.txt\n    int[] WordBreak_Extend_chars // only the first char in ranges\n        = { 0x300, 0x483, 0x591, 0x5bf, 0x5c1, 0x5c4, 0x5c7, 0x610, 0x64b, 0x670, 0x6d6, 0x6df,\n            0x6e7, 0x6ea, 0x711, 0x730, 0x7a6, 0x7eb, 0x816, 0x81b, 0x825, 0x829, 0x859, 0x8e4,\n            0x900, 0x93a, 0x93e, 0x951, 0x962, 0x981, 0x9bc, 0x9be, 0x9c7, 0x9cb, 0x9d7, 0x9e2,\n            0xa01, 0xa3c, 0xa3e, 0xa47, 0xa4b, 0xa51, 0xa70, 0xa75, 0xa81, 0xabc, 0xabe, 0xac7,\n            0xacb, 0xae2, 0xb01, 0xb3c, 0xb3e, 0xb47, 0xb4b, 0xb56, 0xb62, 0xb82, 0xbbe, 0xbc6,\n            0xbca, 0xbd7, 0xc01, 0xc3e, 0xc46, 0xc4a, 0xc55, 0xc62, 0xc82, 0xcbc, 0xcbe, 0xcc6,\n            0xcca, 0xcd5, 0xce2, 0xd02, 0xd3e, 0xd46, 0xd4a, 0xd57, 0xd62, 0xd82, 0xdca, 0xdcf,\n            0xdd6, 0xdd8, 0xdf2, 0xe31, 0xe34, 0xe47, 0xeb1, 0xeb4, 0xebb, 0xec8, 0xf18, 0xf35,\n            0xf37, 0xf39, 0xf3e, 0xf71, 0xf86, 0xf8d, 0xf99, 0xfc6, 0x102b, 0x1056, 0x105e, 0x1062,\n            0x1067, 0x1071, 0x1082, 0x108f, 0x109a, 0x135d, 0x1712, 0x1732, 0x1752, 0x1772, 0x17b4, \n            0x17dd, 0x180b, 0x18a9, 0x1920, 0x1930, 0x19b0, 0x19c8, 0x1a17, 0x1a55, 0x1a60, 0x1a7f,\n            0x1b00, 0x1b34, 0x1b6b, 0x1b80, 0x1ba1, 0x1be6, 0x1c24, 0x1cd0, 0x1cd4, 0x1ced, 0x1cf2, \n            0x1dc0, 0x1dfc, 0x200c, 0x20d0, 0x2cef, 0x2d7f, 0x2de0, 0x302a, 0x3099, 0xa66f, 0xa674,\n            0xa69f, 0xa6f0, 0xa802, 0xa806, 0xa80b, 0xa823, 0xa880, 0xa8b4, 0xa8e0, 0xa926, 0xa947, \n            0xa980, 0xa9b3, 0xaa29, 0xaa43, 0xaa4c, 0xaa7b, 0xaab0, 0xaab2, 0xaab7, 0xaabe, 0xaac1,\n            0xaaeb, 0xaaf5, 0xabe3, 0xabec, 0xfb1e, 0xfe00, 0xfe20, 0xff9e, 0x101fd, 0x10a01,\n            0x10a05, 0x10a0C, 0x10a38, 0x10a3F, 0x11000, 0x11001, 0x11038, 0x11080, 0x11082,\n            0x110b0, 0x110b3, 0x110b7, 0x110b9, 0x11100, 0x11127, 0x1112c, 0x11180, 0x11182,\n            0x111b3, 0x111b6, 0x111bF, 0x116ab, 0x116ac, 0x116b0, 0x116b6, 0x16f51, 0x16f8f,\n            0x1d165, 0x1d167, 0x1d16d, 0x1d17b, 0x1d185, 0x1d1aa, 0x1d242, 0xe0100 }; \n        \n    StringBuilder builder = new StringBuilder();\n    int numChars = TestUtil.nextInt(random(), 100 * 1024, 1024 * 1024);\n    for (int i = 0 ; i < numChars ; ) {\n      builder.append(WordBreak_ExtendNumLet_chars[random().nextInt(WordBreak_ExtendNumLet_chars.length)]);\n      ++i;\n      if (random().nextBoolean()) {\n        int numFormatExtendChars = TestUtil.nextInt(random(), 1, 8);\n        for (int j = 0; j < numFormatExtendChars; ++j) {\n          int codepoint;\n          if (random().nextBoolean()) {\n            codepoint = WordBreak_Format_chars[random().nextInt(WordBreak_Format_chars.length)];\n          } else {\n            codepoint = WordBreak_Extend_chars[random().nextInt(WordBreak_Extend_chars.length)];\n          }\n          char[] chars = Character.toChars(codepoint);\n          builder.append(chars);\n          i += chars.length;\n        }\n      }\n    }\n    StandardTokenizer ts = new StandardTokenizer();\n    ts.setReader(new StringReader(builder.toString()));\n    ts.reset();\n    while (ts.incrementToken()) { }\n    ts.end();\n    ts.close();\n\n    int newBufferSize = TestUtil.nextInt(random(), 200, 8192);\n    ts.setMaxTokenLength(newBufferSize); // try a different buffer size\n    ts.setReader(new StringReader(builder.toString()));\n    ts.reset();\n    while (ts.incrementToken()) { }\n    ts.end();\n    ts.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"55980207f1977bd1463465de1659b821347e2fa8":["3c00ffa555aa637d932f7d491038cf9992403994","91a5e37a1dee5ad8d3fe6d55228839d5d0412999"],"91a5e37a1dee5ad8d3fe6d55228839d5d0412999":["3c00ffa555aa637d932f7d491038cf9992403994"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3c00ffa555aa637d932f7d491038cf9992403994":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["91a5e37a1dee5ad8d3fe6d55228839d5d0412999"]},"commit2Childs":{"55980207f1977bd1463465de1659b821347e2fa8":[],"91a5e37a1dee5ad8d3fe6d55228839d5d0412999":["55980207f1977bd1463465de1659b821347e2fa8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3c00ffa555aa637d932f7d491038cf9992403994"],"3c00ffa555aa637d932f7d491038cf9992403994":["55980207f1977bd1463465de1659b821347e2fa8","91a5e37a1dee5ad8d3fe6d55228839d5d0412999"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["55980207f1977bd1463465de1659b821347e2fa8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}