{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","commits":[{"id":"6256acedd658c13275a01e4ba106a621956a22f6","date":1400192928,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns false if the term deos not exist, or it exists but its version is < minIDVersion. */\n  public boolean seekExact(final BytesRef target, long minIDVersion) throws IOException {\n\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n    // if (DEBUG) {\n    //   System.out.println(\"\\nBTTR.seekExact seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + brToString(target) + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n    //   printSeekState();\n    // }\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      // if (DEBUG) {\n      //   System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      // }\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n\n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: reverse vLong byte order for better FST\n      // prefix output sharing\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        // if (DEBUG) {\n        //   System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        // }\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n        //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n        //}\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        if (arc.output != NO_OUTPUT) {\n          output = fstOutputs.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame; we only do this\n        // to find out if the target term is before,\n        // equal or after the current term\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          // if (DEBUG) {\n          //   System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          // }\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        // if (DEBUG) {\n        //   System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord);\n        // }\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        // if (DEBUG) {\n        //   System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        // }\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n          // if (DEBUG) {\n          //   System.out.println(\"  target is same as current; return true\");\n          // }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //   System.out.println(\"  target is same as current but term doesn't exist\");\n          // }\n        }\n        //validIndexPrefix = currentFrame.depth;\n        //term.length = target.length;\n        //return termExists;\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n      // if (DEBUG) {\n      //   System.out.println(\"    no seek state; push root frame\");\n      // }\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), 0);\n    }\n\n    // if (DEBUG) {\n    //   System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n    // }\n\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n        // }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          term.length = 1+targetUpto;\n          // if (DEBUG) {\n          //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n\n        if ((Long.MAX_VALUE-output.output2) < minIDVersion) {\n          // The max version for all terms in this block is lower than the minVersion\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          // if (DEBUG) {\n          //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n          // }\n\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // The max version for this term is lower than the minVersion\n            return false;\n          }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //   System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n      } else {\n        // Follow this arc\n        arc = nextArc;\n        term.bytes[targetUpto] = (byte) targetLabel;\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != NO_OUTPUT) {\n          output = fstOutputs.add(output, arc.output);\n        }\n\n        // if (DEBUG) {\n        //   System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        // }\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          //if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), targetUpto);\n          //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    // Target term is entirely contained in the index:\n    if (!currentFrame.hasTerms) {\n      termExists = false;\n      term.length = targetUpto;\n      // if (DEBUG) {\n      //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n      // }\n      return false;\n    }\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, true);            \n    if (result == SeekStatus.FOUND) {\n      // if (DEBUG) {\n      //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n      // }\n      return true;\n    } else {\n      // if (DEBUG) {\n      //   System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n      // }\n\n      return false;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e82ae1be1dc68d59626e4bb94d2029d309b20878","date":1400195857,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","sourceNew":"  /** Returns false if the term deos not exist, or it exists but its version is < minIDVersion. */\n  public boolean seekExact(final BytesRef target, long minIDVersion) throws IOException {\n\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n    System.out.println(\"seekExact target=\" + target + \" minIDVersion=\" + minIDVersion);\n\n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n    // if (DEBUG) {\n    //   System.out.println(\"\\nBTTR.seekExact seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + brToString(target) + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n    //   printSeekState();\n    // }\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      // if (DEBUG) {\n      //   System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      // }\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n\n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: reverse vLong byte order for better FST\n      // prefix output sharing\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        // if (DEBUG) {\n        //   System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        // }\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n        //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n        //}\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame; we only do this\n        // to find out if the target term is before,\n        // equal or after the current term\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          // if (DEBUG) {\n          //   System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          // }\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        // if (DEBUG) {\n        //   System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord);\n        // }\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        // if (DEBUG) {\n        //   System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        // }\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n          // if (DEBUG) {\n          //   System.out.println(\"  target is same as current; return true\");\n          // }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //   System.out.println(\"  target is same as current but term doesn't exist\");\n          // }\n        }\n        //validIndexPrefix = currentFrame.depth;\n        //term.length = target.length;\n        //return termExists;\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n      System.out.println(\"first arc=\" + arc);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n      // if (DEBUG) {\n      //   System.out.println(\"    no seek state; push root frame\");\n      // }\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    // if (DEBUG) {\n    //   System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n    // }\n\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n        // }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          term.length = 1+targetUpto;\n          // if (DEBUG) {\n          //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n        System.out.println(\"  check output=\" +((output.output2)));\n\n        if (currentFrame.maxIDVersion < minIDVersion) {\n          // The max version for all terms in this block is lower than the minVersion\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          // if (DEBUG) {\n          //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n          // }\n\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // The max version for this term is lower than the minVersion\n            return false;\n          }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //   System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n      } else {\n        // Follow this arc\n        arc = nextArc;\n        term.bytes[targetUpto] = (byte) targetLabel;\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n        // if (DEBUG) {\n        //   System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        // }\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          //if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    // Target term is entirely contained in the index:\n    if (!currentFrame.hasTerms) {\n      termExists = false;\n      term.length = targetUpto;\n      // if (DEBUG) {\n      //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n      // }\n      return false;\n    }\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, true);            \n    if (result == SeekStatus.FOUND) {\n      // if (DEBUG) {\n      //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n      // }\n      return true;\n    } else {\n      // if (DEBUG) {\n      //   System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n      // }\n\n      return false;\n    }\n  }\n\n","sourceOld":"  /** Returns false if the term deos not exist, or it exists but its version is < minIDVersion. */\n  public boolean seekExact(final BytesRef target, long minIDVersion) throws IOException {\n\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n    // if (DEBUG) {\n    //   System.out.println(\"\\nBTTR.seekExact seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + brToString(target) + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n    //   printSeekState();\n    // }\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      // if (DEBUG) {\n      //   System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      // }\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n\n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: reverse vLong byte order for better FST\n      // prefix output sharing\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        // if (DEBUG) {\n        //   System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        // }\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n        //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n        //}\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        if (arc.output != NO_OUTPUT) {\n          output = fstOutputs.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame; we only do this\n        // to find out if the target term is before,\n        // equal or after the current term\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          // if (DEBUG) {\n          //   System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          // }\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        // if (DEBUG) {\n        //   System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord);\n        // }\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        // if (DEBUG) {\n        //   System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        // }\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n          // if (DEBUG) {\n          //   System.out.println(\"  target is same as current; return true\");\n          // }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //   System.out.println(\"  target is same as current but term doesn't exist\");\n          // }\n        }\n        //validIndexPrefix = currentFrame.depth;\n        //term.length = target.length;\n        //return termExists;\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n      // if (DEBUG) {\n      //   System.out.println(\"    no seek state; push root frame\");\n      // }\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), 0);\n    }\n\n    // if (DEBUG) {\n    //   System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n    // }\n\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n        // }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          term.length = 1+targetUpto;\n          // if (DEBUG) {\n          //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n\n        if ((Long.MAX_VALUE-output.output2) < minIDVersion) {\n          // The max version for all terms in this block is lower than the minVersion\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          // if (DEBUG) {\n          //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n          // }\n\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // The max version for this term is lower than the minVersion\n            return false;\n          }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //   System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n      } else {\n        // Follow this arc\n        arc = nextArc;\n        term.bytes[targetUpto] = (byte) targetLabel;\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != NO_OUTPUT) {\n          output = fstOutputs.add(output, arc.output);\n        }\n\n        // if (DEBUG) {\n        //   System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        // }\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          //if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, fstOutputs.add(output, arc.nextFinalOutput), targetUpto);\n          //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    // Target term is entirely contained in the index:\n    if (!currentFrame.hasTerms) {\n      termExists = false;\n      term.length = targetUpto;\n      // if (DEBUG) {\n      //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n      // }\n      return false;\n    }\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, true);            \n    if (result == SeekStatus.FOUND) {\n      // if (DEBUG) {\n      //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n      // }\n      return true;\n    } else {\n      // if (DEBUG) {\n      //   System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n      // }\n\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7d615ef411046679022f6728bb2b876273d13ae","date":1400253450,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","sourceNew":"  /** Returns false if the term deos not exist, or it exists but its version is < minIDVersion. */\n  public boolean seekExact(final BytesRef target, long minIDVersion) throws IOException {\n\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    // nocommit would be nice if somehow on doing deletes we didn't have to double-lookup again...\n\n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n     if (DEBUG) {\n       System.out.println(\"\\nBTTR.seekExact seg=\" + fr.parent.segment + \" target=\" + fr.fieldInfo.name + \":\" + brToString(target) + \" minIDVersion=\" + minIDVersion + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n       printSeekState(System.out);\n     }\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    // nocommit we could stop earlier w/ the version check, every time we traverse an index arc we can check?\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n       if (DEBUG) {\n         System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n       }\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n\n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length: \"validIndexPrefix=\" + validIndexPrefix + \" term.length=\" + term.length + \" seg=\" + fr.parent.segment;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: reverse vLong byte order for better FST\n      // prefix output sharing\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n         if (DEBUG) {\n           System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n         }\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n        //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n        //}\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame; we only do this\n        // to find out if the target term is before,\n        // equal or after the current term\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n           if (DEBUG) {\n             System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n           }\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n         if (DEBUG) {\n           System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord + \"; targetUpto=\" + targetUpto);\n         }\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n         if (DEBUG) {\n           System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n         }\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n\n          if (currentFrame.maxIDVersion < minIDVersion) {\n            // The max version for all terms in this block is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current maxIDVersion=\" + currentFrame.maxIDVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // The max version for this term is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current but version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n\n           if (DEBUG) {\n             System.out.println(\"  target is same as current; return true\");\n           }\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  target is same as current but term doesn't exist\");\n           }\n        }\n        //validIndexPrefix = currentFrame.depth;\n        //term.length = target.length;\n        //return termExists;\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n      //System.out.println(\"first arc=\" + arc);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n       if (DEBUG) {\n         System.out.println(\"    no seek state; push root frame\");\n       }\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n     if (DEBUG) {\n       System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n     }\n\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n         if (DEBUG) {\n           System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + Integer.toHexString(targetLabel));\n         }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          term.length = 1+targetUpto;\n           if (DEBUG) {\n             System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n        //System.out.println(\"  check maxVersion=\" + currentFrame.maxIDVersion + \" vs \" + minIDVersion);\n\n        if (currentFrame.maxIDVersion < minIDVersion) {\n          // The max version for all terms in this block is lower than the minVersion\n          //termExists = false;\n          //term.bytes[targetUpto] = (byte) targetLabel;\n          //term.length = 1+targetUpto;\n          if (DEBUG) {\n            System.out.println(\"    FAST version NOT_FOUND term=\" + brToString(term) + \" currentFrame.maxIDVersion=\" + currentFrame.maxIDVersion + \" validIndexPrefix=\" + validIndexPrefix);\n          }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // The max version for this term is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"    return NOT_FOUND: idVersion=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" vs minIDVersion=\" + minIDVersion);\n            }\n            return false;\n          }\n\n           if (DEBUG) {\n             System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n           }\n\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n      } else {\n        // Follow this arc\n        arc = nextArc;\n        term.bytes[targetUpto] = (byte) targetLabel;\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n         if (DEBUG) {\n           System.out.println(\"    index: follow label=\" + Integer.toHexString((target.bytes[target.offset + targetUpto]&0xff)) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n         }\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    // Target term is entirely contained in the index:\n    if (!currentFrame.hasTerms) {\n      termExists = false;\n      term.length = targetUpto;\n       if (DEBUG) {\n         System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n       }\n      return false;\n    }\n\n    if (currentFrame.maxIDVersion < minIDVersion) {\n      // The max version for all terms in this block is lower than the minVersion\n      termExists = false;\n      term.length = targetUpto;\n      return false;\n    }\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, true);            \n    if (result == SeekStatus.FOUND) {\n       if (DEBUG) {\n         System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n       }\n      currentFrame.decodeMetaData();\n      if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n        // The max version for this term is lower than the minVersion\n        return false;\n      }\n      return true;\n    } else {\n       if (DEBUG) {\n         System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n       }\n\n      return false;\n    }\n  }\n\n","sourceOld":"  /** Returns false if the term deos not exist, or it exists but its version is < minIDVersion. */\n  public boolean seekExact(final BytesRef target, long minIDVersion) throws IOException {\n\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n    System.out.println(\"seekExact target=\" + target + \" minIDVersion=\" + minIDVersion);\n\n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n    // if (DEBUG) {\n    //   System.out.println(\"\\nBTTR.seekExact seg=\" + segment + \" target=\" + fieldInfo.name + \":\" + brToString(target) + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n    //   printSeekState();\n    // }\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      // if (DEBUG) {\n      //   System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      // }\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n\n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: reverse vLong byte order for better FST\n      // prefix output sharing\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        // if (DEBUG) {\n        //   System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        // }\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n        //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n        //}\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame; we only do this\n        // to find out if the target term is before,\n        // equal or after the current term\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          // if (DEBUG) {\n          //   System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          // }\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        // if (DEBUG) {\n        //   System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord);\n        // }\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        // if (DEBUG) {\n        //   System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        // }\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n          // if (DEBUG) {\n          //   System.out.println(\"  target is same as current; return true\");\n          // }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //   System.out.println(\"  target is same as current but term doesn't exist\");\n          // }\n        }\n        //validIndexPrefix = currentFrame.depth;\n        //term.length = target.length;\n        //return termExists;\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n      System.out.println(\"first arc=\" + arc);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n      // if (DEBUG) {\n      //   System.out.println(\"    no seek state; push root frame\");\n      // }\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    // if (DEBUG) {\n    //   System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n    // }\n\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //   System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + toHex(targetLabel));\n        // }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          term.length = 1+targetUpto;\n          // if (DEBUG) {\n          //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n        System.out.println(\"  check output=\" +((output.output2)));\n\n        if (currentFrame.maxIDVersion < minIDVersion) {\n          // The max version for all terms in this block is lower than the minVersion\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          // if (DEBUG) {\n          //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n          // }\n\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // The max version for this term is lower than the minVersion\n            return false;\n          }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //   System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n      } else {\n        // Follow this arc\n        arc = nextArc;\n        term.bytes[targetUpto] = (byte) targetLabel;\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n        // if (DEBUG) {\n        //   System.out.println(\"    index: follow label=\" + toHex(target.bytes[target.offset + targetUpto]&0xff) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        // }\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          //if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          //if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    // Target term is entirely contained in the index:\n    if (!currentFrame.hasTerms) {\n      termExists = false;\n      term.length = targetUpto;\n      // if (DEBUG) {\n      //   System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n      // }\n      return false;\n    }\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, true);            \n    if (result == SeekStatus.FOUND) {\n      // if (DEBUG) {\n      //   System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n      // }\n      return true;\n    } else {\n      // if (DEBUG) {\n      //   System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n      // }\n\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f56ba5d8fecfb0b8bfdca8c0b630372d998131a9","date":1400353720,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","sourceNew":"  /** Returns false if the term deos not exist, or it exists but its version is < minIDVersion. */\n  public boolean seekExact(final BytesRef target, long minIDVersion) throws IOException {\n\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    // nocommit would be nice if somehow on doing deletes we didn't have to double-lookup again...\n\n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n     if (DEBUG) {\n       System.out.println(\"\\nBTTR.seekExact seg=\" + fr.parent.segment + \" target=\" + fr.fieldInfo.name + \":\" + brToString(target) + \" minIDVersion=\" + minIDVersion + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n       printSeekState(System.out);\n     }\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    long startFrameFP = currentFrame.fp;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    // nocommit we could stop earlier w/ the version check, every time we traverse an index arc we can check?\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n       if (DEBUG) {\n         System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n       }\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n\n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length: \"validIndexPrefix=\" + validIndexPrefix + \" term.length=\" + term.length + \" seg=\" + fr.parent.segment;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: reverse vLong byte order for better FST\n      // prefix output sharing\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n         if (DEBUG) {\n           System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n         }\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n        //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n        //}\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame; we only do this\n        // to find out if the target term is before,\n        // equal or after the current term\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n           if (DEBUG) {\n             System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n           }\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n         if (DEBUG) {\n           System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord + \"; targetUpto=\" + targetUpto);\n         }\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n         if (DEBUG) {\n           System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n         }\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n        // nocommit put this back to BT also?\n        term.length = targetUpto;\n        termExists = false;\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n\n          if (currentFrame.maxIDVersion < minIDVersion) {\n            // The max version for all terms in this block is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current maxIDVersion=\" + currentFrame.maxIDVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // The max version for this term is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current but version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n          System.out.println(\"  term version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" frame version=\" + currentFrame.maxIDVersion + \" frame ord=\" + currentFrame.ord);\n\n           if (DEBUG) {\n             System.out.println(\"  target is same as current; return true\");\n           }\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  target is same as current but term doesn't exist\");\n           }\n        }\n        //validIndexPrefix = currentFrame.depth;\n        //term.length = target.length;\n        //return termExists;\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n      //System.out.println(\"first arc=\" + arc);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n       if (DEBUG) {\n         System.out.println(\"    no seek state; push root frame\");\n       }\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    if (DEBUG) {\n      System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n    }\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n         if (DEBUG) {\n           System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + Integer.toHexString(targetLabel));\n         }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          term.length = 1+targetUpto;\n           if (DEBUG) {\n             System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n        //System.out.println(\"  check maxVersion=\" + currentFrame.maxIDVersion + \" vs \" + minIDVersion);\n\n        if (DEBUG) {\n          System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n        }\n\n        if (currentFrame.maxIDVersion < minIDVersion) {\n          // The max version for all terms in this block is lower than the minVersion\n          if (currentFrame.fp != startFrameFP) {\n          //if (targetUpto+1 > term.length) {\n            termExists = false;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            term.length = 1+targetUpto;\n            if (DEBUG) {\n              System.out.println(\"    reset current term\");\n            }\n            validIndexPrefix = Math.min(validIndexPrefix, term.length);\n          }\n            //if (currentFrame.ord != startFrameOrd) {\n            //termExists = false;\n            //}\n          if (DEBUG) {\n            System.out.println(\"    FAST version NOT_FOUND term=\" + brToString(term) + \" targetUpto=\" + targetUpto + \" currentFrame.maxIDVersion=\" + currentFrame.maxIDVersion + \" validIndexPrefix=\" + validIndexPrefix);\n          }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        if (DEBUG) {\n          System.out.println(\"    scan currentFrame ord=\" + currentFrame.ord);\n        }\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // The max version for this term is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"    return NOT_FOUND: idVersion=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" vs minIDVersion=\" + minIDVersion);\n            }\n            return false;\n          }\n\n           if (DEBUG) {\n             System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n           }\n\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n      } else {\n        // Follow this arc\n        arc = nextArc;\n        term.bytes[targetUpto] = (byte) targetLabel;\n        termExists = false;\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n         if (DEBUG) {\n           System.out.println(\"    index: follow label=\" + (char) ((target.bytes[target.offset + targetUpto]&0xff)) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n         }\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    // Target term is entirely contained in the index:\n    if (!currentFrame.hasTerms) {\n      termExists = false;\n      term.length = targetUpto;\n       if (DEBUG) {\n         System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n       }\n      return false;\n    }\n\n    if (DEBUG) {\n      System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n    }\n\n    if (currentFrame.maxIDVersion < minIDVersion) {\n      // The max version for all terms in this block is lower than the minVersion\n      // nocommit need same logic here as above?\n      termExists = false;\n      term.length = targetUpto;\n      return false;\n    }\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, true);            \n    if (result == SeekStatus.FOUND) {\n       if (DEBUG) {\n         System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n       }\n      currentFrame.decodeMetaData();\n      if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n        // The max version for this term is lower than the minVersion\n        return false;\n      }\n      return true;\n    } else {\n       if (DEBUG) {\n         System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n       }\n\n      return false;\n    }\n  }\n\n","sourceOld":"  /** Returns false if the term deos not exist, or it exists but its version is < minIDVersion. */\n  public boolean seekExact(final BytesRef target, long minIDVersion) throws IOException {\n\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    // nocommit would be nice if somehow on doing deletes we didn't have to double-lookup again...\n\n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n     if (DEBUG) {\n       System.out.println(\"\\nBTTR.seekExact seg=\" + fr.parent.segment + \" target=\" + fr.fieldInfo.name + \":\" + brToString(target) + \" minIDVersion=\" + minIDVersion + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n       printSeekState(System.out);\n     }\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    // nocommit we could stop earlier w/ the version check, every time we traverse an index arc we can check?\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n       if (DEBUG) {\n         System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n       }\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n\n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length: \"validIndexPrefix=\" + validIndexPrefix + \" term.length=\" + term.length + \" seg=\" + fr.parent.segment;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: reverse vLong byte order for better FST\n      // prefix output sharing\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n         if (DEBUG) {\n           System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n         }\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n        //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n        //}\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame; we only do this\n        // to find out if the target term is before,\n        // equal or after the current term\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n           if (DEBUG) {\n             System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n           }\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n         if (DEBUG) {\n           System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord + \"; targetUpto=\" + targetUpto);\n         }\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n         if (DEBUG) {\n           System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n         }\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n\n          if (currentFrame.maxIDVersion < minIDVersion) {\n            // The max version for all terms in this block is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current maxIDVersion=\" + currentFrame.maxIDVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // The max version for this term is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current but version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n\n           if (DEBUG) {\n             System.out.println(\"  target is same as current; return true\");\n           }\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  target is same as current but term doesn't exist\");\n           }\n        }\n        //validIndexPrefix = currentFrame.depth;\n        //term.length = target.length;\n        //return termExists;\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n      //System.out.println(\"first arc=\" + arc);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n       if (DEBUG) {\n         System.out.println(\"    no seek state; push root frame\");\n       }\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n     if (DEBUG) {\n       System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n     }\n\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n         if (DEBUG) {\n           System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + Integer.toHexString(targetLabel));\n         }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          term.length = 1+targetUpto;\n           if (DEBUG) {\n             System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n        //System.out.println(\"  check maxVersion=\" + currentFrame.maxIDVersion + \" vs \" + minIDVersion);\n\n        if (currentFrame.maxIDVersion < minIDVersion) {\n          // The max version for all terms in this block is lower than the minVersion\n          //termExists = false;\n          //term.bytes[targetUpto] = (byte) targetLabel;\n          //term.length = 1+targetUpto;\n          if (DEBUG) {\n            System.out.println(\"    FAST version NOT_FOUND term=\" + brToString(term) + \" currentFrame.maxIDVersion=\" + currentFrame.maxIDVersion + \" validIndexPrefix=\" + validIndexPrefix);\n          }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // The max version for this term is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"    return NOT_FOUND: idVersion=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" vs minIDVersion=\" + minIDVersion);\n            }\n            return false;\n          }\n\n           if (DEBUG) {\n             System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n           }\n\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n      } else {\n        // Follow this arc\n        arc = nextArc;\n        term.bytes[targetUpto] = (byte) targetLabel;\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n         if (DEBUG) {\n           System.out.println(\"    index: follow label=\" + Integer.toHexString((target.bytes[target.offset + targetUpto]&0xff)) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n         }\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    // Target term is entirely contained in the index:\n    if (!currentFrame.hasTerms) {\n      termExists = false;\n      term.length = targetUpto;\n       if (DEBUG) {\n         System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n       }\n      return false;\n    }\n\n    if (currentFrame.maxIDVersion < minIDVersion) {\n      // The max version for all terms in this block is lower than the minVersion\n      termExists = false;\n      term.length = targetUpto;\n      return false;\n    }\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, true);            \n    if (result == SeekStatus.FOUND) {\n       if (DEBUG) {\n         System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n       }\n      currentFrame.decodeMetaData();\n      if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n        // The max version for this term is lower than the minVersion\n        return false;\n      }\n      return true;\n    } else {\n       if (DEBUG) {\n         System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n       }\n\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e19aeadf1fb6c63b76ee4828b087b1ff7256b228","date":1400363857,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","sourceNew":"  /** Returns false if the term deos not exist, or it exists but its version is too old (< minIDVersion). */\n  public boolean seekExact(final BytesRef target, long minIDVersion) throws IOException {\n\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    // nocommit would be nice if somehow on doing deletes we didn't have to double-lookup again...\n\n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n     if (DEBUG) {\n       System.out.println(\"\\nBTTR.seekExact seg=\" + fr.parent.segment + \" target=\" + fr.fieldInfo.name + \":\" + brToString(target) + \" minIDVersion=\" + minIDVersion + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n       printSeekState(System.out);\n     }\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    long startFrameFP = currentFrame.fp;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    boolean rewind = false;\n\n    // nocommit we could stop earlier w/ the version check, every time we traverse an index arc we can check?\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n       if (DEBUG) {\n         System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n       }\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n\n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length: \"validIndexPrefix=\" + validIndexPrefix + \" term.length=\" + term.length + \" seg=\" + fr.parent.segment;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: reverse vLong byte order for better FST\n      // prefix output sharing\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n         if (DEBUG) {\n           System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n         }\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n        //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n        //}\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame; we only do this\n        // to find out if the target term is before,\n        // equal or after the current term\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n           if (DEBUG) {\n             System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n           }\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n         if (DEBUG) {\n           System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord + \"; targetUpto=\" + targetUpto);\n         }\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        rewind = true;\n         if (DEBUG) {\n           System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n         }\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n        // nocommit put this back to BT also?\n        term.length = targetUpto;\n        termExists = false;\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n\n          if (currentFrame.maxIDVersion < minIDVersion) {\n            // The max version for all terms in this block is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current maxIDVersion=\" + currentFrame.maxIDVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // The max version for this term is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current but version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n          System.out.println(\"  term version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" frame version=\" + currentFrame.maxIDVersion + \" frame ord=\" + currentFrame.ord);\n\n           if (DEBUG) {\n             System.out.println(\"  target is same as current; return true\");\n           }\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  target is same as current but term doesn't exist\");\n           }\n        }\n        //validIndexPrefix = currentFrame.depth;\n        //term.length = target.length;\n        //return termExists;\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n      //System.out.println(\"first arc=\" + arc);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n       if (DEBUG) {\n         System.out.println(\"    no seek state; push root frame\");\n       }\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    if (DEBUG) {\n      System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n    }\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n         if (DEBUG) {\n           System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + Integer.toHexString(targetLabel));\n         }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          term.length = 1+targetUpto;\n           if (DEBUG) {\n             System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n        //System.out.println(\"  check maxVersion=\" + currentFrame.maxIDVersion + \" vs \" + minIDVersion);\n\n        if (DEBUG) {\n          System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n        }\n\n        if (currentFrame.maxIDVersion < minIDVersion) {\n          // The max version for all terms in this block is lower than the minVersion\n          if (currentFrame.fp != startFrameFP || rewind) {\n          //if (targetUpto+1 > term.length) {\n            termExists = false;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            term.length = 1+targetUpto;\n            if (DEBUG) {\n              System.out.println(\"    reset current term\");\n            }\n            validIndexPrefix = Math.min(validIndexPrefix, term.length);\n          }\n            //if (currentFrame.ord != startFrameOrd) {\n            //termExists = false;\n            //}\n          if (DEBUG) {\n            System.out.println(\"    FAST version NOT_FOUND term=\" + brToString(term) + \" targetUpto=\" + targetUpto + \" currentFrame.maxIDVersion=\" + currentFrame.maxIDVersion + \" validIndexPrefix=\" + validIndexPrefix + \" startFrameFP=\" + startFrameFP + \" vs \" + currentFrame.fp);\n          }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        if (DEBUG) {\n          System.out.println(\"    scan currentFrame ord=\" + currentFrame.ord);\n        }\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // The max version for this term is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"    return NOT_FOUND: idVersion=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" vs minIDVersion=\" + minIDVersion);\n            }\n            return false;\n          }\n\n           if (DEBUG) {\n             System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n           }\n\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n      } else {\n        // Follow this arc\n        arc = nextArc;\n        term.bytes[targetUpto] = (byte) targetLabel;\n        termExists = false;\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n         if (DEBUG) {\n           System.out.println(\"    index: follow label=\" + (char) ((target.bytes[target.offset + targetUpto]&0xff)) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n         }\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    // Target term is entirely contained in the index:\n    if (!currentFrame.hasTerms) {\n      termExists = false;\n      term.length = targetUpto;\n       if (DEBUG) {\n         System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n       }\n      return false;\n    }\n\n    if (DEBUG) {\n      System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n    }\n\n    if (currentFrame.maxIDVersion < minIDVersion) {\n      // The max version for all terms in this block is lower than the minVersion\n      // nocommit need same logic here as above?\n      termExists = false;\n      term.length = targetUpto;\n      return false;\n    }\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, true);            \n    if (result == SeekStatus.FOUND) {\n       if (DEBUG) {\n         System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n       }\n      currentFrame.decodeMetaData();\n      if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n        // The max version for this term is lower than the minVersion\n        return false;\n      }\n      return true;\n    } else {\n       if (DEBUG) {\n         System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n       }\n\n      return false;\n    }\n  }\n\n","sourceOld":"  /** Returns false if the term deos not exist, or it exists but its version is < minIDVersion. */\n  public boolean seekExact(final BytesRef target, long minIDVersion) throws IOException {\n\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    // nocommit would be nice if somehow on doing deletes we didn't have to double-lookup again...\n\n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n     if (DEBUG) {\n       System.out.println(\"\\nBTTR.seekExact seg=\" + fr.parent.segment + \" target=\" + fr.fieldInfo.name + \":\" + brToString(target) + \" minIDVersion=\" + minIDVersion + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n       printSeekState(System.out);\n     }\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    long startFrameFP = currentFrame.fp;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    // nocommit we could stop earlier w/ the version check, every time we traverse an index arc we can check?\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n       if (DEBUG) {\n         System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n       }\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n\n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length: \"validIndexPrefix=\" + validIndexPrefix + \" term.length=\" + term.length + \" seg=\" + fr.parent.segment;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: reverse vLong byte order for better FST\n      // prefix output sharing\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n         if (DEBUG) {\n           System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n         }\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n        //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n        //}\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame; we only do this\n        // to find out if the target term is before,\n        // equal or after the current term\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n           if (DEBUG) {\n             System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n           }\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n         if (DEBUG) {\n           System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord + \"; targetUpto=\" + targetUpto);\n         }\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n         if (DEBUG) {\n           System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n         }\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n        // nocommit put this back to BT also?\n        term.length = targetUpto;\n        termExists = false;\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n\n          if (currentFrame.maxIDVersion < minIDVersion) {\n            // The max version for all terms in this block is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current maxIDVersion=\" + currentFrame.maxIDVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // The max version for this term is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current but version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n          System.out.println(\"  term version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" frame version=\" + currentFrame.maxIDVersion + \" frame ord=\" + currentFrame.ord);\n\n           if (DEBUG) {\n             System.out.println(\"  target is same as current; return true\");\n           }\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  target is same as current but term doesn't exist\");\n           }\n        }\n        //validIndexPrefix = currentFrame.depth;\n        //term.length = target.length;\n        //return termExists;\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n      //System.out.println(\"first arc=\" + arc);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n       if (DEBUG) {\n         System.out.println(\"    no seek state; push root frame\");\n       }\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    if (DEBUG) {\n      System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n    }\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n         if (DEBUG) {\n           System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + Integer.toHexString(targetLabel));\n         }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          term.length = 1+targetUpto;\n           if (DEBUG) {\n             System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n        //System.out.println(\"  check maxVersion=\" + currentFrame.maxIDVersion + \" vs \" + minIDVersion);\n\n        if (DEBUG) {\n          System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n        }\n\n        if (currentFrame.maxIDVersion < minIDVersion) {\n          // The max version for all terms in this block is lower than the minVersion\n          if (currentFrame.fp != startFrameFP) {\n          //if (targetUpto+1 > term.length) {\n            termExists = false;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            term.length = 1+targetUpto;\n            if (DEBUG) {\n              System.out.println(\"    reset current term\");\n            }\n            validIndexPrefix = Math.min(validIndexPrefix, term.length);\n          }\n            //if (currentFrame.ord != startFrameOrd) {\n            //termExists = false;\n            //}\n          if (DEBUG) {\n            System.out.println(\"    FAST version NOT_FOUND term=\" + brToString(term) + \" targetUpto=\" + targetUpto + \" currentFrame.maxIDVersion=\" + currentFrame.maxIDVersion + \" validIndexPrefix=\" + validIndexPrefix);\n          }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        if (DEBUG) {\n          System.out.println(\"    scan currentFrame ord=\" + currentFrame.ord);\n        }\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // The max version for this term is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"    return NOT_FOUND: idVersion=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" vs minIDVersion=\" + minIDVersion);\n            }\n            return false;\n          }\n\n           if (DEBUG) {\n             System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n           }\n\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n      } else {\n        // Follow this arc\n        arc = nextArc;\n        term.bytes[targetUpto] = (byte) targetLabel;\n        termExists = false;\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n         if (DEBUG) {\n           System.out.println(\"    index: follow label=\" + (char) ((target.bytes[target.offset + targetUpto]&0xff)) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n         }\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    // Target term is entirely contained in the index:\n    if (!currentFrame.hasTerms) {\n      termExists = false;\n      term.length = targetUpto;\n       if (DEBUG) {\n         System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n       }\n      return false;\n    }\n\n    if (DEBUG) {\n      System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n    }\n\n    if (currentFrame.maxIDVersion < minIDVersion) {\n      // The max version for all terms in this block is lower than the minVersion\n      // nocommit need same logic here as above?\n      termExists = false;\n      term.length = targetUpto;\n      return false;\n    }\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, true);            \n    if (result == SeekStatus.FOUND) {\n       if (DEBUG) {\n         System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n       }\n      currentFrame.decodeMetaData();\n      if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n        // The max version for this term is lower than the minVersion\n        return false;\n      }\n      return true;\n    } else {\n       if (DEBUG) {\n         System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n       }\n\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3251bdaf728baf81f779183e464984bc769ed9c7","date":1400494940,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","sourceNew":"  /** Returns false if the term deos not exist, or it exists but its version is too old (< minIDVersion). */\n  public boolean seekExact(final BytesRef target, long minIDVersion) throws IOException {\n\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    // nocommit would be nice if somehow on doing deletes we didn't have to double-lookup again...\n\n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n     if (DEBUG) {\n       System.out.println(\"\\nBTTR.seekExact seg=\" + fr.parent.segment + \" target=\" + fr.fieldInfo.name + \":\" + brToString(target) + \" minIDVersion=\" + minIDVersion + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n       printSeekState(System.out);\n     }\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    long startFrameFP = currentFrame.fp;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    boolean changed = false;\n\n    // nocommit we could stop earlier w/ the version check, every time we traverse an index arc we can check?\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n       if (DEBUG) {\n         System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n       }\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n\n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length: \"validIndexPrefix=\" + validIndexPrefix + \" term.length=\" + term.length + \" seg=\" + fr.parent.segment;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: reverse vLong byte order for better FST\n      // prefix output sharing\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n         if (DEBUG) {\n           System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n         }\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n        //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n        //}\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame; we only do this\n        // to find out if the target term is before,\n        // equal or after the current term\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n           if (DEBUG) {\n             System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n           }\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n         if (DEBUG) {\n           System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord + \"; targetUpto=\" + targetUpto);\n         }\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        changed = true;\n         if (DEBUG) {\n           System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n         }\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n        // nocommit put this back to BT also?\n        //term.length = targetUpto;\n\n        // nocommit put this back???\n        //termExists = false;\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n\n          if (currentFrame.maxIDVersion < minIDVersion) {\n            // The max version for all terms in this block is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current maxIDVersion=\" + currentFrame.maxIDVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current but version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n          System.out.println(\"  term version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" frame version=\" + currentFrame.maxIDVersion + \" frame ord=\" + currentFrame.ord);\n\n           if (DEBUG) {\n             System.out.println(\"  target is same as current; return true\");\n           }\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  target is same as current but term doesn't exist\");\n           }\n        }\n        //validIndexPrefix = currentFrame.depth;\n        //term.length = target.length;\n        //return termExists;\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n      //System.out.println(\"first arc=\" + arc);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n       if (DEBUG) {\n         System.out.println(\"    no seek state; push root frame\");\n       }\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    if (DEBUG) {\n      System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength + \" termExists=\" + termExists);\n    }\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n         if (DEBUG) {\n           System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + Integer.toHexString(targetLabel) + \" termExists=\" + termExists);\n         }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          term.length = 1+targetUpto;\n           if (DEBUG) {\n             System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n        //System.out.println(\"  check maxVersion=\" + currentFrame.maxIDVersion + \" vs \" + minIDVersion);\n\n        if (DEBUG) {\n          System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n        }\n\n        if (currentFrame.maxIDVersion < minIDVersion) {\n          // The max version for all terms in this block is lower than the minVersion\n          if (currentFrame.fp != startFrameFP || changed) {\n          //if (targetUpto+1 > term.length) {\n            termExists = false;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            term.length = 1+targetUpto;\n            if (DEBUG) {\n              System.out.println(\"    reset current term\");\n            }\n            validIndexPrefix = Math.min(validIndexPrefix, term.length);\n          }\n            //if (currentFrame.ord != startFrameOrd) {\n            //termExists = false;\n            //}\n          if (DEBUG) {\n            System.out.println(\"    FAST version NOT_FOUND term=\" + brToString(term) + \" targetUpto=\" + targetUpto + \" currentFrame.maxIDVersion=\" + currentFrame.maxIDVersion + \" validIndexPrefix=\" + validIndexPrefix + \" startFrameFP=\" + startFrameFP + \" vs \" + currentFrame.fp + \" termExists=\" + termExists);\n          }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        if (DEBUG) {\n          System.out.println(\"    scan currentFrame ord=\" + currentFrame.ord);\n        }\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"    return NOT_FOUND: idVersion=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" vs minIDVersion=\" + minIDVersion);\n            }\n            return false;\n          }\n\n           if (DEBUG) {\n             System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n           }\n\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n      } else {\n        // Follow this arc\n        arc = nextArc;\n        if (term.bytes[targetUpto] != (byte) targetLabel) {\n          if (DEBUG) {\n            System.out.println(\"  now set termExists=false targetUpto=\" + targetUpto + \" term=\" + term.bytes[targetUpto] + \" targetLabel=\" + targetLabel);\n          }\n          changed = true;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          termExists = false;\n        }\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n         if (DEBUG) {\n           System.out.println(\"    index: follow label=\" + (char) ((target.bytes[target.offset + targetUpto]&0xff)) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n         }\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    // Target term is entirely contained in the index:\n    if (!currentFrame.hasTerms) {\n      termExists = false;\n      term.length = targetUpto;\n       if (DEBUG) {\n         System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n       }\n      return false;\n    }\n\n    if (DEBUG) {\n      System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n    }\n\n    if (currentFrame.maxIDVersion < minIDVersion) {\n      // The max version for all terms in this block is lower than the minVersion\n      // nocommit need same logic here as above?\n      termExists = false;\n      term.length = targetUpto;\n      return false;\n    }\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, true);            \n    if (result == SeekStatus.FOUND) {\n       if (DEBUG) {\n         System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n       }\n      currentFrame.decodeMetaData();\n      if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n        // This term's version is lower than the minVersion\n        return false;\n      }\n      return true;\n    } else {\n       if (DEBUG) {\n         System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n       }\n\n      return false;\n    }\n  }\n\n","sourceOld":"  /** Returns false if the term deos not exist, or it exists but its version is too old (< minIDVersion). */\n  public boolean seekExact(final BytesRef target, long minIDVersion) throws IOException {\n\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    // nocommit would be nice if somehow on doing deletes we didn't have to double-lookup again...\n\n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n     if (DEBUG) {\n       System.out.println(\"\\nBTTR.seekExact seg=\" + fr.parent.segment + \" target=\" + fr.fieldInfo.name + \":\" + brToString(target) + \" minIDVersion=\" + minIDVersion + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n       printSeekState(System.out);\n     }\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    long startFrameFP = currentFrame.fp;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    boolean rewind = false;\n\n    // nocommit we could stop earlier w/ the version check, every time we traverse an index arc we can check?\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n       if (DEBUG) {\n         System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n       }\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n\n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length: \"validIndexPrefix=\" + validIndexPrefix + \" term.length=\" + term.length + \" seg=\" + fr.parent.segment;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: reverse vLong byte order for better FST\n      // prefix output sharing\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n         if (DEBUG) {\n           System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n         }\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n        //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n        //}\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame; we only do this\n        // to find out if the target term is before,\n        // equal or after the current term\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n           if (DEBUG) {\n             System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n           }\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n         if (DEBUG) {\n           System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord + \"; targetUpto=\" + targetUpto);\n         }\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        rewind = true;\n         if (DEBUG) {\n           System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n         }\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n        // nocommit put this back to BT also?\n        term.length = targetUpto;\n        termExists = false;\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n\n          if (currentFrame.maxIDVersion < minIDVersion) {\n            // The max version for all terms in this block is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current maxIDVersion=\" + currentFrame.maxIDVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // The max version for this term is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current but version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n          System.out.println(\"  term version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" frame version=\" + currentFrame.maxIDVersion + \" frame ord=\" + currentFrame.ord);\n\n           if (DEBUG) {\n             System.out.println(\"  target is same as current; return true\");\n           }\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  target is same as current but term doesn't exist\");\n           }\n        }\n        //validIndexPrefix = currentFrame.depth;\n        //term.length = target.length;\n        //return termExists;\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n      //System.out.println(\"first arc=\" + arc);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n       if (DEBUG) {\n         System.out.println(\"    no seek state; push root frame\");\n       }\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    if (DEBUG) {\n      System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength);\n    }\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n         if (DEBUG) {\n           System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + Integer.toHexString(targetLabel));\n         }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          term.length = 1+targetUpto;\n           if (DEBUG) {\n             System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n        //System.out.println(\"  check maxVersion=\" + currentFrame.maxIDVersion + \" vs \" + minIDVersion);\n\n        if (DEBUG) {\n          System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n        }\n\n        if (currentFrame.maxIDVersion < minIDVersion) {\n          // The max version for all terms in this block is lower than the minVersion\n          if (currentFrame.fp != startFrameFP || rewind) {\n          //if (targetUpto+1 > term.length) {\n            termExists = false;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            term.length = 1+targetUpto;\n            if (DEBUG) {\n              System.out.println(\"    reset current term\");\n            }\n            validIndexPrefix = Math.min(validIndexPrefix, term.length);\n          }\n            //if (currentFrame.ord != startFrameOrd) {\n            //termExists = false;\n            //}\n          if (DEBUG) {\n            System.out.println(\"    FAST version NOT_FOUND term=\" + brToString(term) + \" targetUpto=\" + targetUpto + \" currentFrame.maxIDVersion=\" + currentFrame.maxIDVersion + \" validIndexPrefix=\" + validIndexPrefix + \" startFrameFP=\" + startFrameFP + \" vs \" + currentFrame.fp);\n          }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        if (DEBUG) {\n          System.out.println(\"    scan currentFrame ord=\" + currentFrame.ord);\n        }\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // The max version for this term is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"    return NOT_FOUND: idVersion=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" vs minIDVersion=\" + minIDVersion);\n            }\n            return false;\n          }\n\n           if (DEBUG) {\n             System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n           }\n\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n      } else {\n        // Follow this arc\n        arc = nextArc;\n        term.bytes[targetUpto] = (byte) targetLabel;\n        termExists = false;\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n         if (DEBUG) {\n           System.out.println(\"    index: follow label=\" + (char) ((target.bytes[target.offset + targetUpto]&0xff)) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n         }\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    // Target term is entirely contained in the index:\n    if (!currentFrame.hasTerms) {\n      termExists = false;\n      term.length = targetUpto;\n       if (DEBUG) {\n         System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n       }\n      return false;\n    }\n\n    if (DEBUG) {\n      System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n    }\n\n    if (currentFrame.maxIDVersion < minIDVersion) {\n      // The max version for all terms in this block is lower than the minVersion\n      // nocommit need same logic here as above?\n      termExists = false;\n      term.length = targetUpto;\n      return false;\n    }\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, true);            \n    if (result == SeekStatus.FOUND) {\n       if (DEBUG) {\n         System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n       }\n      currentFrame.decodeMetaData();\n      if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n        // The max version for this term is lower than the minVersion\n        return false;\n      }\n      return true;\n    } else {\n       if (DEBUG) {\n         System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n       }\n\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a16b40feb4e6e0d55c1716733bde48296bedd20","date":1400540388,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","sourceNew":"  /** Returns false if the term deos not exist, or it exists but its version is too old (< minIDVersion). */\n  public boolean seekExact(final BytesRef target, long minIDVersion) throws IOException {\n\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    // nocommit would be nice if somehow on doing deletes we didn't have to double-lookup again...\n\n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n     if (DEBUG) {\n       System.out.println(\"\\nBTTR.seekExact seg=\" + fr.parent.segment + \" target=\" + fr.fieldInfo.name + \":\" + brToString(target) + \" minIDVersion=\" + minIDVersion + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n       printSeekState(System.out);\n     }\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    long startFrameFP = currentFrame.fp;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    boolean changed = false;\n\n    // nocommit we could stop earlier w/ the version check, every time we traverse an index arc we can check?\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n       if (DEBUG) {\n         System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n       }\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n\n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length: \"validIndexPrefix=\" + validIndexPrefix + \" term.length=\" + term.length + \" seg=\" + fr.parent.segment;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: reverse vLong byte order for better FST\n      // prefix output sharing\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n         if (DEBUG) {\n           System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n         }\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n        //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n        //}\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame; we only do this\n        // to find out if the target term is before,\n        // equal or after the current term\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n           if (DEBUG) {\n             System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n           }\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n         if (DEBUG) {\n           System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord + \"; targetUpto=\" + targetUpto);\n         }\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        changed = true;\n         if (DEBUG) {\n           System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n         }\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n\n          if (currentFrame.maxIDVersion < minIDVersion) {\n            // The max version for all terms in this block is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current maxIDVersion=\" + currentFrame.maxIDVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current but version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n          System.out.println(\"  term version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" frame version=\" + currentFrame.maxIDVersion + \" frame ord=\" + currentFrame.ord);\n\n           if (DEBUG) {\n             System.out.println(\"  target is same as current; return true\");\n           }\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  target is same as current but term doesn't exist\");\n           }\n        }\n        //validIndexPrefix = currentFrame.depth;\n        //term.length = target.length;\n        //return termExists;\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n      //System.out.println(\"first arc=\" + arc);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n       if (DEBUG) {\n         System.out.println(\"    no seek state; push root frame\");\n       }\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    if (DEBUG) {\n      System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength + \" termExists=\" + termExists);\n    }\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n         if (DEBUG) {\n           System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + Integer.toHexString(targetLabel) + \" termExists=\" + termExists);\n         }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          term.length = 1+targetUpto;\n           if (DEBUG) {\n             System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n        //System.out.println(\"  check maxVersion=\" + currentFrame.maxIDVersion + \" vs \" + minIDVersion);\n\n        if (DEBUG) {\n          System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n        }\n\n        if (currentFrame.maxIDVersion < minIDVersion) {\n          // The max version for all terms in this block is lower than the minVersion\n          if (currentFrame.fp != startFrameFP || changed) {\n          //if (targetUpto+1 > term.length) {\n            termExists = false;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            term.length = 1+targetUpto;\n            if (DEBUG) {\n              System.out.println(\"    reset current term\");\n            }\n            validIndexPrefix = Math.min(validIndexPrefix, term.length);\n          }\n            //if (currentFrame.ord != startFrameOrd) {\n            //termExists = false;\n            //}\n          if (DEBUG) {\n            System.out.println(\"    FAST version NOT_FOUND term=\" + brToString(term) + \" targetUpto=\" + targetUpto + \" currentFrame.maxIDVersion=\" + currentFrame.maxIDVersion + \" validIndexPrefix=\" + validIndexPrefix + \" startFrameFP=\" + startFrameFP + \" vs \" + currentFrame.fp + \" termExists=\" + termExists);\n          }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        if (DEBUG) {\n          System.out.println(\"    scan currentFrame ord=\" + currentFrame.ord);\n        }\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"    return NOT_FOUND: idVersion=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" vs minIDVersion=\" + minIDVersion);\n            }\n            return false;\n          }\n\n           if (DEBUG) {\n             System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n           }\n\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n      } else {\n        // Follow this arc\n        arc = nextArc;\n        if (term.bytes[targetUpto] != (byte) targetLabel) {\n          if (DEBUG) {\n            System.out.println(\"  now set termExists=false targetUpto=\" + targetUpto + \" term=\" + term.bytes[targetUpto] + \" targetLabel=\" + targetLabel);\n          }\n          changed = true;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          termExists = false;\n        }\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n         if (DEBUG) {\n           System.out.println(\"    index: follow label=\" + (char) ((target.bytes[target.offset + targetUpto]&0xff)) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n         }\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    // Target term is entirely contained in the index:\n    if (!currentFrame.hasTerms) {\n      termExists = false;\n      term.length = targetUpto;\n       if (DEBUG) {\n         System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n       }\n      return false;\n    }\n\n    if (DEBUG) {\n      System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n    }\n\n    if (currentFrame.maxIDVersion < minIDVersion) {\n      // The max version for all terms in this block is lower than the minVersion\n      termExists = false;\n      term.length = targetUpto;\n      return false;\n    }\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, true);            \n    if (result == SeekStatus.FOUND) {\n       if (DEBUG) {\n         System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n       }\n      currentFrame.decodeMetaData();\n      if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n        // This term's version is lower than the minVersion\n        return false;\n      }\n      return true;\n    } else {\n       if (DEBUG) {\n         System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n       }\n\n      return false;\n    }\n  }\n\n","sourceOld":"  /** Returns false if the term deos not exist, or it exists but its version is too old (< minIDVersion). */\n  public boolean seekExact(final BytesRef target, long minIDVersion) throws IOException {\n\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    // nocommit would be nice if somehow on doing deletes we didn't have to double-lookup again...\n\n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n     if (DEBUG) {\n       System.out.println(\"\\nBTTR.seekExact seg=\" + fr.parent.segment + \" target=\" + fr.fieldInfo.name + \":\" + brToString(target) + \" minIDVersion=\" + minIDVersion + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n       printSeekState(System.out);\n     }\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    long startFrameFP = currentFrame.fp;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    boolean changed = false;\n\n    // nocommit we could stop earlier w/ the version check, every time we traverse an index arc we can check?\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n       if (DEBUG) {\n         System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n       }\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n\n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length: \"validIndexPrefix=\" + validIndexPrefix + \" term.length=\" + term.length + \" seg=\" + fr.parent.segment;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: reverse vLong byte order for better FST\n      // prefix output sharing\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n         if (DEBUG) {\n           System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n         }\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n        //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n        //}\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame; we only do this\n        // to find out if the target term is before,\n        // equal or after the current term\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n           if (DEBUG) {\n             System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n           }\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n         if (DEBUG) {\n           System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord + \"; targetUpto=\" + targetUpto);\n         }\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        changed = true;\n         if (DEBUG) {\n           System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n         }\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n        // nocommit put this back to BT also?\n        //term.length = targetUpto;\n\n        // nocommit put this back???\n        //termExists = false;\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n\n          if (currentFrame.maxIDVersion < minIDVersion) {\n            // The max version for all terms in this block is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current maxIDVersion=\" + currentFrame.maxIDVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current but version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n          System.out.println(\"  term version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" frame version=\" + currentFrame.maxIDVersion + \" frame ord=\" + currentFrame.ord);\n\n           if (DEBUG) {\n             System.out.println(\"  target is same as current; return true\");\n           }\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  target is same as current but term doesn't exist\");\n           }\n        }\n        //validIndexPrefix = currentFrame.depth;\n        //term.length = target.length;\n        //return termExists;\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n      //System.out.println(\"first arc=\" + arc);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n       if (DEBUG) {\n         System.out.println(\"    no seek state; push root frame\");\n       }\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    if (DEBUG) {\n      System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength + \" termExists=\" + termExists);\n    }\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n         if (DEBUG) {\n           System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + Integer.toHexString(targetLabel) + \" termExists=\" + termExists);\n         }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          term.length = 1+targetUpto;\n           if (DEBUG) {\n             System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n        //System.out.println(\"  check maxVersion=\" + currentFrame.maxIDVersion + \" vs \" + minIDVersion);\n\n        if (DEBUG) {\n          System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n        }\n\n        if (currentFrame.maxIDVersion < minIDVersion) {\n          // The max version for all terms in this block is lower than the minVersion\n          if (currentFrame.fp != startFrameFP || changed) {\n          //if (targetUpto+1 > term.length) {\n            termExists = false;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            term.length = 1+targetUpto;\n            if (DEBUG) {\n              System.out.println(\"    reset current term\");\n            }\n            validIndexPrefix = Math.min(validIndexPrefix, term.length);\n          }\n            //if (currentFrame.ord != startFrameOrd) {\n            //termExists = false;\n            //}\n          if (DEBUG) {\n            System.out.println(\"    FAST version NOT_FOUND term=\" + brToString(term) + \" targetUpto=\" + targetUpto + \" currentFrame.maxIDVersion=\" + currentFrame.maxIDVersion + \" validIndexPrefix=\" + validIndexPrefix + \" startFrameFP=\" + startFrameFP + \" vs \" + currentFrame.fp + \" termExists=\" + termExists);\n          }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        if (DEBUG) {\n          System.out.println(\"    scan currentFrame ord=\" + currentFrame.ord);\n        }\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"    return NOT_FOUND: idVersion=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" vs minIDVersion=\" + minIDVersion);\n            }\n            return false;\n          }\n\n           if (DEBUG) {\n             System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n           }\n\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n      } else {\n        // Follow this arc\n        arc = nextArc;\n        if (term.bytes[targetUpto] != (byte) targetLabel) {\n          if (DEBUG) {\n            System.out.println(\"  now set termExists=false targetUpto=\" + targetUpto + \" term=\" + term.bytes[targetUpto] + \" targetLabel=\" + targetLabel);\n          }\n          changed = true;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          termExists = false;\n        }\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n         if (DEBUG) {\n           System.out.println(\"    index: follow label=\" + (char) ((target.bytes[target.offset + targetUpto]&0xff)) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n         }\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    // Target term is entirely contained in the index:\n    if (!currentFrame.hasTerms) {\n      termExists = false;\n      term.length = targetUpto;\n       if (DEBUG) {\n         System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n       }\n      return false;\n    }\n\n    if (DEBUG) {\n      System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n    }\n\n    if (currentFrame.maxIDVersion < minIDVersion) {\n      // The max version for all terms in this block is lower than the minVersion\n      // nocommit need same logic here as above?\n      termExists = false;\n      term.length = targetUpto;\n      return false;\n    }\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, true);            \n    if (result == SeekStatus.FOUND) {\n       if (DEBUG) {\n         System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n       }\n      currentFrame.decodeMetaData();\n      if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n        // This term's version is lower than the minVersion\n        return false;\n      }\n      return true;\n    } else {\n       if (DEBUG) {\n         System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n       }\n\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0efcf27cd5ca23def8376b4c321970c14dd71623","date":1400662679,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","sourceNew":"  /** Returns false if the term does not exist, or it exists but its version is too old (< minIDVersion). */\n  public boolean seekExact(final BytesRef target, long minIDVersion) throws IOException {\n\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n     if (DEBUG) {\n       System.out.println(\"\\nBTTR.seekExact seg=\" + fr.parent.segment + \" target=\" + fr.fieldInfo.name + \":\" + brToString(target) + \" minIDVersion=\" + minIDVersion + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n       printSeekState(System.out);\n     }\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    long startFrameFP = currentFrame.fp;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    boolean changed = false;\n\n    // TODO: we could stop earlier w/ the version check, every time we traverse an index arc we can check?\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n       if (DEBUG) {\n         System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n       }\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n\n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length: \"validIndexPrefix=\" + validIndexPrefix + \" term.length=\" + term.length + \" seg=\" + fr.parent.segment;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: reverse vLong byte order for better FST\n      // prefix output sharing\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n         if (DEBUG) {\n           System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n         }\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n        //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n        //}\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame; we only do this\n        // to find out if the target term is before,\n        // equal or after the current term\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n           if (DEBUG) {\n             System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n           }\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n         if (DEBUG) {\n           System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord + \"; targetUpto=\" + targetUpto);\n         }\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        changed = true;\n         if (DEBUG) {\n           System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n         }\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n\n          if (currentFrame.maxIDVersion < minIDVersion) {\n            // The max version for all terms in this block is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current maxIDVersion=\" + currentFrame.maxIDVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current but version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n          // System.out.println(\"  term version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" frame version=\" + currentFrame.maxIDVersion + \" frame ord=\" + currentFrame.ord);\n\n           if (DEBUG) {\n             System.out.println(\"  target is same as current; return true\");\n           }\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  target is same as current but term doesn't exist\");\n           }\n        }\n        //validIndexPrefix = currentFrame.depth;\n        //term.length = target.length;\n        //return termExists;\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n      //System.out.println(\"first arc=\" + arc);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n       if (DEBUG) {\n         System.out.println(\"    no seek state; push root frame\");\n       }\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    if (DEBUG) {\n      System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength + \" termExists=\" + termExists);\n    }\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n         if (DEBUG) {\n           System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + Integer.toHexString(targetLabel) + \" termExists=\" + termExists);\n         }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          term.length = 1+targetUpto;\n           if (DEBUG) {\n             System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n        //System.out.println(\"  check maxVersion=\" + currentFrame.maxIDVersion + \" vs \" + minIDVersion);\n\n        if (DEBUG) {\n          System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n        }\n\n        if (currentFrame.maxIDVersion < minIDVersion) {\n          // The max version for all terms in this block is lower than the minVersion\n          if (currentFrame.fp != startFrameFP || changed) {\n          //if (targetUpto+1 > term.length) {\n            termExists = false;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            term.length = 1+targetUpto;\n            if (DEBUG) {\n              System.out.println(\"    reset current term\");\n            }\n            validIndexPrefix = Math.min(validIndexPrefix, term.length);\n          }\n            //if (currentFrame.ord != startFrameOrd) {\n            //termExists = false;\n            //}\n          if (DEBUG) {\n            System.out.println(\"    FAST version NOT_FOUND term=\" + brToString(term) + \" targetUpto=\" + targetUpto + \" currentFrame.maxIDVersion=\" + currentFrame.maxIDVersion + \" validIndexPrefix=\" + validIndexPrefix + \" startFrameFP=\" + startFrameFP + \" vs \" + currentFrame.fp + \" termExists=\" + termExists);\n          }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        if (DEBUG) {\n          System.out.println(\"    scan currentFrame ord=\" + currentFrame.ord);\n        }\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"    return NOT_FOUND: idVersion=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" vs minIDVersion=\" + minIDVersion);\n            }\n            return false;\n          }\n\n           if (DEBUG) {\n             System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n           }\n\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n      } else {\n        // Follow this arc\n        arc = nextArc;\n        if (term.bytes[targetUpto] != (byte) targetLabel) {\n          if (DEBUG) {\n            System.out.println(\"  now set termExists=false targetUpto=\" + targetUpto + \" term=\" + term.bytes[targetUpto] + \" targetLabel=\" + targetLabel);\n          }\n          changed = true;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          termExists = false;\n        }\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n         if (DEBUG) {\n           System.out.println(\"    index: follow label=\" + (char) ((target.bytes[target.offset + targetUpto]&0xff)) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n         }\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    // Target term is entirely contained in the index:\n    if (!currentFrame.hasTerms) {\n      termExists = false;\n      term.length = targetUpto;\n       if (DEBUG) {\n         System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n       }\n      return false;\n    }\n\n    if (DEBUG) {\n      System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n    }\n\n    if (currentFrame.maxIDVersion < minIDVersion) {\n      // The max version for all terms in this block is lower than the minVersion\n      termExists = false;\n      term.length = targetUpto;\n      return false;\n    }\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, true);            \n    if (result == SeekStatus.FOUND) {\n       if (DEBUG) {\n         System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n       }\n      currentFrame.decodeMetaData();\n      if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n        // This term's version is lower than the minVersion\n        return false;\n      }\n      return true;\n    } else {\n       if (DEBUG) {\n         System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n       }\n\n      return false;\n    }\n  }\n\n","sourceOld":"  /** Returns false if the term deos not exist, or it exists but its version is too old (< minIDVersion). */\n  public boolean seekExact(final BytesRef target, long minIDVersion) throws IOException {\n\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    // nocommit would be nice if somehow on doing deletes we didn't have to double-lookup again...\n\n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n     if (DEBUG) {\n       System.out.println(\"\\nBTTR.seekExact seg=\" + fr.parent.segment + \" target=\" + fr.fieldInfo.name + \":\" + brToString(target) + \" minIDVersion=\" + minIDVersion + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n       printSeekState(System.out);\n     }\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    long startFrameFP = currentFrame.fp;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    boolean changed = false;\n\n    // nocommit we could stop earlier w/ the version check, every time we traverse an index arc we can check?\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n       if (DEBUG) {\n         System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n       }\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n\n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length: \"validIndexPrefix=\" + validIndexPrefix + \" term.length=\" + term.length + \" seg=\" + fr.parent.segment;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: reverse vLong byte order for better FST\n      // prefix output sharing\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n         if (DEBUG) {\n           System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n         }\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n        //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n        //}\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame; we only do this\n        // to find out if the target term is before,\n        // equal or after the current term\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n           if (DEBUG) {\n             System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n           }\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n         if (DEBUG) {\n           System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord + \"; targetUpto=\" + targetUpto);\n         }\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        changed = true;\n         if (DEBUG) {\n           System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n         }\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n\n          if (currentFrame.maxIDVersion < minIDVersion) {\n            // The max version for all terms in this block is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current maxIDVersion=\" + currentFrame.maxIDVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current but version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n          System.out.println(\"  term version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" frame version=\" + currentFrame.maxIDVersion + \" frame ord=\" + currentFrame.ord);\n\n           if (DEBUG) {\n             System.out.println(\"  target is same as current; return true\");\n           }\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  target is same as current but term doesn't exist\");\n           }\n        }\n        //validIndexPrefix = currentFrame.depth;\n        //term.length = target.length;\n        //return termExists;\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n      //System.out.println(\"first arc=\" + arc);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n       if (DEBUG) {\n         System.out.println(\"    no seek state; push root frame\");\n       }\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    if (DEBUG) {\n      System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength + \" termExists=\" + termExists);\n    }\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n         if (DEBUG) {\n           System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + Integer.toHexString(targetLabel) + \" termExists=\" + termExists);\n         }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          term.length = 1+targetUpto;\n           if (DEBUG) {\n             System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n        //System.out.println(\"  check maxVersion=\" + currentFrame.maxIDVersion + \" vs \" + minIDVersion);\n\n        if (DEBUG) {\n          System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n        }\n\n        if (currentFrame.maxIDVersion < minIDVersion) {\n          // The max version for all terms in this block is lower than the minVersion\n          if (currentFrame.fp != startFrameFP || changed) {\n          //if (targetUpto+1 > term.length) {\n            termExists = false;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            term.length = 1+targetUpto;\n            if (DEBUG) {\n              System.out.println(\"    reset current term\");\n            }\n            validIndexPrefix = Math.min(validIndexPrefix, term.length);\n          }\n            //if (currentFrame.ord != startFrameOrd) {\n            //termExists = false;\n            //}\n          if (DEBUG) {\n            System.out.println(\"    FAST version NOT_FOUND term=\" + brToString(term) + \" targetUpto=\" + targetUpto + \" currentFrame.maxIDVersion=\" + currentFrame.maxIDVersion + \" validIndexPrefix=\" + validIndexPrefix + \" startFrameFP=\" + startFrameFP + \" vs \" + currentFrame.fp + \" termExists=\" + termExists);\n          }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        if (DEBUG) {\n          System.out.println(\"    scan currentFrame ord=\" + currentFrame.ord);\n        }\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"    return NOT_FOUND: idVersion=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" vs minIDVersion=\" + minIDVersion);\n            }\n            return false;\n          }\n\n           if (DEBUG) {\n             System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n           }\n\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n      } else {\n        // Follow this arc\n        arc = nextArc;\n        if (term.bytes[targetUpto] != (byte) targetLabel) {\n          if (DEBUG) {\n            System.out.println(\"  now set termExists=false targetUpto=\" + targetUpto + \" term=\" + term.bytes[targetUpto] + \" targetLabel=\" + targetLabel);\n          }\n          changed = true;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          termExists = false;\n        }\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n         if (DEBUG) {\n           System.out.println(\"    index: follow label=\" + (char) ((target.bytes[target.offset + targetUpto]&0xff)) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n         }\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    // Target term is entirely contained in the index:\n    if (!currentFrame.hasTerms) {\n      termExists = false;\n      term.length = targetUpto;\n       if (DEBUG) {\n         System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n       }\n      return false;\n    }\n\n    if (DEBUG) {\n      System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n    }\n\n    if (currentFrame.maxIDVersion < minIDVersion) {\n      // The max version for all terms in this block is lower than the minVersion\n      termExists = false;\n      term.length = targetUpto;\n      return false;\n    }\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, true);            \n    if (result == SeekStatus.FOUND) {\n       if (DEBUG) {\n         System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n       }\n      currentFrame.decodeMetaData();\n      if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n        // This term's version is lower than the minVersion\n        return false;\n      }\n      return true;\n    } else {\n       if (DEBUG) {\n         System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n       }\n\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ae62bdfdfc2a17d4df98e6004938c8b0eed0a20","date":1400712483,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","sourceNew":"  /** Returns false if the term does not exist, or it exists but its version is too old (< minIDVersion). */\n  public boolean seekExact(final BytesRef target, long minIDVersion) throws IOException {\n\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n    //  if (DEBUG) {\n    //    System.out.println(\"\\nBTTR.seekExact seg=\" + fr.parent.segment + \" target=\" + fr.fieldInfo.name + \":\" + brToString(target) + \" minIDVersion=\" + minIDVersion + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n    //   printSeekState(System.out);\n    //  }\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    long startFrameFP = currentFrame.fp;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    boolean changed = false;\n\n    // TODO: we could stop earlier w/ the version check, every time we traverse an index arc we can check?\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      // if (DEBUG) {\n      //    System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      //  }\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n\n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length: \"validIndexPrefix=\" + validIndexPrefix + \" term.length=\" + term.length + \" seg=\" + fr.parent.segment;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: reverse vLong byte order for better FST\n      // prefix output sharing\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        // if (DEBUG) {\n        //    System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        // }\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n        //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n        //}\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame; we only do this\n        // to find out if the target term is before,\n        // equal or after the current term\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          // if (DEBUG) {\n          //    System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          // }\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        // if (DEBUG) {\n        //    System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord + \"; targetUpto=\" + targetUpto);\n        //  }\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        changed = true;\n        // if (DEBUG) {\n        //    System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        //  }\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n\n          if (currentFrame.maxIDVersion < minIDVersion) {\n            // The max version for all terms in this block is lower than the minVersion\n            // if (DEBUG) {\n            //   System.out.println(\"  target is same as current maxIDVersion=\" + currentFrame.maxIDVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            // }\n            return false;\n          }\n\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            // if (DEBUG) {\n            //   System.out.println(\"  target is same as current but version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            // }\n            return false;\n          }\n          // System.out.println(\"  term version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" frame version=\" + currentFrame.maxIDVersion + \" frame ord=\" + currentFrame.ord);\n\n          // if (DEBUG) {\n          //    System.out.println(\"  target is same as current; return true\");\n          //  }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //    System.out.println(\"  target is same as current but term doesn't exist\");\n          //  }\n        }\n        //validIndexPrefix = currentFrame.depth;\n        //term.length = target.length;\n        //return termExists;\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n      //System.out.println(\"first arc=\" + arc);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n      // if (DEBUG) {\n      //    System.out.println(\"    no seek state; push root frame\");\n      //  }\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    // if (DEBUG) {\n    //   System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength + \" termExists=\" + termExists);\n    // }\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //    System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + Integer.toHexString(targetLabel) + \" termExists=\" + termExists);\n        //  }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          term.length = 1+targetUpto;\n          // if (DEBUG) {\n          //    System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n          //  }\n          return false;\n        }\n        //System.out.println(\"  check maxVersion=\" + currentFrame.maxIDVersion + \" vs \" + minIDVersion);\n\n        // if (DEBUG) {\n        //   System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n        // }\n\n        if (currentFrame.maxIDVersion < minIDVersion) {\n          // The max version for all terms in this block is lower than the minVersion\n          if (currentFrame.fp != startFrameFP || changed) {\n          //if (targetUpto+1 > term.length) {\n            termExists = false;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            term.length = 1+targetUpto;\n            // if (DEBUG) {\n            //   System.out.println(\"    reset current term\");\n            // }\n            validIndexPrefix = Math.min(validIndexPrefix, term.length);\n          }\n            //if (currentFrame.ord != startFrameOrd) {\n            //termExists = false;\n            //}\n          // if (DEBUG) {\n          //   System.out.println(\"    FAST version NOT_FOUND term=\" + brToString(term) + \" targetUpto=\" + targetUpto + \" currentFrame.maxIDVersion=\" + currentFrame.maxIDVersion + \" validIndexPrefix=\" + validIndexPrefix + \" startFrameFP=\" + startFrameFP + \" vs \" + currentFrame.fp + \" termExists=\" + termExists);\n          // }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        // if (DEBUG) {\n        //   System.out.println(\"    scan currentFrame ord=\" + currentFrame.ord);\n        // }\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            // if (DEBUG) {\n            //   System.out.println(\"    return NOT_FOUND: idVersion=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" vs minIDVersion=\" + minIDVersion);\n            // }\n            return false;\n          }\n\n          // if (DEBUG) {\n          //    System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n          //  }\n\n          return true;\n        } else {\n          // if (DEBUG) {\n          //    System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n      } else {\n        // Follow this arc\n        arc = nextArc;\n        if (term.bytes[targetUpto] != (byte) targetLabel) {\n          // if (DEBUG) {\n          //   System.out.println(\"  now set termExists=false targetUpto=\" + targetUpto + \" term=\" + term.bytes[targetUpto] + \" targetLabel=\" + targetLabel);\n          // }\n          changed = true;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          termExists = false;\n        }\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n        // if (DEBUG) {\n        //    System.out.println(\"    index: follow label=\" + (char) ((target.bytes[target.offset + targetUpto]&0xff)) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        //  }\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          // if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          // if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    // Target term is entirely contained in the index:\n    if (!currentFrame.hasTerms) {\n      termExists = false;\n      term.length = targetUpto;\n      // if (DEBUG) {\n      //    System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n      //  }\n      return false;\n    }\n\n    // if (DEBUG) {\n    //   System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n    // }\n\n    if (currentFrame.maxIDVersion < minIDVersion) {\n      // The max version for all terms in this block is lower than the minVersion\n      termExists = false;\n      term.length = targetUpto;\n      return false;\n    }\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, true);            \n    if (result == SeekStatus.FOUND) {\n      // if (DEBUG) {\n      //    System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n      //  }\n      currentFrame.decodeMetaData();\n      if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n        // This term's version is lower than the minVersion\n        return false;\n      }\n      return true;\n    } else {\n      // if (DEBUG) {\n      //    System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n      //  }\n\n      return false;\n    }\n  }\n\n","sourceOld":"  /** Returns false if the term does not exist, or it exists but its version is too old (< minIDVersion). */\n  public boolean seekExact(final BytesRef target, long minIDVersion) throws IOException {\n\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n     if (DEBUG) {\n       System.out.println(\"\\nBTTR.seekExact seg=\" + fr.parent.segment + \" target=\" + fr.fieldInfo.name + \":\" + brToString(target) + \" minIDVersion=\" + minIDVersion + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n       printSeekState(System.out);\n     }\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    long startFrameFP = currentFrame.fp;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    boolean changed = false;\n\n    // TODO: we could stop earlier w/ the version check, every time we traverse an index arc we can check?\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n       if (DEBUG) {\n         System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n       }\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n\n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length: \"validIndexPrefix=\" + validIndexPrefix + \" term.length=\" + term.length + \" seg=\" + fr.parent.segment;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: reverse vLong byte order for better FST\n      // prefix output sharing\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n         if (DEBUG) {\n           System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n         }\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n        //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n        //}\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame; we only do this\n        // to find out if the target term is before,\n        // equal or after the current term\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n           if (DEBUG) {\n             System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n           }\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n         if (DEBUG) {\n           System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord + \"; targetUpto=\" + targetUpto);\n         }\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        changed = true;\n         if (DEBUG) {\n           System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n         }\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n\n          if (currentFrame.maxIDVersion < minIDVersion) {\n            // The max version for all terms in this block is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current maxIDVersion=\" + currentFrame.maxIDVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"  target is same as current but version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            }\n            return false;\n          }\n          // System.out.println(\"  term version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" frame version=\" + currentFrame.maxIDVersion + \" frame ord=\" + currentFrame.ord);\n\n           if (DEBUG) {\n             System.out.println(\"  target is same as current; return true\");\n           }\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  target is same as current but term doesn't exist\");\n           }\n        }\n        //validIndexPrefix = currentFrame.depth;\n        //term.length = target.length;\n        //return termExists;\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n      //System.out.println(\"first arc=\" + arc);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n       if (DEBUG) {\n         System.out.println(\"    no seek state; push root frame\");\n       }\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    if (DEBUG) {\n      System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength + \" termExists=\" + termExists);\n    }\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n         if (DEBUG) {\n           System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + Integer.toHexString(targetLabel) + \" termExists=\" + termExists);\n         }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          term.length = 1+targetUpto;\n           if (DEBUG) {\n             System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n        //System.out.println(\"  check maxVersion=\" + currentFrame.maxIDVersion + \" vs \" + minIDVersion);\n\n        if (DEBUG) {\n          System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n        }\n\n        if (currentFrame.maxIDVersion < minIDVersion) {\n          // The max version for all terms in this block is lower than the minVersion\n          if (currentFrame.fp != startFrameFP || changed) {\n          //if (targetUpto+1 > term.length) {\n            termExists = false;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            term.length = 1+targetUpto;\n            if (DEBUG) {\n              System.out.println(\"    reset current term\");\n            }\n            validIndexPrefix = Math.min(validIndexPrefix, term.length);\n          }\n            //if (currentFrame.ord != startFrameOrd) {\n            //termExists = false;\n            //}\n          if (DEBUG) {\n            System.out.println(\"    FAST version NOT_FOUND term=\" + brToString(term) + \" targetUpto=\" + targetUpto + \" currentFrame.maxIDVersion=\" + currentFrame.maxIDVersion + \" validIndexPrefix=\" + validIndexPrefix + \" startFrameFP=\" + startFrameFP + \" vs \" + currentFrame.fp + \" termExists=\" + termExists);\n          }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        if (DEBUG) {\n          System.out.println(\"    scan currentFrame ord=\" + currentFrame.ord);\n        }\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            if (DEBUG) {\n              System.out.println(\"    return NOT_FOUND: idVersion=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" vs minIDVersion=\" + minIDVersion);\n            }\n            return false;\n          }\n\n           if (DEBUG) {\n             System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n           }\n\n          return true;\n        } else {\n           if (DEBUG) {\n             System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n           }\n          return false;\n        }\n      } else {\n        // Follow this arc\n        arc = nextArc;\n        if (term.bytes[targetUpto] != (byte) targetLabel) {\n          if (DEBUG) {\n            System.out.println(\"  now set termExists=false targetUpto=\" + targetUpto + \" term=\" + term.bytes[targetUpto] + \" targetLabel=\" + targetLabel);\n          }\n          changed = true;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          termExists = false;\n        }\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n         if (DEBUG) {\n           System.out.println(\"    index: follow label=\" + (char) ((target.bytes[target.offset + targetUpto]&0xff)) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n         }\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    // Target term is entirely contained in the index:\n    if (!currentFrame.hasTerms) {\n      termExists = false;\n      term.length = targetUpto;\n       if (DEBUG) {\n         System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n       }\n      return false;\n    }\n\n    if (DEBUG) {\n      System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n    }\n\n    if (currentFrame.maxIDVersion < minIDVersion) {\n      // The max version for all terms in this block is lower than the minVersion\n      termExists = false;\n      term.length = targetUpto;\n      return false;\n    }\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, true);            \n    if (result == SeekStatus.FOUND) {\n       if (DEBUG) {\n         System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n       }\n      currentFrame.decodeMetaData();\n      if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n        // This term's version is lower than the minVersion\n        return false;\n      }\n      return true;\n    } else {\n       if (DEBUG) {\n         System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n       }\n\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ca044bd4a0bea8391cbebb44a34aba53a9b50541","date":1400784655,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","sourceNew":"  /** Optimized version of {@link #seekExact(BytesRef)} that can\n   *  sometimes fail-fast if the version indexed with the requested ID\n   *  is less than the specified minIDVersion.  Applications that index\n   *  a monotonically increasing global version with each document can\n   *  use this for fast optimistic concurrency. */\n  public boolean seekExact(final BytesRef target, long minIDVersion) throws IOException {\n\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n    //  if (DEBUG) {\n    //    System.out.println(\"\\nBTTR.seekExact seg=\" + fr.parent.segment + \" target=\" + fr.fieldInfo.name + \":\" + brToString(target) + \" minIDVersion=\" + minIDVersion + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n    //   printSeekState(System.out);\n    //  }\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    long startFrameFP = currentFrame.fp;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    boolean changed = false;\n\n    // TODO: we could stop earlier w/ the version check, every time we traverse an index arc we can check?\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      // if (DEBUG) {\n      //    System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      //  }\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n\n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length: \"validIndexPrefix=\" + validIndexPrefix + \" term.length=\" + term.length + \" seg=\" + fr.parent.segment;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: reverse vLong byte order for better FST\n      // prefix output sharing\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        // if (DEBUG) {\n        //    System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        // }\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n        //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n        //}\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame; we only do this\n        // to find out if the target term is before,\n        // equal or after the current term\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          // if (DEBUG) {\n          //    System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          // }\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        // if (DEBUG) {\n        //    System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord + \"; targetUpto=\" + targetUpto);\n        //  }\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        changed = true;\n        // if (DEBUG) {\n        //    System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        //  }\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n\n          if (currentFrame.maxIDVersion < minIDVersion) {\n            // The max version for all terms in this block is lower than the minVersion\n            // if (DEBUG) {\n            //   System.out.println(\"  target is same as current maxIDVersion=\" + currentFrame.maxIDVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            // }\n            return false;\n          }\n\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            // if (DEBUG) {\n            //   System.out.println(\"  target is same as current but version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            // }\n            return false;\n          }\n          // System.out.println(\"  term version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" frame version=\" + currentFrame.maxIDVersion + \" frame ord=\" + currentFrame.ord);\n\n          // if (DEBUG) {\n          //    System.out.println(\"  target is same as current; return true\");\n          //  }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //    System.out.println(\"  target is same as current but term doesn't exist\");\n          //  }\n        }\n        //validIndexPrefix = currentFrame.depth;\n        //term.length = target.length;\n        //return termExists;\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n      //System.out.println(\"first arc=\" + arc);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n      // if (DEBUG) {\n      //    System.out.println(\"    no seek state; push root frame\");\n      //  }\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    // if (DEBUG) {\n    //   System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength + \" termExists=\" + termExists);\n    // }\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //    System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + Integer.toHexString(targetLabel) + \" termExists=\" + termExists);\n        //  }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          term.length = 1+targetUpto;\n          // if (DEBUG) {\n          //    System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n          //  }\n          return false;\n        }\n        //System.out.println(\"  check maxVersion=\" + currentFrame.maxIDVersion + \" vs \" + minIDVersion);\n\n        // if (DEBUG) {\n        //   System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n        // }\n\n        if (currentFrame.maxIDVersion < minIDVersion) {\n          // The max version for all terms in this block is lower than the minVersion\n          if (currentFrame.fp != startFrameFP || changed) {\n          //if (targetUpto+1 > term.length) {\n            termExists = false;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            term.length = 1+targetUpto;\n            // if (DEBUG) {\n            //   System.out.println(\"    reset current term\");\n            // }\n            validIndexPrefix = Math.min(validIndexPrefix, term.length);\n          }\n            //if (currentFrame.ord != startFrameOrd) {\n            //termExists = false;\n            //}\n          // if (DEBUG) {\n          //   System.out.println(\"    FAST version NOT_FOUND term=\" + brToString(term) + \" targetUpto=\" + targetUpto + \" currentFrame.maxIDVersion=\" + currentFrame.maxIDVersion + \" validIndexPrefix=\" + validIndexPrefix + \" startFrameFP=\" + startFrameFP + \" vs \" + currentFrame.fp + \" termExists=\" + termExists);\n          // }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        // if (DEBUG) {\n        //   System.out.println(\"    scan currentFrame ord=\" + currentFrame.ord);\n        // }\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            // if (DEBUG) {\n            //   System.out.println(\"    return NOT_FOUND: idVersion=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" vs minIDVersion=\" + minIDVersion);\n            // }\n            return false;\n          }\n\n          // if (DEBUG) {\n          //    System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n          //  }\n\n          return true;\n        } else {\n          // if (DEBUG) {\n          //    System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n      } else {\n        // Follow this arc\n        arc = nextArc;\n        if (term.bytes[targetUpto] != (byte) targetLabel) {\n          // if (DEBUG) {\n          //   System.out.println(\"  now set termExists=false targetUpto=\" + targetUpto + \" term=\" + term.bytes[targetUpto] + \" targetLabel=\" + targetLabel);\n          // }\n          changed = true;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          termExists = false;\n        }\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n        // if (DEBUG) {\n        //    System.out.println(\"    index: follow label=\" + (char) ((target.bytes[target.offset + targetUpto]&0xff)) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        //  }\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          // if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          // if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    // Target term is entirely contained in the index:\n    if (!currentFrame.hasTerms) {\n      termExists = false;\n      term.length = targetUpto;\n      // if (DEBUG) {\n      //    System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n      //  }\n      return false;\n    }\n\n    // if (DEBUG) {\n    //   System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n    // }\n\n    if (currentFrame.maxIDVersion < minIDVersion) {\n      // The max version for all terms in this block is lower than the minVersion\n      termExists = false;\n      term.length = targetUpto;\n      return false;\n    }\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, true);            \n    if (result == SeekStatus.FOUND) {\n      // if (DEBUG) {\n      //    System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n      //  }\n      currentFrame.decodeMetaData();\n      if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n        // This term's version is lower than the minVersion\n        return false;\n      }\n      return true;\n    } else {\n      // if (DEBUG) {\n      //    System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n      //  }\n\n      return false;\n    }\n  }\n\n","sourceOld":"  /** Returns false if the term does not exist, or it exists but its version is too old (< minIDVersion). */\n  public boolean seekExact(final BytesRef target, long minIDVersion) throws IOException {\n\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n    //  if (DEBUG) {\n    //    System.out.println(\"\\nBTTR.seekExact seg=\" + fr.parent.segment + \" target=\" + fr.fieldInfo.name + \":\" + brToString(target) + \" minIDVersion=\" + minIDVersion + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n    //   printSeekState(System.out);\n    //  }\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    long startFrameFP = currentFrame.fp;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    boolean changed = false;\n\n    // TODO: we could stop earlier w/ the version check, every time we traverse an index arc we can check?\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      // if (DEBUG) {\n      //    System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      //  }\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n\n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length: \"validIndexPrefix=\" + validIndexPrefix + \" term.length=\" + term.length + \" seg=\" + fr.parent.segment;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: reverse vLong byte order for better FST\n      // prefix output sharing\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        // if (DEBUG) {\n        //    System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        // }\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n        //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n        //}\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame; we only do this\n        // to find out if the target term is before,\n        // equal or after the current term\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          // if (DEBUG) {\n          //    System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          // }\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        // if (DEBUG) {\n        //    System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord + \"; targetUpto=\" + targetUpto);\n        //  }\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        changed = true;\n        // if (DEBUG) {\n        //    System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        //  }\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n\n          if (currentFrame.maxIDVersion < minIDVersion) {\n            // The max version for all terms in this block is lower than the minVersion\n            // if (DEBUG) {\n            //   System.out.println(\"  target is same as current maxIDVersion=\" + currentFrame.maxIDVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            // }\n            return false;\n          }\n\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            // if (DEBUG) {\n            //   System.out.println(\"  target is same as current but version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            // }\n            return false;\n          }\n          // System.out.println(\"  term version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" frame version=\" + currentFrame.maxIDVersion + \" frame ord=\" + currentFrame.ord);\n\n          // if (DEBUG) {\n          //    System.out.println(\"  target is same as current; return true\");\n          //  }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //    System.out.println(\"  target is same as current but term doesn't exist\");\n          //  }\n        }\n        //validIndexPrefix = currentFrame.depth;\n        //term.length = target.length;\n        //return termExists;\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n      //System.out.println(\"first arc=\" + arc);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n      // if (DEBUG) {\n      //    System.out.println(\"    no seek state; push root frame\");\n      //  }\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    // if (DEBUG) {\n    //   System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength + \" termExists=\" + termExists);\n    // }\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //    System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + Integer.toHexString(targetLabel) + \" termExists=\" + termExists);\n        //  }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          term.length = 1+targetUpto;\n          // if (DEBUG) {\n          //    System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n          //  }\n          return false;\n        }\n        //System.out.println(\"  check maxVersion=\" + currentFrame.maxIDVersion + \" vs \" + minIDVersion);\n\n        // if (DEBUG) {\n        //   System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n        // }\n\n        if (currentFrame.maxIDVersion < minIDVersion) {\n          // The max version for all terms in this block is lower than the minVersion\n          if (currentFrame.fp != startFrameFP || changed) {\n          //if (targetUpto+1 > term.length) {\n            termExists = false;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            term.length = 1+targetUpto;\n            // if (DEBUG) {\n            //   System.out.println(\"    reset current term\");\n            // }\n            validIndexPrefix = Math.min(validIndexPrefix, term.length);\n          }\n            //if (currentFrame.ord != startFrameOrd) {\n            //termExists = false;\n            //}\n          // if (DEBUG) {\n          //   System.out.println(\"    FAST version NOT_FOUND term=\" + brToString(term) + \" targetUpto=\" + targetUpto + \" currentFrame.maxIDVersion=\" + currentFrame.maxIDVersion + \" validIndexPrefix=\" + validIndexPrefix + \" startFrameFP=\" + startFrameFP + \" vs \" + currentFrame.fp + \" termExists=\" + termExists);\n          // }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        // if (DEBUG) {\n        //   System.out.println(\"    scan currentFrame ord=\" + currentFrame.ord);\n        // }\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            // if (DEBUG) {\n            //   System.out.println(\"    return NOT_FOUND: idVersion=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" vs minIDVersion=\" + minIDVersion);\n            // }\n            return false;\n          }\n\n          // if (DEBUG) {\n          //    System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n          //  }\n\n          return true;\n        } else {\n          // if (DEBUG) {\n          //    System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n      } else {\n        // Follow this arc\n        arc = nextArc;\n        if (term.bytes[targetUpto] != (byte) targetLabel) {\n          // if (DEBUG) {\n          //   System.out.println(\"  now set termExists=false targetUpto=\" + targetUpto + \" term=\" + term.bytes[targetUpto] + \" targetLabel=\" + targetLabel);\n          // }\n          changed = true;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          termExists = false;\n        }\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n        // if (DEBUG) {\n        //    System.out.println(\"    index: follow label=\" + (char) ((target.bytes[target.offset + targetUpto]&0xff)) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        //  }\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          // if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          // if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    // Target term is entirely contained in the index:\n    if (!currentFrame.hasTerms) {\n      termExists = false;\n      term.length = targetUpto;\n      // if (DEBUG) {\n      //    System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n      //  }\n      return false;\n    }\n\n    // if (DEBUG) {\n    //   System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n    // }\n\n    if (currentFrame.maxIDVersion < minIDVersion) {\n      // The max version for all terms in this block is lower than the minVersion\n      termExists = false;\n      term.length = targetUpto;\n      return false;\n    }\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, true);            \n    if (result == SeekStatus.FOUND) {\n      // if (DEBUG) {\n      //    System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n      //  }\n      currentFrame.decodeMetaData();\n      if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n        // This term's version is lower than the minVersion\n        return false;\n      }\n      return true;\n    } else {\n      // if (DEBUG) {\n      //    System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n      //  }\n\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e","date":1400786907,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnum#seekExact(BytesRef,long).mjava","sourceNew":"  /** Optimized version of {@link #seekExact(BytesRef)} that can\n   *  sometimes fail-fast if the version indexed with the requested ID\n   *  is less than the specified minIDVersion.  Applications that index\n   *  a monotonically increasing global version with each document can\n   *  use this for fast optimistic concurrency. */\n  public boolean seekExact(final BytesRef target, long minIDVersion) throws IOException {\n\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n    //  if (DEBUG) {\n    //    System.out.println(\"\\nBTTR.seekExact seg=\" + fr.parent.segment + \" target=\" + fr.fieldInfo.name + \":\" + brToString(target) + \" minIDVersion=\" + minIDVersion + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n    //   printSeekState(System.out);\n    //  }\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    long startFrameFP = currentFrame.fp;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    boolean changed = false;\n\n    // TODO: we could stop earlier w/ the version check, every time we traverse an index arc we can check?\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      // if (DEBUG) {\n      //    System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      //  }\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n\n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length: \"validIndexPrefix=\" + validIndexPrefix + \" term.length=\" + term.length + \" seg=\" + fr.parent.segment;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: reverse vLong byte order for better FST\n      // prefix output sharing\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        // if (DEBUG) {\n        //    System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        // }\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n        //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n        //}\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame; we only do this\n        // to find out if the target term is before,\n        // equal or after the current term\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          // if (DEBUG) {\n          //    System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          // }\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        // if (DEBUG) {\n        //    System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord + \"; targetUpto=\" + targetUpto);\n        //  }\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        changed = true;\n        // if (DEBUG) {\n        //    System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        //  }\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n\n          if (currentFrame.maxIDVersion < minIDVersion) {\n            // The max version for all terms in this block is lower than the minVersion\n            // if (DEBUG) {\n            //   System.out.println(\"  target is same as current maxIDVersion=\" + currentFrame.maxIDVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            // }\n            return false;\n          }\n\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            // if (DEBUG) {\n            //   System.out.println(\"  target is same as current but version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            // }\n            return false;\n          }\n          // System.out.println(\"  term version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" frame version=\" + currentFrame.maxIDVersion + \" frame ord=\" + currentFrame.ord);\n\n          // if (DEBUG) {\n          //    System.out.println(\"  target is same as current; return true\");\n          //  }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //    System.out.println(\"  target is same as current but term doesn't exist\");\n          //  }\n        }\n        //validIndexPrefix = currentFrame.depth;\n        //term.length = target.length;\n        //return termExists;\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n      //System.out.println(\"first arc=\" + arc);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n      // if (DEBUG) {\n      //    System.out.println(\"    no seek state; push root frame\");\n      //  }\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    // if (DEBUG) {\n    //   System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength + \" termExists=\" + termExists);\n    // }\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //    System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + Integer.toHexString(targetLabel) + \" termExists=\" + termExists);\n        //  }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          term.length = 1+targetUpto;\n          // if (DEBUG) {\n          //    System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n          //  }\n          return false;\n        }\n        //System.out.println(\"  check maxVersion=\" + currentFrame.maxIDVersion + \" vs \" + minIDVersion);\n\n        // if (DEBUG) {\n        //   System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n        // }\n\n        if (currentFrame.maxIDVersion < minIDVersion) {\n          // The max version for all terms in this block is lower than the minVersion\n          if (currentFrame.fp != startFrameFP || changed) {\n          //if (targetUpto+1 > term.length) {\n            termExists = false;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            term.length = 1+targetUpto;\n            // if (DEBUG) {\n            //   System.out.println(\"    reset current term\");\n            // }\n            validIndexPrefix = Math.min(validIndexPrefix, term.length);\n          }\n            //if (currentFrame.ord != startFrameOrd) {\n            //termExists = false;\n            //}\n          // if (DEBUG) {\n          //   System.out.println(\"    FAST version NOT_FOUND term=\" + brToString(term) + \" targetUpto=\" + targetUpto + \" currentFrame.maxIDVersion=\" + currentFrame.maxIDVersion + \" validIndexPrefix=\" + validIndexPrefix + \" startFrameFP=\" + startFrameFP + \" vs \" + currentFrame.fp + \" termExists=\" + termExists);\n          // }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        // if (DEBUG) {\n        //   System.out.println(\"    scan currentFrame ord=\" + currentFrame.ord);\n        // }\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            // if (DEBUG) {\n            //   System.out.println(\"    return NOT_FOUND: idVersion=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" vs minIDVersion=\" + minIDVersion);\n            // }\n            return false;\n          }\n\n          // if (DEBUG) {\n          //    System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n          //  }\n\n          return true;\n        } else {\n          // if (DEBUG) {\n          //    System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n      } else {\n        // Follow this arc\n        arc = nextArc;\n        if (term.bytes[targetUpto] != (byte) targetLabel) {\n          // if (DEBUG) {\n          //   System.out.println(\"  now set termExists=false targetUpto=\" + targetUpto + \" term=\" + term.bytes[targetUpto] + \" targetLabel=\" + targetLabel);\n          // }\n          changed = true;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          termExists = false;\n        }\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n        // if (DEBUG) {\n        //    System.out.println(\"    index: follow label=\" + (char) ((target.bytes[target.offset + targetUpto]&0xff)) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        //  }\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          // if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          // if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    // Target term is entirely contained in the index:\n    if (!currentFrame.hasTerms) {\n      termExists = false;\n      term.length = targetUpto;\n      // if (DEBUG) {\n      //    System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n      //  }\n      return false;\n    }\n\n    // if (DEBUG) {\n    //   System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n    // }\n\n    if (currentFrame.maxIDVersion < minIDVersion) {\n      // The max version for all terms in this block is lower than the minVersion\n      termExists = false;\n      term.length = targetUpto;\n      return false;\n    }\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, true);            \n    if (result == SeekStatus.FOUND) {\n      // if (DEBUG) {\n      //    System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n      //  }\n      currentFrame.decodeMetaData();\n      if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n        // This term's version is lower than the minVersion\n        return false;\n      }\n      return true;\n    } else {\n      // if (DEBUG) {\n      //    System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n      //  }\n\n      return false;\n    }\n  }\n\n","sourceOld":"  /** Optimized version of {@link #seekExact(BytesRef)} that can\n   *  sometimes fail-fast if the version indexed with the requested ID\n   *  is less than the specified minIDVersion.  Applications that index\n   *  a monotonically increasing global version with each document can\n   *  use this for fast optimistic concurrency. */\n  public boolean seekExact(final BytesRef target, long minIDVersion) throws IOException {\n\n    if (fr.index == null) {\n      throw new IllegalStateException(\"terms index was not loaded\");\n    }\n\n    if (term.bytes.length <= target.length) {\n      term.bytes = ArrayUtil.grow(term.bytes, 1+target.length);\n    }\n\n    assert clearEOF();\n\n    //  if (DEBUG) {\n    //    System.out.println(\"\\nBTTR.seekExact seg=\" + fr.parent.segment + \" target=\" + fr.fieldInfo.name + \":\" + brToString(target) + \" minIDVersion=\" + minIDVersion + \" current=\" + brToString(term) + \" (exists?=\" + termExists + \") validIndexPrefix=\" + validIndexPrefix);\n    //   printSeekState(System.out);\n    //  }\n\n    FST.Arc<Pair<BytesRef,Long>> arc;\n    int targetUpto;\n    Pair<BytesRef,Long> output;\n\n    long startFrameFP = currentFrame.fp;\n\n    targetBeforeCurrentLength = currentFrame.ord;\n\n    boolean changed = false;\n\n    // TODO: we could stop earlier w/ the version check, every time we traverse an index arc we can check?\n\n    if (currentFrame != staticFrame) {\n\n      // We are already seek'd; find the common\n      // prefix of new seek term vs current term and\n      // re-use the corresponding seek state.  For\n      // example, if app first seeks to foobar, then\n      // seeks to foobaz, we can re-use the seek state\n      // for the first 5 bytes.\n\n      // if (DEBUG) {\n      //    System.out.println(\"  re-use current seek state validIndexPrefix=\" + validIndexPrefix);\n      //  }\n\n      arc = arcs[0];\n      assert arc.isFinal();\n      output = arc.output;\n      targetUpto = 0;\n\n      IDVersionSegmentTermsEnumFrame lastFrame = stack[0];\n      assert validIndexPrefix <= term.length: \"validIndexPrefix=\" + validIndexPrefix + \" term.length=\" + term.length + \" seg=\" + fr.parent.segment;\n\n      final int targetLimit = Math.min(target.length, validIndexPrefix);\n\n      int cmp = 0;\n\n      // TODO: reverse vLong byte order for better FST\n      // prefix output sharing\n\n      // First compare up to valid seek frames:\n      while (targetUpto < targetLimit) {\n        cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n        // if (DEBUG) {\n        //    System.out.println(\"    cycle targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\"   + \" arc.output=\" + arc.output + \" output=\" + output);\n        // }\n        if (cmp != 0) {\n          break;\n        }\n        arc = arcs[1+targetUpto];\n        //if (arc.label != (target.bytes[target.offset + targetUpto] & 0xFF)) {\n        //System.out.println(\"FAIL: arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF));\n        //}\n        assert arc.label == (target.bytes[target.offset + targetUpto] & 0xFF): \"arc.label=\" + (char) arc.label + \" targetLabel=\" + (char) (target.bytes[target.offset + targetUpto] & 0xFF);\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n        if (arc.isFinal()) {\n          lastFrame = stack[1+lastFrame.ord];\n        }\n        targetUpto++;\n      }\n\n      if (cmp == 0) {\n        final int targetUptoMid = targetUpto;\n\n        // Second compare the rest of the term, but\n        // don't save arc/output/frame; we only do this\n        // to find out if the target term is before,\n        // equal or after the current term\n        final int targetLimit2 = Math.min(target.length, term.length);\n        while (targetUpto < targetLimit2) {\n          cmp = (term.bytes[targetUpto]&0xFF) - (target.bytes[target.offset + targetUpto]&0xFF);\n          // if (DEBUG) {\n          //    System.out.println(\"    cycle2 targetUpto=\" + targetUpto + \" (vs limit=\" + targetLimit + \") cmp=\" + cmp + \" (targetLabel=\" + (char) (target.bytes[target.offset + targetUpto]) + \" vs termLabel=\" + (char) (term.bytes[targetUpto]) + \")\");\n          // }\n          if (cmp != 0) {\n            break;\n          }\n          targetUpto++;\n        }\n\n        if (cmp == 0) {\n          cmp = term.length - target.length;\n        }\n        targetUpto = targetUptoMid;\n      }\n\n      if (cmp < 0) {\n        // Common case: target term is after current\n        // term, ie, app is seeking multiple terms\n        // in sorted order\n        // if (DEBUG) {\n        //    System.out.println(\"  target is after current (shares prefixLen=\" + targetUpto + \"); frame.ord=\" + lastFrame.ord + \"; targetUpto=\" + targetUpto);\n        //  }\n        currentFrame = lastFrame;\n\n      } else if (cmp > 0) {\n        // Uncommon case: target term\n        // is before current term; this means we can\n        // keep the currentFrame but we must rewind it\n        // (so we scan from the start)\n        targetBeforeCurrentLength = 0;\n        changed = true;\n        // if (DEBUG) {\n        //    System.out.println(\"  target is before current (shares prefixLen=\" + targetUpto + \"); rewind frame ord=\" + lastFrame.ord);\n        //  }\n        currentFrame = lastFrame;\n        currentFrame.rewind();\n      } else {\n        // Target is exactly the same as current term\n        assert term.length == target.length;\n        if (termExists) {\n\n          if (currentFrame.maxIDVersion < minIDVersion) {\n            // The max version for all terms in this block is lower than the minVersion\n            // if (DEBUG) {\n            //   System.out.println(\"  target is same as current maxIDVersion=\" + currentFrame.maxIDVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            // }\n            return false;\n          }\n\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            // if (DEBUG) {\n            //   System.out.println(\"  target is same as current but version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" is < minIDVersion=\" + minIDVersion + \"; return false\");\n            // }\n            return false;\n          }\n          // System.out.println(\"  term version=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" frame version=\" + currentFrame.maxIDVersion + \" frame ord=\" + currentFrame.ord);\n\n          // if (DEBUG) {\n          //    System.out.println(\"  target is same as current; return true\");\n          //  }\n          return true;\n        } else {\n          // if (DEBUG) {\n          //    System.out.println(\"  target is same as current but term doesn't exist\");\n          //  }\n        }\n        //validIndexPrefix = currentFrame.depth;\n        //term.length = target.length;\n        //return termExists;\n      }\n\n    } else {\n\n      targetBeforeCurrentLength = -1;\n      arc = fr.index.getFirstArc(arcs[0]);\n      //System.out.println(\"first arc=\" + arc);\n\n      // Empty string prefix must have an output (block) in the index!\n      assert arc.isFinal();\n      assert arc.output != null;\n\n      // if (DEBUG) {\n      //    System.out.println(\"    no seek state; push root frame\");\n      //  }\n\n      output = arc.output;\n\n      currentFrame = staticFrame;\n\n      //term.length = 0;\n      targetUpto = 0;\n      currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), 0);\n    }\n\n    // if (DEBUG) {\n    //   System.out.println(\"  start index loop targetUpto=\" + targetUpto + \" output=\" + output + \" currentFrame.ord=\" + currentFrame.ord + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength + \" termExists=\" + termExists);\n    // }\n\n    // We are done sharing the common prefix with the incoming target and where we are currently seek'd; now continue walking the index:\n    while (targetUpto < target.length) {\n\n      final int targetLabel = target.bytes[target.offset + targetUpto] & 0xFF;\n\n      final FST.Arc<Pair<BytesRef,Long>> nextArc = fr.index.findTargetArc(targetLabel, arc, getArc(1+targetUpto), fstReader);\n\n      if (nextArc == null) {\n\n        // Index is exhausted\n        // if (DEBUG) {\n        //    System.out.println(\"    index: index exhausted label=\" + ((char) targetLabel) + \" \" + Integer.toHexString(targetLabel) + \" termExists=\" + termExists);\n        //  }\n            \n        validIndexPrefix = currentFrame.prefix;\n        //validIndexPrefix = targetUpto;\n\n        currentFrame.scanToFloorFrame(target);\n\n        if (!currentFrame.hasTerms) {\n          termExists = false;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          term.length = 1+targetUpto;\n          // if (DEBUG) {\n          //    System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n          //  }\n          return false;\n        }\n        //System.out.println(\"  check maxVersion=\" + currentFrame.maxIDVersion + \" vs \" + minIDVersion);\n\n        // if (DEBUG) {\n        //   System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n        // }\n\n        if (currentFrame.maxIDVersion < minIDVersion) {\n          // The max version for all terms in this block is lower than the minVersion\n          if (currentFrame.fp != startFrameFP || changed) {\n          //if (targetUpto+1 > term.length) {\n            termExists = false;\n            term.bytes[targetUpto] = (byte) targetLabel;\n            term.length = 1+targetUpto;\n            // if (DEBUG) {\n            //   System.out.println(\"    reset current term\");\n            // }\n            validIndexPrefix = Math.min(validIndexPrefix, term.length);\n          }\n            //if (currentFrame.ord != startFrameOrd) {\n            //termExists = false;\n            //}\n          // if (DEBUG) {\n          //   System.out.println(\"    FAST version NOT_FOUND term=\" + brToString(term) + \" targetUpto=\" + targetUpto + \" currentFrame.maxIDVersion=\" + currentFrame.maxIDVersion + \" validIndexPrefix=\" + validIndexPrefix + \" startFrameFP=\" + startFrameFP + \" vs \" + currentFrame.fp + \" termExists=\" + termExists);\n          // }\n          return false;\n        }\n\n        currentFrame.loadBlock();\n\n        // if (DEBUG) {\n        //   System.out.println(\"    scan currentFrame ord=\" + currentFrame.ord);\n        // }\n        final SeekStatus result = currentFrame.scanToTerm(target, true);            \n        if (result == SeekStatus.FOUND) {\n          currentFrame.decodeMetaData();\n          if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n            // This term's version is lower than the minVersion\n            // if (DEBUG) {\n            //   System.out.println(\"    return NOT_FOUND: idVersion=\" + ((IDVersionTermState) currentFrame.state).idVersion + \" vs minIDVersion=\" + minIDVersion);\n            // }\n            return false;\n          }\n\n          // if (DEBUG) {\n          //    System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n          //  }\n\n          return true;\n        } else {\n          // if (DEBUG) {\n          //    System.out.println(\"  got \" + result + \"; return NOT_FOUND term=\" + brToString(term));\n          // }\n          return false;\n        }\n      } else {\n        // Follow this arc\n        arc = nextArc;\n        if (term.bytes[targetUpto] != (byte) targetLabel) {\n          // if (DEBUG) {\n          //   System.out.println(\"  now set termExists=false targetUpto=\" + targetUpto + \" term=\" + term.bytes[targetUpto] + \" targetLabel=\" + targetLabel);\n          // }\n          changed = true;\n          term.bytes[targetUpto] = (byte) targetLabel;\n          termExists = false;\n        }\n        // Aggregate output as we go:\n        assert arc.output != null;\n        if (arc.output != VersionBlockTreeTermsWriter.NO_OUTPUT) {\n          output = VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.output);\n        }\n\n        // if (DEBUG) {\n        //    System.out.println(\"    index: follow label=\" + (char) ((target.bytes[target.offset + targetUpto]&0xff)) + \" arc.output=\" + arc.output + \" arc.nfo=\" + arc.nextFinalOutput);\n        //  }\n        targetUpto++;\n\n        if (arc.isFinal()) {\n          // if (DEBUG) System.out.println(\"    arc is final!\");\n          currentFrame = pushFrame(arc, VersionBlockTreeTermsWriter.FST_OUTPUTS.add(output, arc.nextFinalOutput), targetUpto);\n          // if (DEBUG) System.out.println(\"    curFrame.ord=\" + currentFrame.ord + \" hasTerms=\" + currentFrame.hasTerms);\n        }\n      }\n    }\n\n    //validIndexPrefix = targetUpto;\n    validIndexPrefix = currentFrame.prefix;\n\n    currentFrame.scanToFloorFrame(target);\n\n    // Target term is entirely contained in the index:\n    if (!currentFrame.hasTerms) {\n      termExists = false;\n      term.length = targetUpto;\n      // if (DEBUG) {\n      //    System.out.println(\"  FAST NOT_FOUND term=\" + brToString(term));\n      //  }\n      return false;\n    }\n\n    // if (DEBUG) {\n    //   System.out.println(\"  frame.maxIDVersion=\" + currentFrame.maxIDVersion +  \" vs minIDVersion=\" + minIDVersion);\n    // }\n\n    if (currentFrame.maxIDVersion < minIDVersion) {\n      // The max version for all terms in this block is lower than the minVersion\n      termExists = false;\n      term.length = targetUpto;\n      return false;\n    }\n\n    currentFrame.loadBlock();\n\n    final SeekStatus result = currentFrame.scanToTerm(target, true);            \n    if (result == SeekStatus.FOUND) {\n      // if (DEBUG) {\n      //    System.out.println(\"  return FOUND term=\" + term.utf8ToString() + \" \" + term);\n      //  }\n      currentFrame.decodeMetaData();\n      if (((IDVersionTermState) currentFrame.state).idVersion < minIDVersion) {\n        // This term's version is lower than the minVersion\n        return false;\n      }\n      return true;\n    } else {\n      // if (DEBUG) {\n      //    System.out.println(\"  got result \" + result + \"; return NOT_FOUND term=\" + term.utf8ToString());\n      //  }\n\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"4ae62bdfdfc2a17d4df98e6004938c8b0eed0a20":["0efcf27cd5ca23def8376b4c321970c14dd71623"],"0a16b40feb4e6e0d55c1716733bde48296bedd20":["3251bdaf728baf81f779183e464984bc769ed9c7"],"ca044bd4a0bea8391cbebb44a34aba53a9b50541":["4ae62bdfdfc2a17d4df98e6004938c8b0eed0a20"],"0efcf27cd5ca23def8376b4c321970c14dd71623":["0a16b40feb4e6e0d55c1716733bde48296bedd20"],"e82ae1be1dc68d59626e4bb94d2029d309b20878":["6256acedd658c13275a01e4ba106a621956a22f6"],"3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e":["ca044bd4a0bea8391cbebb44a34aba53a9b50541"],"f56ba5d8fecfb0b8bfdca8c0b630372d998131a9":["b7d615ef411046679022f6728bb2b876273d13ae"],"6256acedd658c13275a01e4ba106a621956a22f6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7d615ef411046679022f6728bb2b876273d13ae":["e82ae1be1dc68d59626e4bb94d2029d309b20878"],"e19aeadf1fb6c63b76ee4828b087b1ff7256b228":["f56ba5d8fecfb0b8bfdca8c0b630372d998131a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3251bdaf728baf81f779183e464984bc769ed9c7":["e19aeadf1fb6c63b76ee4828b087b1ff7256b228"]},"commit2Childs":{"4ae62bdfdfc2a17d4df98e6004938c8b0eed0a20":["ca044bd4a0bea8391cbebb44a34aba53a9b50541"],"0a16b40feb4e6e0d55c1716733bde48296bedd20":["0efcf27cd5ca23def8376b4c321970c14dd71623"],"ca044bd4a0bea8391cbebb44a34aba53a9b50541":["3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e"],"0efcf27cd5ca23def8376b4c321970c14dd71623":["4ae62bdfdfc2a17d4df98e6004938c8b0eed0a20"],"e82ae1be1dc68d59626e4bb94d2029d309b20878":["b7d615ef411046679022f6728bb2b876273d13ae"],"3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e":[],"f56ba5d8fecfb0b8bfdca8c0b630372d998131a9":["e19aeadf1fb6c63b76ee4828b087b1ff7256b228"],"6256acedd658c13275a01e4ba106a621956a22f6":["e82ae1be1dc68d59626e4bb94d2029d309b20878"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6256acedd658c13275a01e4ba106a621956a22f6","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b7d615ef411046679022f6728bb2b876273d13ae":["f56ba5d8fecfb0b8bfdca8c0b630372d998131a9"],"e19aeadf1fb6c63b76ee4828b087b1ff7256b228":["3251bdaf728baf81f779183e464984bc769ed9c7"],"3251bdaf728baf81f779183e464984bc769ed9c7":["0a16b40feb4e6e0d55c1716733bde48296bedd20"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}