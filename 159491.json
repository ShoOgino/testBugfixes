{"path":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0dcbe407b62ce0c91dc171a4695a9f442c46ce14","date":1323729111,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ceb6a6c707ada1df8bde804e25c98668e699a18","date":1323800602,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = localParams == null ? params : new DefaultSolrParams(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f08557cdb6c60ac7b88a9342c983a20cd236e74f","date":1330954480,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = U.parseFieldBoosts(solrParams.getParams(DMP.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      U.parseFieldBoosts(solrParams.getParams(DMP.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      U.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DMP.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DMP.PS, 0);\n    int qslop = solrParams.getInt(DMP.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DMP.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          U.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          U.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          U.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DMP.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DMP.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"245c71087515ed70d4fb9d9484f9dcbd79eebdfc","date":1331372561,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    SolrParams solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      boolean specialSyntax = false;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOptional = 0;\n      int numAND = 0;\n      int numOR = 0;\n      int numNOT = 0;\n      boolean sawLowerAnd=false;\n      boolean sawLowerOr=false;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (!clause.isPhrase && clause.hasSpecialSyntax) {\n          specialSyntax = true;\n        }\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"AND\".equals(s)) {\n            numAND++;\n          } else if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators) {\n            if (\"and\".equals(s)) {\n              numAND++;\n              sawLowerAnd=true;\n            } else if (\"or\".equals(s)) {\n              numOR++;\n              sawLowerOr=true;\n            }\n          }\n        }\n      }\n      numOptional = clauses.size() - (numPluses + numMinuses);\n\n      // convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      if (sawLowerAnd || sawLowerOr) {\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<clauses.size(); i++) {\n          Clause clause = clauses.get(i);\n          String s = clause.raw;\n          // and and or won't be operators at the start or end\n          if (i>0 && i+1<clauses.size()) {\n            if (\"AND\".equalsIgnoreCase(s)) {\n              s=\"AND\";\n            } else if (\"OR\".equalsIgnoreCase(s)) {\n              s=\"OR\";\n            }\n          }\n          sb.append(s);\n          sb.append(' ');\n        }\n\n        mainUserQuery = sb.toString();\n      }\n\n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n\n      if (parsedUserQuery == null) {\n        StringBuilder sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"576a4c26b3d237aa2626e691ea3b4fa016037fe3","date":1332565608,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.length() < 1 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":["20349324eb18d1565d301e59be543989f38743d3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"789e15fb466c7a5331d7ad1ff6fa9cdb2b6c89e3","date":1332868570,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      Map<String,Float> bqBoosts = SolrPluginUtils.parseFieldBoosts(boostParams);\n      boostQueries = new ArrayList<Query>();\n      for (Map.Entry<String,Float> bqs : bqBoosts.entrySet()) {\n        if (bqs.getKey().trim().length()==0) continue;\n        Query q = subQuery(bqs.getKey(), null).getQuery();\n        Float b = bqs.getValue();\n        if(b!=null) {\n          q.setBoost(b);\n        }\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":["ea392002c53ec2f3e94edcdbb0c5cc5194e2ea6d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d7c87c58d71fb9a6f5bc4ae8247339ecbbf67edc","date":1332908462,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new ParseException(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      Map<String,Float> bqBoosts = SolrPluginUtils.parseFieldBoosts(boostParams);\n      boostQueries = new ArrayList<Query>();\n      for (Map.Entry<String,Float> bqs : bqBoosts.entrySet()) {\n        if (bqs.getKey().trim().length()==0) continue;\n        Query q = subQuery(bqs.getKey(), null).getQuery();\n        Float b = bqs.getValue();\n        if(b!=null) {\n          q.setBoost(b);\n        }\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      Map<String,Float> bqBoosts = SolrPluginUtils.parseFieldBoosts(boostParams);\n      boostQueries = new ArrayList<Query>();\n      for (Map.Entry<String,Float> bqs : bqBoosts.entrySet()) {\n        if (bqs.getKey().trim().length()==0) continue;\n        Query q = subQuery(bqs.getKey(), null).getQuery();\n        Float b = bqs.getValue();\n        if(b!=null) {\n          q.setBoost(b);\n        }\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15cacbf46c73bd5b0e47b57128be8852cb236160","date":1332942979,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      Map<String,Float> bqBoosts = SolrPluginUtils.parseFieldBoosts(boostParams);\n      boostQueries = new ArrayList<Query>();\n      for (Map.Entry<String,Float> bqs : bqBoosts.entrySet()) {\n        if (bqs.getKey().trim().length()==0) continue;\n        Query q = subQuery(bqs.getKey(), null).getQuery();\n        Float b = bqs.getValue();\n        if(b!=null) {\n          q.setBoost(b);\n        }\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new ParseException(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      Map<String,Float> bqBoosts = SolrPluginUtils.parseFieldBoosts(boostParams);\n      boostQueries = new ArrayList<Query>();\n      for (Map.Entry<String,Float> bqs : bqBoosts.entrySet()) {\n        if (bqs.getKey().trim().length()==0) continue;\n        Query q = subQuery(bqs.getKey(), null).getQuery();\n        Float b = bqs.getValue();\n        if(b!=null) {\n          q.setBoost(b);\n        }\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":["738199265d7244d0d494cdc76ad36c750d9a1bcd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"738199265d7244d0d494cdc76ad36c750d9a1bcd","date":1333253180,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new ParseException(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      Map<String,Float> bqBoosts = SolrPluginUtils.parseFieldBoosts(boostParams);\n      boostQueries = new ArrayList<Query>();\n      for (Map.Entry<String,Float> bqs : bqBoosts.entrySet()) {\n        if (bqs.getKey().trim().length()==0) continue;\n        Query q = subQuery(bqs.getKey(), null).getQuery();\n        Float b = bqs.getValue();\n        if(b!=null) {\n          q.setBoost(b);\n        }\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      Map<String,Float> bqBoosts = SolrPluginUtils.parseFieldBoosts(boostParams);\n      boostQueries = new ArrayList<Query>();\n      for (Map.Entry<String,Float> bqs : bqBoosts.entrySet()) {\n        if (bqs.getKey().trim().length()==0) continue;\n        Query q = subQuery(bqs.getKey(), null).getQuery();\n        Float b = bqs.getValue();\n        if(b!=null) {\n          q.setBoost(b);\n        }\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":["15cacbf46c73bd5b0e47b57128be8852cb236160"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d9e959ce5e0805c43916e999d21f2018a2b475ab","date":1337958990,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    List<FieldParams> phraseFields = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF),0);\n    // Boosted Bi-Term Shingles from the query string\n    List<FieldParams> phraseFields2 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(\"pf2\"),2);\n    // Boosted Tri-Term Shingles from the query string\n    List<FieldParams> phraseFields3 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(\"pf3\"),3);\n\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new ParseException(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      List<FieldParams> allPhraseFields = new ArrayList<FieldParams>();\n      allPhraseFields.addAll(phraseFields);\n      allPhraseFields.addAll(phraseFields2);\n      allPhraseFields.addAll(phraseFields3);\n\n      if (allPhraseFields.size() > 0) {\n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase and shingles\n        for (FieldParams phraseField: allPhraseFields) {\n          int slop = (phraseField.getSlop() == 0) ? pslop : phraseField.getSlop();\n          Map<String,Float> pf = new HashMap<String,Float>(1);\n          pf.put(phraseField.getField(),phraseField.getBoost());\n          addShingledPhraseQueries(query, normalClauses, pf,   \n\t\t\t\t   phraseField.getWordGrams(),tiebreaker, slop);\n        }\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      Map<String,Float> bqBoosts = SolrPluginUtils.parseFieldBoosts(boostParams);\n      boostQueries = new ArrayList<Query>();\n      for (Map.Entry<String,Float> bqs : bqBoosts.entrySet()) {\n        if (bqs.getKey().trim().length()==0) continue;\n        Query q = subQuery(bqs.getKey(), null).getQuery();\n        Float b = bqs.getValue();\n        if(b!=null) {\n          q.setBoost(b);\n        }\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    Map<String,Float> phraseFields = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.PF));\n    // Boosted Bi-Term Shingles from the query string\n    Map<String,Float> phraseFields2 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf2\"));\n    // Boosted Tri-Term Shingles from the query string\n    Map<String,Float> phraseFields3 = \n      SolrPluginUtils.parseFieldBoosts(solrParams.getParams(\"pf3\"));\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new ParseException(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      if (phraseFields.size() > 0 || \n          phraseFields2.size() > 0 ||\n          phraseFields3.size() > 0) {\n        \n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase...\n        addShingledPhraseQueries(query, normalClauses, phraseFields, 0, \n                                 tiebreaker, pslop);\n        // shingles...\n        addShingledPhraseQueries(query, normalClauses, phraseFields2, 2,  \n                                 tiebreaker, pslop);\n        addShingledPhraseQueries(query, normalClauses, phraseFields3, 3,\n                                 tiebreaker, pslop);\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      Map<String,Float> bqBoosts = SolrPluginUtils.parseFieldBoosts(boostParams);\n      boostQueries = new ArrayList<Query>();\n      for (Map.Entry<String,Float> bqs : bqBoosts.entrySet()) {\n        if (bqs.getKey().trim().length()==0) continue;\n        Query q = subQuery(bqs.getKey(), null).getQuery();\n        Float b = bqs.getValue();\n        if(b!=null) {\n          q.setBoost(b);\n        }\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"220acde8206f5221383e3777429a4fb84bed289f","date":1339892825,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = DisMaxQParser.parseQueryFields(req.getSchema(), solrParams);\n    \n    // Boosted phrase of the full query string\n    List<FieldParams> phraseFields = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF),0);\n    // Boosted Bi-Term Shingles from the query string\n    List<FieldParams> phraseFields2 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(\"pf2\"),2);\n    // Boosted Tri-Term Shingles from the query string\n    List<FieldParams> phraseFields3 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(\"pf3\"),3);\n\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new ParseException(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      List<FieldParams> allPhraseFields = new ArrayList<FieldParams>();\n      allPhraseFields.addAll(phraseFields);\n      allPhraseFields.addAll(phraseFields2);\n      allPhraseFields.addAll(phraseFields3);\n\n      if (allPhraseFields.size() > 0) {\n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase and shingles\n        for (FieldParams phraseField: allPhraseFields) {\n          int slop = (phraseField.getSlop() == 0) ? pslop : phraseField.getSlop();\n          Map<String,Float> pf = new HashMap<String,Float>(1);\n          pf.put(phraseField.getField(),phraseField.getBoost());\n          addShingledPhraseQueries(query, normalClauses, pf,   \n\t\t\t\t   phraseField.getWordGrams(),tiebreaker, slop);\n        }\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      Map<String,Float> bqBoosts = SolrPluginUtils.parseFieldBoosts(boostParams);\n      boostQueries = new ArrayList<Query>();\n      for (Map.Entry<String,Float> bqs : bqBoosts.entrySet()) {\n        if (bqs.getKey().trim().length()==0) continue;\n        Query q = subQuery(bqs.getKey(), null).getQuery();\n        Float b = bqs.getValue();\n        if(b!=null) {\n          q.setBoost(b);\n        }\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = SolrPluginUtils.parseFieldBoosts(solrParams.getParams(DisMaxParams.QF));\n    if (0 == queryFields.size()) {\n      queryFields.put(req.getSchema().getDefaultSearchFieldName(), 1.0f);\n    }\n    \n    // Boosted phrase of the full query string\n    List<FieldParams> phraseFields = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF),0);\n    // Boosted Bi-Term Shingles from the query string\n    List<FieldParams> phraseFields2 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(\"pf2\"),2);\n    // Boosted Tri-Term Shingles from the query string\n    List<FieldParams> phraseFields3 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(\"pf3\"),3);\n\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new ParseException(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      List<FieldParams> allPhraseFields = new ArrayList<FieldParams>();\n      allPhraseFields.addAll(phraseFields);\n      allPhraseFields.addAll(phraseFields2);\n      allPhraseFields.addAll(phraseFields3);\n\n      if (allPhraseFields.size() > 0) {\n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase and shingles\n        for (FieldParams phraseField: allPhraseFields) {\n          int slop = (phraseField.getSlop() == 0) ? pslop : phraseField.getSlop();\n          Map<String,Float> pf = new HashMap<String,Float>(1);\n          pf.put(phraseField.getField(),phraseField.getBoost());\n          addShingledPhraseQueries(query, normalClauses, pf,   \n\t\t\t\t   phraseField.getWordGrams(),tiebreaker, slop);\n        }\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      Map<String,Float> bqBoosts = SolrPluginUtils.parseFieldBoosts(boostParams);\n      boostQueries = new ArrayList<Query>();\n      for (Map.Entry<String,Float> bqs : bqBoosts.entrySet()) {\n        if (bqs.getKey().trim().length()==0) continue;\n        Query q = subQuery(bqs.getKey(), null).getQuery();\n        Float b = bqs.getValue();\n        if(b!=null) {\n          q.setBoost(b);\n        }\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"963838fde272080e74cd28379f80e34631528b50","date":1340216115,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = DisMaxQParser.parseQueryFields(req.getSchema(), solrParams);\n    \n    // Boosted phrase of the full query string\n    List<FieldParams> phraseFields = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF),0);\n    // Boosted Bi-Term Shingles from the query string\n    List<FieldParams> phraseFields2 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(\"pf2\"),2);\n    // Boosted Tri-Term Shingles from the query string\n    List<FieldParams> phraseFields3 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(\"pf3\"),3);\n\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new ParseException(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (lowercaseOperators && i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      List<FieldParams> allPhraseFields = new ArrayList<FieldParams>();\n      allPhraseFields.addAll(phraseFields);\n      allPhraseFields.addAll(phraseFields2);\n      allPhraseFields.addAll(phraseFields3);\n\n      if (allPhraseFields.size() > 0) {\n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase and shingles\n        for (FieldParams phraseField: allPhraseFields) {\n          int slop = (phraseField.getSlop() == 0) ? pslop : phraseField.getSlop();\n          Map<String,Float> pf = new HashMap<String,Float>(1);\n          pf.put(phraseField.getField(),phraseField.getBoost());\n          addShingledPhraseQueries(query, normalClauses, pf,   \n\t\t\t\t   phraseField.getWordGrams(),tiebreaker, slop);\n        }\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      Map<String,Float> bqBoosts = SolrPluginUtils.parseFieldBoosts(boostParams);\n      boostQueries = new ArrayList<Query>();\n      for (Map.Entry<String,Float> bqs : bqBoosts.entrySet()) {\n        if (bqs.getKey().trim().length()==0) continue;\n        Query q = subQuery(bqs.getKey(), null).getQuery();\n        Float b = bqs.getValue();\n        if(b!=null) {\n          q.setBoost(b);\n        }\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = DisMaxQParser.parseQueryFields(req.getSchema(), solrParams);\n    \n    // Boosted phrase of the full query string\n    List<FieldParams> phraseFields = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF),0);\n    // Boosted Bi-Term Shingles from the query string\n    List<FieldParams> phraseFields2 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(\"pf2\"),2);\n    // Boosted Tri-Term Shingles from the query string\n    List<FieldParams> phraseFields3 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(\"pf3\"),3);\n\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new ParseException(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      List<FieldParams> allPhraseFields = new ArrayList<FieldParams>();\n      allPhraseFields.addAll(phraseFields);\n      allPhraseFields.addAll(phraseFields2);\n      allPhraseFields.addAll(phraseFields3);\n\n      if (allPhraseFields.size() > 0) {\n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase and shingles\n        for (FieldParams phraseField: allPhraseFields) {\n          int slop = (phraseField.getSlop() == 0) ? pslop : phraseField.getSlop();\n          Map<String,Float> pf = new HashMap<String,Float>(1);\n          pf.put(phraseField.getField(),phraseField.getBoost());\n          addShingledPhraseQueries(query, normalClauses, pf,   \n\t\t\t\t   phraseField.getWordGrams(),tiebreaker, slop);\n        }\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      Map<String,Float> bqBoosts = SolrPluginUtils.parseFieldBoosts(boostParams);\n      boostQueries = new ArrayList<Query>();\n      for (Map.Entry<String,Float> bqs : bqBoosts.entrySet()) {\n        if (bqs.getKey().trim().length()==0) continue;\n        Query q = subQuery(bqs.getKey(), null).getQuery();\n        Float b = bqs.getValue();\n        if(b!=null) {\n          q.setBoost(b);\n        }\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"500052b00ecd22d5bd8b0efd25666d035ef55f85","date":1340322005,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = DisMaxQParser.parseQueryFields(req.getSchema(), solrParams);\n\n    // Phrase slop array\n    int pslop[] = new int[4];\n    pslop[0] = solrParams.getInt(DisMaxParams.PS, 0);\n    pslop[2] = solrParams.getInt(DisMaxParams.PS2, pslop[0]);\n    pslop[3] = solrParams.getInt(DisMaxParams.PS3, pslop[0]);\n\n    \n    // Boosted phrase of the full query string\n    List<FieldParams> phraseFields = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF),0,pslop[0]);\n    // Boosted Bi-Term Shingles from the query string\n    List<FieldParams> phraseFields2 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF2),2,pslop[2]);\n    // Boosted Tri-Term Shingles from the query string\n    List<FieldParams> phraseFields3 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF3),3,pslop[3]);\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new ParseException(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (lowercaseOperators && i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      List<FieldParams> allPhraseFields = new ArrayList<FieldParams>();\n      allPhraseFields.addAll(phraseFields);\n      allPhraseFields.addAll(phraseFields2);\n      allPhraseFields.addAll(phraseFields3);\n\n      if (allPhraseFields.size() > 0) {\n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase and shingles\n        for (FieldParams phraseField: allPhraseFields) {\n          Map<String,Float> pf = new HashMap<String,Float>(1);\n          pf.put(phraseField.getField(),phraseField.getBoost());\n          addShingledPhraseQueries(query, normalClauses, pf,   \n          phraseField.getWordGrams(),tiebreaker, phraseField.getSlop());\n        }\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      Map<String,Float> bqBoosts = SolrPluginUtils.parseFieldBoosts(boostParams);\n      boostQueries = new ArrayList<Query>();\n      for (Map.Entry<String,Float> bqs : bqBoosts.entrySet()) {\n        if (bqs.getKey().trim().length()==0) continue;\n        Query q = subQuery(bqs.getKey(), null).getQuery();\n        Float b = bqs.getValue();\n        if(b!=null) {\n          q.setBoost(b);\n        }\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = DisMaxQParser.parseQueryFields(req.getSchema(), solrParams);\n    \n    // Boosted phrase of the full query string\n    List<FieldParams> phraseFields = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF),0);\n    // Boosted Bi-Term Shingles from the query string\n    List<FieldParams> phraseFields2 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(\"pf2\"),2);\n    // Boosted Tri-Term Shingles from the query string\n    List<FieldParams> phraseFields3 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(\"pf3\"),3);\n\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new ParseException(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (lowercaseOperators && i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      List<FieldParams> allPhraseFields = new ArrayList<FieldParams>();\n      allPhraseFields.addAll(phraseFields);\n      allPhraseFields.addAll(phraseFields2);\n      allPhraseFields.addAll(phraseFields3);\n\n      if (allPhraseFields.size() > 0) {\n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase and shingles\n        for (FieldParams phraseField: allPhraseFields) {\n          int slop = (phraseField.getSlop() == 0) ? pslop : phraseField.getSlop();\n          Map<String,Float> pf = new HashMap<String,Float>(1);\n          pf.put(phraseField.getField(),phraseField.getBoost());\n          addShingledPhraseQueries(query, normalClauses, pf,   \n\t\t\t\t   phraseField.getWordGrams(),tiebreaker, slop);\n        }\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      Map<String,Float> bqBoosts = SolrPluginUtils.parseFieldBoosts(boostParams);\n      boostQueries = new ArrayList<Query>();\n      for (Map.Entry<String,Float> bqs : bqBoosts.entrySet()) {\n        if (bqs.getKey().trim().length()==0) continue;\n        Query q = subQuery(bqs.getKey(), null).getQuery();\n        Float b = bqs.getValue();\n        if(b!=null) {\n          q.setBoost(b);\n        }\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = DisMaxQParser.parseQueryFields(req.getSchema(), solrParams);\n\n    // Phrase slop array\n    int pslop[] = new int[4];\n    pslop[0] = solrParams.getInt(DisMaxParams.PS, 0);\n    pslop[2] = solrParams.getInt(DisMaxParams.PS2, pslop[0]);\n    pslop[3] = solrParams.getInt(DisMaxParams.PS3, pslop[0]);\n\n    \n    // Boosted phrase of the full query string\n    List<FieldParams> phraseFields = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF),0,pslop[0]);\n    // Boosted Bi-Term Shingles from the query string\n    List<FieldParams> phraseFields2 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF2),2,pslop[2]);\n    // Boosted Tri-Term Shingles from the query string\n    List<FieldParams> phraseFields3 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF3),3,pslop[3]);\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new ParseException(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (lowercaseOperators && i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      List<FieldParams> allPhraseFields = new ArrayList<FieldParams>();\n      allPhraseFields.addAll(phraseFields);\n      allPhraseFields.addAll(phraseFields2);\n      allPhraseFields.addAll(phraseFields3);\n\n      if (allPhraseFields.size() > 0) {\n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase and shingles\n        for (FieldParams phraseField: allPhraseFields) {\n          Map<String,Float> pf = new HashMap<String,Float>(1);\n          pf.put(phraseField.getField(),phraseField.getBoost());\n          addShingledPhraseQueries(query, normalClauses, pf,   \n          phraseField.getWordGrams(),tiebreaker, phraseField.getSlop());\n        }\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      Map<String,Float> bqBoosts = SolrPluginUtils.parseFieldBoosts(boostParams);\n      boostQueries = new ArrayList<Query>();\n      for (Map.Entry<String,Float> bqs : bqBoosts.entrySet()) {\n        if (bqs.getKey().trim().length()==0) continue;\n        Query q = subQuery(bqs.getKey(), null).getQuery();\n        Float b = bqs.getValue();\n        if(b!=null) {\n          q.setBoost(b);\n        }\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = DisMaxQParser.parseQueryFields(req.getSchema(), solrParams);\n    \n    // Boosted phrase of the full query string\n    List<FieldParams> phraseFields = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF),0);\n    // Boosted Bi-Term Shingles from the query string\n    List<FieldParams> phraseFields2 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(\"pf2\"),2);\n    // Boosted Tri-Term Shingles from the query string\n    List<FieldParams> phraseFields3 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(\"pf3\"),3);\n\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int pslop = solrParams.getInt(DisMaxParams.PS, 0);\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new ParseException(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      List<FieldParams> allPhraseFields = new ArrayList<FieldParams>();\n      allPhraseFields.addAll(phraseFields);\n      allPhraseFields.addAll(phraseFields2);\n      allPhraseFields.addAll(phraseFields3);\n\n      if (allPhraseFields.size() > 0) {\n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase and shingles\n        for (FieldParams phraseField: allPhraseFields) {\n          int slop = (phraseField.getSlop() == 0) ? pslop : phraseField.getSlop();\n          Map<String,Float> pf = new HashMap<String,Float>(1);\n          pf.put(phraseField.getField(),phraseField.getBoost());\n          addShingledPhraseQueries(query, normalClauses, pf,   \n\t\t\t\t   phraseField.getWordGrams(),tiebreaker, slop);\n        }\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      Map<String,Float> bqBoosts = SolrPluginUtils.parseFieldBoosts(boostParams);\n      boostQueries = new ArrayList<Query>();\n      for (Map.Entry<String,Float> bqs : bqBoosts.entrySet()) {\n        if (bqs.getKey().trim().length()==0) continue;\n        Query q = subQuery(bqs.getKey(), null).getQuery();\n        Float b = bqs.getValue();\n        if(b!=null) {\n          q.setBoost(b);\n        }\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ea392002c53ec2f3e94edcdbb0c5cc5194e2ea6d","date":1347411209,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = DisMaxQParser.parseQueryFields(req.getSchema(), solrParams);\n\n    // Phrase slop array\n    int pslop[] = new int[4];\n    pslop[0] = solrParams.getInt(DisMaxParams.PS, 0);\n    pslop[2] = solrParams.getInt(DisMaxParams.PS2, pslop[0]);\n    pslop[3] = solrParams.getInt(DisMaxParams.PS3, pslop[0]);\n\n    \n    // Boosted phrase of the full query string\n    List<FieldParams> phraseFields = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF),0,pslop[0]);\n    // Boosted Bi-Term Shingles from the query string\n    List<FieldParams> phraseFields2 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF2),2,pslop[2]);\n    // Boosted Tri-Term Shingles from the query string\n    List<FieldParams> phraseFields3 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF3),3,pslop[3]);\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new ParseException(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (lowercaseOperators && i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      List<FieldParams> allPhraseFields = new ArrayList<FieldParams>();\n      allPhraseFields.addAll(phraseFields);\n      allPhraseFields.addAll(phraseFields2);\n      allPhraseFields.addAll(phraseFields3);\n\n      if (allPhraseFields.size() > 0) {\n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase and shingles\n        for (FieldParams phraseField: allPhraseFields) {\n          Map<String,Float> pf = new HashMap<String,Float>(1);\n          pf.put(phraseField.getField(),phraseField.getBoost());\n          addShingledPhraseQueries(query, normalClauses, pf,   \n          phraseField.getWordGrams(),tiebreaker, phraseField.getSlop());\n        }\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = DisMaxQParser.parseQueryFields(req.getSchema(), solrParams);\n\n    // Phrase slop array\n    int pslop[] = new int[4];\n    pslop[0] = solrParams.getInt(DisMaxParams.PS, 0);\n    pslop[2] = solrParams.getInt(DisMaxParams.PS2, pslop[0]);\n    pslop[3] = solrParams.getInt(DisMaxParams.PS3, pslop[0]);\n\n    \n    // Boosted phrase of the full query string\n    List<FieldParams> phraseFields = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF),0,pslop[0]);\n    // Boosted Bi-Term Shingles from the query string\n    List<FieldParams> phraseFields2 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF2),2,pslop[2]);\n    // Boosted Tri-Term Shingles from the query string\n    List<FieldParams> phraseFields3 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF3),3,pslop[3]);\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new ParseException(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (lowercaseOperators && i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      List<FieldParams> allPhraseFields = new ArrayList<FieldParams>();\n      allPhraseFields.addAll(phraseFields);\n      allPhraseFields.addAll(phraseFields2);\n      allPhraseFields.addAll(phraseFields3);\n\n      if (allPhraseFields.size() > 0) {\n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase and shingles\n        for (FieldParams phraseField: allPhraseFields) {\n          Map<String,Float> pf = new HashMap<String,Float>(1);\n          pf.put(phraseField.getField(),phraseField.getBoost());\n          addShingledPhraseQueries(query, normalClauses, pf,   \n          phraseField.getWordGrams(),tiebreaker, phraseField.getSlop());\n        }\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      Map<String,Float> bqBoosts = SolrPluginUtils.parseFieldBoosts(boostParams);\n      boostQueries = new ArrayList<Query>();\n      for (Map.Entry<String,Float> bqs : bqBoosts.entrySet()) {\n        if (bqs.getKey().trim().length()==0) continue;\n        Query q = subQuery(bqs.getKey(), null).getQuery();\n        Float b = bqs.getValue();\n        if(b!=null) {\n          q.setBoost(b);\n        }\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":["789e15fb466c7a5331d7ad1ff6fa9cdb2b6c89e3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19ec10ef17ba08cbd0c263d0d31a6ae9e9461a33","date":1352258720,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = DisMaxQParser.parseQueryFields(req.getSchema(), solrParams);\n\n    // Phrase slop array\n    int pslop[] = new int[4];\n    pslop[0] = solrParams.getInt(DisMaxParams.PS, 0);\n    pslop[2] = solrParams.getInt(DisMaxParams.PS2, pslop[0]);\n    pslop[3] = solrParams.getInt(DisMaxParams.PS3, pslop[0]);\n\n    \n    // Boosted phrase of the full query string\n    List<FieldParams> phraseFields = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF),0,pslop[0]);\n    // Boosted Bi-Term Shingles from the query string\n    List<FieldParams> phraseFields2 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF2),2,pslop[2]);\n    // Boosted Tri-Term Shingles from the query string\n    List<FieldParams> phraseFields3 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF3),3,pslop[3]);\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new ParseException(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (lowercaseOperators && i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n      // but always for unstructured implicit bqs created by getFieldQuery\n      up.minShouldMatch = minShouldMatch;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      List<FieldParams> allPhraseFields = new ArrayList<FieldParams>();\n      allPhraseFields.addAll(phraseFields);\n      allPhraseFields.addAll(phraseFields2);\n      allPhraseFields.addAll(phraseFields3);\n\n      if (allPhraseFields.size() > 0) {\n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase and shingles\n        for (FieldParams phraseField: allPhraseFields) {\n          Map<String,Float> pf = new HashMap<String,Float>(1);\n          pf.put(phraseField.getField(),phraseField.getBoost());\n          addShingledPhraseQueries(query, normalClauses, pf,   \n          phraseField.getWordGrams(),tiebreaker, phraseField.getSlop());\n        }\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = DisMaxQParser.parseQueryFields(req.getSchema(), solrParams);\n\n    // Phrase slop array\n    int pslop[] = new int[4];\n    pslop[0] = solrParams.getInt(DisMaxParams.PS, 0);\n    pslop[2] = solrParams.getInt(DisMaxParams.PS2, pslop[0]);\n    pslop[3] = solrParams.getInt(DisMaxParams.PS3, pslop[0]);\n\n    \n    // Boosted phrase of the full query string\n    List<FieldParams> phraseFields = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF),0,pslop[0]);\n    // Boosted Bi-Term Shingles from the query string\n    List<FieldParams> phraseFields2 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF2),2,pslop[2]);\n    // Boosted Tri-Term Shingles from the query string\n    List<FieldParams> phraseFields3 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF3),3,pslop[3]);\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new ParseException(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (lowercaseOperators && i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      List<FieldParams> allPhraseFields = new ArrayList<FieldParams>();\n      allPhraseFields.addAll(phraseFields);\n      allPhraseFields.addAll(phraseFields2);\n      allPhraseFields.addAll(phraseFields3);\n\n      if (allPhraseFields.size() > 0) {\n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase and shingles\n        for (FieldParams phraseField: allPhraseFields) {\n          Map<String,Float> pf = new HashMap<String,Float>(1);\n          pf.put(phraseField.getField(),phraseField.getBoost());\n          addShingledPhraseQueries(query, normalClauses, pf,   \n          phraseField.getWordGrams(),tiebreaker, phraseField.getSlop());\n        }\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cdb67100dc016748799a77218aa409478372d79","date":1353699950,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws SyntaxError {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = DisMaxQParser.parseQueryFields(req.getSchema(), solrParams);\n\n    // Phrase slop array\n    int pslop[] = new int[4];\n    pslop[0] = solrParams.getInt(DisMaxParams.PS, 0);\n    pslop[2] = solrParams.getInt(DisMaxParams.PS2, pslop[0]);\n    pslop[3] = solrParams.getInt(DisMaxParams.PS3, pslop[0]);\n\n    \n    // Boosted phrase of the full query string\n    List<FieldParams> phraseFields = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF),0,pslop[0]);\n    // Boosted Bi-Term Shingles from the query string\n    List<FieldParams> phraseFields2 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF2),2,pslop[2]);\n    // Boosted Tri-Term Shingles from the query string\n    List<FieldParams> phraseFields3 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF3),3,pslop[3]);\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SyntaxError(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (lowercaseOperators && i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n      // but always for unstructured implicit bqs created by getFieldQuery\n      up.minShouldMatch = minShouldMatch;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      List<FieldParams> allPhraseFields = new ArrayList<FieldParams>();\n      allPhraseFields.addAll(phraseFields);\n      allPhraseFields.addAll(phraseFields2);\n      allPhraseFields.addAll(phraseFields3);\n\n      if (allPhraseFields.size() > 0) {\n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase and shingles\n        for (FieldParams phraseField: allPhraseFields) {\n          Map<String,Float> pf = new HashMap<String,Float>(1);\n          pf.put(phraseField.getField(),phraseField.getBoost());\n          addShingledPhraseQueries(query, normalClauses, pf,   \n          phraseField.getWordGrams(),tiebreaker, phraseField.getSlop());\n        }\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = DisMaxQParser.parseQueryFields(req.getSchema(), solrParams);\n\n    // Phrase slop array\n    int pslop[] = new int[4];\n    pslop[0] = solrParams.getInt(DisMaxParams.PS, 0);\n    pslop[2] = solrParams.getInt(DisMaxParams.PS2, pslop[0]);\n    pslop[3] = solrParams.getInt(DisMaxParams.PS3, pslop[0]);\n\n    \n    // Boosted phrase of the full query string\n    List<FieldParams> phraseFields = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF),0,pslop[0]);\n    // Boosted Bi-Term Shingles from the query string\n    List<FieldParams> phraseFields2 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF2),2,pslop[2]);\n    // Boosted Tri-Term Shingles from the query string\n    List<FieldParams> phraseFields3 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF3),3,pslop[3]);\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new ParseException(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (lowercaseOperators && i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n      // but always for unstructured implicit bqs created by getFieldQuery\n      up.minShouldMatch = minShouldMatch;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      List<FieldParams> allPhraseFields = new ArrayList<FieldParams>();\n      allPhraseFields.addAll(phraseFields);\n      allPhraseFields.addAll(phraseFields2);\n      allPhraseFields.addAll(phraseFields3);\n\n      if (allPhraseFields.size() > 0) {\n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase and shingles\n        for (FieldParams phraseField: allPhraseFields) {\n          Map<String,Float> pf = new HashMap<String,Float>(1);\n          pf.put(phraseField.getField(),phraseField.getBoost());\n          addShingledPhraseQueries(query, normalClauses, pf,   \n          phraseField.getWordGrams(),tiebreaker, phraseField.getSlop());\n        }\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":"  @Override\n  public Query parse() throws SyntaxError {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = DisMaxQParser.parseQueryFields(req.getSchema(), solrParams);\n\n    // Phrase slop array\n    int pslop[] = new int[4];\n    pslop[0] = solrParams.getInt(DisMaxParams.PS, 0);\n    pslop[2] = solrParams.getInt(DisMaxParams.PS2, pslop[0]);\n    pslop[3] = solrParams.getInt(DisMaxParams.PS3, pslop[0]);\n\n    \n    // Boosted phrase of the full query string\n    List<FieldParams> phraseFields = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF),0,pslop[0]);\n    // Boosted Bi-Term Shingles from the query string\n    List<FieldParams> phraseFields2 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF2),2,pslop[2]);\n    // Boosted Tri-Term Shingles from the query string\n    List<FieldParams> phraseFields3 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF3),3,pslop[3]);\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SyntaxError(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (lowercaseOperators && i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n      // but always for unstructured implicit bqs created by getFieldQuery\n      up.minShouldMatch = minShouldMatch;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      List<FieldParams> allPhraseFields = new ArrayList<FieldParams>();\n      allPhraseFields.addAll(phraseFields);\n      allPhraseFields.addAll(phraseFields2);\n      allPhraseFields.addAll(phraseFields3);\n\n      if (allPhraseFields.size() > 0) {\n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase and shingles\n        for (FieldParams phraseField: allPhraseFields) {\n          Map<String,Float> pf = new HashMap<String,Float>(1);\n          pf.put(phraseField.getField(),phraseField.getBoost());\n          addShingledPhraseQueries(query, normalClauses, pf,   \n          phraseField.getWordGrams(),tiebreaker, phraseField.getSlop());\n        }\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","sourceOld":"  @Override\n  public Query parse() throws ParseException {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = DisMaxQParser.parseQueryFields(req.getSchema(), solrParams);\n\n    // Phrase slop array\n    int pslop[] = new int[4];\n    pslop[0] = solrParams.getInt(DisMaxParams.PS, 0);\n    pslop[2] = solrParams.getInt(DisMaxParams.PS2, pslop[0]);\n    pslop[3] = solrParams.getInt(DisMaxParams.PS3, pslop[0]);\n\n    \n    // Boosted phrase of the full query string\n    List<FieldParams> phraseFields = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF),0,pslop[0]);\n    // Boosted Bi-Term Shingles from the query string\n    List<FieldParams> phraseFields2 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF2),2,pslop[2]);\n    // Boosted Tri-Term Shingles from the query string\n    List<FieldParams> phraseFields3 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF3),3,pslop[3]);\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new ParseException(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (lowercaseOperators && i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n      // but always for unstructured implicit bqs created by getFieldQuery\n      up.minShouldMatch = minShouldMatch;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      List<FieldParams> allPhraseFields = new ArrayList<FieldParams>();\n      allPhraseFields.addAll(phraseFields);\n      allPhraseFields.addAll(phraseFields2);\n      allPhraseFields.addAll(phraseFields3);\n\n      if (allPhraseFields.size() > 0) {\n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase and shingles\n        for (FieldParams phraseField: allPhraseFields) {\n          Map<String,Float> pf = new HashMap<String,Float>(1);\n          pf.put(phraseField.getField(),phraseField.getBoost());\n          addShingledPhraseQueries(query, normalClauses, pf,   \n          phraseField.getWordGrams(),tiebreaker, phraseField.getSlop());\n        }\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7e79e31f55cbb444e3023d430a340658755aa31","date":1357666399,"type":4,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":null,"sourceOld":"  @Override\n  public Query parse() throws SyntaxError {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = DisMaxQParser.parseQueryFields(req.getSchema(), solrParams);\n\n    // Phrase slop array\n    int pslop[] = new int[4];\n    pslop[0] = solrParams.getInt(DisMaxParams.PS, 0);\n    pslop[2] = solrParams.getInt(DisMaxParams.PS2, pslop[0]);\n    pslop[3] = solrParams.getInt(DisMaxParams.PS3, pslop[0]);\n\n    \n    // Boosted phrase of the full query string\n    List<FieldParams> phraseFields = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF),0,pslop[0]);\n    // Boosted Bi-Term Shingles from the query string\n    List<FieldParams> phraseFields2 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF2),2,pslop[2]);\n    // Boosted Tri-Term Shingles from the query string\n    List<FieldParams> phraseFields3 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF3),3,pslop[3]);\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SyntaxError(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (lowercaseOperators && i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n      // but always for unstructured implicit bqs created by getFieldQuery\n      up.minShouldMatch = minShouldMatch;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      List<FieldParams> allPhraseFields = new ArrayList<FieldParams>();\n      allPhraseFields.addAll(phraseFields);\n      allPhraseFields.addAll(phraseFields2);\n      allPhraseFields.addAll(phraseFields3);\n\n      if (allPhraseFields.size() > 0) {\n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase and shingles\n        for (FieldParams phraseField: allPhraseFields) {\n          Map<String,Float> pf = new HashMap<String,Float>(1);\n          pf.put(phraseField.getField(),phraseField.getBoost());\n          addShingledPhraseQueries(query, normalClauses, pf,   \n          phraseField.getWordGrams(),tiebreaker, phraseField.getSlop());\n        }\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e6354dd7c71fe122926fc53d7d29f715b1283db","date":1357915185,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser[ExtendedDismaxQParserPlugin]#parse().mjava","sourceNew":null,"sourceOld":"  @Override\n  public Query parse() throws SyntaxError {\n    SolrParams localParams = getLocalParams();\n    SolrParams params = getParams();\n    \n    solrParams = SolrParams.wrapDefaults(localParams, params);\n\n    final String minShouldMatch = \n      DisMaxQParser.parseMinShouldMatch(req.getSchema(), solrParams);\n\n    userFields = new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));\n    \n    queryFields = DisMaxQParser.parseQueryFields(req.getSchema(), solrParams);\n\n    // Phrase slop array\n    int pslop[] = new int[4];\n    pslop[0] = solrParams.getInt(DisMaxParams.PS, 0);\n    pslop[2] = solrParams.getInt(DisMaxParams.PS2, pslop[0]);\n    pslop[3] = solrParams.getInt(DisMaxParams.PS3, pslop[0]);\n\n    \n    // Boosted phrase of the full query string\n    List<FieldParams> phraseFields = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF),0,pslop[0]);\n    // Boosted Bi-Term Shingles from the query string\n    List<FieldParams> phraseFields2 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF2),2,pslop[2]);\n    // Boosted Tri-Term Shingles from the query string\n    List<FieldParams> phraseFields3 = \n      U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF3),3,pslop[3]);\n\n    float tiebreaker = solrParams.getFloat(DisMaxParams.TIE, 0.0f);\n\n    int qslop = solrParams.getInt(DisMaxParams.QS, 0);\n\n    // remove stopwords from mandatory \"matching\" component?\n    boolean stopwords = solrParams.getBool(\"stopwords\", true);\n\n    /* the main query we will execute.  we disable the coord because\n     * this query is an artificial construct\n     */\n    BooleanQuery query = new BooleanQuery(true);\n\n    /* * * Main User Query * * */\n    parsedUserQuery = null;\n    String userQuery = getString();\n    altUserQuery = null;\n    if( userQuery == null || userQuery.trim().length() == 0 ) {\n      // If no query is specified, we may have an alternate\n      String altQ = solrParams.get( DisMaxParams.ALTQ );\n      if (altQ != null) {\n        altQParser = subQuery(altQ, null);\n        altUserQuery = altQParser.getQuery();\n        query.add( altUserQuery , BooleanClause.Occur.MUST );\n      } else {\n        return null;\n        // throw new SyntaxError(\"missing query string\" );\n      }\n    }\n    else {     \n      // There is a valid query string\n      // userQuery = partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();\n\n      boolean lowercaseOperators = solrParams.getBool(\"lowercaseOperators\", true);\n      String mainUserQuery = userQuery;\n\n      ExtendedSolrQueryParser up =\n        new ExtendedSolrQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n      up.addAlias(IMPOSSIBLE_FIELD_NAME,\n                tiebreaker, queryFields);\n      addAliasesFromRequest(up, tiebreaker);\n      up.setPhraseSlop(qslop);     // slop for explicit user phrase queries\n      up.setAllowLeadingWildcard(true);\n\n      // defer escaping and only do if lucene parsing fails, or we need phrases\n      // parsing fails.  Need to sloppy phrase queries anyway though.\n      List<Clause> clauses = null;\n      int numPluses = 0;\n      int numMinuses = 0;\n      int numOR = 0;\n      int numNOT = 0;\n\n      clauses = splitIntoClauses(userQuery, false);\n      for (Clause clause : clauses) {\n        if (clause.must == '+') numPluses++;\n        if (clause.must == '-') numMinuses++;\n        if (clause.isBareWord()) {\n          String s = clause.val;\n          if (\"OR\".equals(s)) {\n            numOR++;\n          } else if (\"NOT\".equals(s)) {\n            numNOT++;\n          } else if (lowercaseOperators && \"or\".equals(s)) {\n            numOR++;\n          }\n        }\n      }\n\n      // Always rebuild mainUserQuery from clauses to catch modifications from splitIntoClauses\n      // This was necessary for userFields modifications to get propagated into the query.\n      // Convert lower or mixed case operators to uppercase if we saw them.\n      // only do this for the lucene query part and not for phrase query boosting\n      // since some fields might not be case insensitive.\n      // We don't use a regex for this because it might change and AND or OR in\n      // a phrase query in a case sensitive field.\n      StringBuilder sb = new StringBuilder();\n      for (int i=0; i<clauses.size(); i++) {\n        Clause clause = clauses.get(i);\n        String s = clause.raw;\n        // and and or won't be operators at the start or end\n        if (lowercaseOperators && i>0 && i+1<clauses.size()) {\n          if (\"AND\".equalsIgnoreCase(s)) {\n            s=\"AND\";\n          } else if (\"OR\".equalsIgnoreCase(s)) {\n            s=\"OR\";\n          }\n        }\n        sb.append(s);\n        sb.append(' ');\n      }\n      \n      mainUserQuery = sb.toString();\n      \n      // For correct lucene queries, turn off mm processing if there\n      // were explicit operators (except for AND).\n      boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0;\n      // but always for unstructured implicit bqs created by getFieldQuery\n      up.minShouldMatch = minShouldMatch;\n\n      try {\n        up.setRemoveStopFilter(!stopwords);\n        up.exceptions = true;\n        parsedUserQuery = up.parse(mainUserQuery);\n\n        if (stopwords && isEmpty(parsedUserQuery)) {\n         // if the query was all stop words, remove none of them\n          up.setRemoveStopFilter(true);\n          parsedUserQuery = up.parse(mainUserQuery);          \n        }\n      } catch (Exception e) {\n        // ignore failure and reparse later after escaping reserved chars\n        up.exceptions = false;\n      }\n\n      if (parsedUserQuery != null && doMinMatched) {\n        if (parsedUserQuery instanceof BooleanQuery) {\n          SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery, minShouldMatch);\n        }\n      }\n\n      if (parsedUserQuery == null) {\n        sb = new StringBuilder();\n        for (Clause clause : clauses) {\n\n          boolean doQuote = clause.isPhrase;\n\n          String s=clause.val;\n          if (!clause.isPhrase && (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s))) {\n            doQuote=true;\n          }\n\n          if (clause.must != 0) {\n            sb.append(clause.must);\n          }\n          if (clause.field != null) {\n            sb.append(clause.field);\n            sb.append(':');\n          }\n          if (doQuote) {\n            sb.append('\"');\n          }\n          sb.append(clause.val);\n          if (doQuote) {\n            sb.append('\"');\n          }\n          if (clause.field != null) {\n            // Add the default user field boost, if any\n            Float boost = userFields.getBoost(clause.field);\n            if(boost != null)\n              sb.append(\"^\").append(boost);\n          }\n          sb.append(' ');\n        }\n        String escapedUserQuery = sb.toString();\n        parsedUserQuery = up.parse(escapedUserQuery);\n\n        if (parsedUserQuery instanceof BooleanQuery) {\n          BooleanQuery t = new BooleanQuery();\n          SolrPluginUtils.flattenBooleanQuery(t, (BooleanQuery)parsedUserQuery);\n          SolrPluginUtils.setMinShouldMatch(t, minShouldMatch);\n          parsedUserQuery = t;\n        }\n      }\n\n      query.add(parsedUserQuery, BooleanClause.Occur.MUST);\n\n      // sloppy phrase queries for proximity\n      List<FieldParams> allPhraseFields = new ArrayList<FieldParams>();\n      allPhraseFields.addAll(phraseFields);\n      allPhraseFields.addAll(phraseFields2);\n      allPhraseFields.addAll(phraseFields3);\n\n      if (allPhraseFields.size() > 0) {\n        // find non-field clauses\n        List<Clause> normalClauses = new ArrayList<Clause>(clauses.size());\n        for (Clause clause : clauses) {\n          if (clause.field != null || clause.isPhrase) continue;\n          // check for keywords \"AND,OR,TO\"\n          if (clause.isBareWord()) {\n            String s = clause.val.toString();\n            // avoid putting explict operators in the phrase query\n            if (\"OR\".equals(s) || \"AND\".equals(s) || \"NOT\".equals(s) || \"TO\".equals(s)) continue;\n          }\n          normalClauses.add(clause);\n        }\n\n        // full phrase and shingles\n        for (FieldParams phraseField: allPhraseFields) {\n          Map<String,Float> pf = new HashMap<String,Float>(1);\n          pf.put(phraseField.getField(),phraseField.getBoost());\n          addShingledPhraseQueries(query, normalClauses, pf,   \n          phraseField.getWordGrams(),tiebreaker, phraseField.getSlop());\n        }\n        \n      }\n    }\n\n\n\n    /* * * Boosting Query * * */\n    boostParams = solrParams.getParams(DisMaxParams.BQ);\n    //List<Query> boostQueries = U.parseQueryStrings(req, boostParams);\n    boostQueries=null;\n    if (boostParams!=null && boostParams.length>0) {\n      boostQueries = new ArrayList<Query>();\n      for (String qs : boostParams) {\n        if (qs.trim().length()==0) continue;\n        Query q = subQuery(qs, null).getQuery();\n        boostQueries.add(q);\n      }\n    }\n    if (null != boostQueries) {\n      for(Query f : boostQueries) {\n        query.add(f, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    /* * * Boosting Functions * * */\n\n    String[] boostFuncs = solrParams.getParams(DisMaxParams.BF);\n    if (null != boostFuncs && 0 != boostFuncs.length) {\n      for (String boostFunc : boostFuncs) {\n        if(null == boostFunc || \"\".equals(boostFunc)) continue;\n        Map<String,Float> ff = SolrPluginUtils.parseFieldBoosts(boostFunc);\n        for (String f : ff.keySet()) {\n          Query fq = subQuery(f, FunctionQParserPlugin.NAME).getQuery();\n          Float b = ff.get(f);\n          if (null != b) {\n            fq.setBoost(b);\n          }\n          query.add(fq, BooleanClause.Occur.SHOULD);\n        }\n      }\n    }\n\n\n    //\n    // create a boosted query (scores multiplied by boosts)\n    //\n    Query topQuery = query;\n    multBoosts = solrParams.getParams(\"boost\");\n    if (multBoosts!=null && multBoosts.length>0) {\n\n      List<ValueSource> boosts = new ArrayList<ValueSource>();\n      for (String boostStr : multBoosts) {\n        if (boostStr==null || boostStr.length()==0) continue;\n        Query boost = subQuery(boostStr, FunctionQParserPlugin.NAME).getQuery();\n        ValueSource vs;\n        if (boost instanceof FunctionQuery) {\n          vs = ((FunctionQuery)boost).getValueSource();\n        } else {\n          vs = new QueryValueSource(boost, 1.0f);\n        }\n        boosts.add(vs);\n      }\n\n      if (boosts.size()>1) {\n        ValueSource prod = new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));\n        topQuery = new BoostedQuery(query, prod);\n      } else if (boosts.size() == 1) {\n        topQuery = new BoostedQuery(query, boosts.get(0));\n      }\n    }\n\n    return topQuery;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"789e15fb466c7a5331d7ad1ff6fa9cdb2b6c89e3":["576a4c26b3d237aa2626e691ea3b4fa016037fe3"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["0dcbe407b62ce0c91dc171a4695a9f442c46ce14","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"d9e959ce5e0805c43916e999d21f2018a2b475ab":["738199265d7244d0d494cdc76ad36c750d9a1bcd"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"19ec10ef17ba08cbd0c263d0d31a6ae9e9461a33":["ea392002c53ec2f3e94edcdbb0c5cc5194e2ea6d"],"15cacbf46c73bd5b0e47b57128be8852cb236160":["d7c87c58d71fb9a6f5bc4ae8247339ecbbf67edc"],"576a4c26b3d237aa2626e691ea3b4fa016037fe3":["245c71087515ed70d4fb9d9484f9dcbd79eebdfc"],"0dcbe407b62ce0c91dc171a4695a9f442c46ce14":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c7e79e31f55cbb444e3023d430a340658755aa31":["3cdb67100dc016748799a77218aa409478372d79"],"500052b00ecd22d5bd8b0efd25666d035ef55f85":["963838fde272080e74cd28379f80e34631528b50"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["407687e67faf6e1f02a211ca078d8e3eed631027","c7e79e31f55cbb444e3023d430a340658755aa31"],"38e3b736c7ca086d61b7dbb841c905ee115490da":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","245c71087515ed70d4fb9d9484f9dcbd79eebdfc"],"4ceb6a6c707ada1df8bde804e25c98668e699a18":["c26f00b574427b55127e869b935845554afde1fa","0dcbe407b62ce0c91dc171a4695a9f442c46ce14"],"3cdb67100dc016748799a77218aa409478372d79":["19ec10ef17ba08cbd0c263d0d31a6ae9e9461a33"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["0dcbe407b62ce0c91dc171a4695a9f442c46ce14"],"d7c87c58d71fb9a6f5bc4ae8247339ecbbf67edc":["789e15fb466c7a5331d7ad1ff6fa9cdb2b6c89e3"],"407687e67faf6e1f02a211ca078d8e3eed631027":["19ec10ef17ba08cbd0c263d0d31a6ae9e9461a33","3cdb67100dc016748799a77218aa409478372d79"],"963838fde272080e74cd28379f80e34631528b50":["220acde8206f5221383e3777429a4fb84bed289f"],"738199265d7244d0d494cdc76ad36c750d9a1bcd":["15cacbf46c73bd5b0e47b57128be8852cb236160"],"220acde8206f5221383e3777429a4fb84bed289f":["d9e959ce5e0805c43916e999d21f2018a2b475ab"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["220acde8206f5221383e3777429a4fb84bed289f","500052b00ecd22d5bd8b0efd25666d035ef55f85"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ea392002c53ec2f3e94edcdbb0c5cc5194e2ea6d":["500052b00ecd22d5bd8b0efd25666d035ef55f85"],"245c71087515ed70d4fb9d9484f9dcbd79eebdfc":["f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c7e79e31f55cbb444e3023d430a340658755aa31"]},"commit2Childs":{"789e15fb466c7a5331d7ad1ff6fa9cdb2b6c89e3":["d7c87c58d71fb9a6f5bc4ae8247339ecbbf67edc"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["38e3b736c7ca086d61b7dbb841c905ee115490da"],"d9e959ce5e0805c43916e999d21f2018a2b475ab":["220acde8206f5221383e3777429a4fb84bed289f"],"c26f00b574427b55127e869b935845554afde1fa":["0dcbe407b62ce0c91dc171a4695a9f442c46ce14","4ceb6a6c707ada1df8bde804e25c98668e699a18"],"19ec10ef17ba08cbd0c263d0d31a6ae9e9461a33":["3cdb67100dc016748799a77218aa409478372d79","407687e67faf6e1f02a211ca078d8e3eed631027"],"576a4c26b3d237aa2626e691ea3b4fa016037fe3":["789e15fb466c7a5331d7ad1ff6fa9cdb2b6c89e3"],"15cacbf46c73bd5b0e47b57128be8852cb236160":["738199265d7244d0d494cdc76ad36c750d9a1bcd"],"0dcbe407b62ce0c91dc171a4695a9f442c46ce14":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","4ceb6a6c707ada1df8bde804e25c98668e699a18","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"c7e79e31f55cbb444e3023d430a340658755aa31":["4e6354dd7c71fe122926fc53d7d29f715b1283db","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"500052b00ecd22d5bd8b0efd25666d035ef55f85":["fe33227f6805edab2036cbb80645cc4e2d1fa424","ea392002c53ec2f3e94edcdbb0c5cc5194e2ea6d"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":[],"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"4ceb6a6c707ada1df8bde804e25c98668e699a18":[],"3cdb67100dc016748799a77218aa409478372d79":["c7e79e31f55cbb444e3023d430a340658755aa31","407687e67faf6e1f02a211ca078d8e3eed631027"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","245c71087515ed70d4fb9d9484f9dcbd79eebdfc"],"d7c87c58d71fb9a6f5bc4ae8247339ecbbf67edc":["15cacbf46c73bd5b0e47b57128be8852cb236160"],"407687e67faf6e1f02a211ca078d8e3eed631027":["4e6354dd7c71fe122926fc53d7d29f715b1283db"],"963838fde272080e74cd28379f80e34631528b50":["500052b00ecd22d5bd8b0efd25666d035ef55f85"],"738199265d7244d0d494cdc76ad36c750d9a1bcd":["d9e959ce5e0805c43916e999d21f2018a2b475ab"],"220acde8206f5221383e3777429a4fb84bed289f":["963838fde272080e74cd28379f80e34631528b50","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ea392002c53ec2f3e94edcdbb0c5cc5194e2ea6d":["19ec10ef17ba08cbd0c263d0d31a6ae9e9461a33"],"245c71087515ed70d4fb9d9484f9dcbd79eebdfc":["576a4c26b3d237aa2626e691ea3b4fa016037fe3","38e3b736c7ca086d61b7dbb841c905ee115490da"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4e6354dd7c71fe122926fc53d7d29f715b1283db","38e3b736c7ca086d61b7dbb841c905ee115490da","4ceb6a6c707ada1df8bde804e25c98668e699a18","fe33227f6805edab2036cbb80645cc4e2d1fa424","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}