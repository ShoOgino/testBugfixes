{"path":"solr/core/src/java/org/apache/solr/request/json/JsonQueryConverter#buildLocalParams(StringBuilder,Object,boolean,Map[String,String[]]).mjava","commits":[{"id":"10eda272dbca4b0397f9b0c2aa6fadad3601db47","date":1504272103,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/json/JsonQueryConverter#buildLocalParams(StringBuilder,Object,boolean,Map[String,String[]]).mjava","pathOld":"/dev/null","sourceNew":"  private void buildLocalParams(StringBuilder builder, Object val, boolean isQParser, Map<String, String[]> additionalParams) {\n    if (!isQParser && !(val instanceof Map)) {\n      // val is value of a query parser, and it is not a map\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n    if (val instanceof String) {\n      builder.append('$').append(putParam(val.toString(), additionalParams));\n      return;\n    }\n    if (val instanceof Number) {\n      builder.append(val);\n      return;\n    }\n    if (!(val instanceof Map)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n\n    Map<String,Object> map = (Map<String, Object>) val;\n    if (isQParser) {\n      if (map.size() != 1) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Error when parsing json query, expect only one query parser here, but found : \"+map.keySet());\n      }\n      String qtype = map.keySet().iterator().next();\n      Object subVal = map.get(qtype);\n\n      // We don't want to introduce unnecessary variable at root level\n      boolean useSubBuilder = builder.length() > 0;\n      StringBuilder subBuilder = builder;\n\n      if (useSubBuilder) subBuilder = new StringBuilder();\n\n      subBuilder = subBuilder.append(\"{!\").append(qtype).append(' ');;\n      buildLocalParams(subBuilder, subVal, false, additionalParams);\n      subBuilder.append(\"}\");\n\n      if (useSubBuilder) builder.append('$').append(putParam(subBuilder.toString(), additionalParams));\n    } else {\n      for (Map.Entry<String, Object> entry : map.entrySet()) {\n        String key = entry.getKey();\n        if (entry.getValue() instanceof List) {\n          if (key.equals(\"query\")) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Error when parsing json query, value of query field should not be a list, found : \" + entry.getValue());\n          }\n          List l = (List) entry.getValue();\n          for (Object subVal : l) {\n            builder.append(key).append(\"=\");\n            buildLocalParams(builder, subVal, true, additionalParams);\n            builder.append(\" \");\n          }\n        } else {\n          if (key.equals(\"query\")) {\n            key = \"v\";\n          }\n          builder.append(key).append(\"=\");\n          buildLocalParams(builder, entry.getValue(), true, additionalParams);\n          builder.append(\" \");\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/json/JsonQueryConverter#buildLocalParams(StringBuilder,Object,boolean,Map[String,String[]]).mjava","pathOld":"/dev/null","sourceNew":"  private void buildLocalParams(StringBuilder builder, Object val, boolean isQParser, Map<String, String[]> additionalParams) {\n    if (!isQParser && !(val instanceof Map)) {\n      // val is value of a query parser, and it is not a map\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n    if (val instanceof String) {\n      builder.append('$').append(putParam(val.toString(), additionalParams));\n      return;\n    }\n    if (val instanceof Number) {\n      builder.append(val);\n      return;\n    }\n    if (!(val instanceof Map)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n\n    Map<String,Object> map = (Map<String, Object>) val;\n    if (isQParser) {\n      if (map.size() != 1) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Error when parsing json query, expect only one query parser here, but found : \"+map.keySet());\n      }\n      String qtype = map.keySet().iterator().next();\n      Object subVal = map.get(qtype);\n\n      // We don't want to introduce unnecessary variable at root level\n      boolean useSubBuilder = builder.length() > 0;\n      StringBuilder subBuilder = builder;\n\n      if (useSubBuilder) subBuilder = new StringBuilder();\n\n      subBuilder = subBuilder.append(\"{!\").append(qtype).append(' ');;\n      buildLocalParams(subBuilder, subVal, false, additionalParams);\n      subBuilder.append(\"}\");\n\n      if (useSubBuilder) builder.append('$').append(putParam(subBuilder.toString(), additionalParams));\n    } else {\n      for (Map.Entry<String, Object> entry : map.entrySet()) {\n        String key = entry.getKey();\n        if (entry.getValue() instanceof List) {\n          if (key.equals(\"query\")) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Error when parsing json query, value of query field should not be a list, found : \" + entry.getValue());\n          }\n          List l = (List) entry.getValue();\n          for (Object subVal : l) {\n            builder.append(key).append(\"=\");\n            buildLocalParams(builder, subVal, true, additionalParams);\n            builder.append(\" \");\n          }\n        } else {\n          if (key.equals(\"query\")) {\n            key = \"v\";\n          }\n          builder.append(key).append(\"=\");\n          buildLocalParams(builder, entry.getValue(), true, additionalParams);\n          builder.append(\" \");\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b21283ed01203901a7257aa4b7f0a0899c86e56e","date":1504689720,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/json/JsonQueryConverter#buildLocalParams(StringBuilder,Object,boolean,Map[String,String[]]).mjava","pathOld":"/dev/null","sourceNew":"  private void buildLocalParams(StringBuilder builder, Object val, boolean isQParser, Map<String, String[]> additionalParams) {\n    if (!isQParser && !(val instanceof Map)) {\n      // val is value of a query parser, and it is not a map\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n    if (val instanceof String) {\n      builder.append('$').append(putParam(val.toString(), additionalParams));\n      return;\n    }\n    if (val instanceof Number) {\n      builder.append(val);\n      return;\n    }\n    if (!(val instanceof Map)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n\n    Map<String,Object> map = (Map<String, Object>) val;\n    if (isQParser) {\n      if (map.size() != 1) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Error when parsing json query, expect only one query parser here, but found : \"+map.keySet());\n      }\n      String qtype = map.keySet().iterator().next();\n      Object subVal = map.get(qtype);\n\n      // We don't want to introduce unnecessary variable at root level\n      boolean useSubBuilder = builder.length() > 0;\n      StringBuilder subBuilder = builder;\n\n      if (useSubBuilder) subBuilder = new StringBuilder();\n\n      subBuilder = subBuilder.append(\"{!\").append(qtype).append(' ');;\n      buildLocalParams(subBuilder, subVal, false, additionalParams);\n      subBuilder.append(\"}\");\n\n      if (useSubBuilder) builder.append('$').append(putParam(subBuilder.toString(), additionalParams));\n    } else {\n      for (Map.Entry<String, Object> entry : map.entrySet()) {\n        String key = entry.getKey();\n        if (entry.getValue() instanceof List) {\n          if (key.equals(\"query\")) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Error when parsing json query, value of query field should not be a list, found : \" + entry.getValue());\n          }\n          List l = (List) entry.getValue();\n          for (Object subVal : l) {\n            builder.append(key).append(\"=\");\n            buildLocalParams(builder, subVal, true, additionalParams);\n            builder.append(\" \");\n          }\n        } else {\n          if (key.equals(\"query\")) {\n            key = \"v\";\n          }\n          builder.append(key).append(\"=\");\n          buildLocalParams(builder, entry.getValue(), true, additionalParams);\n          builder.append(\" \");\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","date":1504848000,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/json/JsonQueryConverter#buildLocalParams(StringBuilder,Object,boolean,Map[String,String[]]).mjava","pathOld":"/dev/null","sourceNew":"  private void buildLocalParams(StringBuilder builder, Object val, boolean isQParser, Map<String, String[]> additionalParams) {\n    if (!isQParser && !(val instanceof Map)) {\n      // val is value of a query parser, and it is not a map\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n    if (val instanceof String) {\n      builder.append('$').append(putParam(val.toString(), additionalParams));\n      return;\n    }\n    if (val instanceof Number) {\n      builder.append(val);\n      return;\n    }\n    if (!(val instanceof Map)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n\n    Map<String,Object> map = (Map<String, Object>) val;\n    if (isQParser) {\n      if (map.size() != 1) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Error when parsing json query, expect only one query parser here, but found : \"+map.keySet());\n      }\n      String qtype = map.keySet().iterator().next();\n      Object subVal = map.get(qtype);\n\n      // We don't want to introduce unnecessary variable at root level\n      boolean useSubBuilder = builder.length() > 0;\n      StringBuilder subBuilder = builder;\n\n      if (useSubBuilder) subBuilder = new StringBuilder();\n\n      subBuilder = subBuilder.append(\"{!\").append(qtype).append(' ');;\n      buildLocalParams(subBuilder, subVal, false, additionalParams);\n      subBuilder.append(\"}\");\n\n      if (useSubBuilder) builder.append('$').append(putParam(subBuilder.toString(), additionalParams));\n    } else {\n      for (Map.Entry<String, Object> entry : map.entrySet()) {\n        String key = entry.getKey();\n        if (entry.getValue() instanceof List) {\n          if (key.equals(\"query\")) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Error when parsing json query, value of query field should not be a list, found : \" + entry.getValue());\n          }\n          List l = (List) entry.getValue();\n          for (Object subVal : l) {\n            builder.append(key).append(\"=\");\n            buildLocalParams(builder, subVal, true, additionalParams);\n            builder.append(\" \");\n          }\n        } else {\n          if (key.equals(\"query\")) {\n            key = \"v\";\n          }\n          builder.append(key).append(\"=\");\n          buildLocalParams(builder, entry.getValue(), true, additionalParams);\n          builder.append(\" \");\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddce5ba13e43e3b34a1772ed921d9b9d7a67e48d","date":1527452536,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/json/JsonQueryConverter#buildLocalParams(StringBuilder,Object,boolean,Map[String,String[]]).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/JsonQueryConverter#buildLocalParams(StringBuilder,Object,boolean,Map[String,String[]]).mjava","sourceNew":"  private void buildLocalParams(StringBuilder builder, Object val, boolean isQParser, Map<String, String[]> additionalParams) {\n    if (!isQParser && !(val instanceof Map)) {\n      // val is value of a query parser, and it is not a map\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n    if (val instanceof String) {\n      builder.append('$').append(putParam(val.toString(), additionalParams));\n      return;\n    }\n    if (val instanceof Number) {\n      builder.append(val);\n      return;\n    }\n    if (!(val instanceof Map)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n\n    Map<String,Object> map = (Map<String, Object>) val;\n    if (isQParser) {\n      if (map.size() != 1) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Error when parsing json query, expect only one query parser here, but found : \"+map.keySet());\n      }\n\n      String qtype = map.keySet().iterator().next();\n      String tagName = null;\n      if (qtype.startsWith(\"#\")) {\n        Object taggedQueryObject = map.get(qtype);\n        tagName = qtype.substring(1);\n        if (taggedQueryObject instanceof String) {\n          builder.append(\"{!tag=\").append(tagName).append(\"}\");\n          builder.append(taggedQueryObject);\n          return;\n        } else if (taggedQueryObject instanceof Map) {\n          map = (Map<String, Object>) taggedQueryObject;\n          qtype = map.keySet().iterator().next();\n        }\n      }\n\n      // We don't want to introduce unnecessary variable at root level\n      boolean useSubBuilder = builder.length() > 0;\n      StringBuilder subBuilder = builder;\n\n      if (useSubBuilder) subBuilder = new StringBuilder();\n\n      Object subVal = map.get(qtype);\n      subBuilder = subBuilder.append(\"{!\").append(qtype).append(' ');\n      if (tagName != null) {\n        subBuilder.append(\"tag=\").append(tagName).append(' ');\n      }\n      buildLocalParams(subBuilder, subVal, false, additionalParams);\n      subBuilder.append(\"}\");\n\n      if (useSubBuilder) {\n        builder.append('$').append(putParam(subBuilder.toString(), additionalParams));\n      }\n    } else {\n      for (Map.Entry<String, Object> entry : map.entrySet()) {\n        String key = entry.getKey();\n        if (entry.getValue() instanceof List) {\n          if (key.equals(\"query\")) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Error when parsing json query, value of query field should not be a list, found : \" + entry.getValue());\n          }\n          List l = (List) entry.getValue();\n          for (Object subVal : l) {\n            builder.append(key).append(\"=\");\n            buildLocalParams(builder, subVal, true, additionalParams);\n            builder.append(\" \");\n          }\n        } else {\n          if (key.equals(\"query\")) {\n            key = \"v\";\n          }\n          builder.append(key).append(\"=\");\n          buildLocalParams(builder, entry.getValue(), true, additionalParams);\n          builder.append(\" \");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void buildLocalParams(StringBuilder builder, Object val, boolean isQParser, Map<String, String[]> additionalParams) {\n    if (!isQParser && !(val instanceof Map)) {\n      // val is value of a query parser, and it is not a map\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n    if (val instanceof String) {\n      builder.append('$').append(putParam(val.toString(), additionalParams));\n      return;\n    }\n    if (val instanceof Number) {\n      builder.append(val);\n      return;\n    }\n    if (!(val instanceof Map)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n\n    Map<String,Object> map = (Map<String, Object>) val;\n    if (isQParser) {\n      if (map.size() != 1) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Error when parsing json query, expect only one query parser here, but found : \"+map.keySet());\n      }\n      String qtype = map.keySet().iterator().next();\n      Object subVal = map.get(qtype);\n\n      // We don't want to introduce unnecessary variable at root level\n      boolean useSubBuilder = builder.length() > 0;\n      StringBuilder subBuilder = builder;\n\n      if (useSubBuilder) subBuilder = new StringBuilder();\n\n      subBuilder = subBuilder.append(\"{!\").append(qtype).append(' ');;\n      buildLocalParams(subBuilder, subVal, false, additionalParams);\n      subBuilder.append(\"}\");\n\n      if (useSubBuilder) builder.append('$').append(putParam(subBuilder.toString(), additionalParams));\n    } else {\n      for (Map.Entry<String, Object> entry : map.entrySet()) {\n        String key = entry.getKey();\n        if (entry.getValue() instanceof List) {\n          if (key.equals(\"query\")) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Error when parsing json query, value of query field should not be a list, found : \" + entry.getValue());\n          }\n          List l = (List) entry.getValue();\n          for (Object subVal : l) {\n            builder.append(key).append(\"=\");\n            buildLocalParams(builder, subVal, true, additionalParams);\n            builder.append(\" \");\n          }\n        } else {\n          if (key.equals(\"query\")) {\n            key = \"v\";\n          }\n          builder.append(key).append(\"=\");\n          buildLocalParams(builder, entry.getValue(), true, additionalParams);\n          builder.append(\" \");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff95b5e47fe4df3d066c51f0a3f8970e8fbb2aa4","date":1528834006,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/json/JsonQueryConverter#buildLocalParams(StringBuilder,Object,boolean,Map[String,String[]]).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/JsonQueryConverter#buildLocalParams(StringBuilder,Object,boolean,Map[String,String[]]).mjava","sourceNew":"  // when isQParser==true, \"val\" is a query object of the form {query_type:{param1:val1, param2:val2}}\n  // when isQParser==false, \"val\" is a parameter on an existing qparser (which could be a simple parameter like 42, or a sub-query)\n  private void buildLocalParams(StringBuilder builder, Object val, boolean isQParser, Map<String, String[]> additionalParams) {\n    if (!isQParser && !(val instanceof Map)) {\n      // val is value of a query parser, and it is not a map\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n      // NOTE: a top-level query *can* be a String, so we should really allow it here.  This currently only works because\n      // we special-case String in toLocalParams() and don't call this method.\n    }\n    // We don't want to introduce unnecessary variable at root level\n    boolean useSubBuilder = builder.length() > 0;\n\n    if (val instanceof String) {\n      if (!useSubBuilder) {\n        // Top level, so just use the value.  NOTE: this case is also short-circuited in toLocalParams() for performance.\n        builder.append(val.toString());\n      } else {\n        // val is a parameter in a qparser, so use param deref and skip escaping: ...=$param1}&param1=<val>\n        builder.append('$').append(putParam(val.toString(), additionalParams));\n      }\n      return;\n    }\n    if (val instanceof Number) {\n      builder.append(val);\n      return;\n    }\n    if (!(val instanceof Map)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n\n    Map<String,Object> map = (Map<String, Object>) val;\n    if (isQParser) {\n      if (map.size() != 1) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Error when parsing json query, expect only one query parser here, but found : \"+map.keySet());\n      }\n\n      String qtype = map.keySet().iterator().next();\n      String tagName = null;\n      if (qtype.startsWith(\"#\")) {\n        Object taggedQueryObject = map.get(qtype);\n        tagName = qtype.substring(1);\n        if (taggedQueryObject instanceof String) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"{!tag=\").append(tagName).append(\"}\");\n          sb.append(taggedQueryObject.toString());\n          buildLocalParams(builder, sb.toString(), true, additionalParams);\n          return;\n        } else if (taggedQueryObject instanceof Map) {\n          map = (Map<String, Object>) taggedQueryObject;\n          qtype = map.keySet().iterator().next();\n          // FUTURE: might want to recurse here instead to handle nested tags (and add tagName as a parameter?)\n        }\n      }\n\n      StringBuilder subBuilder = useSubBuilder ? new StringBuilder() : builder;\n\n      Object subVal = map.get(qtype);\n      subBuilder = subBuilder.append(\"{!\").append(qtype).append(' ');\n      if (tagName != null) {\n        subBuilder.append(\"tag=\").append(tagName).append(' ');\n      }\n      buildLocalParams(subBuilder, subVal, false, additionalParams);\n      subBuilder.append(\"}\");\n\n      if (useSubBuilder) {\n        builder.append('$').append(putParam(subBuilder.toString(), additionalParams));\n      }\n    } else {\n      for (Map.Entry<String, Object> entry : map.entrySet()) {\n        String key = entry.getKey();\n        if (entry.getValue() instanceof List) {\n          if (key.equals(\"query\")) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Error when parsing json query, value of query field should not be a list, found : \" + entry.getValue());\n          }\n          List l = (List) entry.getValue();\n          for (Object subVal : l) {\n            builder.append(key).append(\"=\");\n            buildLocalParams(builder, subVal, true, additionalParams);\n            builder.append(\" \");\n          }\n        } else {\n          if (key.equals(\"query\")) {\n            key = \"v\";\n          }\n          builder.append(key).append(\"=\");\n          buildLocalParams(builder, entry.getValue(), true, additionalParams);\n          builder.append(\" \");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void buildLocalParams(StringBuilder builder, Object val, boolean isQParser, Map<String, String[]> additionalParams) {\n    if (!isQParser && !(val instanceof Map)) {\n      // val is value of a query parser, and it is not a map\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n    if (val instanceof String) {\n      builder.append('$').append(putParam(val.toString(), additionalParams));\n      return;\n    }\n    if (val instanceof Number) {\n      builder.append(val);\n      return;\n    }\n    if (!(val instanceof Map)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n\n    Map<String,Object> map = (Map<String, Object>) val;\n    if (isQParser) {\n      if (map.size() != 1) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Error when parsing json query, expect only one query parser here, but found : \"+map.keySet());\n      }\n\n      String qtype = map.keySet().iterator().next();\n      String tagName = null;\n      if (qtype.startsWith(\"#\")) {\n        Object taggedQueryObject = map.get(qtype);\n        tagName = qtype.substring(1);\n        if (taggedQueryObject instanceof String) {\n          builder.append(\"{!tag=\").append(tagName).append(\"}\");\n          builder.append(taggedQueryObject);\n          return;\n        } else if (taggedQueryObject instanceof Map) {\n          map = (Map<String, Object>) taggedQueryObject;\n          qtype = map.keySet().iterator().next();\n        }\n      }\n\n      // We don't want to introduce unnecessary variable at root level\n      boolean useSubBuilder = builder.length() > 0;\n      StringBuilder subBuilder = builder;\n\n      if (useSubBuilder) subBuilder = new StringBuilder();\n\n      Object subVal = map.get(qtype);\n      subBuilder = subBuilder.append(\"{!\").append(qtype).append(' ');\n      if (tagName != null) {\n        subBuilder.append(\"tag=\").append(tagName).append(' ');\n      }\n      buildLocalParams(subBuilder, subVal, false, additionalParams);\n      subBuilder.append(\"}\");\n\n      if (useSubBuilder) {\n        builder.append('$').append(putParam(subBuilder.toString(), additionalParams));\n      }\n    } else {\n      for (Map.Entry<String, Object> entry : map.entrySet()) {\n        String key = entry.getKey();\n        if (entry.getValue() instanceof List) {\n          if (key.equals(\"query\")) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Error when parsing json query, value of query field should not be a list, found : \" + entry.getValue());\n          }\n          List l = (List) entry.getValue();\n          for (Object subVal : l) {\n            builder.append(key).append(\"=\");\n            buildLocalParams(builder, subVal, true, additionalParams);\n            builder.append(\" \");\n          }\n        } else {\n          if (key.equals(\"query\")) {\n            key = \"v\";\n          }\n          builder.append(key).append(\"=\");\n          buildLocalParams(builder, entry.getValue(), true, additionalParams);\n          builder.append(\" \");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/json/JsonQueryConverter#buildLocalParams(StringBuilder,Object,boolean,Map[String,String[]]).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/JsonQueryConverter#buildLocalParams(StringBuilder,Object,boolean,Map[String,String[]]).mjava","sourceNew":"  // when isQParser==true, \"val\" is a query object of the form {query_type:{param1:val1, param2:val2}}\n  // when isQParser==false, \"val\" is a parameter on an existing qparser (which could be a simple parameter like 42, or a sub-query)\n  private void buildLocalParams(StringBuilder builder, Object val, boolean isQParser, Map<String, String[]> additionalParams) {\n    if (!isQParser && !(val instanceof Map)) {\n      // val is value of a query parser, and it is not a map\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n      // NOTE: a top-level query *can* be a String, so we should really allow it here.  This currently only works because\n      // we special-case String in toLocalParams() and don't call this method.\n    }\n    // We don't want to introduce unnecessary variable at root level\n    boolean useSubBuilder = builder.length() > 0;\n\n    if (val instanceof String) {\n      if (!useSubBuilder) {\n        // Top level, so just use the value.  NOTE: this case is also short-circuited in toLocalParams() for performance.\n        builder.append(val.toString());\n      } else {\n        // val is a parameter in a qparser, so use param deref and skip escaping: ...=$param1}&param1=<val>\n        builder.append('$').append(putParam(val.toString(), additionalParams));\n      }\n      return;\n    }\n    if (val instanceof Number) {\n      builder.append(val);\n      return;\n    }\n    if (!(val instanceof Map)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n\n    Map<String,Object> map = (Map<String, Object>) val;\n    if (isQParser) {\n      if (map.size() != 1) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Error when parsing json query, expect only one query parser here, but found : \"+map.keySet());\n      }\n\n      String qtype = map.keySet().iterator().next();\n      String tagName = null;\n      if (qtype.startsWith(\"#\")) {\n        Object taggedQueryObject = map.get(qtype);\n        tagName = qtype.substring(1);\n        if (taggedQueryObject instanceof String) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"{!tag=\").append(tagName).append(\"}\");\n          sb.append(taggedQueryObject.toString());\n          buildLocalParams(builder, sb.toString(), true, additionalParams);\n          return;\n        } else if (taggedQueryObject instanceof Map) {\n          map = (Map<String, Object>) taggedQueryObject;\n          qtype = map.keySet().iterator().next();\n          // FUTURE: might want to recurse here instead to handle nested tags (and add tagName as a parameter?)\n        }\n      }\n\n      StringBuilder subBuilder = useSubBuilder ? new StringBuilder() : builder;\n\n      Object subVal = map.get(qtype);\n      subBuilder = subBuilder.append(\"{!\").append(qtype).append(' ');\n      if (tagName != null) {\n        subBuilder.append(\"tag=\").append(tagName).append(' ');\n      }\n      buildLocalParams(subBuilder, subVal, false, additionalParams);\n      subBuilder.append(\"}\");\n\n      if (useSubBuilder) {\n        builder.append('$').append(putParam(subBuilder.toString(), additionalParams));\n      }\n    } else {\n      for (Map.Entry<String, Object> entry : map.entrySet()) {\n        String key = entry.getKey();\n        if (entry.getValue() instanceof List) {\n          if (key.equals(\"query\")) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Error when parsing json query, value of query field should not be a list, found : \" + entry.getValue());\n          }\n          List l = (List) entry.getValue();\n          for (Object subVal : l) {\n            builder.append(key).append(\"=\");\n            buildLocalParams(builder, subVal, true, additionalParams);\n            builder.append(\" \");\n          }\n        } else {\n          if (key.equals(\"query\")) {\n            key = \"v\";\n          }\n          builder.append(key).append(\"=\");\n          buildLocalParams(builder, entry.getValue(), true, additionalParams);\n          builder.append(\" \");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void buildLocalParams(StringBuilder builder, Object val, boolean isQParser, Map<String, String[]> additionalParams) {\n    if (!isQParser && !(val instanceof Map)) {\n      // val is value of a query parser, and it is not a map\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n    if (val instanceof String) {\n      builder.append('$').append(putParam(val.toString(), additionalParams));\n      return;\n    }\n    if (val instanceof Number) {\n      builder.append(val);\n      return;\n    }\n    if (!(val instanceof Map)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n\n    Map<String,Object> map = (Map<String, Object>) val;\n    if (isQParser) {\n      if (map.size() != 1) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Error when parsing json query, expect only one query parser here, but found : \"+map.keySet());\n      }\n\n      String qtype = map.keySet().iterator().next();\n      String tagName = null;\n      if (qtype.startsWith(\"#\")) {\n        Object taggedQueryObject = map.get(qtype);\n        tagName = qtype.substring(1);\n        if (taggedQueryObject instanceof String) {\n          builder.append(\"{!tag=\").append(tagName).append(\"}\");\n          builder.append(taggedQueryObject);\n          return;\n        } else if (taggedQueryObject instanceof Map) {\n          map = (Map<String, Object>) taggedQueryObject;\n          qtype = map.keySet().iterator().next();\n        }\n      }\n\n      // We don't want to introduce unnecessary variable at root level\n      boolean useSubBuilder = builder.length() > 0;\n      StringBuilder subBuilder = builder;\n\n      if (useSubBuilder) subBuilder = new StringBuilder();\n\n      Object subVal = map.get(qtype);\n      subBuilder = subBuilder.append(\"{!\").append(qtype).append(' ');\n      if (tagName != null) {\n        subBuilder.append(\"tag=\").append(tagName).append(' ');\n      }\n      buildLocalParams(subBuilder, subVal, false, additionalParams);\n      subBuilder.append(\"}\");\n\n      if (useSubBuilder) {\n        builder.append('$').append(putParam(subBuilder.toString(), additionalParams));\n      }\n    } else {\n      for (Map.Entry<String, Object> entry : map.entrySet()) {\n        String key = entry.getKey();\n        if (entry.getValue() instanceof List) {\n          if (key.equals(\"query\")) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Error when parsing json query, value of query field should not be a list, found : \" + entry.getValue());\n          }\n          List l = (List) entry.getValue();\n          for (Object subVal : l) {\n            builder.append(key).append(\"=\");\n            buildLocalParams(builder, subVal, true, additionalParams);\n            builder.append(\" \");\n          }\n        } else {\n          if (key.equals(\"query\")) {\n            key = \"v\";\n          }\n          builder.append(key).append(\"=\");\n          buildLocalParams(builder, entry.getValue(), true, additionalParams);\n          builder.append(\" \");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/json/JsonQueryConverter#buildLocalParams(StringBuilder,Object,boolean,Map[String,String[]]).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/JsonQueryConverter#buildLocalParams(StringBuilder,Object,boolean,Map[String,String[]]).mjava","sourceNew":"  // when isQParser==true, \"val\" is a query object of the form {query_type:{param1:val1, param2:val2}}\n  // when isQParser==false, \"val\" is a parameter on an existing qparser (which could be a simple parameter like 42, or a sub-query)\n  private void buildLocalParams(StringBuilder builder, Object val, boolean isQParser, Map<String, String[]> additionalParams) {\n    if (!isQParser && !(val instanceof Map)) {\n      // val is value of a query parser, and it is not a map\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n      // NOTE: a top-level query *can* be a String, so we should really allow it here.  This currently only works because\n      // we special-case String in toLocalParams() and don't call this method.\n    }\n    // We don't want to introduce unnecessary variable at root level\n    boolean useSubBuilder = builder.length() > 0;\n\n    if (val instanceof String) {\n      if (!useSubBuilder) {\n        // Top level, so just use the value.  NOTE: this case is also short-circuited in toLocalParams() for performance.\n        builder.append(val.toString());\n      } else {\n        // val is a parameter in a qparser, so use param deref and skip escaping: ...=$param1}&param1=<val>\n        builder.append('$').append(putParam(val.toString(), additionalParams));\n      }\n      return;\n    }\n    if (val instanceof Number) {\n      builder.append(val);\n      return;\n    }\n    if (!(val instanceof Map)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n\n    Map<String,Object> map = (Map<String, Object>) val;\n    if (isQParser) {\n      if (map.size() != 1) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Error when parsing json query, expect only one query parser here, but found : \"+map.keySet());\n      }\n\n      String qtype = map.keySet().iterator().next();\n      String tagName = null;\n      if (qtype.startsWith(\"#\")) {\n        Object taggedQueryObject = map.get(qtype);\n        tagName = qtype.substring(1);\n        if (taggedQueryObject instanceof String) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"{!tag=\").append(tagName).append(\"}\");\n          sb.append(taggedQueryObject.toString());\n          buildLocalParams(builder, sb.toString(), true, additionalParams);\n          return;\n        } else if (taggedQueryObject instanceof Map) {\n          map = (Map<String, Object>) taggedQueryObject;\n          qtype = map.keySet().iterator().next();\n          // FUTURE: might want to recurse here instead to handle nested tags (and add tagName as a parameter?)\n        }\n      }\n\n      StringBuilder subBuilder = useSubBuilder ? new StringBuilder() : builder;\n\n      Object subVal = map.get(qtype);\n      subBuilder = subBuilder.append(\"{!\").append(qtype).append(' ');\n      if (tagName != null) {\n        subBuilder.append(\"tag=\").append(tagName).append(' ');\n      }\n      buildLocalParams(subBuilder, subVal, false, additionalParams);\n      subBuilder.append(\"}\");\n\n      if (useSubBuilder) {\n        builder.append('$').append(putParam(subBuilder.toString(), additionalParams));\n      }\n    } else {\n      for (Map.Entry<String, Object> entry : map.entrySet()) {\n        String key = entry.getKey();\n        if (entry.getValue() instanceof List) {\n          if (key.equals(\"query\")) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Error when parsing json query, value of query field should not be a list, found : \" + entry.getValue());\n          }\n          List l = (List) entry.getValue();\n          for (Object subVal : l) {\n            builder.append(key).append(\"=\");\n            buildLocalParams(builder, subVal, true, additionalParams);\n            builder.append(\" \");\n          }\n        } else {\n          if (key.equals(\"query\")) {\n            key = \"v\";\n          }\n          builder.append(key).append(\"=\");\n          buildLocalParams(builder, entry.getValue(), true, additionalParams);\n          builder.append(\" \");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void buildLocalParams(StringBuilder builder, Object val, boolean isQParser, Map<String, String[]> additionalParams) {\n    if (!isQParser && !(val instanceof Map)) {\n      // val is value of a query parser, and it is not a map\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n    if (val instanceof String) {\n      builder.append('$').append(putParam(val.toString(), additionalParams));\n      return;\n    }\n    if (val instanceof Number) {\n      builder.append(val);\n      return;\n    }\n    if (!(val instanceof Map)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n\n    Map<String,Object> map = (Map<String, Object>) val;\n    if (isQParser) {\n      if (map.size() != 1) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Error when parsing json query, expect only one query parser here, but found : \"+map.keySet());\n      }\n\n      String qtype = map.keySet().iterator().next();\n      String tagName = null;\n      if (qtype.startsWith(\"#\")) {\n        Object taggedQueryObject = map.get(qtype);\n        tagName = qtype.substring(1);\n        if (taggedQueryObject instanceof String) {\n          builder.append(\"{!tag=\").append(tagName).append(\"}\");\n          builder.append(taggedQueryObject);\n          return;\n        } else if (taggedQueryObject instanceof Map) {\n          map = (Map<String, Object>) taggedQueryObject;\n          qtype = map.keySet().iterator().next();\n        }\n      }\n\n      // We don't want to introduce unnecessary variable at root level\n      boolean useSubBuilder = builder.length() > 0;\n      StringBuilder subBuilder = builder;\n\n      if (useSubBuilder) subBuilder = new StringBuilder();\n\n      Object subVal = map.get(qtype);\n      subBuilder = subBuilder.append(\"{!\").append(qtype).append(' ');\n      if (tagName != null) {\n        subBuilder.append(\"tag=\").append(tagName).append(' ');\n      }\n      buildLocalParams(subBuilder, subVal, false, additionalParams);\n      subBuilder.append(\"}\");\n\n      if (useSubBuilder) {\n        builder.append('$').append(putParam(subBuilder.toString(), additionalParams));\n      }\n    } else {\n      for (Map.Entry<String, Object> entry : map.entrySet()) {\n        String key = entry.getKey();\n        if (entry.getValue() instanceof List) {\n          if (key.equals(\"query\")) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Error when parsing json query, value of query field should not be a list, found : \" + entry.getValue());\n          }\n          List l = (List) entry.getValue();\n          for (Object subVal : l) {\n            builder.append(key).append(\"=\");\n            buildLocalParams(builder, subVal, true, additionalParams);\n            builder.append(\" \");\n          }\n        } else {\n          if (key.equals(\"query\")) {\n            key = \"v\";\n          }\n          builder.append(key).append(\"=\");\n          buildLocalParams(builder, entry.getValue(), true, additionalParams);\n          builder.append(\" \");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1900ff20b0f8f377a2de0af89d5dff96418ad3ff","date":1590699113,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/json/JsonQueryConverter#buildLocalParams(StringBuilder,Object,boolean,Map[String,String[]]).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/JsonQueryConverter#buildLocalParams(StringBuilder,Object,boolean,Map[String,String[]]).mjava","sourceNew":"  // when isQParser==true, \"val\" is a query object of the form {query_type:{param1:val1, param2:val2}}\n  // when isQParser==false, \"val\" is a parameter on an existing qparser (which could be a simple parameter like 42, or a sub-query)\n  private void buildLocalParams(StringBuilder builder, Object val, boolean isQParser, Map<String, String[]> additionalParams) {\n    if (!isQParser && !(val instanceof Map)) {\n      // val is value of a query parser, and it is not a map\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n      // NOTE: a top-level query *can* be a String, so we should really allow it here.  This currently only works because\n      // we special-case String in toLocalParams() and don't call this method.\n    }\n    // We don't want to introduce unnecessary variable at root level\n    boolean useSubBuilder = builder.length() > 0;\n\n    if (val instanceof String) {\n      if (!useSubBuilder) {\n        // Top level, so just use the value.  NOTE: this case is also short-circuited in toLocalParams() for performance.\n        builder.append(val.toString());\n      } else {\n        // val is a parameter in a qparser, so use param deref and skip escaping: ...=$param1}&param1=<val>\n        builder.append('$').append(putParam(val.toString(), additionalParams));\n      }\n      return;\n    }\n    if (val instanceof Number) {\n      builder.append(val);\n      return;\n    }\n    if (!(val instanceof Map)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n\n    Map<String,Object> map = (Map<String, Object>) val;\n    if (isQParser) {\n      if (map.size() != 1) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Error when parsing json query, expect only one query parser here, but found : \"+map.keySet());\n      }\n\n      String qtype = map.keySet().iterator().next();\n      String tagName = null;\n      if (qtype.startsWith(\"#\")) {\n        Object taggedQueryObject = map.get(qtype);\n        tagName = qtype.substring(1);\n        if (taggedQueryObject instanceof String) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"{!tag=\").append(tagName).append(\"}\");\n          sb.append(taggedQueryObject.toString());\n          buildLocalParams(builder, sb.toString(), true, additionalParams);\n          return;\n        } else if (taggedQueryObject instanceof Map) {\n          map = (Map<String, Object>) taggedQueryObject;\n          qtype = map.keySet().iterator().next();\n          // FUTURE: might want to recurse here instead to handle nested tags (and add tagName as a parameter?)\n        }\n      } else {\n        if (qtype.equals(\"param\")) {\n          boolean toplevel;\n          if (toplevel=(builder.length() == 0)) {\n            builder.append(\"{!v=\");  \n          }\n          builder.append(\"$\").append(map.get(\"param\"));\n          if (toplevel) {\n            builder.append(\"}\");\n          }\n          return;\n        }\n      }\n\n      StringBuilder subBuilder = useSubBuilder ? new StringBuilder() : builder;\n\n      Object subVal = map.get(qtype);\n      subBuilder = subBuilder.append(\"{!\").append(qtype).append(' ');\n      if (tagName != null) {\n        subBuilder.append(\"tag=\").append(tagName).append(' ');\n      }\n      buildLocalParams(subBuilder, subVal, false, additionalParams);\n      subBuilder.append(\"}\");\n\n      if (useSubBuilder) {\n        builder.append('$').append(putParam(subBuilder.toString(), additionalParams));\n      }\n    } else {\n      if(map.size()==1 && map.keySet().iterator().next().equals(\"param\")) {\n        builder.append(\"v\").append(\"=$\").append(map.get(\"param\")).append(\" \");\n      } else {\n        for (Map.Entry<String, Object> entry : map.entrySet()) {\n          String key = entry.getKey();\n          if (entry.getValue() instanceof List) {\n            if (key.equals(\"query\")) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                  \"Error when parsing json query, value of query field should not be a list, found : \" + entry.getValue());\n            }\n            List l = (List) entry.getValue();\n            for (Object subVal : l) {\n              builder.append(key).append(\"=\");\n              buildLocalParams(builder, subVal, true, additionalParams);\n              builder.append(\" \");\n            }\n          } else {\n            if (key.equals(\"query\")) {\n              key = \"v\";\n            }\n            builder.append(key).append(\"=\");\n            buildLocalParams(builder, entry.getValue(), true, additionalParams);\n            builder.append(\" \");\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // when isQParser==true, \"val\" is a query object of the form {query_type:{param1:val1, param2:val2}}\n  // when isQParser==false, \"val\" is a parameter on an existing qparser (which could be a simple parameter like 42, or a sub-query)\n  private void buildLocalParams(StringBuilder builder, Object val, boolean isQParser, Map<String, String[]> additionalParams) {\n    if (!isQParser && !(val instanceof Map)) {\n      // val is value of a query parser, and it is not a map\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n      // NOTE: a top-level query *can* be a String, so we should really allow it here.  This currently only works because\n      // we special-case String in toLocalParams() and don't call this method.\n    }\n    // We don't want to introduce unnecessary variable at root level\n    boolean useSubBuilder = builder.length() > 0;\n\n    if (val instanceof String) {\n      if (!useSubBuilder) {\n        // Top level, so just use the value.  NOTE: this case is also short-circuited in toLocalParams() for performance.\n        builder.append(val.toString());\n      } else {\n        // val is a parameter in a qparser, so use param deref and skip escaping: ...=$param1}&param1=<val>\n        builder.append('$').append(putParam(val.toString(), additionalParams));\n      }\n      return;\n    }\n    if (val instanceof Number) {\n      builder.append(val);\n      return;\n    }\n    if (!(val instanceof Map)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n\n    Map<String,Object> map = (Map<String, Object>) val;\n    if (isQParser) {\n      if (map.size() != 1) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Error when parsing json query, expect only one query parser here, but found : \"+map.keySet());\n      }\n\n      String qtype = map.keySet().iterator().next();\n      String tagName = null;\n      if (qtype.startsWith(\"#\")) {\n        Object taggedQueryObject = map.get(qtype);\n        tagName = qtype.substring(1);\n        if (taggedQueryObject instanceof String) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"{!tag=\").append(tagName).append(\"}\");\n          sb.append(taggedQueryObject.toString());\n          buildLocalParams(builder, sb.toString(), true, additionalParams);\n          return;\n        } else if (taggedQueryObject instanceof Map) {\n          map = (Map<String, Object>) taggedQueryObject;\n          qtype = map.keySet().iterator().next();\n          // FUTURE: might want to recurse here instead to handle nested tags (and add tagName as a parameter?)\n        }\n      }\n\n      StringBuilder subBuilder = useSubBuilder ? new StringBuilder() : builder;\n\n      Object subVal = map.get(qtype);\n      subBuilder = subBuilder.append(\"{!\").append(qtype).append(' ');\n      if (tagName != null) {\n        subBuilder.append(\"tag=\").append(tagName).append(' ');\n      }\n      buildLocalParams(subBuilder, subVal, false, additionalParams);\n      subBuilder.append(\"}\");\n\n      if (useSubBuilder) {\n        builder.append('$').append(putParam(subBuilder.toString(), additionalParams));\n      }\n    } else {\n      for (Map.Entry<String, Object> entry : map.entrySet()) {\n        String key = entry.getKey();\n        if (entry.getValue() instanceof List) {\n          if (key.equals(\"query\")) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Error when parsing json query, value of query field should not be a list, found : \" + entry.getValue());\n          }\n          List l = (List) entry.getValue();\n          for (Object subVal : l) {\n            builder.append(key).append(\"=\");\n            buildLocalParams(builder, subVal, true, additionalParams);\n            builder.append(\" \");\n          }\n        } else {\n          if (key.equals(\"query\")) {\n            key = \"v\";\n          }\n          builder.append(key).append(\"=\");\n          buildLocalParams(builder, entry.getValue(), true, additionalParams);\n          builder.append(\" \");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd25fa3647fa73152703b8dccb4fb5f43633de20","date":1592060458,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/json/JsonQueryConverter#buildLocalParams(StringBuilder,Object,boolean,Map[String,String[]]).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/json/JsonQueryConverter#buildLocalParams(StringBuilder,Object,boolean,Map[String,String[]]).mjava","sourceNew":"  // when isQParser==true, \"val\" is a query object of the form {query_type:{param1:val1, param2:val2}}\n  // when isQParser==false, \"val\" is a parameter on an existing qparser (which could be a simple parameter like 42, or a sub-query)\n  @SuppressWarnings({\"unchecked\"})\n  private void buildLocalParams(StringBuilder builder, Object val, boolean isQParser, Map<String, String[]> additionalParams) {\n    if (!isQParser && !(val instanceof Map)) {\n      // val is value of a query parser, and it is not a map\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n      // NOTE: a top-level query *can* be a String, so we should really allow it here.  This currently only works because\n      // we special-case String in toLocalParams() and don't call this method.\n    }\n    // We don't want to introduce unnecessary variable at root level\n    boolean useSubBuilder = builder.length() > 0;\n\n    if (val instanceof String) {\n      if (!useSubBuilder) {\n        // Top level, so just use the value.  NOTE: this case is also short-circuited in toLocalParams() for performance.\n        builder.append(val.toString());\n      } else {\n        // val is a parameter in a qparser, so use param deref and skip escaping: ...=$param1}&param1=<val>\n        builder.append('$').append(putParam(val.toString(), additionalParams));\n      }\n      return;\n    }\n    if (val instanceof Number) {\n      builder.append(val);\n      return;\n    }\n    if (!(val instanceof Map)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n\n    Map<String,Object> map = (Map<String, Object>) val;\n    if (isQParser) {\n      if (map.size() != 1) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Error when parsing json query, expect only one query parser here, but found : \"+map.keySet());\n      }\n\n      String qtype = map.keySet().iterator().next();\n      String tagName = null;\n      if (qtype.startsWith(\"#\")) {\n        Object taggedQueryObject = map.get(qtype);\n        tagName = qtype.substring(1);\n        if (taggedQueryObject instanceof String) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"{!tag=\").append(tagName).append(\"}\");\n          sb.append(taggedQueryObject.toString());\n          buildLocalParams(builder, sb.toString(), true, additionalParams);\n          return;\n        } else if (taggedQueryObject instanceof Map) {\n          map = (Map<String, Object>) taggedQueryObject;\n          qtype = map.keySet().iterator().next();\n          // FUTURE: might want to recurse here instead to handle nested tags (and add tagName as a parameter?)\n        }\n      } else {\n        if (qtype.equals(\"param\")) {\n          boolean toplevel;\n          if (toplevel=(builder.length() == 0)) {\n            builder.append(\"{!v=\");  \n          }\n          builder.append(\"$\").append(map.get(\"param\"));\n          if (toplevel) {\n            builder.append(\"}\");\n          }\n          return;\n        }\n      }\n\n      StringBuilder subBuilder = useSubBuilder ? new StringBuilder() : builder;\n\n      Object subVal = map.get(qtype);\n      subBuilder = subBuilder.append(\"{!\").append(qtype).append(' ');\n      if (tagName != null) {\n        subBuilder.append(\"tag=\").append(tagName).append(' ');\n      }\n      buildLocalParams(subBuilder, subVal, false, additionalParams);\n      subBuilder.append(\"}\");\n\n      if (useSubBuilder) {\n        builder.append('$').append(putParam(subBuilder.toString(), additionalParams));\n      }\n    } else {\n      if(map.size()==1 && map.keySet().iterator().next().equals(\"param\")) {\n        builder.append(\"v\").append(\"=$\").append(map.get(\"param\")).append(\" \");\n      } else {\n        for (Map.Entry<String, Object> entry : map.entrySet()) {\n          String key = entry.getKey();\n          if (entry.getValue() instanceof List) {\n            if (key.equals(\"query\")) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                  \"Error when parsing json query, value of query field should not be a list, found : \" + entry.getValue());\n            }\n            @SuppressWarnings({\"rawtypes\"})\n            List l = (List) entry.getValue();\n            for (Object subVal : l) {\n              builder.append(key).append(\"=\");\n              buildLocalParams(builder, subVal, true, additionalParams);\n              builder.append(\" \");\n            }\n          } else {\n            if (key.equals(\"query\")) {\n              key = \"v\";\n            }\n            builder.append(key).append(\"=\");\n            buildLocalParams(builder, entry.getValue(), true, additionalParams);\n            builder.append(\" \");\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // when isQParser==true, \"val\" is a query object of the form {query_type:{param1:val1, param2:val2}}\n  // when isQParser==false, \"val\" is a parameter on an existing qparser (which could be a simple parameter like 42, or a sub-query)\n  private void buildLocalParams(StringBuilder builder, Object val, boolean isQParser, Map<String, String[]> additionalParams) {\n    if (!isQParser && !(val instanceof Map)) {\n      // val is value of a query parser, and it is not a map\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n      // NOTE: a top-level query *can* be a String, so we should really allow it here.  This currently only works because\n      // we special-case String in toLocalParams() and don't call this method.\n    }\n    // We don't want to introduce unnecessary variable at root level\n    boolean useSubBuilder = builder.length() > 0;\n\n    if (val instanceof String) {\n      if (!useSubBuilder) {\n        // Top level, so just use the value.  NOTE: this case is also short-circuited in toLocalParams() for performance.\n        builder.append(val.toString());\n      } else {\n        // val is a parameter in a qparser, so use param deref and skip escaping: ...=$param1}&param1=<val>\n        builder.append('$').append(putParam(val.toString(), additionalParams));\n      }\n      return;\n    }\n    if (val instanceof Number) {\n      builder.append(val);\n      return;\n    }\n    if (!(val instanceof Map)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error when parsing json query, expect a json object here, but found : \"+val);\n    }\n\n    Map<String,Object> map = (Map<String, Object>) val;\n    if (isQParser) {\n      if (map.size() != 1) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            \"Error when parsing json query, expect only one query parser here, but found : \"+map.keySet());\n      }\n\n      String qtype = map.keySet().iterator().next();\n      String tagName = null;\n      if (qtype.startsWith(\"#\")) {\n        Object taggedQueryObject = map.get(qtype);\n        tagName = qtype.substring(1);\n        if (taggedQueryObject instanceof String) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"{!tag=\").append(tagName).append(\"}\");\n          sb.append(taggedQueryObject.toString());\n          buildLocalParams(builder, sb.toString(), true, additionalParams);\n          return;\n        } else if (taggedQueryObject instanceof Map) {\n          map = (Map<String, Object>) taggedQueryObject;\n          qtype = map.keySet().iterator().next();\n          // FUTURE: might want to recurse here instead to handle nested tags (and add tagName as a parameter?)\n        }\n      } else {\n        if (qtype.equals(\"param\")) {\n          boolean toplevel;\n          if (toplevel=(builder.length() == 0)) {\n            builder.append(\"{!v=\");  \n          }\n          builder.append(\"$\").append(map.get(\"param\"));\n          if (toplevel) {\n            builder.append(\"}\");\n          }\n          return;\n        }\n      }\n\n      StringBuilder subBuilder = useSubBuilder ? new StringBuilder() : builder;\n\n      Object subVal = map.get(qtype);\n      subBuilder = subBuilder.append(\"{!\").append(qtype).append(' ');\n      if (tagName != null) {\n        subBuilder.append(\"tag=\").append(tagName).append(' ');\n      }\n      buildLocalParams(subBuilder, subVal, false, additionalParams);\n      subBuilder.append(\"}\");\n\n      if (useSubBuilder) {\n        builder.append('$').append(putParam(subBuilder.toString(), additionalParams));\n      }\n    } else {\n      if(map.size()==1 && map.keySet().iterator().next().equals(\"param\")) {\n        builder.append(\"v\").append(\"=$\").append(map.get(\"param\")).append(\" \");\n      } else {\n        for (Map.Entry<String, Object> entry : map.entrySet()) {\n          String key = entry.getKey();\n          if (entry.getValue() instanceof List) {\n            if (key.equals(\"query\")) {\n              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                  \"Error when parsing json query, value of query field should not be a list, found : \" + entry.getValue());\n            }\n            List l = (List) entry.getValue();\n            for (Object subVal : l) {\n              builder.append(key).append(\"=\");\n              buildLocalParams(builder, subVal, true, additionalParams);\n              builder.append(\" \");\n            }\n          } else {\n            if (key.equals(\"query\")) {\n              key = \"v\";\n            }\n            builder.append(key).append(\"=\");\n            buildLocalParams(builder, entry.getValue(), true, additionalParams);\n            builder.append(\" \");\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b21283ed01203901a7257aa4b7f0a0899c86e56e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","10eda272dbca4b0397f9b0c2aa6fadad3601db47"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["ddce5ba13e43e3b34a1772ed921d9b9d7a67e48d","ff95b5e47fe4df3d066c51f0a3f8970e8fbb2aa4"],"ddce5ba13e43e3b34a1772ed921d9b9d7a67e48d":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b21283ed01203901a7257aa4b7f0a0899c86e56e"],"10eda272dbca4b0397f9b0c2aa6fadad3601db47":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","10eda272dbca4b0397f9b0c2aa6fadad3601db47"],"ff95b5e47fe4df3d066c51f0a3f8970e8fbb2aa4":["ddce5ba13e43e3b34a1772ed921d9b9d7a67e48d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["1900ff20b0f8f377a2de0af89d5dff96418ad3ff"],"1900ff20b0f8f377a2de0af89d5dff96418ad3ff":["ff95b5e47fe4df3d066c51f0a3f8970e8fbb2aa4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bd25fa3647fa73152703b8dccb4fb5f43633de20"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["ddce5ba13e43e3b34a1772ed921d9b9d7a67e48d","ff95b5e47fe4df3d066c51f0a3f8970e8fbb2aa4"]},"commit2Childs":{"b21283ed01203901a7257aa4b7f0a0899c86e56e":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"10eda272dbca4b0397f9b0c2aa6fadad3601db47":["b21283ed01203901a7257aa4b7f0a0899c86e56e","3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"ddce5ba13e43e3b34a1772ed921d9b9d7a67e48d":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","ff95b5e47fe4df3d066c51f0a3f8970e8fbb2aa4","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["ddce5ba13e43e3b34a1772ed921d9b9d7a67e48d"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":[],"ff95b5e47fe4df3d066c51f0a3f8970e8fbb2aa4":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","1900ff20b0f8f377a2de0af89d5dff96418ad3ff","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b21283ed01203901a7257aa4b7f0a0899c86e56e","104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","10eda272dbca4b0397f9b0c2aa6fadad3601db47","3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1900ff20b0f8f377a2de0af89d5dff96418ad3ff":["bd25fa3647fa73152703b8dccb4fb5f43633de20"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","3a7809d1d753b67f48b1a706e17034bf8b624ea3","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}