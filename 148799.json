{"path":"lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier#train(LeafReader,String,String,Analyzer,Query).mjava","commits":[{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":0,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier#train(LeafReader,String,String,Analyzer,Query).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void train(LeafReader leafReader, String textFieldName,\n      String classFieldName, Analyzer analyzer, Query query) throws IOException {\n    this.textTerms = MultiFields.getTerms(leafReader, textFieldName);\n\n    if (textTerms == null) {\n      throw new IOException(\"term vectors need to be available for field \" + textFieldName);\n    }\n\n    this.analyzer = analyzer;\n    this.textFieldName = textFieldName;\n\n    if (threshold == null || threshold == 0d) {\n      // automatic assign a threshold\n      long sumDocFreq = leafReader.getSumDocFreq(textFieldName);\n      if (sumDocFreq != -1) {\n        this.threshold = (double) sumDocFreq / 2d;\n      } else {\n        throw new IOException(\n            \"threshold cannot be assigned since term vectors for field \"\n                + textFieldName + \" do not exist\");\n      }\n    }\n\n    // TODO : remove this map as soon as we have a writable FST\n    SortedMap<String,Double> weights = new TreeMap<>();\n\n    TermsEnum reuse = textTerms.iterator(null);\n    BytesRef textTerm;\n    while ((textTerm = reuse.next()) != null) {\n      weights.put(textTerm.utf8ToString(), (double) reuse.totalTermFreq());\n    }\n    updateFST(weights);\n\n    IndexSearcher indexSearcher = new IndexSearcher(leafReader);\n\n    int batchCount = 0;\n\n    BooleanQuery q = new BooleanQuery();\n    q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, \"*\")), BooleanClause.Occur.MUST));\n    if (query != null) {\n      q.add(new BooleanClause(query, BooleanClause.Occur.MUST));\n    }\n    // run the search and use stored field values\n    for (ScoreDoc scoreDoc : indexSearcher.search(q,\n        Integer.MAX_VALUE).scoreDocs) {\n      StoredDocument doc = indexSearcher.doc(scoreDoc.doc);\n\n      // assign class to the doc\n      ClassificationResult<Boolean> classificationResult = assignClass(doc\n          .getField(textFieldName).stringValue());\n      Boolean assignedClass = classificationResult.getAssignedClass();\n      \n      // get the expected result\n      StorableField field = doc.getField(classFieldName);\n      \n      Boolean correctClass = Boolean.valueOf(field.stringValue());\n      long modifier = correctClass.compareTo(assignedClass);\n      if (modifier != 0) {\n        reuse = updateWeights(leafReader, reuse, scoreDoc.doc, assignedClass,\n            weights, modifier, batchCount % batchSize == 0);\n      }\n      batchCount++;\n    }\n    weights.clear(); // free memory while waiting for GC\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["97c4023912a7db66594166f4f93c9f73c154844c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e7e9c8ade373b2cc85c2a51c4f5961bb0695cc44","date":1415781486,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier#train(LeafReader,String,String,Analyzer,Query).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier#train(LeafReader,String,String,Analyzer,Query).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void train(LeafReader leafReader, String textFieldName,\n                    String classFieldName, Analyzer analyzer, Query query) throws IOException {\n    this.textTerms = MultiFields.getTerms(leafReader, textFieldName);\n\n    if (textTerms == null) {\n      throw new IOException(\"term vectors need to be available for field \" + textFieldName);\n    }\n\n    this.analyzer = analyzer;\n    this.textFieldName = textFieldName;\n\n    if (threshold == null || threshold == 0d) {\n      // automatic assign a threshold\n      long sumDocFreq = leafReader.getSumDocFreq(textFieldName);\n      if (sumDocFreq != -1) {\n        this.threshold = (double) sumDocFreq / 2d;\n      } else {\n        throw new IOException(\n            \"threshold cannot be assigned since term vectors for field \"\n                + textFieldName + \" do not exist\");\n      }\n    }\n\n    // TODO : remove this map as soon as we have a writable FST\n    SortedMap<String, Double> weights = new ConcurrentSkipListMap<>();\n\n    TermsEnum reuse = textTerms.iterator(null);\n    BytesRef textTerm;\n    while ((textTerm = reuse.next()) != null) {\n      weights.put(textTerm.utf8ToString(), (double) reuse.totalTermFreq());\n    }\n    updateFST(weights);\n\n    IndexSearcher indexSearcher = new IndexSearcher(leafReader);\n\n    int batchCount = 0;\n\n    BooleanQuery q = new BooleanQuery();\n    q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, \"*\")), BooleanClause.Occur.MUST));\n    if (query != null) {\n      q.add(new BooleanClause(query, BooleanClause.Occur.MUST));\n    }\n    // run the search and use stored field values\n    for (ScoreDoc scoreDoc : indexSearcher.search(q,\n        Integer.MAX_VALUE).scoreDocs) {\n      StoredDocument doc = indexSearcher.doc(scoreDoc.doc);\n\n      // assign class to the doc\n      ClassificationResult<Boolean> classificationResult = assignClass(doc\n          .getField(textFieldName).stringValue());\n      Boolean assignedClass = classificationResult.getAssignedClass();\n\n      // get the expected result\n      StorableField field = doc.getField(classFieldName);\n\n      Boolean correctClass = Boolean.valueOf(field.stringValue());\n      long modifier = correctClass.compareTo(assignedClass);\n      if (modifier != 0) {\n        reuse = updateWeights(leafReader, reuse, scoreDoc.doc, assignedClass,\n            weights, modifier, batchCount % batchSize == 0);\n      }\n      batchCount++;\n    }\n    weights.clear(); // free memory while waiting for GC\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void train(LeafReader leafReader, String textFieldName,\n      String classFieldName, Analyzer analyzer, Query query) throws IOException {\n    this.textTerms = MultiFields.getTerms(leafReader, textFieldName);\n\n    if (textTerms == null) {\n      throw new IOException(\"term vectors need to be available for field \" + textFieldName);\n    }\n\n    this.analyzer = analyzer;\n    this.textFieldName = textFieldName;\n\n    if (threshold == null || threshold == 0d) {\n      // automatic assign a threshold\n      long sumDocFreq = leafReader.getSumDocFreq(textFieldName);\n      if (sumDocFreq != -1) {\n        this.threshold = (double) sumDocFreq / 2d;\n      } else {\n        throw new IOException(\n            \"threshold cannot be assigned since term vectors for field \"\n                + textFieldName + \" do not exist\");\n      }\n    }\n\n    // TODO : remove this map as soon as we have a writable FST\n    SortedMap<String,Double> weights = new TreeMap<>();\n\n    TermsEnum reuse = textTerms.iterator(null);\n    BytesRef textTerm;\n    while ((textTerm = reuse.next()) != null) {\n      weights.put(textTerm.utf8ToString(), (double) reuse.totalTermFreq());\n    }\n    updateFST(weights);\n\n    IndexSearcher indexSearcher = new IndexSearcher(leafReader);\n\n    int batchCount = 0;\n\n    BooleanQuery q = new BooleanQuery();\n    q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, \"*\")), BooleanClause.Occur.MUST));\n    if (query != null) {\n      q.add(new BooleanClause(query, BooleanClause.Occur.MUST));\n    }\n    // run the search and use stored field values\n    for (ScoreDoc scoreDoc : indexSearcher.search(q,\n        Integer.MAX_VALUE).scoreDocs) {\n      StoredDocument doc = indexSearcher.doc(scoreDoc.doc);\n\n      // assign class to the doc\n      ClassificationResult<Boolean> classificationResult = assignClass(doc\n          .getField(textFieldName).stringValue());\n      Boolean assignedClass = classificationResult.getAssignedClass();\n      \n      // get the expected result\n      StorableField field = doc.getField(classFieldName);\n      \n      Boolean correctClass = Boolean.valueOf(field.stringValue());\n      long modifier = correctClass.compareTo(assignedClass);\n      if (modifier != 0) {\n        reuse = updateWeights(leafReader, reuse, scoreDoc.doc, assignedClass,\n            weights, modifier, batchCount % batchSize == 0);\n      }\n      batchCount++;\n    }\n    weights.clear(); // free memory while waiting for GC\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","date":1428522487,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier#train(LeafReader,String,String,Analyzer,Query).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier#train(LeafReader,String,String,Analyzer,Query).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void train(LeafReader leafReader, String textFieldName,\n                    String classFieldName, Analyzer analyzer, Query query) throws IOException {\n    this.textTerms = MultiFields.getTerms(leafReader, textFieldName);\n\n    if (textTerms == null) {\n      throw new IOException(\"term vectors need to be available for field \" + textFieldName);\n    }\n\n    this.analyzer = analyzer;\n    this.textFieldName = textFieldName;\n\n    if (threshold == null || threshold == 0d) {\n      // automatic assign a threshold\n      long sumDocFreq = leafReader.getSumDocFreq(textFieldName);\n      if (sumDocFreq != -1) {\n        this.threshold = (double) sumDocFreq / 2d;\n      } else {\n        throw new IOException(\n            \"threshold cannot be assigned since term vectors for field \"\n                + textFieldName + \" do not exist\");\n      }\n    }\n\n    // TODO : remove this map as soon as we have a writable FST\n    SortedMap<String, Double> weights = new ConcurrentSkipListMap<>();\n\n    TermsEnum termsEnum = textTerms.iterator();\n    BytesRef textTerm;\n    while ((textTerm = termsEnum.next()) != null) {\n      weights.put(textTerm.utf8ToString(), (double) termsEnum.totalTermFreq());\n    }\n    updateFST(weights);\n\n    IndexSearcher indexSearcher = new IndexSearcher(leafReader);\n\n    int batchCount = 0;\n\n    BooleanQuery q = new BooleanQuery();\n    q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, \"*\")), BooleanClause.Occur.MUST));\n    if (query != null) {\n      q.add(new BooleanClause(query, BooleanClause.Occur.MUST));\n    }\n    // run the search and use stored field values\n    for (ScoreDoc scoreDoc : indexSearcher.search(q,\n        Integer.MAX_VALUE).scoreDocs) {\n      StoredDocument doc = indexSearcher.doc(scoreDoc.doc);\n\n      // assign class to the doc\n      ClassificationResult<Boolean> classificationResult = assignClass(doc\n          .getField(textFieldName).stringValue());\n      Boolean assignedClass = classificationResult.getAssignedClass();\n\n      // get the expected result\n      StorableField field = doc.getField(classFieldName);\n\n      Boolean correctClass = Boolean.valueOf(field.stringValue());\n      long modifier = correctClass.compareTo(assignedClass);\n      if (modifier != 0) {\n        updateWeights(leafReader, scoreDoc.doc, assignedClass,\n            weights, modifier, batchCount % batchSize == 0);\n      }\n      batchCount++;\n    }\n    weights.clear(); // free memory while waiting for GC\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void train(LeafReader leafReader, String textFieldName,\n                    String classFieldName, Analyzer analyzer, Query query) throws IOException {\n    this.textTerms = MultiFields.getTerms(leafReader, textFieldName);\n\n    if (textTerms == null) {\n      throw new IOException(\"term vectors need to be available for field \" + textFieldName);\n    }\n\n    this.analyzer = analyzer;\n    this.textFieldName = textFieldName;\n\n    if (threshold == null || threshold == 0d) {\n      // automatic assign a threshold\n      long sumDocFreq = leafReader.getSumDocFreq(textFieldName);\n      if (sumDocFreq != -1) {\n        this.threshold = (double) sumDocFreq / 2d;\n      } else {\n        throw new IOException(\n            \"threshold cannot be assigned since term vectors for field \"\n                + textFieldName + \" do not exist\");\n      }\n    }\n\n    // TODO : remove this map as soon as we have a writable FST\n    SortedMap<String, Double> weights = new ConcurrentSkipListMap<>();\n\n    TermsEnum reuse = textTerms.iterator(null);\n    BytesRef textTerm;\n    while ((textTerm = reuse.next()) != null) {\n      weights.put(textTerm.utf8ToString(), (double) reuse.totalTermFreq());\n    }\n    updateFST(weights);\n\n    IndexSearcher indexSearcher = new IndexSearcher(leafReader);\n\n    int batchCount = 0;\n\n    BooleanQuery q = new BooleanQuery();\n    q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, \"*\")), BooleanClause.Occur.MUST));\n    if (query != null) {\n      q.add(new BooleanClause(query, BooleanClause.Occur.MUST));\n    }\n    // run the search and use stored field values\n    for (ScoreDoc scoreDoc : indexSearcher.search(q,\n        Integer.MAX_VALUE).scoreDocs) {\n      StoredDocument doc = indexSearcher.doc(scoreDoc.doc);\n\n      // assign class to the doc\n      ClassificationResult<Boolean> classificationResult = assignClass(doc\n          .getField(textFieldName).stringValue());\n      Boolean assignedClass = classificationResult.getAssignedClass();\n\n      // get the expected result\n      StorableField field = doc.getField(classFieldName);\n\n      Boolean correctClass = Boolean.valueOf(field.stringValue());\n      long modifier = correctClass.compareTo(assignedClass);\n      if (modifier != 0) {\n        reuse = updateWeights(leafReader, reuse, scoreDoc.doc, assignedClass,\n            weights, modifier, batchCount % batchSize == 0);\n      }\n      batchCount++;\n    }\n    weights.clear(); // free memory while waiting for GC\n  }\n\n","bugFix":null,"bugIntro":["97c4023912a7db66594166f4f93c9f73c154844c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"97c4023912a7db66594166f4f93c9f73c154844c","date":1429278377,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier#train(LeafReader,String,String,Analyzer,Query).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier#train(LeafReader,String,String,Analyzer,Query).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void train(LeafReader leafReader, String textFieldName,\n                    String classFieldName, Analyzer analyzer, Query query) throws IOException {\n    this.textTerms = MultiFields.getTerms(leafReader, textFieldName);\n\n    if (textTerms == null) {\n      throw new IOException(\"term vectors need to be available for field \" + textFieldName);\n    }\n\n    this.analyzer = analyzer;\n    this.textFieldName = textFieldName;\n\n    if (threshold == null || threshold == 0d) {\n      // automatic assign a threshold\n      long sumDocFreq = leafReader.getSumDocFreq(textFieldName);\n      if (sumDocFreq != -1) {\n        this.threshold = (double) sumDocFreq / 2d;\n      } else {\n        throw new IOException(\n            \"threshold cannot be assigned since term vectors for field \"\n                + textFieldName + \" do not exist\");\n      }\n    }\n\n    // TODO : remove this map as soon as we have a writable FST\n    SortedMap<String, Double> weights = new ConcurrentSkipListMap<>();\n\n    TermsEnum termsEnum = textTerms.iterator();\n    BytesRef textTerm;\n    while ((textTerm = termsEnum.next()) != null) {\n      weights.put(textTerm.utf8ToString(), (double) termsEnum.totalTermFreq());\n    }\n    updateFST(weights);\n\n    IndexSearcher indexSearcher = new IndexSearcher(leafReader);\n\n    int batchCount = 0;\n\n    BooleanQuery q = new BooleanQuery();\n    q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, \"*\")), BooleanClause.Occur.MUST));\n    if (query != null) {\n      q.add(new BooleanClause(query, BooleanClause.Occur.MUST));\n    }\n    // run the search and use stored field values\n    for (ScoreDoc scoreDoc : indexSearcher.search(q,\n        Integer.MAX_VALUE).scoreDocs) {\n      StoredDocument doc = indexSearcher.doc(scoreDoc.doc);\n\n      StorableField textField = doc.getField(textFieldName);\n\n      // get the expected result\n      StorableField classField = doc.getField(classFieldName);\n\n      if (textField != null && classField != null) {\n        // assign class to the doc\n        ClassificationResult<Boolean> classificationResult = assignClass(textField.stringValue());\n        Boolean assignedClass = classificationResult.getAssignedClass();\n\n        Boolean correctClass = Boolean.valueOf(classField.stringValue());\n        long modifier = correctClass.compareTo(assignedClass);\n        if (modifier != 0) {\n          updateWeights(leafReader, scoreDoc.doc, assignedClass,\n                weights, modifier, batchCount % batchSize == 0);\n        }\n        batchCount++;\n      }\n    }\n    weights.clear(); // free memory while waiting for GC\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void train(LeafReader leafReader, String textFieldName,\n                    String classFieldName, Analyzer analyzer, Query query) throws IOException {\n    this.textTerms = MultiFields.getTerms(leafReader, textFieldName);\n\n    if (textTerms == null) {\n      throw new IOException(\"term vectors need to be available for field \" + textFieldName);\n    }\n\n    this.analyzer = analyzer;\n    this.textFieldName = textFieldName;\n\n    if (threshold == null || threshold == 0d) {\n      // automatic assign a threshold\n      long sumDocFreq = leafReader.getSumDocFreq(textFieldName);\n      if (sumDocFreq != -1) {\n        this.threshold = (double) sumDocFreq / 2d;\n      } else {\n        throw new IOException(\n            \"threshold cannot be assigned since term vectors for field \"\n                + textFieldName + \" do not exist\");\n      }\n    }\n\n    // TODO : remove this map as soon as we have a writable FST\n    SortedMap<String, Double> weights = new ConcurrentSkipListMap<>();\n\n    TermsEnum termsEnum = textTerms.iterator();\n    BytesRef textTerm;\n    while ((textTerm = termsEnum.next()) != null) {\n      weights.put(textTerm.utf8ToString(), (double) termsEnum.totalTermFreq());\n    }\n    updateFST(weights);\n\n    IndexSearcher indexSearcher = new IndexSearcher(leafReader);\n\n    int batchCount = 0;\n\n    BooleanQuery q = new BooleanQuery();\n    q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, \"*\")), BooleanClause.Occur.MUST));\n    if (query != null) {\n      q.add(new BooleanClause(query, BooleanClause.Occur.MUST));\n    }\n    // run the search and use stored field values\n    for (ScoreDoc scoreDoc : indexSearcher.search(q,\n        Integer.MAX_VALUE).scoreDocs) {\n      StoredDocument doc = indexSearcher.doc(scoreDoc.doc);\n\n      // assign class to the doc\n      ClassificationResult<Boolean> classificationResult = assignClass(doc\n          .getField(textFieldName).stringValue());\n      Boolean assignedClass = classificationResult.getAssignedClass();\n\n      // get the expected result\n      StorableField field = doc.getField(classFieldName);\n\n      Boolean correctClass = Boolean.valueOf(field.stringValue());\n      long modifier = correctClass.compareTo(assignedClass);\n      if (modifier != 0) {\n        updateWeights(leafReader, scoreDoc.doc, assignedClass,\n            weights, modifier, batchCount % batchSize == 0);\n      }\n      batchCount++;\n    }\n    weights.clear(); // free memory while waiting for GC\n  }\n\n","bugFix":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","c9fb5f46e264daf5ba3860defe623a89d202dd87"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"360ff513ddb24a30ffa2111a3ef0f91038803100","date":1430403123,"type":5,"author":"Tommaso Teofili","isMerge":false,"pathNew":"lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier#BooleanPerceptronClassifier(LeafReader,String,String,Analyzer,Query,Integer,Double).mjava","pathOld":"lucene/classification/src/java/org/apache/lucene/classification/BooleanPerceptronClassifier#train(LeafReader,String,String,Analyzer,Query).mjava","sourceNew":"  public BooleanPerceptronClassifier(LeafReader leafReader, String textFieldName, String classFieldName, Analyzer analyzer,\n                                     Query query, Integer batchSize, Double threshold) throws IOException {\n    this.textTerms = MultiFields.getTerms(leafReader, textFieldName);\n\n    if (textTerms == null) {\n      throw new IOException(\"term vectors need to be available for field \" + textFieldName);\n    }\n\n    this.analyzer = analyzer;\n    this.textFieldName = textFieldName;\n\n    if (threshold == null || threshold == 0d) {\n      // automatic assign a threshold\n      long sumDocFreq = leafReader.getSumDocFreq(textFieldName);\n      if (sumDocFreq != -1) {\n        this.threshold = (double) sumDocFreq / 2d;\n      } else {\n        throw new IOException(\n                \"threshold cannot be assigned since term vectors for field \"\n                        + textFieldName + \" do not exist\");\n      }\n    } else {\n      this.threshold = threshold;\n    }\n\n    // TODO : remove this map as soon as we have a writable FST\n    SortedMap<String, Double> weights = new ConcurrentSkipListMap<>();\n\n    TermsEnum termsEnum = textTerms.iterator();\n    BytesRef textTerm;\n    while ((textTerm = termsEnum.next()) != null) {\n      weights.put(textTerm.utf8ToString(), (double) termsEnum.totalTermFreq());\n    }\n    updateFST(weights);\n\n    IndexSearcher indexSearcher = new IndexSearcher(leafReader);\n\n    int batchCount = 0;\n\n    BooleanQuery q = new BooleanQuery();\n    q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, \"*\")), BooleanClause.Occur.MUST));\n    if (query != null) {\n      q.add(new BooleanClause(query, BooleanClause.Occur.MUST));\n    }\n    // run the search and use stored field values\n    for (ScoreDoc scoreDoc : indexSearcher.search(q,\n            Integer.MAX_VALUE).scoreDocs) {\n      StoredDocument doc = indexSearcher.doc(scoreDoc.doc);\n\n      StorableField textField = doc.getField(textFieldName);\n\n      // get the expected result\n      StorableField classField = doc.getField(classFieldName);\n\n      if (textField != null && classField != null) {\n        // assign class to the doc\n        ClassificationResult<Boolean> classificationResult = assignClass(textField.stringValue());\n        Boolean assignedClass = classificationResult.getAssignedClass();\n\n        Boolean correctClass = Boolean.valueOf(classField.stringValue());\n        long modifier = correctClass.compareTo(assignedClass);\n        if (modifier != 0) {\n          updateWeights(leafReader, scoreDoc.doc, assignedClass,\n                  weights, modifier, batchCount % batchSize == 0);\n        }\n        batchCount++;\n      }\n    }\n    weights.clear(); // free memory while waiting for GC\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public void train(LeafReader leafReader, String textFieldName,\n                    String classFieldName, Analyzer analyzer, Query query) throws IOException {\n    this.textTerms = MultiFields.getTerms(leafReader, textFieldName);\n\n    if (textTerms == null) {\n      throw new IOException(\"term vectors need to be available for field \" + textFieldName);\n    }\n\n    this.analyzer = analyzer;\n    this.textFieldName = textFieldName;\n\n    if (threshold == null || threshold == 0d) {\n      // automatic assign a threshold\n      long sumDocFreq = leafReader.getSumDocFreq(textFieldName);\n      if (sumDocFreq != -1) {\n        this.threshold = (double) sumDocFreq / 2d;\n      } else {\n        throw new IOException(\n            \"threshold cannot be assigned since term vectors for field \"\n                + textFieldName + \" do not exist\");\n      }\n    }\n\n    // TODO : remove this map as soon as we have a writable FST\n    SortedMap<String, Double> weights = new ConcurrentSkipListMap<>();\n\n    TermsEnum termsEnum = textTerms.iterator();\n    BytesRef textTerm;\n    while ((textTerm = termsEnum.next()) != null) {\n      weights.put(textTerm.utf8ToString(), (double) termsEnum.totalTermFreq());\n    }\n    updateFST(weights);\n\n    IndexSearcher indexSearcher = new IndexSearcher(leafReader);\n\n    int batchCount = 0;\n\n    BooleanQuery q = new BooleanQuery();\n    q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName, \"*\")), BooleanClause.Occur.MUST));\n    if (query != null) {\n      q.add(new BooleanClause(query, BooleanClause.Occur.MUST));\n    }\n    // run the search and use stored field values\n    for (ScoreDoc scoreDoc : indexSearcher.search(q,\n        Integer.MAX_VALUE).scoreDocs) {\n      StoredDocument doc = indexSearcher.doc(scoreDoc.doc);\n\n      StorableField textField = doc.getField(textFieldName);\n\n      // get the expected result\n      StorableField classField = doc.getField(classFieldName);\n\n      if (textField != null && classField != null) {\n        // assign class to the doc\n        ClassificationResult<Boolean> classificationResult = assignClass(textField.stringValue());\n        Boolean assignedClass = classificationResult.getAssignedClass();\n\n        Boolean correctClass = Boolean.valueOf(classField.stringValue());\n        long modifier = correctClass.compareTo(assignedClass);\n        if (modifier != 0) {\n          updateWeights(leafReader, scoreDoc.doc, assignedClass,\n                weights, modifier, batchCount % batchSize == 0);\n        }\n        batchCount++;\n      }\n    }\n    weights.clear(); // free memory while waiting for GC\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["e7e9c8ade373b2cc85c2a51c4f5961bb0695cc44"],"e7e9c8ade373b2cc85c2a51c4f5961bb0695cc44":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"97c4023912a7db66594166f4f93c9f73c154844c":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["360ff513ddb24a30ffa2111a3ef0f91038803100"],"360ff513ddb24a30ffa2111a3ef0f91038803100":["97c4023912a7db66594166f4f93c9f73c154844c"]},"commit2Childs":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["97c4023912a7db66594166f4f93c9f73c154844c"],"e7e9c8ade373b2cc85c2a51c4f5961bb0695cc44":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"97c4023912a7db66594166f4f93c9f73c154844c":["360ff513ddb24a30ffa2111a3ef0f91038803100"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["e7e9c8ade373b2cc85c2a51c4f5961bb0695cc44"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"360ff513ddb24a30ffa2111a3ef0f91038803100":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}