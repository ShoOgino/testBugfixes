{"path":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","commits":[{"id":"4a52b01a73cacbd2d360240e72d64c0ba353618f","date":1489389749,"type":1,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator target = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                if (target.matches(leaf)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (target.intersects(node) == false) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (target.within(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                } else if (target.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS or CROSSES query:\n                  return (queryType == QueryType.CONTAINS || queryType == QueryType.CROSSES) ?\n                      Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount() == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(), values.getMaxPackedValue());\n          // if the internal node is not equal and not contained by the query, all docs do not match\n          if (queryType == QueryType.CROSSES || (!Arrays.equals(ranges, range)\n              && (target.contains(range) == false || queryType != QueryType.WITHIN))) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator target = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                if (target.matches(leaf)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (target.intersects(node) == false) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (target.within(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                } else if (target.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS or CROSSES query:\n                  return (queryType == QueryType.CONTAINS || queryType == QueryType.CROSSES) ?\n                      Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount() == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(), values.getMaxPackedValue());\n          // if the internal node is not equal and not contained by the query, all docs do not match\n          if (queryType == QueryType.CROSSES || (!Arrays.equals(ranges, range)\n              && (target.contains(range) == false || queryType != QueryType.WITHIN))) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91e78d339fc63f8487cc36dbc676582553f5e622","date":1495558010,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator target = new RangeFieldComparator();\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                if (target.matches(leaf)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                return compareRange(minPackedValue, maxPackedValue);\n              }\n            });\n        return result.build();\n      }\n\n      private Relation compareRange(byte[] minPackedValue, byte[] maxPackedValue) {\n        byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n        // compute range relation for BKD traversal\n        if (target.intersects(node) == false) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        } else if (target.within(node)) {\n          // target within cell; continue traversing:\n          return Relation.CELL_CROSSES_QUERY;\n        } else if (target.contains(node)) {\n          // target contains cell; add iff queryType is not a CONTAINS or CROSSES query:\n          return (queryType == QueryType.CONTAINS || queryType == QueryType.CROSSES) ?\n              Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n        }\n        // target intersects cell; continue traversing:\n        return Relation.CELL_CROSSES_QUERY;\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && compareRange(values.getMinPackedValue(), values.getMaxPackedValue()) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator target = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                if (target.matches(leaf)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (target.intersects(node) == false) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (target.within(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                } else if (target.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS or CROSSES query:\n                  return (queryType == QueryType.CONTAINS || queryType == QueryType.CROSSES) ?\n                      Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount() == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(), values.getMaxPackedValue());\n          // if the internal node is not equal and not contained by the query, all docs do not match\n          if (queryType == QueryType.CROSSES || (!Arrays.equals(ranges, range)\n              && (target.contains(range) == false || queryType != QueryType.WITHIN))) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","bugFix":["9dec1cfab325d955644ed528eb211dd09d093086","367f57e2ee85b7f7e28cfe73370a22cf67624f65","4e6bfc2c1eac33d890bf4d5638c8e149e1dcbcca","05f4c28bc6a6df30868753f35eb802cbff28ce5c","2ec1a327bcb7e91c018b0c601d542e8482af8890"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator target = new RangeFieldComparator();\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                if (target.matches(leaf)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                return compareRange(minPackedValue, maxPackedValue);\n              }\n            });\n        return result.build();\n      }\n\n      private Relation compareRange(byte[] minPackedValue, byte[] maxPackedValue) {\n        byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n        // compute range relation for BKD traversal\n        if (target.intersects(node) == false) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        } else if (target.within(node)) {\n          // target within cell; continue traversing:\n          return Relation.CELL_CROSSES_QUERY;\n        } else if (target.contains(node)) {\n          // target contains cell; add iff queryType is not a CONTAINS or CROSSES query:\n          return (queryType == QueryType.CONTAINS || queryType == QueryType.CROSSES) ?\n              Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n        }\n        // target intersects cell; continue traversing:\n        return Relation.CELL_CROSSES_QUERY;\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && compareRange(values.getMinPackedValue(), values.getMaxPackedValue()) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator target = new RangeFieldComparator();\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                if (target.matches(leaf)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n                // compute range relation for BKD traversal\n                if (target.intersects(node) == false) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (target.within(node)) {\n                  // target within cell; continue traversing:\n                  return Relation.CELL_CROSSES_QUERY;\n                } else if (target.contains(node)) {\n                  // target contains cell; add iff queryType is not a CONTAINS or CROSSES query:\n                  return (queryType == QueryType.CONTAINS || queryType == QueryType.CROSSES) ?\n                      Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n                }\n                // target intersects cell; continue traversing:\n                return Relation.CELL_CROSSES_QUERY;\n              }\n            });\n        return result.build();\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = true;\n        if (values.getDocCount() == reader.maxDoc()) {\n          // if query crosses, docs need to be further scrutinized\n          byte[] range = getInternalRange(values.getMinPackedValue(), values.getMaxPackedValue());\n          // if the internal node is not equal and not contained by the query, all docs do not match\n          if (queryType == QueryType.CROSSES || (!Arrays.equals(ranges, range)\n              && (target.contains(range) == false || queryType != QueryType.WITHIN))) {\n            allDocsMatch = false;\n          }\n        } else {\n          allDocsMatch = false;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ea930c677e0d29840f39b895d89457b42b3e3540","date":1496850573,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(boolean randomAccess) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(boolean randomAccess) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(false);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator target = new RangeFieldComparator();\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                if (target.matches(leaf)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                return compareRange(minPackedValue, maxPackedValue);\n              }\n            });\n        return result.build();\n      }\n\n      private Relation compareRange(byte[] minPackedValue, byte[] maxPackedValue) {\n        byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n        // compute range relation for BKD traversal\n        if (target.intersects(node) == false) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        } else if (target.within(node)) {\n          // target within cell; continue traversing:\n          return Relation.CELL_CROSSES_QUERY;\n        } else if (target.contains(node)) {\n          // target contains cell; add iff queryType is not a CONTAINS or CROSSES query:\n          return (queryType == QueryType.CONTAINS || queryType == QueryType.CROSSES) ?\n              Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n        }\n        // target intersects cell; continue traversing:\n        return Relation.CELL_CROSSES_QUERY;\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && compareRange(values.getMinPackedValue(), values.getMaxPackedValue()) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f344bb33ca91f48e99c061980115b46fa84fc8f5","date":1496903283,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(boolean randomAccess) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(boolean randomAccess) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(false);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator target = new RangeFieldComparator();\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                if (target.matches(leaf)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                return compareRange(minPackedValue, maxPackedValue);\n              }\n            });\n        return result.build();\n      }\n\n      private Relation compareRange(byte[] minPackedValue, byte[] maxPackedValue) {\n        byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n        // compute range relation for BKD traversal\n        if (target.intersects(node) == false) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        } else if (target.within(node)) {\n          // target within cell; continue traversing:\n          return Relation.CELL_CROSSES_QUERY;\n        } else if (target.contains(node)) {\n          // target contains cell; add iff queryType is not a CONTAINS or CROSSES query:\n          return (queryType == QueryType.CONTAINS || queryType == QueryType.CROSSES) ?\n              Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n        }\n        // target intersects cell; continue traversing:\n        return Relation.CELL_CROSSES_QUERY;\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && compareRange(values.getMinPackedValue(), values.getMaxPackedValue()) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(boolean randomAccess) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(boolean randomAccess) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(false);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator target = new RangeFieldComparator();\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                if (target.matches(leaf)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                return compareRange(minPackedValue, maxPackedValue);\n              }\n            });\n        return result.build();\n      }\n\n      private Relation compareRange(byte[] minPackedValue, byte[] maxPackedValue) {\n        byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n        // compute range relation for BKD traversal\n        if (target.intersects(node) == false) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        } else if (target.within(node)) {\n          // target within cell; continue traversing:\n          return Relation.CELL_CROSSES_QUERY;\n        } else if (target.contains(node)) {\n          // target contains cell; add iff queryType is not a CONTAINS or CROSSES query:\n          return (queryType == QueryType.CONTAINS || queryType == QueryType.CROSSES) ?\n              Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n        }\n        // target intersects cell; continue traversing:\n        return Relation.CELL_CROSSES_QUERY;\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && compareRange(values.getMinPackedValue(), values.getMaxPackedValue()) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(boolean randomAccess) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(boolean randomAccess) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(false);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n      final RangeFieldComparator target = new RangeFieldComparator();\n\n      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n        values.intersect(\n            new IntersectVisitor() {\n              DocIdSetBuilder.BulkAdder adder;\n              @Override\n              public void grow(int count) {\n                adder = result.grow(count);\n              }\n              @Override\n              public void visit(int docID) throws IOException {\n                adder.add(docID);\n              }\n              @Override\n              public void visit(int docID, byte[] leaf) throws IOException {\n                if (target.matches(leaf)) {\n                  adder.add(docID);\n                }\n              }\n              @Override\n              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                return compareRange(minPackedValue, maxPackedValue);\n              }\n            });\n        return result.build();\n      }\n\n      private Relation compareRange(byte[] minPackedValue, byte[] maxPackedValue) {\n        byte[] node = getInternalRange(minPackedValue, maxPackedValue);\n        // compute range relation for BKD traversal\n        if (target.intersects(node) == false) {\n          return Relation.CELL_OUTSIDE_QUERY;\n        } else if (target.within(node)) {\n          // target within cell; continue traversing:\n          return Relation.CELL_CROSSES_QUERY;\n        } else if (target.contains(node)) {\n          // target contains cell; add iff queryType is not a CONTAINS or CROSSES query:\n          return (queryType == QueryType.CONTAINS || queryType == QueryType.CROSSES) ?\n              Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;\n        }\n        // target intersects cell; continue traversing:\n        return Relation.CELL_CROSSES_QUERY;\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && compareRange(values.getMinPackedValue(), values.getMaxPackedValue()) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        DocIdSetIterator iterator = allDocsMatch == true ?\n            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      /** get an encoded byte representation of the internal node; this is\n       *  the lower half of the min array and the upper half of the max array */\n      private byte[] getInternalRange(byte[] min, byte[] max) {\n        byte[] range = new byte[min.length];\n        final int dimSize = numDims * bytesPerDim;\n        System.arraycopy(min, 0, range, 0, dimSize);\n        System.arraycopy(max, dimSize, range, dimSize, dimSize);\n        return range;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24f3e9c0fc20b3107388ec853a6fbad9f891b461","date":1502359844,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(boolean randomAccess) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(boolean randomAccess) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(false);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7d6ba405c7c8192661bdf7ce782181d12f3162a6","date":1502361392,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(boolean randomAccess) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(boolean randomAccess) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(false);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58884af1f68e9d61c217c753fbd6266d86a63b14","date":1502363401,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(boolean randomAccess) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(boolean randomAccess) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(false);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","date":1502692251,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(boolean randomAccess) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(boolean randomAccess) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(false);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"706a7a3396c030cc66dda92a0492eb492131c4c0","date":1509705614,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public IndexReader.CacheHelper getCacheHelper(LeafReaderContext context) {\n        return context.reader().getCoreCacheHelper();\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d523b8189b211dd1630166aa77b8c88bb48b3fcc","date":1510144168,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public IndexReader.CacheHelper getCacheHelper(LeafReaderContext context) {\n        return context.reader().getCoreCacheHelper();\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da1460d7a5dea2658e7b8e4f6e632e53ade440ac","date":1510316270,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public IndexReader.CacheHelper getCacheHelper(LeafReaderContext context) {\n        return context.reader().getCoreCacheHelper();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n\n    };\n  }\n\n","bugFix":null,"bugIntro":["3c09c5c6cd995294d83f12c1bdf8d47d8e749f49","3c09c5c6cd995294d83f12c1bdf8d47d8e749f49"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,ScoreMode,float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n\n    };\n  }\n\n","sourceOld":"  @Override\n  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    return new ConstantScoreWeight(this, boost) {\n\n      private IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {\n        return new IntersectVisitor() {\n          DocIdSetBuilder.BulkAdder adder;\n          @Override\n          public void grow(int count) {\n            adder = result.grow(count);\n          }\n          @Override\n          public void visit(int docID) throws IOException {\n            adder.add(docID);\n          }\n          @Override\n          public void visit(int docID, byte[] leaf) throws IOException {\n            if (queryType.matches(ranges, leaf, numDims, bytesPerDim)) {\n              adder.add(docID);\n            }\n          }\n          @Override\n          public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n            return queryType.compare(ranges, minPackedValue, maxPackedValue, numDims, bytesPerDim);\n          }\n        };\n      }\n\n      @Override\n      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues(field);\n        if (values == null) {\n          // no docs in this segment indexed any ranges\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // no docs in this segment indexed this field\n          return null;\n        }\n        checkFieldInfo(fieldInfo);\n        boolean allDocsMatch = false;\n        if (values.getDocCount() == reader.maxDoc()\n            && queryType.compare(ranges, values.getMinPackedValue(), values.getMaxPackedValue(), numDims, bytesPerDim) == Relation.CELL_INSIDE_QUERY) {\n          allDocsMatch = true;\n        }\n\n        final Weight weight = this;\n        if (allDocsMatch) {\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) {\n              return new ConstantScoreScorer(weight, score(), DocIdSetIterator.all(reader.maxDoc()));\n            }\n\n            @Override\n            public long cost() {\n              return reader.maxDoc();\n            }\n          };\n        } else {\n          return new ScorerSupplier() {\n\n            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);\n            final IntersectVisitor visitor = getIntersectVisitor(result);\n            long cost = -1;\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              values.intersect(visitor);\n              DocIdSetIterator iterator = result.build().iterator();\n              return new ConstantScoreScorer(weight, score(), iterator);\n            }\n\n            @Override\n            public long cost() {\n              if (cost == -1) {\n                // Computing the cost may be expensive, so only do it if necessary\n                cost = values.estimatePointCount(visitor);\n                assert cost >= 0;\n              }\n              return cost;\n            }\n          };\n        }\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        ScorerSupplier scorerSupplier = scorerSupplier(context);\n        if (scorerSupplier == null) {\n          return null;\n        }\n        return scorerSupplier.get(Long.MAX_VALUE);\n      }\n\n      @Override\n      public boolean isCacheable(LeafReaderContext ctx) {\n        return true;\n      }\n\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"706a7a3396c030cc66dda92a0492eb492131c4c0":["7d6ba405c7c8192661bdf7ce782181d12f3162a6"],"24f3e9c0fc20b3107388ec853a6fbad9f891b461":["28288370235ed02234a64753cdbf0c6ec096304a"],"da1460d7a5dea2658e7b8e4f6e632e53ade440ac":["d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"d523b8189b211dd1630166aa77b8c88bb48b3fcc":["7d6ba405c7c8192661bdf7ce782181d12f3162a6","706a7a3396c030cc66dda92a0492eb492131c4c0"],"4a52b01a73cacbd2d360240e72d64c0ba353618f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f344bb33ca91f48e99c061980115b46fa84fc8f5":["91e78d339fc63f8487cc36dbc676582553f5e622","ea930c677e0d29840f39b895d89457b42b3e3540"],"91e78d339fc63f8487cc36dbc676582553f5e622":["4a52b01a73cacbd2d360240e72d64c0ba353618f"],"28288370235ed02234a64753cdbf0c6ec096304a":["91e78d339fc63f8487cc36dbc676582553f5e622","f344bb33ca91f48e99c061980115b46fa84fc8f5"],"417142ff08fda9cf0b72d5133e63097a166c6458":["da1460d7a5dea2658e7b8e4f6e632e53ade440ac","9fc47cb7b4346802411bb432f501ed0673d7119e"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["4a52b01a73cacbd2d360240e72d64c0ba353618f","91e78d339fc63f8487cc36dbc676582553f5e622"],"ea930c677e0d29840f39b895d89457b42b3e3540":["91e78d339fc63f8487cc36dbc676582553f5e622"],"7d6ba405c7c8192661bdf7ce782181d12f3162a6":["28288370235ed02234a64753cdbf0c6ec096304a","24f3e9c0fc20b3107388ec853a6fbad9f891b461"],"58884af1f68e9d61c217c753fbd6266d86a63b14":["28288370235ed02234a64753cdbf0c6ec096304a","7d6ba405c7c8192661bdf7ce782181d12f3162a6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","7d6ba405c7c8192661bdf7ce782181d12f3162a6"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["da1460d7a5dea2658e7b8e4f6e632e53ade440ac"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["e9017cf144952056066919f1ebc7897ff9bd71b1","f344bb33ca91f48e99c061980115b46fa84fc8f5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["417142ff08fda9cf0b72d5133e63097a166c6458"]},"commit2Childs":{"706a7a3396c030cc66dda92a0492eb492131c4c0":["d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"24f3e9c0fc20b3107388ec853a6fbad9f891b461":["7d6ba405c7c8192661bdf7ce782181d12f3162a6"],"da1460d7a5dea2658e7b8e4f6e632e53ade440ac":["417142ff08fda9cf0b72d5133e63097a166c6458","9fc47cb7b4346802411bb432f501ed0673d7119e"],"d523b8189b211dd1630166aa77b8c88bb48b3fcc":["da1460d7a5dea2658e7b8e4f6e632e53ade440ac"],"4a52b01a73cacbd2d360240e72d64c0ba353618f":["91e78d339fc63f8487cc36dbc676582553f5e622","e9017cf144952056066919f1ebc7897ff9bd71b1"],"f344bb33ca91f48e99c061980115b46fa84fc8f5":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"91e78d339fc63f8487cc36dbc676582553f5e622":["f344bb33ca91f48e99c061980115b46fa84fc8f5","28288370235ed02234a64753cdbf0c6ec096304a","e9017cf144952056066919f1ebc7897ff9bd71b1","ea930c677e0d29840f39b895d89457b42b3e3540"],"28288370235ed02234a64753cdbf0c6ec096304a":["24f3e9c0fc20b3107388ec853a6fbad9f891b461","7d6ba405c7c8192661bdf7ce782181d12f3162a6","58884af1f68e9d61c217c753fbd6266d86a63b14"],"417142ff08fda9cf0b72d5133e63097a166c6458":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"7d6ba405c7c8192661bdf7ce782181d12f3162a6":["706a7a3396c030cc66dda92a0492eb492131c4c0","d523b8189b211dd1630166aa77b8c88bb48b3fcc","58884af1f68e9d61c217c753fbd6266d86a63b14","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be"],"ea930c677e0d29840f39b895d89457b42b3e3540":["f344bb33ca91f48e99c061980115b46fa84fc8f5"],"58884af1f68e9d61c217c753fbd6266d86a63b14":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4a52b01a73cacbd2d360240e72d64c0ba353618f"],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":[],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["58884af1f68e9d61c217c753fbd6266d86a63b14","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}