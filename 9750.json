{"path":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","commits":[{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"\t@Override\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n\t\tBasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n\t\t\t\t.stemmerFactory(LuceneCarrot2StemmerFactory.class)\n\t\t\t\t.tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n\t\t\t\t.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n\t\t// Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n\t\tinitAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n        .resourceLookup(new ResourceLookup(new IResourceLocator() {\n          @Override\n          public IResource[] getAll(final String resource) {\n            final SolrResourceLoader resourceLoader = core.getResourceLoader();\n            final String carrot2ResourcesDir = resourceLoader.getConfigDir()\n                + initParams.get(CarrotParams.LEXICAL_RESOURCES_DIR, CARROT_RESOURCES_PREFIX);\n            try {\n              log.debug(\"Looking for \" + resource + \" in \"\n                  + carrot2ResourcesDir);\n              final InputStream resourceStream = resourceLoader\n                  .openResource(carrot2ResourcesDir + \"/\" + resource);\n\n              log.info(resource + \" loaded from \" + carrot2ResourcesDir);\n              final IResource foundResource = new IResource() {\n                @Override\n                public InputStream open() throws IOException {\n                  return resourceStream;\n                }\n              };\n              return new IResource[] { foundResource };\n            } catch (RuntimeException e) {\n              // No way to distinguish if the resource was found but failed\n              // to load or wasn't found at all, so we simply fall back\n              // to Carrot2 defaults here by returning an empty locations array.\n              log.debug(resource + \" not found in \" + carrot2ResourcesDir\n                  + \". Using the default \" + resource + \" from Carrot JAR.\");\n              return new IResource[] {};\n            }\n          }\n        },\n\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","sourceOld":"\t@Override\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n\t\tBasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n\t\t\t\t.stemmerFactory(LuceneCarrot2StemmerFactory.class)\n\t\t\t\t.tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n\t\t\t\t.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n\t\t// Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n\t\tinitAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n        .resourceLookup(new ResourceLookup(new IResourceLocator() {\n          @Override\n          public IResource[] getAll(final String resource) {\n            final SolrResourceLoader resourceLoader = core.getResourceLoader();\n            final String carrot2ResourcesDir = resourceLoader.getConfigDir()\n                + initParams.get(CarrotParams.LEXICAL_RESOURCES_DIR, CARROT_RESOURCES_PREFIX);\n            try {\n              log.debug(\"Looking for \" + resource + \" in \"\n                  + carrot2ResourcesDir);\n              final InputStream resourceStream = resourceLoader\n                  .openResource(carrot2ResourcesDir + \"/\" + resource);\n\n              log.info(resource + \" loaded from \" + carrot2ResourcesDir);\n              final IResource foundResource = new IResource() {\n                @Override\n                public InputStream open() throws IOException {\n                  return resourceStream;\n                }\n              };\n              return new IResource[] { foundResource };\n            } catch (RuntimeException e) {\n              // No way to distinguish if the resource was found but failed\n              // to load or wasn't found at all, so we simply fall back\n              // to Carrot2 defaults here by returning an empty locations array.\n              log.debug(resource + \" not found in \" + carrot2ResourcesDir\n                  + \". Using the default \" + resource + \" from Carrot JAR.\");\n              return new IResource[] {};\n            }\n          }\n        },\n\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/main/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"\t@Override\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n\t\tBasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n\t\t\t\t.stemmerFactory(LuceneCarrot2StemmerFactory.class)\n\t\t\t\t.tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n\t\t\t\t.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n\t\t// Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n\t\tinitAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n        .resourceLookup(new ResourceLookup(new IResourceLocator() {\n          @Override\n          public IResource[] getAll(final String resource) {\n            final SolrResourceLoader resourceLoader = core.getResourceLoader();\n            final String carrot2ResourcesDir = resourceLoader.getConfigDir()\n                + initParams.get(CarrotParams.LEXICAL_RESOURCES_DIR, CARROT_RESOURCES_PREFIX);\n            try {\n              log.debug(\"Looking for \" + resource + \" in \"\n                  + carrot2ResourcesDir);\n              final InputStream resourceStream = resourceLoader\n                  .openResource(carrot2ResourcesDir + \"/\" + resource);\n\n              log.info(resource + \" loaded from \" + carrot2ResourcesDir);\n              final IResource foundResource = new IResource() {\n                @Override\n                public InputStream open() throws IOException {\n                  return resourceStream;\n                }\n              };\n              return new IResource[] { foundResource };\n            } catch (RuntimeException e) {\n              // No way to distinguish if the resource was found but failed\n              // to load or wasn't found at all, so we simply fall back\n              // to Carrot2 defaults here by returning an empty locations array.\n              log.debug(resource + \" not found in \" + carrot2ResourcesDir\n                  + \". Using the default \" + resource + \" from Carrot JAR.\");\n              return new IResource[] {};\n            }\n          }\n        },\n\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","sourceOld":"\t@Override\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n\t\tBasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n\t\t\t\t.stemmerFactory(LuceneCarrot2StemmerFactory.class)\n\t\t\t\t.tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n\t\t\t\t.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n\t\t// Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n\t\tinitAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n        .resourceLookup(new ResourceLookup(new IResourceLocator() {\n          @Override\n          public IResource[] getAll(final String resource) {\n            final SolrResourceLoader resourceLoader = core.getResourceLoader();\n            final String carrot2ResourcesDir = resourceLoader.getConfigDir()\n                + initParams.get(CarrotParams.LEXICAL_RESOURCES_DIR, CARROT_RESOURCES_PREFIX);\n            try {\n              log.debug(\"Looking for \" + resource + \" in \"\n                  + carrot2ResourcesDir);\n              final InputStream resourceStream = resourceLoader\n                  .openResource(carrot2ResourcesDir + \"/\" + resource);\n\n              log.info(resource + \" loaded from \" + carrot2ResourcesDir);\n              final IResource foundResource = new IResource() {\n                @Override\n                public InputStream open() throws IOException {\n                  return resourceStream;\n                }\n              };\n              return new IResource[] { foundResource };\n            } catch (RuntimeException e) {\n              // No way to distinguish if the resource was found but failed\n              // to load or wasn't found at all, so we simply fall back\n              // to Carrot2 defaults here by returning an empty locations array.\n              log.debug(resource + \" not found in \" + carrot2ResourcesDir\n                  + \". Using the default \" + resource + \" from Carrot JAR.\");\n              return new IResource[] {};\n            }\n          }\n        },\n\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7ad8cec4fae7376b9e16eaffdc98d990dc84556","date":1313065237,"type":3,"author":"Stanisław Osiński","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"\t@Override\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n\t\tBasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n\t\t\t\t.stemmerFactory(LuceneCarrot2StemmerFactory.class)\n\t\t\t\t.tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n\t\t\t\t.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n\t\t// Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n\t\tinitAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n        .resourceLookup(new ResourceLookup(new IResourceLocator() {\n          @Override\n          public IResource[] getAll(final String resource) {\n            final SolrResourceLoader resourceLoader = core.getResourceLoader();\n            final String carrot2ResourcesDir = initParams.get(\n                CarrotParams.LEXICAL_RESOURCES_DIR, CARROT_RESOURCES_PREFIX);\n            try {\n              log.debug(\"Looking for \" + resource + \" in \"\n                  + carrot2ResourcesDir);\n              final InputStream resourceStream = resourceLoader\n                  .openResource(carrot2ResourcesDir + \"/\" + resource);\n\n              log.info(resource + \" loaded from \" + carrot2ResourcesDir);\n              final IResource foundResource = new IResource() {\n                @Override\n                public InputStream open() throws IOException {\n                  return resourceStream;\n                }\n              };\n              return new IResource[] { foundResource };\n            } catch (RuntimeException e) {\n              // No way to distinguish if the resource was found but failed\n              // to load or wasn't found at all, so we simply fall back\n              // to Carrot2 defaults here by returning an empty locations array.\n              log.debug(resource + \" not found in \" + carrot2ResourcesDir\n                  + \". Using the default \" + resource + \" from Carrot JAR.\");\n              return new IResource[] {};\n            }\n          }\n        },\n\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","sourceOld":"\t@Override\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n\t\tBasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n\t\t\t\t.stemmerFactory(LuceneCarrot2StemmerFactory.class)\n\t\t\t\t.tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n\t\t\t\t.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n\t\t// Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n\t\tinitAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n        .resourceLookup(new ResourceLookup(new IResourceLocator() {\n          @Override\n          public IResource[] getAll(final String resource) {\n            final SolrResourceLoader resourceLoader = core.getResourceLoader();\n            final String carrot2ResourcesDir = resourceLoader.getConfigDir()\n                + initParams.get(CarrotParams.LEXICAL_RESOURCES_DIR, CARROT_RESOURCES_PREFIX);\n            try {\n              log.debug(\"Looking for \" + resource + \" in \"\n                  + carrot2ResourcesDir);\n              final InputStream resourceStream = resourceLoader\n                  .openResource(carrot2ResourcesDir + \"/\" + resource);\n\n              log.info(resource + \" loaded from \" + carrot2ResourcesDir);\n              final IResource foundResource = new IResource() {\n                @Override\n                public InputStream open() throws IOException {\n                  return resourceStream;\n                }\n              };\n              return new IResource[] { foundResource };\n            } catch (RuntimeException e) {\n              // No way to distinguish if the resource was found but failed\n              // to load or wasn't found at all, so we simply fall back\n              // to Carrot2 defaults here by returning an empty locations array.\n              log.debug(resource + \" not found in \" + carrot2ResourcesDir\n                  + \". Using the default \" + resource + \" from Carrot JAR.\");\n              return new IResource[] {};\n            }\n          }\n        },\n\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"61876dc4063744e15bb670e7ac4962c5869c7317","date":1319790210,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"\t@Override\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n\t\tBasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n\t\t\t\t.stemmerFactory(LuceneCarrot2StemmerFactory.class)\n\t\t\t\t.tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n\t\t\t\t.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n\t\t// Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n\t\tinitAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes).resourceLookup(\n      new ResourceLookup(\n        // Solr-specific resource loading.\n        new SolrResourceLocator(core, initParams),\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","sourceOld":"\t@Override\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n\t\tBasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n\t\t\t\t.stemmerFactory(LuceneCarrot2StemmerFactory.class)\n\t\t\t\t.tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n\t\t\t\t.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n\t\t// Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n\t\tinitAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n        .resourceLookup(new ResourceLookup(new IResourceLocator() {\n          @Override\n          public IResource[] getAll(final String resource) {\n            final SolrResourceLoader resourceLoader = core.getResourceLoader();\n            final String carrot2ResourcesDir = initParams.get(\n                CarrotParams.LEXICAL_RESOURCES_DIR, CARROT_RESOURCES_PREFIX);\n            try {\n              log.debug(\"Looking for \" + resource + \" in \"\n                  + carrot2ResourcesDir);\n              final InputStream resourceStream = resourceLoader\n                  .openResource(carrot2ResourcesDir + \"/\" + resource);\n\n              log.info(resource + \" loaded from \" + carrot2ResourcesDir);\n              final IResource foundResource = new IResource() {\n                @Override\n                public InputStream open() throws IOException {\n                  return resourceStream;\n                }\n              };\n              return new IResource[] { foundResource };\n            } catch (RuntimeException e) {\n              // No way to distinguish if the resource was found but failed\n              // to load or wasn't found at all, so we simply fall back\n              // to Carrot2 defaults here by returning an empty locations array.\n              log.debug(resource + \" not found in \" + carrot2ResourcesDir\n                  + \". Using the default \" + resource + \" from Carrot JAR.\");\n              return new IResource[] {};\n            }\n          }\n        },\n\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef9e7ba08c124ce913ef60415c21ae1ca833d211","date":1323446079,"type":3,"author":"Stanisław Osiński","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n        .stemmerFactory(LuceneCarrot2StemmerFactory.class)\n        .tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n        .lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n    // Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes).resourceLookup(\n      new ResourceLookup(\n        // Solr-specific resource loading.\n        new SolrResourceLocator(core, initParams),\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","sourceOld":"\t@Override\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n\t\tBasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n\t\t\t\t.stemmerFactory(LuceneCarrot2StemmerFactory.class)\n\t\t\t\t.tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n\t\t\t\t.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n\t\t// Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n\t\tinitAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes).resourceLookup(\n      new ResourceLookup(\n        // Solr-specific resource loading.\n        new SolrResourceLocator(core, initParams),\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1d586ca4ec276ea1c8b12cef9b9b22017e58e7e1","date":1323446622,"type":3,"author":"Stanisław Osiński","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n        .stemmerFactory(LuceneCarrot2StemmerFactory.class)\n        .tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n        .lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n    // Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes).resourceLookup(\n      new ResourceLookup(\n        // Solr-specific resource loading.\n        new SolrResourceLocator(core, initParams),\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    \n    SchemaField uniqueField = core.getSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n        .stemmerFactory(LuceneCarrot2StemmerFactory.class)\n        .tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n        .lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n    // Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes).resourceLookup(\n      new ResourceLookup(\n        // Solr-specific resource loading.\n        new SolrResourceLocator(core, initParams),\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","bugFix":["d2771e5f68dda632a1044fdfecbc7bffae0a4ea8"],"bugIntro":["f9fddef147e9702c85a51239935df11e5338bfbf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ff99371bc1f34bf1a2ccdb754940ee5fe5cc2565","date":1323540308,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n        .stemmerFactory(LuceneCarrot2StemmerFactory.class)\n        .tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n        .lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n    // Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes).resourceLookup(\n      new ResourceLookup(\n        // Solr-specific resource loading.\n        new SolrResourceLocator(core, initParams),\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    \n    SchemaField uniqueField = core.getSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","sourceOld":"\t@Override\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n\t\tBasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n\t\t\t\t.stemmerFactory(LuceneCarrot2StemmerFactory.class)\n\t\t\t\t.tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n\t\t\t\t.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n\t\t// Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n\t\tinitAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes).resourceLookup(\n      new ResourceLookup(\n        // Solr-specific resource loading.\n        new SolrResourceLocator(core, initParams),\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    this.idFieldName = core.getSchema().getUniqueKeyField().getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7ebf3a5f9e588d0bb564ac30d6dc32056ce9a41","date":1334628185,"type":3,"author":"Christopher John Male","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n        .stemmerFactory(LuceneCarrot2StemmerFactory.class)\n        .tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n        .lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n    // Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes).resourceLookup(\n      new ResourceLookup(\n        // Solr-specific resource loading.\n        new SolrResourceLocator(core, initParams),\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    \n    SchemaField uniqueField = core.getSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    this.clusteringAlgorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    return result;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n        .stemmerFactory(LuceneCarrot2StemmerFactory.class)\n        .tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n        .lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n    // Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes).resourceLookup(\n      new ResourceLookup(\n        // Solr-specific resource loading.\n        new SolrResourceLocator(core, initParams),\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    \n    SchemaField uniqueField = core.getSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    Class<?> algorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName);\n    if (!IClusteringAlgorithm.class.isAssignableFrom(algorithmClass)) {\n      throw new IllegalArgumentException(\"Class provided as \"\n              + CarrotParams.ALGORITHM + \" must implement \"\n              + IClusteringAlgorithm.class.getName());\n    }\n    this.clusteringAlgorithmClass = (Class<? extends IClusteringAlgorithm>) algorithmClass;\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"92e771b0c74da7aad7dea56ed75654c0e6d44688","date":1337514831,"type":3,"author":"Stanisław Osiński","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes).resourceLookup(\n      new ResourceLookup(\n        // Solr-specific resource loading.\n        new SolrResourceLocator(core, initParams),\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    \n    SchemaField uniqueField = core.getSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    this.clusteringAlgorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    return result;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n        .stemmerFactory(LuceneCarrot2StemmerFactory.class)\n        .tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n        .lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n    // Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes).resourceLookup(\n      new ResourceLookup(\n        // Solr-specific resource loading.\n        new SolrResourceLocator(core, initParams),\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    \n    SchemaField uniqueField = core.getSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    this.clusteringAlgorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f9fddef147e9702c85a51239935df11e5338bfbf","date":1337590651,"type":3,"author":"Stanisław Osiński","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes).resourceLookup(\n      new ResourceLookup(\n        // Solr-specific resource loading.\n        new SolrResourceLocator(core, initParams),\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    Thread ct = Thread.currentThread();\n    ClassLoader prev = ct.getContextClassLoader();\n    try {\n      ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n      this.controller.init(initAttributes);\n    } finally {\n      ct.setContextClassLoader(prev);\n    }\n\n    SchemaField uniqueField = core.getSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    this.clusteringAlgorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    return result;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes).resourceLookup(\n      new ResourceLookup(\n        // Solr-specific resource loading.\n        new SolrResourceLocator(core, initParams),\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    \n    SchemaField uniqueField = core.getSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    this.clusteringAlgorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    return result;\n  }\n\n","bugFix":["017c035439201490351b0f5f3d33a393c6c24551","1d586ca4ec276ea1c8b12cef9b9b22017e58e7e1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ef0d8a69209261514c5739c770bba706c2308450","date":1337607597,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes).resourceLookup(\n      new ResourceLookup(\n        // Solr-specific resource loading.\n        new SolrResourceLocator(core, initParams),\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    Thread ct = Thread.currentThread();\n    ClassLoader prev = ct.getContextClassLoader();\n    try {\n      ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n      this.controller.init(initAttributes);\n    } finally {\n      ct.setContextClassLoader(prev);\n    }\n\n    SchemaField uniqueField = core.getSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    this.clusteringAlgorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    return result;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes)\n        .stemmerFactory(LuceneCarrot2StemmerFactory.class)\n        .tokenizerFactory(LuceneCarrot2TokenizerFactory.class)\n        .lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n\n    // Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes).resourceLookup(\n      new ResourceLookup(\n        // Solr-specific resource loading.\n        new SolrResourceLocator(core, initParams),\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    this.controller.init(initAttributes);\n    \n    SchemaField uniqueField = core.getSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    this.clusteringAlgorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08970e5b8411182a29412c177eff67ec1110095b","date":1366640815,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes).resourceLookup(\n      new ResourceLookup(\n        // Solr-specific resource loading.\n        new SolrResourceLocator(core, initParams),\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    Thread ct = Thread.currentThread();\n    ClassLoader prev = ct.getContextClassLoader();\n    try {\n      ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n      this.controller.init(initAttributes);\n    } finally {\n      ct.setContextClassLoader(prev);\n    }\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    this.clusteringAlgorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    return result;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrIndexSchema\", core.getSchema());\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes).resourceLookup(\n      new ResourceLookup(\n        // Solr-specific resource loading.\n        new SolrResourceLocator(core, initParams),\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    Thread ct = Thread.currentThread();\n    ClassLoader prev = ct.getContextClassLoader();\n    try {\n      ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n      this.controller.init(initAttributes);\n    } finally {\n      ct.setContextClassLoader(prev);\n    }\n\n    SchemaField uniqueField = core.getSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    this.clusteringAlgorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e9ad156d6e96d7d7b6d8015f686c50b1142760a","date":1378497777,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    log.info(\"Initializing Clustering Engine '\" + Objects.firstNonNull(componentName, \"<no 'name' attribute>\") + \"'\");\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: \" \n              + Arrays.toString(attributeXmls));\n        }\n\n        Thread ct = Thread.currentThread();\n        ClassLoader prev = ct.getContextClassLoader();\n        try {\n          ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n\n          AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n          AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n          initAttributes.putAll(defaultSet.getAttributeValues());\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \n              \"Could not read attributes XML for clustering component: \" \n                  + componentName, e);\n        } finally {\n          ct.setContextClassLoader(prev);\n        }\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    Thread ct = Thread.currentThread();\n    ClassLoader prev = ct.getContextClassLoader();\n    try {\n      ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n      this.controller.init(initAttributes);\n    } finally {\n      ct.setContextClassLoader(prev);\n    }\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n        carrotAlgorithmClassName, IClusteringAlgorithm.class);\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialize Carrot2 controller. Pass initialization attributes, if any.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes).resourceLookup(\n      new ResourceLookup(\n        // Solr-specific resource loading.\n        new SolrResourceLocator(core, initParams),\n        // Using the class loader directly because this time we want to omit the prefix\n        new ClassLoaderLocator(core.getResourceLoader().getClassLoader())));\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    Thread ct = Thread.currentThread();\n    ClassLoader prev = ct.getContextClassLoader();\n    try {\n      ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n      this.controller.init(initAttributes);\n    } finally {\n      ct.setContextClassLoader(prev);\n    }\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    this.clusteringAlgorithmClass = core.getResourceLoader().findClass(carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"788184b02a01588fb0bca602e39018a580397a99","date":1378925127,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    log.info(\"Initializing Clustering Engine '\" + Objects.firstNonNull(componentName, \"<no 'name' attribute>\") + \"'\");\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: \" \n              + Arrays.toString(attributeXmls));\n        }\n\n        Thread ct = Thread.currentThread();\n        ClassLoader prev = ct.getContextClassLoader();\n        try {\n          ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n\n          AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n          AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n          initAttributes.putAll(defaultSet.getAttributeValues());\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \n              \"Could not read attributes XML for clustering component: \" \n                  + componentName, e);\n        } finally {\n          ct.setContextClassLoader(prev);\n        }\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    Thread ct = Thread.currentThread();\n    ClassLoader prev = ct.getContextClassLoader();\n    try {\n      ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n      this.controller.init(initAttributes);\n    } finally {\n      ct.setContextClassLoader(prev);\n    }\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n        carrotAlgorithmClassName, IClusteringAlgorithm.class);\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    log.info(\"Initializing Clustering Engine '\" + Objects.firstNonNull(componentName, \"<no 'name' attribute>\") + \"'\");\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: \" \n              + Arrays.toString(attributeXmls));\n        }\n\n        Thread ct = Thread.currentThread();\n        ClassLoader prev = ct.getContextClassLoader();\n        try {\n          ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n\n          AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n          AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n          initAttributes.putAll(defaultSet.getAttributeValues());\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \n              \"Could not read attributes XML for clustering component: \" \n                  + componentName, e);\n        } finally {\n          ct.setContextClassLoader(prev);\n        }\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    Thread ct = Thread.currentThread();\n    ClassLoader prev = ct.getContextClassLoader();\n    try {\n      ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n      this.controller.init(initAttributes);\n    } finally {\n      ct.setContextClassLoader(prev);\n    }\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n        carrotAlgorithmClassName, IClusteringAlgorithm.class);\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    log.info(\"Initializing Clustering Engine '\" + Objects.firstNonNull(componentName, \"<no 'name' attribute>\") + \"'\");\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: \" \n              + Arrays.toString(attributeXmls));\n        }\n\n        Thread ct = Thread.currentThread();\n        ClassLoader prev = ct.getContextClassLoader();\n        try {\n          ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n\n          AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n          AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n          initAttributes.putAll(defaultSet.getAttributeValues());\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \n              \"Could not read attributes XML for clustering component: \" \n                  + componentName, e);\n        } finally {\n          ct.setContextClassLoader(prev);\n        }\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    Thread ct = Thread.currentThread();\n    ClassLoader prev = ct.getContextClassLoader();\n    try {\n      ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n      this.controller.init(initAttributes);\n    } finally {\n      ct.setContextClassLoader(prev);\n    }\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n        carrotAlgorithmClassName, IClusteringAlgorithm.class);\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<String, Object>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    log.info(\"Initializing Clustering Engine '\" + Objects.firstNonNull(componentName, \"<no 'name' attribute>\") + \"'\");\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: \" \n              + Arrays.toString(attributeXmls));\n        }\n\n        Thread ct = Thread.currentThread();\n        ClassLoader prev = ct.getContextClassLoader();\n        try {\n          ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n\n          AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n          AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n          initAttributes.putAll(defaultSet.getAttributeValues());\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \n              \"Could not read attributes XML for clustering component: \" \n                  + componentName, e);\n        } finally {\n          ct.setContextClassLoader(prev);\n        }\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    Thread ct = Thread.currentThread();\n    ClassLoader prev = ct.getContextClassLoader();\n    try {\n      ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n      this.controller.init(initAttributes);\n    } finally {\n      ct.setContextClassLoader(prev);\n    }\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n        carrotAlgorithmClassName, IClusteringAlgorithm.class);\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5275eb9c84ba42bd01ecb9ab2b5f7e42519a97b5","date":1440505299,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    try {\n      this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n          carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    } catch (SolrException s) {\n      if (!(s.getCause() instanceof ClassNotFoundException)) {\n        throw s;\n      } \n    }\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    log.info(\"Initializing Clustering Engine '\" + Objects.firstNonNull(componentName, \"<no 'name' attribute>\") + \"'\");\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: \" \n              + Arrays.toString(attributeXmls));\n        }\n\n        Thread ct = Thread.currentThread();\n        ClassLoader prev = ct.getContextClassLoader();\n        try {\n          ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n\n          AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n          AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n          initAttributes.putAll(defaultSet.getAttributeValues());\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \n              \"Could not read attributes XML for clustering component: \" \n                  + componentName, e);\n        } finally {\n          ct.setContextClassLoader(prev);\n        }\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    Thread ct = Thread.currentThread();\n    ClassLoader prev = ct.getContextClassLoader();\n    try {\n      ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n      this.controller.init(initAttributes);\n    } finally {\n      ct.setContextClassLoader(prev);\n    }\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    log.info(\"Initializing Clustering Engine '\" + Objects.firstNonNull(componentName, \"<no 'name' attribute>\") + \"'\");\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: \" \n              + Arrays.toString(attributeXmls));\n        }\n\n        Thread ct = Thread.currentThread();\n        ClassLoader prev = ct.getContextClassLoader();\n        try {\n          ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n\n          AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n          AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n          initAttributes.putAll(defaultSet.getAttributeValues());\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \n              \"Could not read attributes XML for clustering component: \" \n                  + componentName, e);\n        } finally {\n          ct.setContextClassLoader(prev);\n        }\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    Thread ct = Thread.currentThread();\n    ClassLoader prev = ct.getContextClassLoader();\n    try {\n      ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n      this.controller.init(initAttributes);\n    } finally {\n      ct.setContextClassLoader(prev);\n    }\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n        carrotAlgorithmClassName, IClusteringAlgorithm.class);\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7290fa7ae2cc2a80abb6aecc0b0dd90cbfde2b7f","date":1478271720,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    try {\n      this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n          carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    } catch (SolrException s) {\n      if (!(s.getCause() instanceof ClassNotFoundException)) {\n        throw s;\n      } \n    }\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    log.info(\"Initializing Clustering Engine '\" +\n        MoreObjects.firstNonNull(componentName, \"<no 'name' attribute>\") + \"'\");\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: \" \n              + Arrays.toString(attributeXmls));\n        }\n\n        Thread ct = Thread.currentThread();\n        ClassLoader prev = ct.getContextClassLoader();\n        try {\n          ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n\n          AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n          AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n          initAttributes.putAll(defaultSet.getAttributeValues());\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \n              \"Could not read attributes XML for clustering component: \" \n                  + componentName, e);\n        } finally {\n          ct.setContextClassLoader(prev);\n        }\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    Thread ct = Thread.currentThread();\n    ClassLoader prev = ct.getContextClassLoader();\n    try {\n      ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n      this.controller.init(initAttributes);\n    } finally {\n      ct.setContextClassLoader(prev);\n    }\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    try {\n      this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n          carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    } catch (SolrException s) {\n      if (!(s.getCause() instanceof ClassNotFoundException)) {\n        throw s;\n      } \n    }\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    log.info(\"Initializing Clustering Engine '\" + Objects.firstNonNull(componentName, \"<no 'name' attribute>\") + \"'\");\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: \" \n              + Arrays.toString(attributeXmls));\n        }\n\n        Thread ct = Thread.currentThread();\n        ClassLoader prev = ct.getContextClassLoader();\n        try {\n          ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n\n          AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n          AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n          initAttributes.putAll(defaultSet.getAttributeValues());\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \n              \"Could not read attributes XML for clustering component: \" \n                  + componentName, e);\n        } finally {\n          ct.setContextClassLoader(prev);\n        }\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    Thread ct = Thread.currentThread();\n    ClassLoader prev = ct.getContextClassLoader();\n    try {\n      ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n      this.controller.init(initAttributes);\n    } finally {\n      ct.setContextClassLoader(prev);\n    }\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    try {\n      this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n          carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    } catch (SolrException s) {\n      if (!(s.getCause() instanceof ClassNotFoundException)) {\n        throw s;\n      } \n    }\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    log.info(\"Initializing Clustering Engine '\" +\n        MoreObjects.firstNonNull(componentName, \"<no 'name' attribute>\") + \"'\");\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: \" \n              + Arrays.toString(attributeXmls));\n        }\n\n        Thread ct = Thread.currentThread();\n        ClassLoader prev = ct.getContextClassLoader();\n        try {\n          ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n\n          AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n          AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n          initAttributes.putAll(defaultSet.getAttributeValues());\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \n              \"Could not read attributes XML for clustering component: \" \n                  + componentName, e);\n        } finally {\n          ct.setContextClassLoader(prev);\n        }\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    Thread ct = Thread.currentThread();\n    ClassLoader prev = ct.getContextClassLoader();\n    try {\n      ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n      this.controller.init(initAttributes);\n    } finally {\n      ct.setContextClassLoader(prev);\n    }\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    try {\n      this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n          carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    } catch (SolrException s) {\n      if (!(s.getCause() instanceof ClassNotFoundException)) {\n        throw s;\n      } \n    }\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    log.info(\"Initializing Clustering Engine '\" + Objects.firstNonNull(componentName, \"<no 'name' attribute>\") + \"'\");\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: \" \n              + Arrays.toString(attributeXmls));\n        }\n\n        Thread ct = Thread.currentThread();\n        ClassLoader prev = ct.getContextClassLoader();\n        try {\n          ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n\n          AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n          AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n          initAttributes.putAll(defaultSet.getAttributeValues());\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \n              \"Could not read attributes XML for clustering component: \" \n                  + componentName, e);\n        } finally {\n          ct.setContextClassLoader(prev);\n        }\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    Thread ct = Thread.currentThread();\n    ClassLoader prev = ct.getContextClassLoader();\n    try {\n      ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n      this.controller.init(initAttributes);\n    } finally {\n      ct.setContextClassLoader(prev);\n    }\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a2748831fb25b0e9d5a4c315047bf877c887460","date":1498155650,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    try {\n      this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n          carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    } catch (SolrException s) {\n      if (!(s.getCause() instanceof ClassNotFoundException)) {\n        throw s;\n      } \n    }\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    log.info(\"Initializing Clustering Engine '\" +\n        MoreObjects.firstNonNull(componentName, \"<no 'name' attribute>\") + \"'\");\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: \" \n              + Arrays.toString(attributeXmls));\n        }\n\n        withContextClassLoader(core.getResourceLoader().getClassLoader(), () -> {\n          try {\n            AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n            AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n            initAttributes.putAll(defaultSet.getAttributeValues());\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \n                \"Could not read attributes XML for clustering component: \" + componentName, e);\n          }\n          return null;\n        });\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    withContextClassLoader(core.getResourceLoader().getClassLoader(), () -> this.controller.init(initAttributes));\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    try {\n      this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n          carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    } catch (SolrException s) {\n      if (!(s.getCause() instanceof ClassNotFoundException)) {\n        throw s;\n      } \n    }\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    log.info(\"Initializing Clustering Engine '\" +\n        MoreObjects.firstNonNull(componentName, \"<no 'name' attribute>\") + \"'\");\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: \" \n              + Arrays.toString(attributeXmls));\n        }\n\n        Thread ct = Thread.currentThread();\n        ClassLoader prev = ct.getContextClassLoader();\n        try {\n          ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n\n          AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n          AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n          initAttributes.putAll(defaultSet.getAttributeValues());\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \n              \"Could not read attributes XML for clustering component: \" \n                  + componentName, e);\n        } finally {\n          ct.setContextClassLoader(prev);\n        }\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    Thread ct = Thread.currentThread();\n    ClassLoader prev = ct.getContextClassLoader();\n    try {\n      ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n      this.controller.init(initAttributes);\n    } finally {\n      ct.setContextClassLoader(prev);\n    }\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    try {\n      this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n          carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    } catch (SolrException s) {\n      if (!(s.getCause() instanceof ClassNotFoundException)) {\n        throw s;\n      } \n    }\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    log.info(\"Initializing Clustering Engine '\" +\n        MoreObjects.firstNonNull(componentName, \"<no 'name' attribute>\") + \"'\");\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: \" \n              + Arrays.toString(attributeXmls));\n        }\n\n        withContextClassLoader(core.getResourceLoader().getClassLoader(), () -> {\n          try {\n            AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n            AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n            initAttributes.putAll(defaultSet.getAttributeValues());\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \n                \"Could not read attributes XML for clustering component: \" + componentName, e);\n          }\n          return null;\n        });\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    withContextClassLoader(core.getResourceLoader().getClassLoader(), () -> this.controller.init(initAttributes));\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    try {\n      this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n          carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    } catch (SolrException s) {\n      if (!(s.getCause() instanceof ClassNotFoundException)) {\n        throw s;\n      } \n    }\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    log.info(\"Initializing Clustering Engine '\" +\n        MoreObjects.firstNonNull(componentName, \"<no 'name' attribute>\") + \"'\");\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: \" \n              + Arrays.toString(attributeXmls));\n        }\n\n        Thread ct = Thread.currentThread();\n        ClassLoader prev = ct.getContextClassLoader();\n        try {\n          ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n\n          AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n          AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n          initAttributes.putAll(defaultSet.getAttributeValues());\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \n              \"Could not read attributes XML for clustering component: \" \n                  + componentName, e);\n        } finally {\n          ct.setContextClassLoader(prev);\n        }\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    Thread ct = Thread.currentThread();\n    ClassLoader prev = ct.getContextClassLoader();\n    try {\n      ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n      this.controller.init(initAttributes);\n    } finally {\n      ct.setContextClassLoader(prev);\n    }\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    try {\n      this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n          carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    } catch (SolrException s) {\n      if (!(s.getCause() instanceof ClassNotFoundException)) {\n        throw s;\n      } \n    }\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    log.info(\"Initializing Clustering Engine '\" +\n        MoreObjects.firstNonNull(componentName, \"<no 'name' attribute>\") + \"'\");\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: \" \n              + Arrays.toString(attributeXmls));\n        }\n\n        withContextClassLoader(core.getResourceLoader().getClassLoader(), () -> {\n          try {\n            AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n            AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n            initAttributes.putAll(defaultSet.getAttributeValues());\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \n                \"Could not read attributes XML for clustering component: \" + componentName, e);\n          }\n          return null;\n        });\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    withContextClassLoader(core.getResourceLoader().getClassLoader(), () -> this.controller.init(initAttributes));\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    try {\n      this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n          carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    } catch (SolrException s) {\n      if (!(s.getCause() instanceof ClassNotFoundException)) {\n        throw s;\n      } \n    }\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    log.info(\"Initializing Clustering Engine '\" +\n        MoreObjects.firstNonNull(componentName, \"<no 'name' attribute>\") + \"'\");\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: \" \n              + Arrays.toString(attributeXmls));\n        }\n\n        Thread ct = Thread.currentThread();\n        ClassLoader prev = ct.getContextClassLoader();\n        try {\n          ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n\n          AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n          AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n          initAttributes.putAll(defaultSet.getAttributeValues());\n        } catch (Exception e) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \n              \"Could not read attributes XML for clustering component: \" \n                  + componentName, e);\n        } finally {\n          ct.setContextClassLoader(prev);\n        }\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    Thread ct = Thread.currentThread();\n    ClassLoader prev = ct.getContextClassLoader();\n    try {\n      ct.setContextClassLoader(core.getResourceLoader().getClassLoader());\n      this.controller.init(initAttributes);\n    } finally {\n      ct.setContextClassLoader(prev);\n    }\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"129e5b874f99ae4e04f39c337c940dda690f2d38","date":1524504409,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = config.toSolrParams();\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    try {\n      this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n          carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    } catch (SolrException s) {\n      if (!(s.getCause() instanceof ClassNotFoundException)) {\n        throw s;\n      } \n    }\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    log.info(\"Initializing Clustering Engine '\" +\n        MoreObjects.firstNonNull(componentName, \"<no 'name' attribute>\") + \"'\");\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: \" \n              + Arrays.toString(attributeXmls));\n        }\n\n        withContextClassLoader(core.getResourceLoader().getClassLoader(), () -> {\n          try {\n            AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n            AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n            initAttributes.putAll(defaultSet.getAttributeValues());\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \n                \"Could not read attributes XML for clustering component: \" + componentName, e);\n          }\n          return null;\n        });\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    withContextClassLoader(core.getResourceLoader().getClassLoader(), () -> this.controller.init(initAttributes));\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = SolrParams.toSolrParams(config);\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    try {\n      this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n          carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    } catch (SolrException s) {\n      if (!(s.getCause() instanceof ClassNotFoundException)) {\n        throw s;\n      } \n    }\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    log.info(\"Initializing Clustering Engine '\" +\n        MoreObjects.firstNonNull(componentName, \"<no 'name' attribute>\") + \"'\");\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: \" \n              + Arrays.toString(attributeXmls));\n        }\n\n        withContextClassLoader(core.getResourceLoader().getClassLoader(), () -> {\n          try {\n            AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n            AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n            initAttributes.putAll(defaultSet.getAttributeValues());\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \n                \"Could not read attributes XML for clustering component: \" + componentName, e);\n          }\n          return null;\n        });\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    withContextClassLoader(core.getResourceLoader().getClassLoader(), () -> this.controller.init(initAttributes));\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = config.toSolrParams();\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    try {\n      this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n          carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    } catch (SolrException s) {\n      if (!(s.getCause() instanceof ClassNotFoundException)) {\n        throw s;\n      } \n    }\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    if (log.isInfoEnabled()) {\n      log.info(\"Initializing Clustering Engine '{}'\", MoreObjects.firstNonNull(componentName, \"<no 'name' attribute>\"));\n    }\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: {}\"\n              , Arrays.toString(attributeXmls)); // logOk\n        }\n\n        withContextClassLoader(core.getResourceLoader().getClassLoader(), () -> {\n          try {\n            AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n            AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n            initAttributes.putAll(defaultSet.getAttributeValues());\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \n                \"Could not read attributes XML for clustering component: \" + componentName, e);\n          }\n          return null;\n        });\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    withContextClassLoader(core.getResourceLoader().getClassLoader(), () -> this.controller.init(initAttributes));\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = config.toSolrParams();\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    try {\n      this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n          carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    } catch (SolrException s) {\n      if (!(s.getCause() instanceof ClassNotFoundException)) {\n        throw s;\n      } \n    }\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    log.info(\"Initializing Clustering Engine '\" +\n        MoreObjects.firstNonNull(componentName, \"<no 'name' attribute>\") + \"'\");\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: \" \n              + Arrays.toString(attributeXmls));\n        }\n\n        withContextClassLoader(core.getResourceLoader().getClassLoader(), () -> {\n          try {\n            AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n            AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n            initAttributes.putAll(defaultSet.getAttributeValues());\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \n                \"Could not read attributes XML for clustering component: \" + componentName, e);\n          }\n          return null;\n        });\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    withContextClassLoader(core.getResourceLoader().getClassLoader(), () -> this.controller.init(initAttributes));\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2d19164145b2a65acf62a657c75f4a249b649c0","date":1601732857,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","pathOld":"solr/contrib/clustering/src/java/org/apache/solr/handler/clustering/carrot2/CarrotClusteringEngine#init(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = config.toSolrParams();\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    try {\n      this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n          carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    } catch (SolrException s) {\n      if (!(s.getCause() instanceof ClassNotFoundException)) {\n        throw s;\n      } \n    }\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    if (log.isInfoEnabled()) {\n      log.info(\"Initializing Clustering Engine '{}'\", MoreObjects.firstNonNull(componentName, \"<no 'name' attribute>\"));\n    }\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: {}\"\n              , Arrays.toString(attributeXmls)); // nowarn\n        }\n\n        withContextClassLoader(core.getResourceLoader().getClassLoader(), () -> {\n          try {\n            AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n            AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n            initAttributes.putAll(defaultSet.getAttributeValues());\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \n                \"Could not read attributes XML for clustering component: \" + componentName, e);\n          }\n          return null;\n        });\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    withContextClassLoader(core.getResourceLoader().getClassLoader(), () -> this.controller.init(initAttributes));\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    return result;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"rawtypes\")\n  public String init(NamedList config, final SolrCore core) {\n    this.core = core;\n\n    String result = super.init(config, core);\n    final SolrParams initParams = config.toSolrParams();\n\n    // Initialization attributes for Carrot2 controller.\n    HashMap<String, Object> initAttributes = new HashMap<>();\n\n    // Customize Carrot2's resource lookup to first look for resources\n    // using Solr's resource loader. If that fails, try loading from the classpath.\n    ResourceLookup resourceLookup = new ResourceLookup(\n      // Solr-specific resource loading.\n      new SolrResourceLocator(core, initParams),\n      // Using the class loader directly because this time we want to omit the prefix\n      new ClassLoaderLocator(core.getResourceLoader().getClassLoader()));\n\n    DefaultLexicalDataFactoryDescriptor.attributeBuilder(initAttributes)\n      .resourceLookup(resourceLookup);\n\n    // Make sure the requested Carrot2 clustering algorithm class is available\n    String carrotAlgorithmClassName = initParams.get(CarrotParams.ALGORITHM);\n    try {\n      this.clusteringAlgorithmClass = core.getResourceLoader().findClass(\n          carrotAlgorithmClassName, IClusteringAlgorithm.class);\n    } catch (SolrException s) {\n      if (!(s.getCause() instanceof ClassNotFoundException)) {\n        throw s;\n      } \n    }\n\n    // Load Carrot2-Workbench exported attribute XMLs based on the 'name' attribute\n    // of this component. This by-name convention lookup is used to simplify configuring algorithms.\n    String componentName = initParams.get(ClusteringEngine.ENGINE_NAME);\n    if (log.isInfoEnabled()) {\n      log.info(\"Initializing Clustering Engine '{}'\", MoreObjects.firstNonNull(componentName, \"<no 'name' attribute>\"));\n    }\n\n    if (!Strings.isNullOrEmpty(componentName)) {\n      IResource[] attributeXmls = resourceLookup.getAll(componentName + \"-attributes.xml\");\n      if (attributeXmls.length > 0) {\n        if (attributeXmls.length > 1) {\n          log.warn(\"More than one attribute file found, first one will be used: {}\"\n              , Arrays.toString(attributeXmls)); // logOk\n        }\n\n        withContextClassLoader(core.getResourceLoader().getClassLoader(), () -> {\n          try {\n            AttributeValueSets avs = AttributeValueSets.deserialize(attributeXmls[0].open());\n            AttributeValueSet defaultSet = avs.getDefaultAttributeValueSet();\n            initAttributes.putAll(defaultSet.getAttributeValues());\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.SERVER_ERROR, \n                \"Could not read attributes XML for clustering component: \" + componentName, e);\n          }\n          return null;\n        });\n      }\n    }\n\n    // Extract solrconfig attributes, they take precedence.\n    extractCarrotAttributes(initParams, initAttributes);\n\n    // Customize the stemmer and tokenizer factories. The implementations we provide here\n    // are included in the code base of Solr, so that it's possible to refactor\n    // the Lucene APIs the factories rely on if needed.\n    // Additionally, we set a custom lexical resource factory for Carrot2 that\n    // will use both Carrot2 default stop words as well as stop words from\n    // the StopFilter defined on the field.\n    final AttributeBuilder attributeBuilder = BasicPreprocessingPipelineDescriptor.attributeBuilder(initAttributes);\n    attributeBuilder.lexicalDataFactory(SolrStopwordsCarrot2LexicalDataFactory.class);\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.TOKENIZER_FACTORY)) {\n      attributeBuilder.tokenizerFactory(LuceneCarrot2TokenizerFactory.class);\n    }\n    if (!initAttributes.containsKey(BasicPreprocessingPipelineDescriptor.Keys.STEMMER_FACTORY)) {\n      attributeBuilder.stemmerFactory(LuceneCarrot2StemmerFactory.class);\n    }\n\n    // Pass the schema (via the core) to SolrStopwordsCarrot2LexicalDataFactory.\n    initAttributes.put(\"solrCore\", core);\n\n    // Carrot2 uses current thread's context class loader to get\n    // certain classes (e.g. custom tokenizer/stemmer) at initialization time.\n    // To make sure classes from contrib JARs are available,\n    // we swap the context class loader for the time of clustering.\n    withContextClassLoader(core.getResourceLoader().getClassLoader(), () -> this.controller.init(initAttributes));\n\n    SchemaField uniqueField = core.getLatestSchema().getUniqueKeyField();\n    if (uniqueField == null) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \n          CarrotClusteringEngine.class.getSimpleName() + \" requires the schema to have a uniqueKeyField\");\n    }\n    this.idFieldName = uniqueField.getName();\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"788184b02a01588fb0bca602e39018a580397a99":["7e9ad156d6e96d7d7b6d8015f686c50b1142760a"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["5275eb9c84ba42bd01ecb9ab2b5f7e42519a97b5","7290fa7ae2cc2a80abb6aecc0b0dd90cbfde2b7f"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["129e5b874f99ae4e04f39c337c940dda690f2d38"],"08970e5b8411182a29412c177eff67ec1110095b":["f9fddef147e9702c85a51239935df11e5338bfbf"],"1d586ca4ec276ea1c8b12cef9b9b22017e58e7e1":["ef9e7ba08c124ce913ef60415c21ae1ca833d211"],"a7ad8cec4fae7376b9e16eaffdc98d990dc84556":["c26f00b574427b55127e869b935845554afde1fa"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"129e5b874f99ae4e04f39c337c940dda690f2d38":["28288370235ed02234a64753cdbf0c6ec096304a"],"7290fa7ae2cc2a80abb6aecc0b0dd90cbfde2b7f":["5275eb9c84ba42bd01ecb9ab2b5f7e42519a97b5"],"f9fddef147e9702c85a51239935df11e5338bfbf":["92e771b0c74da7aad7dea56ed75654c0e6d44688"],"5a2748831fb25b0e9d5a4c315047bf877c887460":["7290fa7ae2cc2a80abb6aecc0b0dd90cbfde2b7f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b2d19164145b2a65acf62a657c75f4a249b649c0":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"ff99371bc1f34bf1a2ccdb754940ee5fe5cc2565":["61876dc4063744e15bb670e7ac4962c5869c7317","1d586ca4ec276ea1c8b12cef9b9b22017e58e7e1"],"ef0d8a69209261514c5739c770bba706c2308450":["a7ebf3a5f9e588d0bb564ac30d6dc32056ce9a41","f9fddef147e9702c85a51239935df11e5338bfbf"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["788184b02a01588fb0bca602e39018a580397a99"],"ef9e7ba08c124ce913ef60415c21ae1ca833d211":["61876dc4063744e15bb670e7ac4962c5869c7317"],"61876dc4063744e15bb670e7ac4962c5869c7317":["a7ad8cec4fae7376b9e16eaffdc98d990dc84556"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["7290fa7ae2cc2a80abb6aecc0b0dd90cbfde2b7f","5a2748831fb25b0e9d5a4c315047bf877c887460"],"28288370235ed02234a64753cdbf0c6ec096304a":["7290fa7ae2cc2a80abb6aecc0b0dd90cbfde2b7f","5a2748831fb25b0e9d5a4c315047bf877c887460"],"92e771b0c74da7aad7dea56ed75654c0e6d44688":["a7ebf3a5f9e588d0bb564ac30d6dc32056ce9a41"],"7e9ad156d6e96d7d7b6d8015f686c50b1142760a":["08970e5b8411182a29412c177eff67ec1110095b"],"a7ebf3a5f9e588d0bb564ac30d6dc32056ce9a41":["1d586ca4ec276ea1c8b12cef9b9b22017e58e7e1"],"5275eb9c84ba42bd01ecb9ab2b5f7e42519a97b5":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b2d19164145b2a65acf62a657c75f4a249b649c0"]},"commit2Childs":{"c26f00b574427b55127e869b935845554afde1fa":["a7ad8cec4fae7376b9e16eaffdc98d990dc84556"],"788184b02a01588fb0bca602e39018a580397a99":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["b2d19164145b2a65acf62a657c75f4a249b649c0"],"08970e5b8411182a29412c177eff67ec1110095b":["7e9ad156d6e96d7d7b6d8015f686c50b1142760a"],"1d586ca4ec276ea1c8b12cef9b9b22017e58e7e1":["ff99371bc1f34bf1a2ccdb754940ee5fe5cc2565","a7ebf3a5f9e588d0bb564ac30d6dc32056ce9a41"],"a7ad8cec4fae7376b9e16eaffdc98d990dc84556":["61876dc4063744e15bb670e7ac4962c5869c7317"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["c26f00b574427b55127e869b935845554afde1fa"],"7290fa7ae2cc2a80abb6aecc0b0dd90cbfde2b7f":["199dfa410f1fdbfd3294106b04096cce5ed34b21","5a2748831fb25b0e9d5a4c315047bf877c887460","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"129e5b874f99ae4e04f39c337c940dda690f2d38":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"f9fddef147e9702c85a51239935df11e5338bfbf":["08970e5b8411182a29412c177eff67ec1110095b","ef0d8a69209261514c5739c770bba706c2308450"],"5a2748831fb25b0e9d5a4c315047bf877c887460":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"b2d19164145b2a65acf62a657c75f4a249b649c0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ff99371bc1f34bf1a2ccdb754940ee5fe5cc2565":[],"ef0d8a69209261514c5739c770bba706c2308450":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["5275eb9c84ba42bd01ecb9ab2b5f7e42519a97b5"],"ef9e7ba08c124ce913ef60415c21ae1ca833d211":["1d586ca4ec276ea1c8b12cef9b9b22017e58e7e1"],"61876dc4063744e15bb670e7ac4962c5869c7317":["ff99371bc1f34bf1a2ccdb754940ee5fe5cc2565","ef9e7ba08c124ce913ef60415c21ae1ca833d211"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["129e5b874f99ae4e04f39c337c940dda690f2d38"],"92e771b0c74da7aad7dea56ed75654c0e6d44688":["f9fddef147e9702c85a51239935df11e5338bfbf"],"7e9ad156d6e96d7d7b6d8015f686c50b1142760a":["788184b02a01588fb0bca602e39018a580397a99"],"a7ebf3a5f9e588d0bb564ac30d6dc32056ce9a41":["ef0d8a69209261514c5739c770bba706c2308450","92e771b0c74da7aad7dea56ed75654c0e6d44688"],"5275eb9c84ba42bd01ecb9ab2b5f7e42519a97b5":["199dfa410f1fdbfd3294106b04096cce5ed34b21","7290fa7ae2cc2a80abb6aecc0b0dd90cbfde2b7f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["199dfa410f1fdbfd3294106b04096cce5ed34b21","ff99371bc1f34bf1a2ccdb754940ee5fe5cc2565","ef0d8a69209261514c5739c770bba706c2308450","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}