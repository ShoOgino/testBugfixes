{"path":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","commits":[{"id":"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1","date":1244392278,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"/dev/null","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          if (directory != null)\n            files = directory.listAll();\n          else\n            files = FSDirectory.listAll(fileDirectory);\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          if (directory != null) {\n            for(int i=0;i<defaultGenFileRetryCount;i++) {\n              IndexInput genInput = null;\n              try {\n                genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n              } catch (FileNotFoundException e) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n                break;\n              } catch (IOException e) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n\n              if (genInput != null) {\n                try {\n                  int version = genInput.readInt();\n                  if (version == FORMAT_LOCKLESS) {\n                    long gen0 = genInput.readLong();\n                    long gen1 = genInput.readLong();\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                    if (gen0 == gen1) {\n                      // The file is consistent.\n                      genB = gen0;\n                      break;\n                    }\n                  }\n                } catch (IOException err2) {\n                  // will retry\n                } finally {\n                  genInput.close();\n                }\n              }\n              try {\n                Thread.sleep(defaultGenFileRetryPauseMsec);\n              } catch (InterruptedException ie) {\n                // In 3.0 we will change this to throw\n                // InterruptedException instead\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(ie);\n              }\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            String s;\n            if (files != null) {\n              s = \"\";\n              for(int i=0;i<files.length;i++)\n                s += \" \" + files[i];\n            } else\n              s = \" null\";\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            if (directory != null)\n              prevExists = directory.fileExists(prevSegmentFileName);\n            else\n              prevExists = new File(fileDirectory, prevSegmentFileName).exists();\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","0ba9135468ec4b027cb08a206cba13633a410e8c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba712167ee848727018d8b77aa0c273839fbe15c","date":1244411561,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          if (directory != null) {\n            for(int i=0;i<defaultGenFileRetryCount;i++) {\n              IndexInput genInput = null;\n              try {\n                genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n              } catch (FileNotFoundException e) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n                break;\n              } catch (IOException e) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n\n              if (genInput != null) {\n                try {\n                  int version = genInput.readInt();\n                  if (version == FORMAT_LOCKLESS) {\n                    long gen0 = genInput.readLong();\n                    long gen1 = genInput.readLong();\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                    if (gen0 == gen1) {\n                      // The file is consistent.\n                      genB = gen0;\n                      break;\n                    }\n                  }\n                } catch (IOException err2) {\n                  // will retry\n                } finally {\n                  genInput.close();\n                }\n              }\n              try {\n                Thread.sleep(defaultGenFileRetryPauseMsec);\n              } catch (InterruptedException ie) {\n                // In 3.0 we will change this to throw\n                // InterruptedException instead\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(ie);\n              }\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            String s;\n            if (files != null) {\n              s = \"\";\n              for(int i=0;i<files.length;i++)\n                s += \" \" + files[i];\n            } else\n              s = \" null\";\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          if (directory != null)\n            files = directory.listAll();\n          else\n            files = FSDirectory.listAll(fileDirectory);\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          if (directory != null) {\n            for(int i=0;i<defaultGenFileRetryCount;i++) {\n              IndexInput genInput = null;\n              try {\n                genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n              } catch (FileNotFoundException e) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n                break;\n              } catch (IOException e) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n\n              if (genInput != null) {\n                try {\n                  int version = genInput.readInt();\n                  if (version == FORMAT_LOCKLESS) {\n                    long gen0 = genInput.readLong();\n                    long gen1 = genInput.readLong();\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                    if (gen0 == gen1) {\n                      // The file is consistent.\n                      genB = gen0;\n                      break;\n                    }\n                  }\n                } catch (IOException err2) {\n                  // will retry\n                } finally {\n                  genInput.close();\n                }\n              }\n              try {\n                Thread.sleep(defaultGenFileRetryPauseMsec);\n              } catch (InterruptedException ie) {\n                // In 3.0 we will change this to throw\n                // InterruptedException instead\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(ie);\n              }\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            String s;\n            if (files != null) {\n              s = \"\";\n              for(int i=0;i<files.length;i++)\n                s += \" \" + files[i];\n            } else\n              s = \" null\";\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            if (directory != null)\n              prevExists = directory.fileExists(prevSegmentFileName);\n            else\n              prevExists = new File(fileDirectory, prevSegmentFileName).exists();\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"885de4e77fb63695c07114d96501597bed21857c","date":1244809634,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n              break;\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              // In 3.0 we will change this to throw\n              // InterruptedException instead\n              Thread.currentThread().interrupt();\n              throw new RuntimeException(ie);\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            String s;\n            if (files != null) {\n              s = \"\";\n              for(int i=0;i<files.length;i++)\n                s += \" \" + files[i];\n            } else\n              s = \" null\";\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          if (directory != null) {\n            for(int i=0;i<defaultGenFileRetryCount;i++) {\n              IndexInput genInput = null;\n              try {\n                genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n              } catch (FileNotFoundException e) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n                break;\n              } catch (IOException e) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n\n              if (genInput != null) {\n                try {\n                  int version = genInput.readInt();\n                  if (version == FORMAT_LOCKLESS) {\n                    long gen0 = genInput.readLong();\n                    long gen1 = genInput.readLong();\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                    if (gen0 == gen1) {\n                      // The file is consistent.\n                      genB = gen0;\n                      break;\n                    }\n                  }\n                } catch (IOException err2) {\n                  // will retry\n                } finally {\n                  genInput.close();\n                }\n              }\n              try {\n                Thread.sleep(defaultGenFileRetryPauseMsec);\n              } catch (InterruptedException ie) {\n                // In 3.0 we will change this to throw\n                // InterruptedException instead\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(ie);\n              }\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            String s;\n            if (files != null) {\n              s = \"\";\n              for(int i=0;i<files.length;i++)\n                s += \" \" + files[i];\n            } else\n              s = \" null\";\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"41678bef429da05938d7d484f4a2469bddb01053","date":1257284308,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n              break;\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              // In 3.0 we will change this to throw\n              // InterruptedException instead\n              Thread.currentThread().interrupt();\n              throw new RuntimeException(ie);\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n              break;\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              // In 3.0 we will change this to throw\n              // InterruptedException instead\n              Thread.currentThread().interrupt();\n              throw new RuntimeException(ie);\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            String s;\n            if (files != null) {\n              s = \"\";\n              for(int i=0;i<files.length;i++)\n                s += \" \" + files[i];\n            } else\n              s = \" null\";\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files:\" + s);\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aa4b66eb16ead894fa7130904af6ecf34331f050","date":1258198413,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n              break;\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n              break;\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              // In 3.0 we will change this to throw\n              // InterruptedException instead\n              Thread.currentThread().interrupt();\n              throw new RuntimeException(ie);\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a9ac13b5f0ce5ef1b2ce168367d993a79594b23a","date":1267298041,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n              break;\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                message(\"success on fallback \" + prevSegmentFileName);\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n              break;\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d8a2ba2f29c523b1ce4db7c3491d01615d912b15","date":1267376414,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n              break;\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                message(\"success on fallback \" + prevSegmentFileName);\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["0ba9135468ec4b027cb08a206cba13633a410e8c","d4ce75c5c8181cb19bc310a09f2dc44481cfa1ac"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          if (infoStream != null) {\n            message(\"directory listing genA=\" + genA);\n          }\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: FileNotFoundException \" + e);\n              }\n              break;\n            } catch (IOException e) {\n              if (infoStream != null) {\n                message(\"segments.gen open: IOException \" + e);\n              }\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  if (infoStream != null) {\n                    message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  }\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          if (infoStream != null) {\n            message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n          }\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            if (infoStream != null) {\n              message(\"look ahead increment gen to \" + gen);\n            }\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null && infoStream != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          if (infoStream != null) {\n            message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n          }\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              if (infoStream != null) {\n                message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              }\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (infoStream != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                if (infoStream != null) {\n                  message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d8a2ba2f29c523b1ce4db7c3491d01615d912b15":["a9ac13b5f0ce5ef1b2ce168367d993a79594b23a"],"885de4e77fb63695c07114d96501597bed21857c":["ba712167ee848727018d8b77aa0c273839fbe15c"],"41678bef429da05938d7d484f4a2469bddb01053":["885de4e77fb63695c07114d96501597bed21857c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"aa4b66eb16ead894fa7130904af6ecf34331f050":["41678bef429da05938d7d484f4a2469bddb01053"],"a9ac13b5f0ce5ef1b2ce168367d993a79594b23a":["aa4b66eb16ead894fa7130904af6ecf34331f050"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["d8a2ba2f29c523b1ce4db7c3491d01615d912b15"],"ba712167ee848727018d8b77aa0c273839fbe15c":["0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1"]},"commit2Childs":{"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1":["ba712167ee848727018d8b77aa0c273839fbe15c"],"d8a2ba2f29c523b1ce4db7c3491d01615d912b15":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"885de4e77fb63695c07114d96501597bed21857c":["41678bef429da05938d7d484f4a2469bddb01053"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1"],"41678bef429da05938d7d484f4a2469bddb01053":["aa4b66eb16ead894fa7130904af6ecf34331f050"],"aa4b66eb16ead894fa7130904af6ecf34331f050":["a9ac13b5f0ce5ef1b2ce168367d993a79594b23a"],"a9ac13b5f0ce5ef1b2ce168367d993a79594b23a":["d8a2ba2f29c523b1ce4db7c3491d01615d912b15"],"ba712167ee848727018d8b77aa0c273839fbe15c":["885de4e77fb63695c07114d96501597bed21857c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}