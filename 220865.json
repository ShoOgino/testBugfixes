{"path":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : emptyReaders[0],\n      emptyReaders[0],\n      new MultiReader(edge < 0 ? emptyReaders[4] : emptyReaders[0],\n          emptyReaders[0],\n          0 == edge ? r : emptyReaders[0]),\n      0 < edge ? emptyReaders[0] : emptyReaders[7],\n      emptyReaders[0],\n      new MultiReader(0 < edge ? emptyReaders[0] : emptyReaders[5],\n          emptyReaders[0],\n          0 < edge ? r : emptyReaders[0])\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarity(s.getSimilarity());\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : emptyReaders[0],\n      emptyReaders[0],\n      new MultiReader(edge < 0 ? emptyReaders[4] : emptyReaders[0],\n          emptyReaders[0],\n          0 == edge ? r : emptyReaders[0]),\n      0 < edge ? emptyReaders[0] : emptyReaders[7],\n      emptyReaders[0],\n      new MultiReader(0 < edge ? emptyReaders[0] : emptyReaders[5],\n          emptyReaders[0],\n          0 < edge ? r : emptyReaders[0])\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarity(s.getSimilarity());\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2700d038f8343300ca3d0a2df0173be396564175","date":1329863343,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : emptyReaders[0],\n      emptyReaders[0],\n      new MultiReader(edge < 0 ? emptyReaders[4] : emptyReaders[0],\n          emptyReaders[0],\n          0 == edge ? r : emptyReaders[0]),\n      0 < edge ? emptyReaders[0] : emptyReaders[7],\n      emptyReaders[0],\n      new MultiReader(0 < edge ? emptyReaders[0] : emptyReaders[5],\n          emptyReaders[0],\n          0 < edge ? r : emptyReaders[0])\n    };\n\n    // TODO: fix me,\n    //   wrapping causes insanity when we have an already-atomic reader?!\n    // IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers), false);\n    out.setSimilarity(s.getSimilarity());\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : emptyReaders[0],\n      emptyReaders[0],\n      new MultiReader(edge < 0 ? emptyReaders[4] : emptyReaders[0],\n          emptyReaders[0],\n          0 == edge ? r : emptyReaders[0]),\n      0 < edge ? emptyReaders[0] : emptyReaders[7],\n      emptyReaders[0],\n      new MultiReader(0 < edge ? emptyReaders[0] : emptyReaders[5],\n          emptyReaders[0],\n          0 < edge ? r : emptyReaders[0])\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarity(s.getSimilarity());\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6c939a28130e1107d4e349d6c10d1a92c489662","date":1330299480,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : emptyReaders[0],\n      emptyReaders[0],\n      new MultiReader(edge < 0 ? emptyReaders[4] : emptyReaders[0],\n          emptyReaders[0],\n          0 == edge ? r : emptyReaders[0]),\n      0 < edge ? emptyReaders[0] : emptyReaders[7],\n      emptyReaders[0],\n      new MultiReader(0 < edge ? emptyReaders[0] : emptyReaders[5],\n          emptyReaders[0],\n          0 < edge ? r : emptyReaders[0])\n    };\n\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarity(s.getSimilarity());\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : emptyReaders[0],\n      emptyReaders[0],\n      new MultiReader(edge < 0 ? emptyReaders[4] : emptyReaders[0],\n          emptyReaders[0],\n          0 == edge ? r : emptyReaders[0]),\n      0 < edge ? emptyReaders[0] : emptyReaders[7],\n      emptyReaders[0],\n      new MultiReader(0 < edge ? emptyReaders[0] : emptyReaders[5],\n          emptyReaders[0],\n          0 < edge ? r : emptyReaders[0])\n    };\n\n    // TODO: fix me,\n    //   wrapping causes insanity when we have an already-atomic reader?!\n    // IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers), false);\n    out.setSimilarity(s.getSimilarity());\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1dfbab3b123144c2bf2fe399c49001108d9c721c","date":1330368339,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : emptyReaders[0],\n      emptyReaders[0],\n      new FCInvisibleMultiReader(edge < 0 ? emptyReaders[4] : emptyReaders[0],\n          emptyReaders[0],\n          0 == edge ? r : emptyReaders[0]),\n      0 < edge ? emptyReaders[0] : emptyReaders[7],\n      emptyReaders[0],\n      new FCInvisibleMultiReader(0 < edge ? emptyReaders[0] : emptyReaders[5],\n          emptyReaders[0],\n          0 < edge ? r : emptyReaders[0])\n    };\n\n    IndexSearcher out = LuceneTestCase.newSearcher(new FCInvisibleMultiReader(readers));\n    out.setSimilarity(s.getSimilarity());\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : emptyReaders[0],\n      emptyReaders[0],\n      new MultiReader(edge < 0 ? emptyReaders[4] : emptyReaders[0],\n          emptyReaders[0],\n          0 == edge ? r : emptyReaders[0]),\n      0 < edge ? emptyReaders[0] : emptyReaders[7],\n      emptyReaders[0],\n      new MultiReader(0 < edge ? emptyReaders[0] : emptyReaders[5],\n          emptyReaders[0],\n          0 < edge ? r : emptyReaders[0])\n    };\n\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarity(s.getSimilarity());\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : emptyReaders[0],\n      emptyReaders[0],\n      new FCInvisibleMultiReader(edge < 0 ? emptyReaders[4] : emptyReaders[0],\n          emptyReaders[0],\n          0 == edge ? r : emptyReaders[0]),\n      0 < edge ? emptyReaders[0] : emptyReaders[7],\n      emptyReaders[0],\n      new FCInvisibleMultiReader(0 < edge ? emptyReaders[0] : emptyReaders[5],\n          emptyReaders[0],\n          0 < edge ? r : emptyReaders[0])\n    };\n\n    IndexSearcher out = LuceneTestCase.newSearcher(new FCInvisibleMultiReader(readers));\n    out.setSimilarity(s.getSimilarity());\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : emptyReaders[0],\n      emptyReaders[0],\n      new MultiReader(edge < 0 ? emptyReaders[4] : emptyReaders[0],\n          emptyReaders[0],\n          0 == edge ? r : emptyReaders[0]),\n      0 < edge ? emptyReaders[0] : emptyReaders[7],\n      emptyReaders[0],\n      new MultiReader(0 < edge ? emptyReaders[0] : emptyReaders[5],\n          emptyReaders[0],\n          0 < edge ? r : emptyReaders[0])\n    };\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarity(s.getSimilarity());\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5dcfd27b9fe602b19e032acdb429aab9fd78c6ef","date":1429503225,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : new MultiReader(),\n      new MultiReader(),\n      new FCInvisibleMultiReader(edge < 0 ? emptyReader(4) : new MultiReader(),\n          new MultiReader(),\n          0 == edge ? r : new MultiReader()),\n      0 < edge ? new MultiReader() : emptyReader(7),\n      new MultiReader(),\n      new FCInvisibleMultiReader(0 < edge ? new MultiReader() : emptyReader(5),\n          new MultiReader(),\n          0 < edge ? r : new MultiReader())\n    };\n\n    IndexSearcher out = LuceneTestCase.newSearcher(new FCInvisibleMultiReader(readers));\n    out.setSimilarity(s.getSimilarity());\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : emptyReaders[0],\n      emptyReaders[0],\n      new FCInvisibleMultiReader(edge < 0 ? emptyReaders[4] : emptyReaders[0],\n          emptyReaders[0],\n          0 == edge ? r : emptyReaders[0]),\n      0 < edge ? emptyReaders[0] : emptyReaders[7],\n      emptyReaders[0],\n      new FCInvisibleMultiReader(0 < edge ? emptyReaders[0] : emptyReaders[5],\n          emptyReaders[0],\n          0 < edge ? r : emptyReaders[0])\n    };\n\n    IndexSearcher out = LuceneTestCase.newSearcher(new FCInvisibleMultiReader(readers));\n    out.setSimilarity(s.getSimilarity());\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"485545da3b4429d6f138b4baac573a97820ee93b","date":1433876557,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : new MultiReader(),\n      new MultiReader(),\n      new FCInvisibleMultiReader(edge < 0 ? emptyReader(4) : new MultiReader(),\n          new MultiReader(),\n          0 == edge ? r : new MultiReader()),\n      0 < edge ? new MultiReader() : emptyReader(7),\n      new MultiReader(),\n      new FCInvisibleMultiReader(0 < edge ? new MultiReader() : emptyReader(5),\n          new MultiReader(),\n          0 < edge ? r : new MultiReader())\n    };\n\n    IndexSearcher out = LuceneTestCase.newSearcher(new FCInvisibleMultiReader(readers));\n    out.setSimilarity(s.getSimilarity(true));\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : new MultiReader(),\n      new MultiReader(),\n      new FCInvisibleMultiReader(edge < 0 ? emptyReader(4) : new MultiReader(),\n          new MultiReader(),\n          0 == edge ? r : new MultiReader()),\n      0 < edge ? new MultiReader() : emptyReader(7),\n      new MultiReader(),\n      new FCInvisibleMultiReader(0 < edge ? new MultiReader() : emptyReader(5),\n          new MultiReader(),\n          0 < edge ? r : new MultiReader())\n    };\n\n    IndexSearcher out = LuceneTestCase.newSearcher(new FCInvisibleMultiReader(readers));\n    out.setSimilarity(s.getSimilarity());\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e7bc21595222ae4f75509300fbb7726691f387f","date":1464078795,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader\n   * is a MultiReader containing the Reader of the original IndexSearcher,\n   * as well as several \"empty\" IndexReaders -- some of which will have\n   * deleted documents in them.  This new IndexSearcher should\n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge)\n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : new MultiReader(),\n      new MultiReader(),\n      new FCInvisibleMultiReader(edge < 0 ? emptyReader(4) : new MultiReader(),\n          new MultiReader(),\n          0 == edge ? r : new MultiReader()),\n      0 < edge ? new MultiReader() : emptyReader(7),\n      new MultiReader(),\n      new FCInvisibleMultiReader(0 < edge ? new MultiReader() : emptyReader(5),\n          new MultiReader(),\n          0 < edge ? r : new MultiReader())\n    };\n\n    IndexSearcher out = LuceneTestCase.newSearcher(new FCInvisibleMultiReader(readers));\n    out.setSimilarity(s.getSimilarity(true));\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : new MultiReader(),\n      new MultiReader(),\n      new FCInvisibleMultiReader(edge < 0 ? emptyReader(4) : new MultiReader(),\n          new MultiReader(),\n          0 == edge ? r : new MultiReader()),\n      0 < edge ? new MultiReader() : emptyReader(7),\n      new MultiReader(),\n      new FCInvisibleMultiReader(0 < edge ? new MultiReader() : emptyReader(5),\n          new MultiReader(),\n          0 < edge ? r : new MultiReader())\n    };\n\n    IndexSearcher out = LuceneTestCase.newSearcher(new FCInvisibleMultiReader(readers));\n    out.setSimilarity(s.getSimilarity(true));\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader\n   * is a MultiReader containing the Reader of the original IndexSearcher,\n   * as well as several \"empty\" IndexReaders -- some of which will have\n   * deleted documents in them.  This new IndexSearcher should\n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge)\n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : new MultiReader(),\n      new MultiReader(),\n      new FCInvisibleMultiReader(edge < 0 ? emptyReader(4) : new MultiReader(),\n          new MultiReader(),\n          0 == edge ? r : new MultiReader()),\n      0 < edge ? new MultiReader() : emptyReader(7),\n      new MultiReader(),\n      new FCInvisibleMultiReader(0 < edge ? new MultiReader() : emptyReader(5),\n          new MultiReader(),\n          0 < edge ? r : new MultiReader())\n    };\n\n    IndexSearcher out = LuceneTestCase.newSearcher(new FCInvisibleMultiReader(readers));\n    out.setSimilarity(s.getSimilarity(true));\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader \n   * is a MultiReader containing the Reader of the original IndexSearcher, \n   * as well as several \"empty\" IndexReaders -- some of which will have \n   * deleted documents in them.  This new IndexSearcher should \n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge) \n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : new MultiReader(),\n      new MultiReader(),\n      new FCInvisibleMultiReader(edge < 0 ? emptyReader(4) : new MultiReader(),\n          new MultiReader(),\n          0 == edge ? r : new MultiReader()),\n      0 < edge ? new MultiReader() : emptyReader(7),\n      new MultiReader(),\n      new FCInvisibleMultiReader(0 < edge ? new MultiReader() : emptyReader(5),\n          new MultiReader(),\n          0 < edge ? r : new MultiReader())\n    };\n\n    IndexSearcher out = LuceneTestCase.newSearcher(new FCInvisibleMultiReader(readers));\n    out.setSimilarity(s.getSimilarity(true));\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d211216c83f01894810543d1c107160a9ae3650b","date":1488289605,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader\n   * is a MultiReader containing the Reader of the original IndexSearcher,\n   * as well as several \"empty\" IndexReaders -- some of which will have\n   * deleted documents in them.  This new IndexSearcher should\n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge)\n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : new MultiReader(),\n      new MultiReader(),\n      new MultiReader(edge < 0 ? emptyReader(4) : new MultiReader(),\n          new MultiReader(),\n          0 == edge ? r : new MultiReader()),\n      0 < edge ? new MultiReader() : emptyReader(7),\n      new MultiReader(),\n      new MultiReader(0 < edge ? new MultiReader() : emptyReader(5),\n          new MultiReader(),\n          0 < edge ? r : new MultiReader())\n    };\n\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarity(s.getSimilarity(true));\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader\n   * is a MultiReader containing the Reader of the original IndexSearcher,\n   * as well as several \"empty\" IndexReaders -- some of which will have\n   * deleted documents in them.  This new IndexSearcher should\n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge)\n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : new MultiReader(),\n      new MultiReader(),\n      new FCInvisibleMultiReader(edge < 0 ? emptyReader(4) : new MultiReader(),\n          new MultiReader(),\n          0 == edge ? r : new MultiReader()),\n      0 < edge ? new MultiReader() : emptyReader(7),\n      new MultiReader(),\n      new FCInvisibleMultiReader(0 < edge ? new MultiReader() : emptyReader(5),\n          new MultiReader(),\n          0 < edge ? r : new MultiReader())\n    };\n\n    IndexSearcher out = LuceneTestCase.newSearcher(new FCInvisibleMultiReader(readers));\n    out.setSimilarity(s.getSimilarity(true));\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68d6cb7f0f019661a784bd0e5a21e85b5f812af6","date":1515075216,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader\n   * is a MultiReader containing the Reader of the original IndexSearcher,\n   * as well as several \"empty\" IndexReaders -- some of which will have\n   * deleted documents in them.  This new IndexSearcher should\n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge)\n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : new MultiReader(),\n      new MultiReader(),\n      new MultiReader(edge < 0 ? emptyReader(4) : new MultiReader(),\n          new MultiReader(),\n          0 == edge ? r : new MultiReader()),\n      0 < edge ? new MultiReader() : emptyReader(7),\n      new MultiReader(),\n      new MultiReader(0 < edge ? new MultiReader() : emptyReader(5),\n          new MultiReader(),\n          0 < edge ? r : new MultiReader())\n    };\n\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarity(s.getSimilarity());\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader\n   * is a MultiReader containing the Reader of the original IndexSearcher,\n   * as well as several \"empty\" IndexReaders -- some of which will have\n   * deleted documents in them.  This new IndexSearcher should\n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge)\n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : new MultiReader(),\n      new MultiReader(),\n      new MultiReader(edge < 0 ? emptyReader(4) : new MultiReader(),\n          new MultiReader(),\n          0 == edge ? r : new MultiReader()),\n      0 < edge ? new MultiReader() : emptyReader(7),\n      new MultiReader(),\n      new MultiReader(0 < edge ? new MultiReader() : emptyReader(5),\n          new MultiReader(),\n          0 < edge ? r : new MultiReader())\n    };\n\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarity(s.getSimilarity(true));\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#wrapUnderlyingReader(Random,IndexSearcher,int).mjava","sourceNew":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader\n   * is a MultiReader containing the Reader of the original IndexSearcher,\n   * as well as several \"empty\" IndexReaders -- some of which will have\n   * deleted documents in them.  This new IndexSearcher should\n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge)\n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : new MultiReader(),\n      new MultiReader(),\n      new MultiReader(edge < 0 ? emptyReader(4) : new MultiReader(),\n          new MultiReader(),\n          0 == edge ? r : new MultiReader()),\n      0 < edge ? new MultiReader() : emptyReader(7),\n      new MultiReader(),\n      new MultiReader(0 < edge ? new MultiReader() : emptyReader(5),\n          new MultiReader(),\n          0 < edge ? r : new MultiReader())\n    };\n\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarity(s.getSimilarity());\n    return out;\n  }\n\n","sourceOld":"  /**\n   * Given an IndexSearcher, returns a new IndexSearcher whose IndexReader\n   * is a MultiReader containing the Reader of the original IndexSearcher,\n   * as well as several \"empty\" IndexReaders -- some of which will have\n   * deleted documents in them.  This new IndexSearcher should\n   * behave exactly the same as the original IndexSearcher.\n   * @param s the searcher to wrap\n   * @param edge if negative, s will be the first sub; if 0, s will be in the middle, if positive s will be the last sub\n   */\n  public static IndexSearcher wrapUnderlyingReader(Random random, final IndexSearcher s, final int edge)\n    throws IOException {\n\n    IndexReader r = s.getIndexReader();\n\n    // we can't put deleted docs before the nested reader, because\n    // it will throw off the docIds\n    IndexReader[] readers = new IndexReader[] {\n      edge < 0 ? r : new MultiReader(),\n      new MultiReader(),\n      new MultiReader(edge < 0 ? emptyReader(4) : new MultiReader(),\n          new MultiReader(),\n          0 == edge ? r : new MultiReader()),\n      0 < edge ? new MultiReader() : emptyReader(7),\n      new MultiReader(),\n      new MultiReader(0 < edge ? new MultiReader() : emptyReader(5),\n          new MultiReader(),\n          0 < edge ? r : new MultiReader())\n    };\n\n    IndexSearcher out = LuceneTestCase.newSearcher(new MultiReader(readers));\n    out.setSimilarity(s.getSimilarity(true));\n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["d211216c83f01894810543d1c107160a9ae3650b","68d6cb7f0f019661a784bd0e5a21e85b5f812af6"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","1dfbab3b123144c2bf2fe399c49001108d9c721c"],"2700d038f8343300ca3d0a2df0173be396564175":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"485545da3b4429d6f138b4baac573a97820ee93b":["5dcfd27b9fe602b19e032acdb429aab9fd78c6ef"],"1dfbab3b123144c2bf2fe399c49001108d9c721c":["d6c939a28130e1107d4e349d6c10d1a92c489662"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["485545da3b4429d6f138b4baac573a97820ee93b","0e7bc21595222ae4f75509300fbb7726691f387f"],"68d6cb7f0f019661a784bd0e5a21e85b5f812af6":["d211216c83f01894810543d1c107160a9ae3650b"],"d211216c83f01894810543d1c107160a9ae3650b":["0e7bc21595222ae4f75509300fbb7726691f387f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0e7bc21595222ae4f75509300fbb7726691f387f":["485545da3b4429d6f138b4baac573a97820ee93b"],"5dcfd27b9fe602b19e032acdb429aab9fd78c6ef":["1dfbab3b123144c2bf2fe399c49001108d9c721c"],"d6c939a28130e1107d4e349d6c10d1a92c489662":["2700d038f8343300ca3d0a2df0173be396564175"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"2700d038f8343300ca3d0a2df0173be396564175":["d6c939a28130e1107d4e349d6c10d1a92c489662"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","2700d038f8343300ca3d0a2df0173be396564175"],"485545da3b4429d6f138b4baac573a97820ee93b":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0e7bc21595222ae4f75509300fbb7726691f387f"],"1dfbab3b123144c2bf2fe399c49001108d9c721c":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","5dcfd27b9fe602b19e032acdb429aab9fd78c6ef"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"68d6cb7f0f019661a784bd0e5a21e85b5f812af6":["b94236357aaa22b76c10629851fe4e376e0cea82"],"d211216c83f01894810543d1c107160a9ae3650b":["b94236357aaa22b76c10629851fe4e376e0cea82","68d6cb7f0f019661a784bd0e5a21e85b5f812af6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"0e7bc21595222ae4f75509300fbb7726691f387f":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d211216c83f01894810543d1c107160a9ae3650b"],"5dcfd27b9fe602b19e032acdb429aab9fd78c6ef":["485545da3b4429d6f138b4baac573a97820ee93b"],"d6c939a28130e1107d4e349d6c10d1a92c489662":["1dfbab3b123144c2bf2fe399c49001108d9c721c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}