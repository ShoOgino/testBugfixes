{"path":"src/java/org/apache/lucene/index/SegmentTermDocs#skipTo(int).mjava","commits":[{"id":"91109046a59c58ee0ee5d0d2767b08d1f30d6702","date":1000830588,"type":0,"author":"Jason van Zyl","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentTermDocs#skipTo(int).mjava","pathOld":"/dev/null","sourceNew":"  /** As yet unoptimized implementation. */\n  public boolean skipTo(int target) throws IOException {\n    do {\n      if (!next())\n\treturn false;\n    } while (target > doc);\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7fb6d70db034a5456ae560175dd1b821eea9ff4","date":1066759157,"type":4,"author":"Doug Cutting","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/index/SegmentTermDocs#skipTo(int).mjava","sourceNew":null,"sourceOld":"  /** As yet unoptimized implementation. */\n  public boolean skipTo(int target) throws IOException {\n    do {\n      if (!next())\n\treturn false;\n    } while (target > doc);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eafd816608011f66422f3052c37962973582d12a","date":1087172166,"type":0,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentTermDocs#skipTo(int).mjava","pathOld":"/dev/null","sourceNew":"  /** Optimized implementation. */\n  public boolean skipTo(int target) throws IOException {\n    if (df >= skipInterval) {                      // optimized case\n\n      if (skipStream == null)\n        skipStream = (InputStream) freqStream.clone(); // lazily clone\n\n      if (!haveSkipped) {                          // lazily seek skip stream\n        skipStream.seek(skipPointer);\n        haveSkipped = true;\n      }\n\n      // scan skip data\n      int lastSkipDoc = skipDoc;\n      long lastFreqPointer = freqStream.getFilePointer();\n      long lastProxPointer = -1;\n      int numSkipped = -1 - (count % skipInterval);\n\n      while (target > skipDoc) {\n        lastSkipDoc = skipDoc;\n        lastFreqPointer = freqPointer;\n        lastProxPointer = proxPointer;\n        \n        if (skipDoc != 0 && skipDoc >= doc)\n          numSkipped += skipInterval;\n        \n        if(skipCount >= numSkips)\n          break;\n\n        skipDoc += skipStream.readVInt();\n        freqPointer += skipStream.readVInt();\n        proxPointer += skipStream.readVInt();\n\n        skipCount++;\n      }\n      \n      // if we found something to skip, then skip it\n      if (lastFreqPointer > freqStream.getFilePointer()) {\n        freqStream.seek(lastFreqPointer);\n        skipProx(lastProxPointer);\n\n        doc = lastSkipDoc;\n        count += numSkipped;\n      }\n\n    }\n\n    // done skipping, now just scan\n    do {\n      if (!next())\n        return false;\n    } while (target > doc);\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e971ba25509e21a130fef61f0687be0446ca27a0","date":1095369217,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentTermDocs#skipTo(int).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentTermDocs#skipTo(int).mjava","sourceNew":"  /** Optimized implementation. */\n  public boolean skipTo(int target) throws IOException {\n    if (df >= skipInterval) {                      // optimized case\n\n      if (skipStream == null)\n        skipStream = (IndexInput) freqStream.clone(); // lazily clone\n\n      if (!haveSkipped) {                          // lazily seek skip stream\n        skipStream.seek(skipPointer);\n        haveSkipped = true;\n      }\n\n      // scan skip data\n      int lastSkipDoc = skipDoc;\n      long lastFreqPointer = freqStream.getFilePointer();\n      long lastProxPointer = -1;\n      int numSkipped = -1 - (count % skipInterval);\n\n      while (target > skipDoc) {\n        lastSkipDoc = skipDoc;\n        lastFreqPointer = freqPointer;\n        lastProxPointer = proxPointer;\n        \n        if (skipDoc != 0 && skipDoc >= doc)\n          numSkipped += skipInterval;\n        \n        if(skipCount >= numSkips)\n          break;\n\n        skipDoc += skipStream.readVInt();\n        freqPointer += skipStream.readVInt();\n        proxPointer += skipStream.readVInt();\n\n        skipCount++;\n      }\n      \n      // if we found something to skip, then skip it\n      if (lastFreqPointer > freqStream.getFilePointer()) {\n        freqStream.seek(lastFreqPointer);\n        skipProx(lastProxPointer);\n\n        doc = lastSkipDoc;\n        count += numSkipped;\n      }\n\n    }\n\n    // done skipping, now just scan\n    do {\n      if (!next())\n        return false;\n    } while (target > doc);\n    return true;\n  }\n\n","sourceOld":"  /** Optimized implementation. */\n  public boolean skipTo(int target) throws IOException {\n    if (df >= skipInterval) {                      // optimized case\n\n      if (skipStream == null)\n        skipStream = (InputStream) freqStream.clone(); // lazily clone\n\n      if (!haveSkipped) {                          // lazily seek skip stream\n        skipStream.seek(skipPointer);\n        haveSkipped = true;\n      }\n\n      // scan skip data\n      int lastSkipDoc = skipDoc;\n      long lastFreqPointer = freqStream.getFilePointer();\n      long lastProxPointer = -1;\n      int numSkipped = -1 - (count % skipInterval);\n\n      while (target > skipDoc) {\n        lastSkipDoc = skipDoc;\n        lastFreqPointer = freqPointer;\n        lastProxPointer = proxPointer;\n        \n        if (skipDoc != 0 && skipDoc >= doc)\n          numSkipped += skipInterval;\n        \n        if(skipCount >= numSkips)\n          break;\n\n        skipDoc += skipStream.readVInt();\n        freqPointer += skipStream.readVInt();\n        proxPointer += skipStream.readVInt();\n\n        skipCount++;\n      }\n      \n      // if we found something to skip, then skip it\n      if (lastFreqPointer > freqStream.getFilePointer()) {\n        freqStream.seek(lastFreqPointer);\n        skipProx(lastProxPointer);\n\n        doc = lastSkipDoc;\n        count += numSkipped;\n      }\n\n    }\n\n    // done skipping, now just scan\n    do {\n      if (!next())\n        return false;\n    } while (target > doc);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8522ae207a56c6db28ca06fe6cc33e70911c3600","date":1173935743,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentTermDocs#skipTo(int).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentTermDocs#skipTo(int).mjava","sourceNew":"  /** Optimized implementation. */\n  public boolean skipTo(int target) throws IOException {\n    if (df >= skipInterval) {                      // optimized case\n\n      if (skipStream == null)\n        skipStream = (IndexInput) freqStream.clone(); // lazily clone\n\n      if (!haveSkipped) {                          // lazily seek skip stream\n        skipStream.seek(skipPointer);\n        haveSkipped = true;\n      }\n\n      // scan skip data\n      int lastSkipDoc = skipDoc;\n      int lastPayloadLength = 0;\n      long lastFreqPointer = freqStream.getFilePointer();\n      long lastProxPointer = -1;\n      int numSkipped = -1 - (count % skipInterval);\n\n      while (target > skipDoc) {\n        lastSkipDoc = skipDoc;\n        lastFreqPointer = freqPointer;\n        lastProxPointer = proxPointer;\n        lastPayloadLength = payloadLengthAtLastSkip;\n        \n        if (skipDoc != 0 && skipDoc >= doc)\n          numSkipped += skipInterval;\n        \n        if(skipCount >= numSkips)\n          break;\n\n        if (currentFieldStoresPayloads) {\n          // the current field stores payloads.\n          // if the doc delta is odd then we have\n          // to read the current payload length\n          // because it differs from the length of the\n          // previous payload\n          int delta = skipStream.readVInt();\n          if ((delta & 1) != 0) {\n            payloadLengthAtLastSkip = skipStream.readVInt();\n          }\n          delta >>>= 1;\n          skipDoc += delta;\n        } else {\n          skipDoc += skipStream.readVInt();\n        }\n        freqPointer += skipStream.readVInt();\n        proxPointer += skipStream.readVInt();\n\n        skipCount++;\n      }\n      \n      // if we found something to skip, then skip it\n      if (lastFreqPointer > freqStream.getFilePointer()) {\n        freqStream.seek(lastFreqPointer);\n        skipProx(lastProxPointer, lastPayloadLength);\n\n        doc = lastSkipDoc;\n        count += numSkipped;\n      }\n\n    }\n\n    // done skipping, now just scan\n    do {\n      if (!next())\n        return false;\n    } while (target > doc);\n    return true;\n  }\n\n","sourceOld":"  /** Optimized implementation. */\n  public boolean skipTo(int target) throws IOException {\n    if (df >= skipInterval) {                      // optimized case\n\n      if (skipStream == null)\n        skipStream = (IndexInput) freqStream.clone(); // lazily clone\n\n      if (!haveSkipped) {                          // lazily seek skip stream\n        skipStream.seek(skipPointer);\n        haveSkipped = true;\n      }\n\n      // scan skip data\n      int lastSkipDoc = skipDoc;\n      long lastFreqPointer = freqStream.getFilePointer();\n      long lastProxPointer = -1;\n      int numSkipped = -1 - (count % skipInterval);\n\n      while (target > skipDoc) {\n        lastSkipDoc = skipDoc;\n        lastFreqPointer = freqPointer;\n        lastProxPointer = proxPointer;\n        \n        if (skipDoc != 0 && skipDoc >= doc)\n          numSkipped += skipInterval;\n        \n        if(skipCount >= numSkips)\n          break;\n\n        skipDoc += skipStream.readVInt();\n        freqPointer += skipStream.readVInt();\n        proxPointer += skipStream.readVInt();\n\n        skipCount++;\n      }\n      \n      // if we found something to skip, then skip it\n      if (lastFreqPointer > freqStream.getFilePointer()) {\n        freqStream.seek(lastFreqPointer);\n        skipProx(lastProxPointer);\n\n        doc = lastSkipDoc;\n        count += numSkipped;\n      }\n\n    }\n\n    // done skipping, now just scan\n    do {\n      if (!next())\n        return false;\n    } while (target > doc);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08d1ee9808e270c86ce5c9be08b8bd7a19d0a709","date":1180597733,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentTermDocs#skipTo(int).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentTermDocs#skipTo(int).mjava","sourceNew":"  /** Optimized implementation. */\n  public boolean skipTo(int target) throws IOException {\n    if (df >= skipInterval) {                      // optimized case\n      if (skipListReader == null)\n        skipListReader = new DefaultSkipListReader((IndexInput) freqStream.clone(), maxSkipLevels, skipInterval); // lazily clone\n\n      if (!haveSkipped) {                          // lazily initialize skip stream\n        skipListReader.init(skipPointer, freqBasePointer, proxBasePointer, df, currentFieldStoresPayloads);\n        haveSkipped = true;\n      }\n\n      int newCount = skipListReader.skipTo(target); \n      if (newCount > count) {\n        freqStream.seek(skipListReader.getFreqPointer());\n        skipProx(skipListReader.getProxPointer(), skipListReader.getPayloadLength());\n\n        doc = skipListReader.getDoc();\n        count = newCount;\n      }      \n    }\n\n    // done skipping, now just scan\n    do {\n      if (!next())\n        return false;\n    } while (target > doc);\n    return true;\n  }\n\n","sourceOld":"  /** Optimized implementation. */\n  public boolean skipTo(int target) throws IOException {\n    if (df >= skipInterval) {                      // optimized case\n\n      if (skipStream == null)\n        skipStream = (IndexInput) freqStream.clone(); // lazily clone\n\n      if (!haveSkipped) {                          // lazily seek skip stream\n        skipStream.seek(skipPointer);\n        haveSkipped = true;\n      }\n\n      // scan skip data\n      int lastSkipDoc = skipDoc;\n      int lastPayloadLength = 0;\n      long lastFreqPointer = freqStream.getFilePointer();\n      long lastProxPointer = -1;\n      int numSkipped = -1 - (count % skipInterval);\n\n      while (target > skipDoc) {\n        lastSkipDoc = skipDoc;\n        lastFreqPointer = freqPointer;\n        lastProxPointer = proxPointer;\n        lastPayloadLength = payloadLengthAtLastSkip;\n        \n        if (skipDoc != 0 && skipDoc >= doc)\n          numSkipped += skipInterval;\n        \n        if(skipCount >= numSkips)\n          break;\n\n        if (currentFieldStoresPayloads) {\n          // the current field stores payloads.\n          // if the doc delta is odd then we have\n          // to read the current payload length\n          // because it differs from the length of the\n          // previous payload\n          int delta = skipStream.readVInt();\n          if ((delta & 1) != 0) {\n            payloadLengthAtLastSkip = skipStream.readVInt();\n          }\n          delta >>>= 1;\n          skipDoc += delta;\n        } else {\n          skipDoc += skipStream.readVInt();\n        }\n        freqPointer += skipStream.readVInt();\n        proxPointer += skipStream.readVInt();\n\n        skipCount++;\n      }\n      \n      // if we found something to skip, then skip it\n      if (lastFreqPointer > freqStream.getFilePointer()) {\n        freqStream.seek(lastFreqPointer);\n        skipProx(lastProxPointer, lastPayloadLength);\n\n        doc = lastSkipDoc;\n        count += numSkipped;\n      }\n\n    }\n\n    // done skipping, now just scan\n    do {\n      if (!next())\n        return false;\n    } while (target > doc);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentTermDocs#skipTo(int).mjava","pathOld":"src/java/org/apache/lucene/index/SegmentTermDocs#skipTo(int).mjava","sourceNew":"  /** Optimized implementation. */\n  public boolean skipTo(int target) throws IOException {\n    if (df >= skipInterval) {                      // optimized case\n      if (skipListReader == null)\n        skipListReader = new DefaultSkipListReader((IndexInput) freqStream.clone(), maxSkipLevels, skipInterval); // lazily clone\n\n      if (!haveSkipped) {                          // lazily initialize skip stream\n        skipListReader.init(skipPointer, freqBasePointer, proxBasePointer, df, currentFieldStoresPayloads);\n        haveSkipped = true;\n      }\n\n      int newCount = skipListReader.skipTo(target); \n      if (newCount > count) {\n        freqStream.seek(skipListReader.getFreqPointer());\n        skipProx(skipListReader.getProxPointer(), skipListReader.getPayloadLength());\n\n        doc = skipListReader.getDoc();\n        count = newCount;\n      }      \n    }\n\n    // done skipping, now just scan\n    do {\n      if (!next())\n        return false;\n    } while (target > doc);\n    return true;\n  }\n\n","sourceOld":"  /** Optimized implementation. */\n  public boolean skipTo(int target) throws IOException {\n    if (df >= skipInterval) {                      // optimized case\n      if (skipListReader == null)\n        skipListReader = new DefaultSkipListReader((IndexInput) freqStream.clone(), maxSkipLevels, skipInterval); // lazily clone\n\n      if (!haveSkipped) {                          // lazily initialize skip stream\n        skipListReader.init(skipPointer, freqBasePointer, proxBasePointer, df, currentFieldStoresPayloads);\n        haveSkipped = true;\n      }\n\n      int newCount = skipListReader.skipTo(target); \n      if (newCount > count) {\n        freqStream.seek(skipListReader.getFreqPointer());\n        skipProx(skipListReader.getProxPointer(), skipListReader.getPayloadLength());\n\n        doc = skipListReader.getDoc();\n        count = newCount;\n      }      \n    }\n\n    // done skipping, now just scan\n    do {\n      if (!next())\n        return false;\n    } while (target > doc);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"eafd816608011f66422f3052c37962973582d12a":["e7fb6d70db034a5456ae560175dd1b821eea9ff4"],"e971ba25509e21a130fef61f0687be0446ca27a0":["eafd816608011f66422f3052c37962973582d12a"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e7fb6d70db034a5456ae560175dd1b821eea9ff4":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"8522ae207a56c6db28ca06fe6cc33e70911c3600":["e971ba25509e21a130fef61f0687be0446ca27a0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["08d1ee9808e270c86ce5c9be08b8bd7a19d0a709"],"08d1ee9808e270c86ce5c9be08b8bd7a19d0a709":["8522ae207a56c6db28ca06fe6cc33e70911c3600"]},"commit2Childs":{"eafd816608011f66422f3052c37962973582d12a":["e971ba25509e21a130fef61f0687be0446ca27a0"],"e971ba25509e21a130fef61f0687be0446ca27a0":["8522ae207a56c6db28ca06fe6cc33e70911c3600"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["e7fb6d70db034a5456ae560175dd1b821eea9ff4"],"e7fb6d70db034a5456ae560175dd1b821eea9ff4":["eafd816608011f66422f3052c37962973582d12a"],"8522ae207a56c6db28ca06fe6cc33e70911c3600":["08d1ee9808e270c86ce5c9be08b8bd7a19d0a709"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"08d1ee9808e270c86ce5c9be08b8bd7a19d0a709":["9454a6510e2db155fb01faa5c049b06ece95fab9"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}