{"path":"lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase#testThreadSafety().mjava","commits":[{"id":"c15a75016387504d70a40cba6e9314b8885307f0","date":1397542349,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase#testThreadSafety().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/store/TestDirectory#testThreadSafety().mjava","sourceNew":"  // test is occasionally very slow, i dont know why\n  // try this seed: 7D7E036AD12927F5:93333EF9E6DE44DE\n  @Nightly\n  public void testThreadSafety() throws Exception {\n    final Directory raw = getDirectory(createTempDir(\"testThreadSafety\"));\n    final BaseDirectoryWrapper dir = newDirectory(raw);\n    dir.setCheckIndexOnClose(false); // we arent making an index\n    if (dir instanceof MockDirectoryWrapper) {\n      ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER); // makes this test really slow\n    }\n    \n    if (VERBOSE) {\n      System.out.println(dir);\n    }\n\n    class TheThread extends Thread {\n      private String name;\n\n      public TheThread(String name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        for (int i = 0; i < 3000; i++) {\n          String fileName = this.name + i;\n          try {\n            //System.out.println(\"create:\" + fileName);\n            IndexOutput output = dir.createOutput(fileName, newIOContext(random()));\n            output.close();\n            assertTrue(slowFileExists(dir, fileName));\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    };\n    \n    class TheThread2 extends Thread {\n      private String name;\n\n      public TheThread2(String name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        for (int i = 0; i < 10000; i++) {\n          try {\n            String[] files = dir.listAll();\n            for (String file : files) {\n              //System.out.println(\"file:\" + file);\n             try {\n              IndexInput input = dir.openInput(file, newIOContext(random()));\n              input.close();\n              } catch (FileNotFoundException | NoSuchFileException e) {\n                // ignore\n              } catch (IOException e) {\n                if (e.getMessage().contains(\"still open for writing\")) {\n                  // ignore\n                } else {\n                  throw new RuntimeException(e);\n                }\n              }\n              if (random().nextBoolean()) {\n                break;\n              }\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    };\n    \n    TheThread theThread = new TheThread(\"t1\");\n    TheThread2 theThread2 = new TheThread2(\"t2\");\n    theThread.start();\n    theThread2.start();\n    \n    theThread.join();\n    theThread2.join();\n    \n    dir.close();\n    raw.close();\n  }\n\n","sourceOld":"  // test is occasionally very slow, i dont know why\n  // try this seed: 7D7E036AD12927F5:93333EF9E6DE44DE\n  @Nightly\n  public void testThreadSafety() throws Exception {\n    final BaseDirectoryWrapper dir = newDirectory();\n    dir.setCheckIndexOnClose(false); // we arent making an index\n    if (dir instanceof MockDirectoryWrapper) {\n      ((MockDirectoryWrapper)dir).setThrottling(Throttling.NEVER); // makes this test really slow\n    }\n    \n    if (VERBOSE) {\n      System.out.println(dir);\n    }\n\n    class TheThread extends Thread {\n      private String name;\n\n      public TheThread(String name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        for (int i = 0; i < 3000; i++) {\n          String fileName = this.name + i;\n          try {\n            //System.out.println(\"create:\" + fileName);\n            IndexOutput output = dir.createOutput(fileName, newIOContext(random()));\n            output.close();\n            assertTrue(slowFileExists(dir, fileName));\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    };\n    \n    class TheThread2 extends Thread {\n      private String name;\n\n      public TheThread2(String name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        for (int i = 0; i < 10000; i++) {\n          try {\n            String[] files = dir.listAll();\n            for (String file : files) {\n              //System.out.println(\"file:\" + file);\n             try {\n              IndexInput input = dir.openInput(file, newIOContext(random()));\n              input.close();\n              } catch (FileNotFoundException | NoSuchFileException e) {\n                // ignore\n              } catch (IOException e) {\n                if (e.getMessage().contains(\"still open for writing\")) {\n                  // ignore\n                } else {\n                  throw new RuntimeException(e);\n                }\n              }\n              if (random().nextBoolean()) {\n                break;\n              }\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    };\n    \n    TheThread theThread = new TheThread(\"t1\");\n    TheThread2 theThread2 = new TheThread2(\"t2\");\n    theThread.start();\n    theThread2.start();\n    \n    theThread.join();\n    theThread2.join();\n    \n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2b4f556b82db31fb563c4d6c44604ac6c92017a8","date":1397571871,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase#testThreadSafety().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = getDirectory(createTempDir(\"testThreadSafety\"));\n    if (dir instanceof BaseDirectoryWrapper) {\n      ((BaseDirectoryWrapper)dir).setCheckIndexOnClose(false); // we arent making an index\n    }\n    if (dir instanceof MockDirectoryWrapper) {\n      ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER); // makes this test really slow\n    }\n    \n    if (VERBOSE) {\n      System.out.println(dir);\n    }\n\n    class TheThread extends Thread {\n      private String name;\n\n      public TheThread(String name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        for (int i = 0; i < 3000; i++) {\n          String fileName = this.name + i;\n          try {\n            //System.out.println(\"create:\" + fileName);\n            IndexOutput output = dir.createOutput(fileName, newIOContext(random()));\n            output.close();\n            assertTrue(slowFileExists(dir, fileName));\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    };\n    \n    class TheThread2 extends Thread {\n      private String name;\n      private volatile boolean stop;\n\n      public TheThread2(String name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        while (stop == false) {\n          try {\n            String[] files = dir.listAll();\n            for (String file : files) {\n              //System.out.println(\"file:\" + file);\n             try {\n              IndexInput input = dir.openInput(file, newIOContext(random()));\n              input.close();\n              } catch (FileNotFoundException | NoSuchFileException e) {\n                // ignore\n              } catch (IOException e) {\n                if (e.getMessage() != null && e.getMessage().contains(\"still open for writing\")) {\n                  // ignore\n                } else {\n                  throw new RuntimeException(e);\n                }\n              }\n              if (random().nextBoolean()) {\n                break;\n              }\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    };\n    \n    TheThread theThread = new TheThread(\"t1\");\n    TheThread2 theThread2 = new TheThread2(\"t2\");\n    theThread.start();\n    theThread2.start();\n    \n    theThread.join();\n    \n    // after first thread is done, no sense in waiting on thread 2 \n    // to listFiles() and loop over and over\n    theThread2.stop = true;\n    theThread2.join();\n    \n    dir.close();\n  }\n\n","sourceOld":"  // test is occasionally very slow, i dont know why\n  // try this seed: 7D7E036AD12927F5:93333EF9E6DE44DE\n  @Nightly\n  public void testThreadSafety() throws Exception {\n    final Directory raw = getDirectory(createTempDir(\"testThreadSafety\"));\n    final BaseDirectoryWrapper dir = newDirectory(raw);\n    dir.setCheckIndexOnClose(false); // we arent making an index\n    if (dir instanceof MockDirectoryWrapper) {\n      ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER); // makes this test really slow\n    }\n    \n    if (VERBOSE) {\n      System.out.println(dir);\n    }\n\n    class TheThread extends Thread {\n      private String name;\n\n      public TheThread(String name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        for (int i = 0; i < 3000; i++) {\n          String fileName = this.name + i;\n          try {\n            //System.out.println(\"create:\" + fileName);\n            IndexOutput output = dir.createOutput(fileName, newIOContext(random()));\n            output.close();\n            assertTrue(slowFileExists(dir, fileName));\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    };\n    \n    class TheThread2 extends Thread {\n      private String name;\n\n      public TheThread2(String name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        for (int i = 0; i < 10000; i++) {\n          try {\n            String[] files = dir.listAll();\n            for (String file : files) {\n              //System.out.println(\"file:\" + file);\n             try {\n              IndexInput input = dir.openInput(file, newIOContext(random()));\n              input.close();\n              } catch (FileNotFoundException | NoSuchFileException e) {\n                // ignore\n              } catch (IOException e) {\n                if (e.getMessage().contains(\"still open for writing\")) {\n                  // ignore\n                } else {\n                  throw new RuntimeException(e);\n                }\n              }\n              if (random().nextBoolean()) {\n                break;\n              }\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    };\n    \n    TheThread theThread = new TheThread(\"t1\");\n    TheThread2 theThread2 = new TheThread2(\"t2\");\n    theThread.start();\n    theThread2.start();\n    \n    theThread.join();\n    theThread2.join();\n    \n    dir.close();\n    raw.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6a2469c81a34d38d9edbf0763494a526e29db0a","date":1417052082,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase#testThreadSafety().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = getDirectory(createTempDir(\"testThreadSafety\"));\n    if (dir instanceof BaseDirectoryWrapper) {\n      ((BaseDirectoryWrapper)dir).setCheckIndexOnClose(false); // we arent making an index\n    }\n    if (dir instanceof MockDirectoryWrapper) {\n      ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER); // makes this test really slow\n    }\n    \n    if (VERBOSE) {\n      System.out.println(dir);\n    }\n\n    class TheThread extends Thread {\n      private String name;\n\n      public TheThread(String name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        for (int i = 0; i < 1000; i++) {\n          String fileName = this.name + i;\n          try {\n            //System.out.println(\"create:\" + fileName);\n            IndexOutput output = dir.createOutput(fileName, newIOContext(random()));\n            output.close();\n            assertTrue(slowFileExists(dir, fileName));\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    };\n    \n    class TheThread2 extends Thread {\n      private String name;\n      private volatile boolean stop;\n\n      public TheThread2(String name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        while (stop == false) {\n          try {\n            String[] files = dir.listAll();\n            for (String file : files) {\n              //System.out.println(\"file:\" + file);\n             try {\n              IndexInput input = dir.openInput(file, newIOContext(random()));\n              input.close();\n              } catch (FileNotFoundException | NoSuchFileException e) {\n                // ignore\n              } catch (IOException e) {\n                if (e.getMessage() != null && e.getMessage().contains(\"still open for writing\")) {\n                  // ignore\n                } else {\n                  throw new RuntimeException(e);\n                }\n              }\n              if (random().nextBoolean()) {\n                break;\n              }\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    };\n    \n    TheThread theThread = new TheThread(\"t1\");\n    TheThread2 theThread2 = new TheThread2(\"t2\");\n    theThread.start();\n    theThread2.start();\n    \n    theThread.join();\n    \n    // after first thread is done, no sense in waiting on thread 2 \n    // to listFiles() and loop over and over\n    theThread2.stop = true;\n    theThread2.join();\n    \n    dir.close();\n  }\n\n","sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = getDirectory(createTempDir(\"testThreadSafety\"));\n    if (dir instanceof BaseDirectoryWrapper) {\n      ((BaseDirectoryWrapper)dir).setCheckIndexOnClose(false); // we arent making an index\n    }\n    if (dir instanceof MockDirectoryWrapper) {\n      ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER); // makes this test really slow\n    }\n    \n    if (VERBOSE) {\n      System.out.println(dir);\n    }\n\n    class TheThread extends Thread {\n      private String name;\n\n      public TheThread(String name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        for (int i = 0; i < 3000; i++) {\n          String fileName = this.name + i;\n          try {\n            //System.out.println(\"create:\" + fileName);\n            IndexOutput output = dir.createOutput(fileName, newIOContext(random()));\n            output.close();\n            assertTrue(slowFileExists(dir, fileName));\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    };\n    \n    class TheThread2 extends Thread {\n      private String name;\n      private volatile boolean stop;\n\n      public TheThread2(String name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        while (stop == false) {\n          try {\n            String[] files = dir.listAll();\n            for (String file : files) {\n              //System.out.println(\"file:\" + file);\n             try {\n              IndexInput input = dir.openInput(file, newIOContext(random()));\n              input.close();\n              } catch (FileNotFoundException | NoSuchFileException e) {\n                // ignore\n              } catch (IOException e) {\n                if (e.getMessage() != null && e.getMessage().contains(\"still open for writing\")) {\n                  // ignore\n                } else {\n                  throw new RuntimeException(e);\n                }\n              }\n              if (random().nextBoolean()) {\n                break;\n              }\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    };\n    \n    TheThread theThread = new TheThread(\"t1\");\n    TheThread2 theThread2 = new TheThread2(\"t2\");\n    theThread.start();\n    theThread2.start();\n    \n    theThread.join();\n    \n    // after first thread is done, no sense in waiting on thread 2 \n    // to listFiles() and loop over and over\n    theThread2.stop = true;\n    theThread2.join();\n    \n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22989c36ff05c657df26dd3377b37c9ad35859bc","date":1424477375,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase#testThreadSafety().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase#testThreadSafety().mjava","sourceNew":"  public void testThreadSafety() throws Exception {\n    final Directory dir = getDirectory(createTempDir(\"testThreadSafety\"));\n    if (dir instanceof BaseDirectoryWrapper) {\n      ((BaseDirectoryWrapper)dir).setCheckIndexOnClose(false); // we arent making an index\n    }\n    if (dir instanceof MockDirectoryWrapper) {\n      ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER); // makes this test really slow\n    }\n    \n    if (VERBOSE) {\n      System.out.println(dir);\n    }\n\n    class TheThread extends Thread {\n      private String name;\n\n      public TheThread(String name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        for (int i = 0; i < 1000; i++) {\n          String fileName = this.name + i;\n          try {\n            //System.out.println(\"create:\" + fileName);\n            IndexOutput output = dir.createOutput(fileName, newIOContext(random()));\n            output.close();\n            assertTrue(slowFileExists(dir, fileName));\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    };\n    \n    class TheThread2 extends Thread {\n      private String name;\n      private volatile boolean stop;\n\n      public TheThread2(String name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        while (stop == false) {\n          try {\n            String[] files = dir.listAll();\n            for (String file : files) {\n              if (!file.startsWith(name)) {\n                continue;\n              }\n              //System.out.println(\"file:\" + file);\n             try {\n              IndexInput input = dir.openInput(file, newIOContext(random()));\n              input.close();\n              } catch (FileNotFoundException | NoSuchFileException e) {\n                // ignore\n              } catch (IOException e) {\n                if (e.getMessage() != null && e.getMessage().contains(\"still open for writing\")) {\n                  // ignore\n                } else {\n                  throw new RuntimeException(e);\n                }\n              }\n              if (random().nextBoolean()) {\n                break;\n              }\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    };\n    \n    TheThread theThread = new TheThread(\"t1\");\n    TheThread2 theThread2 = new TheThread2(\"t2\");\n    theThread.start();\n    theThread2.start();\n    \n    theThread.join();\n    \n    // after first thread is done, no sense in waiting on thread 2 \n    // to listFiles() and loop over and over\n    theThread2.stop = true;\n    theThread2.join();\n    \n    dir.close();\n  }\n\n","sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = getDirectory(createTempDir(\"testThreadSafety\"));\n    if (dir instanceof BaseDirectoryWrapper) {\n      ((BaseDirectoryWrapper)dir).setCheckIndexOnClose(false); // we arent making an index\n    }\n    if (dir instanceof MockDirectoryWrapper) {\n      ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER); // makes this test really slow\n    }\n    \n    if (VERBOSE) {\n      System.out.println(dir);\n    }\n\n    class TheThread extends Thread {\n      private String name;\n\n      public TheThread(String name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        for (int i = 0; i < 1000; i++) {\n          String fileName = this.name + i;\n          try {\n            //System.out.println(\"create:\" + fileName);\n            IndexOutput output = dir.createOutput(fileName, newIOContext(random()));\n            output.close();\n            assertTrue(slowFileExists(dir, fileName));\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    };\n    \n    class TheThread2 extends Thread {\n      private String name;\n      private volatile boolean stop;\n\n      public TheThread2(String name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        while (stop == false) {\n          try {\n            String[] files = dir.listAll();\n            for (String file : files) {\n              //System.out.println(\"file:\" + file);\n             try {\n              IndexInput input = dir.openInput(file, newIOContext(random()));\n              input.close();\n              } catch (FileNotFoundException | NoSuchFileException e) {\n                // ignore\n              } catch (IOException e) {\n                if (e.getMessage() != null && e.getMessage().contains(\"still open for writing\")) {\n                  // ignore\n                } else {\n                  throw new RuntimeException(e);\n                }\n              }\n              if (random().nextBoolean()) {\n                break;\n              }\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    };\n    \n    TheThread theThread = new TheThread(\"t1\");\n    TheThread2 theThread2 = new TheThread2(\"t2\");\n    theThread.start();\n    theThread2.start();\n    \n    theThread.join();\n    \n    // after first thread is done, no sense in waiting on thread 2 \n    // to listFiles() and loop over and over\n    theThread2.stop = true;\n    theThread2.join();\n    \n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f3adea0022cffaaa592081efed775a7b8bf86b51","date":1532414870,"type":4,"author":"Dawid Weiss","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase#testThreadSafety().mjava","sourceNew":null,"sourceOld":"  public void testThreadSafety() throws Exception {\n    final Directory dir = getDirectory(createTempDir(\"testThreadSafety\"));\n    if (dir instanceof BaseDirectoryWrapper) {\n      ((BaseDirectoryWrapper)dir).setCheckIndexOnClose(false); // we arent making an index\n    }\n    if (dir instanceof MockDirectoryWrapper) {\n      ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER); // makes this test really slow\n    }\n    \n    if (VERBOSE) {\n      System.out.println(dir);\n    }\n\n    class TheThread extends Thread {\n      private String name;\n\n      public TheThread(String name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        for (int i = 0; i < 1000; i++) {\n          String fileName = this.name + i;\n          try {\n            //System.out.println(\"create:\" + fileName);\n            IndexOutput output = dir.createOutput(fileName, newIOContext(random()));\n            output.close();\n            assertTrue(slowFileExists(dir, fileName));\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    };\n    \n    class TheThread2 extends Thread {\n      private String name;\n      private volatile boolean stop;\n\n      public TheThread2(String name) {\n        this.name = name;\n      }\n      \n      @Override\n      public void run() {\n        while (stop == false) {\n          try {\n            String[] files = dir.listAll();\n            for (String file : files) {\n              if (!file.startsWith(name)) {\n                continue;\n              }\n              //System.out.println(\"file:\" + file);\n             try {\n              IndexInput input = dir.openInput(file, newIOContext(random()));\n              input.close();\n              } catch (FileNotFoundException | NoSuchFileException e) {\n                // ignore\n              } catch (IOException e) {\n                if (e.getMessage() != null && e.getMessage().contains(\"still open for writing\")) {\n                  // ignore\n                } else {\n                  throw new RuntimeException(e);\n                }\n              }\n              if (random().nextBoolean()) {\n                break;\n              }\n            }\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n    };\n    \n    TheThread theThread = new TheThread(\"t1\");\n    TheThread2 theThread2 = new TheThread2(\"t2\");\n    theThread.start();\n    theThread2.start();\n    \n    theThread.join();\n    \n    // after first thread is done, no sense in waiting on thread 2 \n    // to listFiles() and loop over and over\n    theThread2.stop = true;\n    theThread2.join();\n    \n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c6a2469c81a34d38d9edbf0763494a526e29db0a":["2b4f556b82db31fb563c4d6c44604ac6c92017a8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c15a75016387504d70a40cba6e9314b8885307f0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"22989c36ff05c657df26dd3377b37c9ad35859bc":["c6a2469c81a34d38d9edbf0763494a526e29db0a"],"2b4f556b82db31fb563c4d6c44604ac6c92017a8":["c15a75016387504d70a40cba6e9314b8885307f0"],"f3adea0022cffaaa592081efed775a7b8bf86b51":["22989c36ff05c657df26dd3377b37c9ad35859bc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f3adea0022cffaaa592081efed775a7b8bf86b51"]},"commit2Childs":{"c6a2469c81a34d38d9edbf0763494a526e29db0a":["22989c36ff05c657df26dd3377b37c9ad35859bc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c15a75016387504d70a40cba6e9314b8885307f0"],"c15a75016387504d70a40cba6e9314b8885307f0":["2b4f556b82db31fb563c4d6c44604ac6c92017a8"],"22989c36ff05c657df26dd3377b37c9ad35859bc":["f3adea0022cffaaa592081efed775a7b8bf86b51"],"2b4f556b82db31fb563c4d6c44604ac6c92017a8":["c6a2469c81a34d38d9edbf0763494a526e29db0a"],"f3adea0022cffaaa592081efed775a7b8bf86b51":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}