{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","commits":[{"id":"fb0345a2d45479f891041f8b3ce351bc975e64ac","date":1462708700,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"/dev/null","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(1000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      // nocommit do some deletions\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true);\n      EarlyTerminatingSortingCollector c3 = new EarlyTerminatingSortingCollector(c2, sort, numHits);\n      s2.search(new MatchAllDocsQuery(), c3);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6116503eb8c6efc9f1adafe5e5dd5d8060d465f8","date":1462708991,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(1000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true);\n      EarlyTerminatingSortingCollector c3 = new EarlyTerminatingSortingCollector(c2, sort, numHits);\n      s2.search(new MatchAllDocsQuery(), c3);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(1000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      // nocommit do some deletions\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true);\n      EarlyTerminatingSortingCollector c3 = new EarlyTerminatingSortingCollector(c2, sort, numHits);\n      s2.search(new MatchAllDocsQuery(), c3);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5e03940e6e9044943de4b7ac08f8581da37a9534","date":1462870173,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(10000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true);\n      EarlyTerminatingSortingCollector c3 = new EarlyTerminatingSortingCollector(c2, sort, numHits);\n      s2.search(new MatchAllDocsQuery(), c3);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(1000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true);\n      EarlyTerminatingSortingCollector c3 = new EarlyTerminatingSortingCollector(c2, sort, numHits);\n      s2.search(new MatchAllDocsQuery(), c3);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d33e731a93d4b57e662ff094f64f94a745422d4","date":1463128289,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"/dev/null","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(10000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true);\n      EarlyTerminatingSortingCollector c3 = new EarlyTerminatingSortingCollector(c2, sort, numHits);\n      s2.search(new MatchAllDocsQuery(), c3);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"/dev/null","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(10000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true);\n      EarlyTerminatingSortingCollector c3 = new EarlyTerminatingSortingCollector(c2, sort, numHits);\n      s2.search(new MatchAllDocsQuery(), c3);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"/dev/null","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(10000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true);\n      EarlyTerminatingSortingCollector c3 = new EarlyTerminatingSortingCollector(c2, sort, numHits);\n      s2.search(new MatchAllDocsQuery(), c3);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9dea8da13fd1a227ae1071e8f4ce66bff42174de","date":1471439735,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(1000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true);\n      EarlyTerminatingSortingCollector c3 = new EarlyTerminatingSortingCollector(c2, sort, numHits);\n      s2.search(new MatchAllDocsQuery(), c3);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(10000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true);\n      EarlyTerminatingSortingCollector c3 = new EarlyTerminatingSortingCollector(c2, sort, numHits);\n      s2.search(new MatchAllDocsQuery(), c3);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","date":1471496851,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(1000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true);\n      EarlyTerminatingSortingCollector c3 = new EarlyTerminatingSortingCollector(c2, sort, numHits);\n      s2.search(new MatchAllDocsQuery(), c3);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(10000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true);\n      EarlyTerminatingSortingCollector c3 = new EarlyTerminatingSortingCollector(c2, sort, numHits);\n      s2.search(new MatchAllDocsQuery(), c3);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"403d05f7f8d69b65659157eff1bc1d2717f04c66","date":1471692961,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(1000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true);\n      EarlyTerminatingSortingCollector c3 = new EarlyTerminatingSortingCollector(c2, sort, numHits);\n      s2.search(new MatchAllDocsQuery(), c3);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(10000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true);\n      EarlyTerminatingSortingCollector c3 = new EarlyTerminatingSortingCollector(c2, sort, numHits);\n      s2.search(new MatchAllDocsQuery(), c3);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"/dev/null","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(1000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true);\n      EarlyTerminatingSortingCollector c3 = new EarlyTerminatingSortingCollector(c2, sort, numHits);\n      s2.search(new MatchAllDocsQuery(), c3);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e065cebbdee472a02bde38052717a8cd7ee8ab3b","date":1479244971,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(1000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true);\n      EarlyTerminatingSortingCollector c3 = new EarlyTerminatingSortingCollector(c2, sort, numHits);\n      s2.search(new MatchAllDocsQuery(), c3);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(1000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true);\n      EarlyTerminatingSortingCollector c3 = new EarlyTerminatingSortingCollector(c2, sort, numHits);\n      s2.search(new MatchAllDocsQuery(), c3);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1ef55e1fff7ff44354432770ad8bc19be1fcc75","date":1479266056,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(1000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true);\n      EarlyTerminatingSortingCollector c3 = new EarlyTerminatingSortingCollector(c2, sort, numHits);\n      s2.search(new MatchAllDocsQuery(), c3);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(1000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true);\n      EarlyTerminatingSortingCollector c3 = new EarlyTerminatingSortingCollector(c2, sort, numHits);\n      s2.search(new MatchAllDocsQuery(), c3);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"404d1ab7f6f396235047017c88d545fec15dafb7","date":1511975378,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(1000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(1000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true);\n      EarlyTerminatingSortingCollector c3 = new EarlyTerminatingSortingCollector(c2, sort, numHits);\n      s2.search(new MatchAllDocsQuery(), c3);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(1000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(1000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true);\n      EarlyTerminatingSortingCollector c3 = new EarlyTerminatingSortingCollector(c2, sort, numHits);\n      s2.search(new MatchAllDocsQuery(), c3);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee1c874cf5797465f29805797e8dc5232b87b72f","date":1523122154,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(1000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa62115b9e45c213699273acb13af242762232e4","date":1523184285,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs;\n    if (TEST_NIGHTLY) {\n      numDocs = atLeast(100000);\n    } else {\n      numDocs = atLeast(1000);\n    }\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3c9595c75582a7ea7efb585014102ed83f2d9c8b","date":1523581112,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","sourceNew":"  // pits index time sorting against query time sorting\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 09-Apr-2018\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b87d1f8719d7f05be003f3477450b74af13706a","date":1523590376,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","sourceNew":"  // pits index time sorting against query time sorting\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 09-Apr-2018\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"002966bc568705b0552a145efeca1b68b6fdfd98","date":1523888644,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":"  // pits index time sorting against query time sorting\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 09-Apr-2018\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertTrue(hits2.totalHits <= hits1.totalHits);\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04c370507e5521b2eb998530736f1c19b851ed5a","date":1531911305,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d3f7ab1a502671bbdb03bcced21e764d2483221","date":1532329609,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits.value);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits.value);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe3c6364bed04a73ad0884b05401d80ce96027a9","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, Integer.MAX_VALUE);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, 1);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits.value);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits.value);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, false);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits.value);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits.value);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"773bf150032d3ef6c95997a154fb914b82875cb8","date":1590150786,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexSorting#testRandom3().mjava","sourceNew":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n        System.out.println(\"  mvf=\" + Arrays.toString(docValues.floatValues));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, Integer.MAX_VALUE);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, 1);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits.value);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits.value);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","sourceOld":"  // pits index time sorting against query time sorting\n  public void testRandom3() throws Exception {\n    int numDocs = atLeast(1000);\n    List<RandomDoc> docs = new ArrayList<>();\n\n    Sort sort = randomSort();\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs + \" use sort=\" + sort);\n    }\n\n    // no index sorting, all search-time sorting:\n    Directory dir1 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc1 = newIndexWriterConfig(new MockAnalyzer(random()));\n    IndexWriter w1 = new IndexWriter(dir1, iwc1);\n\n    // use index sorting:\n    Directory dir2 = newFSDirectory(createTempDir());\n    IndexWriterConfig iwc2 = newIndexWriterConfig(new MockAnalyzer(random()));\n    iwc2.setIndexSort(sort);\n    IndexWriter w2 = new IndexWriter(dir2, iwc2);\n\n    Set<Integer> toDelete = new HashSet<>();\n\n    double deleteChance = random().nextDouble();\n\n    for(int id=0;id<numDocs;id++) {\n      RandomDoc docValues = new RandomDoc(id);\n      docs.add(docValues);\n      if (VERBOSE) {\n        System.out.println(\"TEST: doc id=\" + id);\n        System.out.println(\"  int=\" + docValues.intValue);\n        System.out.println(\"  long=\" + docValues.longValue);\n        System.out.println(\"  float=\" + docValues.floatValue);\n        System.out.println(\"  double=\" + docValues.doubleValue);\n        System.out.println(\"  bytes=\" + new BytesRef(docValues.bytesValue));\n      }\n\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", Integer.toString(id), Field.Store.YES));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      doc.add(new NumericDocValuesField(\"int\", docValues.intValue));\n      doc.add(new NumericDocValuesField(\"long\", docValues.longValue));\n      doc.add(new DoubleDocValuesField(\"double\", docValues.doubleValue));\n      doc.add(new FloatDocValuesField(\"float\", docValues.floatValue));\n      doc.add(new SortedDocValuesField(\"bytes\", new BytesRef(docValues.bytesValue)));\n\n      for (int value : docValues.intValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_int\", value));\n      }\n\n      for (long value : docValues.longValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_long\", value));\n      }\n\n      for (float value : docValues.floatValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_float\", NumericUtils.floatToSortableInt(value)));\n      }\n\n      for (double value : docValues.doubleValues) {\n        doc.add(new SortedNumericDocValuesField(\"multi_valued_double\", NumericUtils.doubleToSortableLong(value)));\n      }\n\n      for (byte[] value : docValues.bytesValues) {\n        doc.add(new SortedSetDocValuesField(\"multi_valued_bytes\", new BytesRef(value)));\n      }\n\n      w1.addDocument(doc);\n      w2.addDocument(doc);\n      if (random().nextDouble() < deleteChance) {\n        toDelete.add(id);\n      }\n    }\n    for(int id : toDelete) {\n      w1.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n      w2.deleteDocuments(new Term(\"id\", Integer.toString(id)));\n    }\n    DirectoryReader r1 = DirectoryReader.open(w1);\n    IndexSearcher s1 = newSearcher(r1);\n\n    if (random().nextBoolean()) {\n      int maxSegmentCount = TestUtil.nextInt(random(), 1, 5);\n      if (VERBOSE) {\n        System.out.println(\"TEST: now forceMerge(\" + maxSegmentCount + \")\");\n      }\n      w2.forceMerge(maxSegmentCount);\n    }\n\n    DirectoryReader r2 = DirectoryReader.open(w2);\n    IndexSearcher s2 = newSearcher(r2);\n\n    /*\n    System.out.println(\"TEST: full index:\");\n    SortedDocValues docValues = MultiDocValues.getSortedValues(r2, \"bytes\");\n    for(int i=0;i<r2.maxDoc();i++) {\n      System.out.println(\"  doc \" + i + \" id=\" + r2.document(i).get(\"id\") + \" bytes=\" + docValues.get(i));\n    }\n    */\n\n    for(int iter=0;iter<100;iter++) {\n      int numHits = TestUtil.nextInt(random(), 1, numDocs);\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + iter + \" numHits=\" + numHits);\n      }\n\n      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, Integer.MAX_VALUE);\n      s1.search(new MatchAllDocsQuery(), c1);\n      TopDocs hits1 = c1.topDocs();\n\n      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, 1);\n      s2.search(new MatchAllDocsQuery(), c2);\n\n      TopDocs hits2 = c2.topDocs();\n\n      if (VERBOSE) {\n        System.out.println(\"  topDocs query-time sort: totalHits=\" + hits1.totalHits.value);\n        for(ScoreDoc scoreDoc : hits1.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n        System.out.println(\"  topDocs index-time sort: totalHits=\" + hits2.totalHits.value);\n        for(ScoreDoc scoreDoc : hits2.scoreDocs) {\n          System.out.println(\"    \" + scoreDoc.doc);\n        }\n      }\n\n      assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);\n      for(int i=0;i<hits2.scoreDocs.length;i++) {\n        ScoreDoc hit1 = hits1.scoreDocs[i];\n        ScoreDoc hit2 = hits2.scoreDocs[i];\n        assertEquals(r1.document(hit1.doc).get(\"id\"), r2.document(hit2.doc).get(\"id\"));\n        assertArrayEquals(((FieldDoc) hit1).fields, ((FieldDoc) hit2).fields);\n      }\n    }\n\n    IOUtils.close(r1, r2, w1, w2, dir1, dir2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6116503eb8c6efc9f1adafe5e5dd5d8060d465f8":["fb0345a2d45479f891041f8b3ce351bc975e64ac"],"3c9595c75582a7ea7efb585014102ed83f2d9c8b":["aa62115b9e45c213699273acb13af242762232e4"],"04c370507e5521b2eb998530736f1c19b851ed5a":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"0ad30c6a479e764150a3316e57263319775f1df2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3d33e731a93d4b57e662ff094f64f94a745422d4"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["d470c8182e92b264680e34081b75e70a9f2b3c89","9dea8da13fd1a227ae1071e8f4ce66bff42174de"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0ad30c6a479e764150a3316e57263319775f1df2"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["e065cebbdee472a02bde38052717a8cd7ee8ab3b","404d1ab7f6f396235047017c88d545fec15dafb7"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["002966bc568705b0552a145efeca1b68b6fdfd98","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"773bf150032d3ef6c95997a154fb914b82875cb8":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"002966bc568705b0552a145efeca1b68b6fdfd98":["6b87d1f8719d7f05be003f3477450b74af13706a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"83788ad129a5154d5c6562c4e8ce3db48793aada":["1d3f7ab1a502671bbdb03bcced21e764d2483221"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["d470c8182e92b264680e34081b75e70a9f2b3c89","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"aa62115b9e45c213699273acb13af242762232e4":["1aad05eeff7818b0833c02ac6b743aa72054963b","ee1c874cf5797465f29805797e8dc5232b87b72f"],"404d1ab7f6f396235047017c88d545fec15dafb7":["e065cebbdee472a02bde38052717a8cd7ee8ab3b"],"e065cebbdee472a02bde38052717a8cd7ee8ab3b":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"9dea8da13fd1a227ae1071e8f4ce66bff42174de":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"ee1c874cf5797465f29805797e8dc5232b87b72f":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","403d05f7f8d69b65659157eff1bc1d2717f04c66"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["04c370507e5521b2eb998530736f1c19b851ed5a"],"fb0345a2d45479f891041f8b3ce351bc975e64ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6b87d1f8719d7f05be003f3477450b74af13706a":["aa62115b9e45c213699273acb13af242762232e4","3c9595c75582a7ea7efb585014102ed83f2d9c8b"],"a1ef55e1fff7ff44354432770ad8bc19be1fcc75":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e065cebbdee472a02bde38052717a8cd7ee8ab3b"],"5e03940e6e9044943de4b7ac08f8581da37a9534":["6116503eb8c6efc9f1adafe5e5dd5d8060d465f8"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["002966bc568705b0552a145efeca1b68b6fdfd98"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5e03940e6e9044943de4b7ac08f8581da37a9534"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["773bf150032d3ef6c95997a154fb914b82875cb8"]},"commit2Childs":{"6116503eb8c6efc9f1adafe5e5dd5d8060d465f8":["5e03940e6e9044943de4b7ac08f8581da37a9534"],"3c9595c75582a7ea7efb585014102ed83f2d9c8b":["6b87d1f8719d7f05be003f3477450b74af13706a"],"04c370507e5521b2eb998530736f1c19b851ed5a":["1d3f7ab1a502671bbdb03bcced21e764d2483221"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","403d05f7f8d69b65659157eff1bc1d2717f04c66","9dea8da13fd1a227ae1071e8f4ce66bff42174de"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["aa62115b9e45c213699273acb13af242762232e4","ee1c874cf5797465f29805797e8dc5232b87b72f"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0ad30c6a479e764150a3316e57263319775f1df2","d470c8182e92b264680e34081b75e70a9f2b3c89","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","fb0345a2d45479f891041f8b3ce351bc975e64ac","3d33e731a93d4b57e662ff094f64f94a745422d4"],"002966bc568705b0552a145efeca1b68b6fdfd98":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"773bf150032d3ef6c95997a154fb914b82875cb8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["773bf150032d3ef6c95997a154fb914b82875cb8"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["e065cebbdee472a02bde38052717a8cd7ee8ab3b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"aa62115b9e45c213699273acb13af242762232e4":["3c9595c75582a7ea7efb585014102ed83f2d9c8b","6b87d1f8719d7f05be003f3477450b74af13706a"],"404d1ab7f6f396235047017c88d545fec15dafb7":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"e065cebbdee472a02bde38052717a8cd7ee8ab3b":["1aad05eeff7818b0833c02ac6b743aa72054963b","404d1ab7f6f396235047017c88d545fec15dafb7","a1ef55e1fff7ff44354432770ad8bc19be1fcc75"],"9dea8da13fd1a227ae1071e8f4ce66bff42174de":["2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"ee1c874cf5797465f29805797e8dc5232b87b72f":["aa62115b9e45c213699273acb13af242762232e4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a1ef55e1fff7ff44354432770ad8bc19be1fcc75"],"fb0345a2d45479f891041f8b3ce351bc975e64ac":["6116503eb8c6efc9f1adafe5e5dd5d8060d465f8"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"6b87d1f8719d7f05be003f3477450b74af13706a":["002966bc568705b0552a145efeca1b68b6fdfd98"],"a1ef55e1fff7ff44354432770ad8bc19be1fcc75":[],"5e03940e6e9044943de4b7ac08f8581da37a9534":["3d33e731a93d4b57e662ff094f64f94a745422d4"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["04c370507e5521b2eb998530736f1c19b851ed5a","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["0ad30c6a479e764150a3316e57263319775f1df2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","a1ef55e1fff7ff44354432770ad8bc19be1fcc75","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}