{"path":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","commits":[{"id":"83acba3fc55d3d2b4a83237a4592325ac077f3dc","date":1359721016,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","pathOld":"/dev/null","sourceNew":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<BytesRef>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRef ref = new BytesRef();\n      for (int i = 0; i < numValues; i++) {\n        final String value = _TestUtil.randomRealisticUnicodeString(random(),\n            maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref);\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        pool.readBytes(ref, position, expected.length);\n        assertEquals(expected, ref);\n        position += ref.length;\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  } \n\n","sourceOld":null,"bugFix":null,"bugIntro":["22f56bf98bcc4bbd169ab6c3d65b65d9f84d8e57","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2b3cc2f5fa15326949acef967166394fb5b4a5e8","date":1359739263,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","sourceNew":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<BytesRef>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRef ref = new BytesRef();\n      for (int i = 0; i < numValues; i++) {\n        final String value = _TestUtil.randomRealisticUnicodeString(random(),\n            maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref);\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        ref.grow(expected.length);\n        ref.length = expected.length;\n        pool.readBytes(position, ref.bytes, ref.offset, ref.length);\n        assertEquals(expected, ref);\n        position += ref.length;\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  } \n\n","sourceOld":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<BytesRef>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRef ref = new BytesRef();\n      for (int i = 0; i < numValues; i++) {\n        final String value = _TestUtil.randomRealisticUnicodeString(random(),\n            maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref);\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        pool.readBytes(ref, position, expected.length);\n        assertEquals(expected, ref);\n        position += ref.length;\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  } \n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","pathOld":"/dev/null","sourceNew":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<BytesRef>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRef ref = new BytesRef();\n      for (int i = 0; i < numValues; i++) {\n        final String value = _TestUtil.randomRealisticUnicodeString(random(),\n            maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref);\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        ref.grow(expected.length);\n        ref.length = expected.length;\n        pool.readBytes(position, ref.bytes, ref.offset, ref.length);\n        assertEquals(expected, ref);\n        position += ref.length;\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  } \n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","sourceNew":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<BytesRef>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRef ref = new BytesRef();\n      for (int i = 0; i < numValues; i++) {\n        final String value = TestUtil.randomRealisticUnicodeString(random(),\n            maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref);\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        ref.grow(expected.length);\n        ref.length = expected.length;\n        pool.readBytes(position, ref.bytes, ref.offset, ref.length);\n        assertEquals(expected, ref);\n        position += ref.length;\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  } \n\n","sourceOld":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<BytesRef>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRef ref = new BytesRef();\n      for (int i = 0; i < numValues; i++) {\n        final String value = _TestUtil.randomRealisticUnicodeString(random(),\n            maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref);\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        ref.grow(expected.length);\n        ref.length = expected.length;\n        pool.readBytes(position, ref.bytes, ref.offset, ref.length);\n        assertEquals(expected, ref);\n        position += ref.length;\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  } \n\n","bugFix":null,"bugIntro":["22f56bf98bcc4bbd169ab6c3d65b65d9f84d8e57"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","sourceNew":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRef ref = new BytesRef();\n      for (int i = 0; i < numValues; i++) {\n        final String value = TestUtil.randomRealisticUnicodeString(random(),\n            maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref);\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        ref.grow(expected.length);\n        ref.length = expected.length;\n        pool.readBytes(position, ref.bytes, ref.offset, ref.length);\n        assertEquals(expected, ref);\n        position += ref.length;\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  } \n\n","sourceOld":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<BytesRef>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRef ref = new BytesRef();\n      for (int i = 0; i < numValues; i++) {\n        final String value = TestUtil.randomRealisticUnicodeString(random(),\n            maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref);\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        ref.grow(expected.length);\n        ref.length = expected.length;\n        pool.readBytes(position, ref.bytes, ref.offset, ref.length);\n        assertEquals(expected, ref);\n        position += ref.length;\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","sourceNew":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRefBuilder ref = new BytesRefBuilder();\n      for (int i = 0; i < numValues; i++) {\n        final String value = TestUtil.randomRealisticUnicodeString(random(),\n            maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref.get());\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        ref.grow(expected.length);\n        ref.setLength(expected.length);\n        pool.readBytes(position, ref.bytes(), 0, ref.length());\n        assertEquals(expected, ref.get());\n        position += ref.length();\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  } \n\n","sourceOld":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRef ref = new BytesRef();\n      for (int i = 0; i < numValues; i++) {\n        final String value = TestUtil.randomRealisticUnicodeString(random(),\n            maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref);\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        ref.grow(expected.length);\n        ref.length = expected.length;\n        pool.readBytes(position, ref.bytes, ref.offset, ref.length);\n        assertEquals(expected, ref);\n        position += ref.length;\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  } \n\n","bugFix":["83acba3fc55d3d2b4a83237a4592325ac077f3dc","2b3cc2f5fa15326949acef967166394fb5b4a5e8"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d561885e9bb6238af1ff8afe8630dcfe49b66ac7","date":1469780634,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","sourceNew":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRefBuilder ref = new BytesRefBuilder();\n      for (int i = 0; i < numValues; i++) {\n        final String value = TestUtil.randomRealisticUnicodeString(random(),\n            maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref.get());\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        ref.grow(expected.length);\n        ref.setLength(expected.length);\n        if (random().nextBoolean()) {\n          pool.readBytes(position, ref.bytes(), 0, ref.length());\n        } else {\n          for (int i = 0; i < ref.length(); ++i) {\n            ref.setByteAt(i, pool.readByte(position + i));\n          }\n        }\n        assertEquals(expected, ref.get());\n        position += ref.length();\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  } \n\n","sourceOld":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRefBuilder ref = new BytesRefBuilder();\n      for (int i = 0; i < numValues; i++) {\n        final String value = TestUtil.randomRealisticUnicodeString(random(),\n            maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref.get());\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        ref.grow(expected.length);\n        ref.setLength(expected.length);\n        pool.readBytes(position, ref.bytes(), 0, ref.length());\n        assertEquals(expected, ref.get());\n        position += ref.length();\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a20457919db052812998f60294d17daa883ff972","date":1470227748,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","sourceNew":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRefBuilder ref = new BytesRefBuilder();\n      for (int i = 0; i < numValues; i++) {\n        final String value = TestUtil.randomRealisticUnicodeString(random(),\n            maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref.get());\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        ref.grow(expected.length);\n        ref.setLength(expected.length);\n        switch (random().nextInt(3)) {\n          case 0:\n            // copy bytes\n            pool.readBytes(position, ref.bytes(), 0, ref.length());\n            break;\n          case 1:\n            // copy bytes one by one\n            for (int i = 0; i < ref.length(); ++i) {\n              ref.setByteAt(i, pool.readByte(position + i));\n            }\n            break;\n          case 2:\n            BytesRef scratch = new BytesRef();\n            scratch.length = ref.length();\n            pool.setRawBytesRef(scratch, position);\n            System.arraycopy(scratch.bytes, scratch.offset, ref.bytes(), 0, ref.length());\n            break;\n          default:\n            fail();\n        }\n        assertEquals(expected, ref.get());\n        position += ref.length();\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  } \n\n","sourceOld":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRefBuilder ref = new BytesRefBuilder();\n      for (int i = 0; i < numValues; i++) {\n        final String value = TestUtil.randomRealisticUnicodeString(random(),\n            maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref.get());\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        ref.grow(expected.length);\n        ref.setLength(expected.length);\n        if (random().nextBoolean()) {\n          pool.readBytes(position, ref.bytes(), 0, ref.length());\n        } else {\n          for (int i = 0; i < ref.length(); ++i) {\n            ref.setByteAt(i, pool.readByte(position + i));\n          }\n        }\n        assertEquals(expected, ref.get());\n        position += ref.length();\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","sourceNew":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRefBuilder ref = new BytesRefBuilder();\n      for (int i = 0; i < numValues; i++) {\n        final String value = TestUtil.randomRealisticUnicodeString(random(),\n            maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref.get());\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        ref.grow(expected.length);\n        ref.setLength(expected.length);\n        switch (random().nextInt(3)) {\n          case 0:\n            // copy bytes\n            pool.readBytes(position, ref.bytes(), 0, ref.length());\n            break;\n          case 1:\n            // copy bytes one by one\n            for (int i = 0; i < ref.length(); ++i) {\n              ref.setByteAt(i, pool.readByte(position + i));\n            }\n            break;\n          case 2:\n            BytesRef scratch = new BytesRef();\n            scratch.length = ref.length();\n            pool.setRawBytesRef(scratch, position);\n            System.arraycopy(scratch.bytes, scratch.offset, ref.bytes(), 0, ref.length());\n            break;\n          default:\n            fail();\n        }\n        assertEquals(expected, ref.get());\n        position += ref.length();\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  } \n\n","sourceOld":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRefBuilder ref = new BytesRefBuilder();\n      for (int i = 0; i < numValues; i++) {\n        final String value = TestUtil.randomRealisticUnicodeString(random(),\n            maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref.get());\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        ref.grow(expected.length);\n        ref.setLength(expected.length);\n        pool.readBytes(position, ref.bytes(), 0, ref.length());\n        assertEquals(expected, ref.get());\n        position += ref.length();\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","sourceNew":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRefBuilder ref = new BytesRefBuilder();\n      for (int i = 0; i < numValues; i++) {\n        final String value = TestUtil.randomRealisticUnicodeString(random(),\n            maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref.get());\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        ref.grow(expected.length);\n        ref.setLength(expected.length);\n        switch (random().nextInt(3)) {\n          case 0:\n            // copy bytes\n            pool.readBytes(position, ref.bytes(), 0, ref.length());\n            break;\n          case 1:\n            // copy bytes one by one\n            for (int i = 0; i < ref.length(); ++i) {\n              ref.setByteAt(i, pool.readByte(position + i));\n            }\n            break;\n          case 2:\n            BytesRef scratch = new BytesRef();\n            scratch.length = ref.length();\n            pool.setRawBytesRef(scratch, position);\n            System.arraycopy(scratch.bytes, scratch.offset, ref.bytes(), 0, ref.length());\n            break;\n          default:\n            fail();\n        }\n        assertEquals(expected, ref.get());\n        position += ref.length();\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  } \n\n","sourceOld":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRefBuilder ref = new BytesRefBuilder();\n      for (int i = 0; i < numValues; i++) {\n        final String value = TestUtil.randomRealisticUnicodeString(random(),\n            maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref.get());\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        ref.grow(expected.length);\n        ref.setLength(expected.length);\n        pool.readBytes(position, ref.bytes(), 0, ref.length());\n        assertEquals(expected, ref.get());\n        position += ref.length();\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22f56bf98bcc4bbd169ab6c3d65b65d9f84d8e57","date":1491925651,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","sourceNew":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRefBuilder ref = new BytesRefBuilder();\n      for (int i = 0; i < numValues; i++) {\n        final String value = TestUtil.randomRealisticUnicodeString(random(), maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref.get());\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        ref.grow(expected.length);\n        ref.setLength(expected.length);\n        switch (random().nextInt(3)) {\n          case 0:\n            // copy bytes\n            pool.readBytes(position, ref.bytes(), 0, ref.length());\n            break;\n          case 1:\n            // copy bytes one by one\n            for (int i = 0; i < ref.length(); ++i) {\n              ref.setByteAt(i, pool.readByte(position + i));\n            }\n            break;\n          case 2:\n            BytesRef scratch = new BytesRef();\n            scratch.length = ref.length();\n            pool.setRawBytesRef(scratch, position);\n            System.arraycopy(scratch.bytes, scratch.offset, ref.bytes(), 0, ref.length());\n            break;\n          default:\n            fail();\n        }\n        assertEquals(expected, ref.get());\n        position += ref.length();\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  }\n\n","sourceOld":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRefBuilder ref = new BytesRefBuilder();\n      for (int i = 0; i < numValues; i++) {\n        final String value = TestUtil.randomRealisticUnicodeString(random(),\n            maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref.get());\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        ref.grow(expected.length);\n        ref.setLength(expected.length);\n        switch (random().nextInt(3)) {\n          case 0:\n            // copy bytes\n            pool.readBytes(position, ref.bytes(), 0, ref.length());\n            break;\n          case 1:\n            // copy bytes one by one\n            for (int i = 0; i < ref.length(); ++i) {\n              ref.setByteAt(i, pool.readByte(position + i));\n            }\n            break;\n          case 2:\n            BytesRef scratch = new BytesRef();\n            scratch.length = ref.length();\n            pool.setRawBytesRef(scratch, position);\n            System.arraycopy(scratch.bytes, scratch.offset, ref.bytes(), 0, ref.length());\n            break;\n          default:\n            fail();\n        }\n        assertEquals(expected, ref.get());\n        position += ref.length();\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  } \n\n","bugFix":["83acba3fc55d3d2b4a83237a4592325ac077f3dc","6613659748fe4411a7dcf85266e55db1f95f7315"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestByteBlockPool#testReadAndWrite().mjava","sourceNew":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRefBuilder ref = new BytesRefBuilder();\n      for (int i = 0; i < numValues; i++) {\n        final String value = TestUtil.randomRealisticUnicodeString(random(), maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref.get());\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        ref.grow(expected.length);\n        ref.setLength(expected.length);\n        switch (random().nextInt(3)) {\n          case 0:\n            // copy bytes\n            pool.readBytes(position, ref.bytes(), 0, ref.length());\n            break;\n          case 1:\n            // copy bytes one by one\n            for (int i = 0; i < ref.length(); ++i) {\n              ref.setByteAt(i, pool.readByte(position + i));\n            }\n            break;\n          case 2:\n            BytesRef scratch = new BytesRef();\n            scratch.length = ref.length();\n            pool.setRawBytesRef(scratch, position);\n            System.arraycopy(scratch.bytes, scratch.offset, ref.bytes(), 0, ref.length());\n            break;\n          default:\n            fail();\n        }\n        assertEquals(expected, ref.get());\n        position += ref.length();\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  }\n\n","sourceOld":"  public void testReadAndWrite() throws IOException {\n    Counter bytesUsed = Counter.newCounter();\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));\n    pool.nextBuffer();\n    boolean reuseFirst = random().nextBoolean();\n    for (int j = 0; j < 2; j++) {\n        \n      List<BytesRef> list = new ArrayList<>();\n      int maxLength = atLeast(500);\n      final int numValues = atLeast(100);\n      BytesRefBuilder ref = new BytesRefBuilder();\n      for (int i = 0; i < numValues; i++) {\n        final String value = TestUtil.randomRealisticUnicodeString(random(),\n            maxLength);\n        list.add(new BytesRef(value));\n        ref.copyChars(value);\n        pool.append(ref.get());\n      }\n      // verify\n      long position = 0;\n      for (BytesRef expected : list) {\n        ref.grow(expected.length);\n        ref.setLength(expected.length);\n        switch (random().nextInt(3)) {\n          case 0:\n            // copy bytes\n            pool.readBytes(position, ref.bytes(), 0, ref.length());\n            break;\n          case 1:\n            // copy bytes one by one\n            for (int i = 0; i < ref.length(); ++i) {\n              ref.setByteAt(i, pool.readByte(position + i));\n            }\n            break;\n          case 2:\n            BytesRef scratch = new BytesRef();\n            scratch.length = ref.length();\n            pool.setRawBytesRef(scratch, position);\n            System.arraycopy(scratch.bytes, scratch.offset, ref.bytes(), 0, ref.length());\n            break;\n          default:\n            fail();\n        }\n        assertEquals(expected, ref.get());\n        position += ref.length();\n      }\n      pool.reset(random().nextBoolean(), reuseFirst);\n      if (reuseFirst) {\n        assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE, bytesUsed.get());\n      } else {\n        assertEquals(0, bytesUsed.get());\n        pool.nextBuffer(); // prepare for next iter\n      }\n    }\n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"22f56bf98bcc4bbd169ab6c3d65b65d9f84d8e57":["a20457919db052812998f60294d17daa883ff972"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["a20457919db052812998f60294d17daa883ff972"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"2b3cc2f5fa15326949acef967166394fb5b4a5e8":["83acba3fc55d3d2b4a83237a4592325ac077f3dc"],"a20457919db052812998f60294d17daa883ff972":["d561885e9bb6238af1ff8afe8630dcfe49b66ac7"],"6613659748fe4411a7dcf85266e55db1f95f7315":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"d561885e9bb6238af1ff8afe8630dcfe49b66ac7":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","a20457919db052812998f60294d17daa883ff972"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2b3cc2f5fa15326949acef967166394fb5b4a5e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","a20457919db052812998f60294d17daa883ff972"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["22f56bf98bcc4bbd169ab6c3d65b65d9f84d8e57"],"83acba3fc55d3d2b4a83237a4592325ac077f3dc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"22f56bf98bcc4bbd169ab6c3d65b65d9f84d8e57":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"2b3cc2f5fa15326949acef967166394fb5b4a5e8":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"a20457919db052812998f60294d17daa883ff972":["22f56bf98bcc4bbd169ab6c3d65b65d9f84d8e57","54ca69905c5d9d1529286f06ab1d12c68f6c13cb","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["d561885e9bb6238af1ff8afe8630dcfe49b66ac7","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"d561885e9bb6238af1ff8afe8630dcfe49b66ac7":["a20457919db052812998f60294d17daa883ff972"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d4d69c535930b5cce125cff868d40f6373dc27d4":["6613659748fe4411a7dcf85266e55db1f95f7315"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d4d69c535930b5cce125cff868d40f6373dc27d4","83acba3fc55d3d2b4a83237a4592325ac077f3dc"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"83acba3fc55d3d2b4a83237a4592325ac077f3dc":["2b3cc2f5fa15326949acef967166394fb5b4a5e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}