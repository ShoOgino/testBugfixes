{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand,SolrInputDocument).mjava","commits":[{"id":"c5fa11bf621ab6d2af49b9e9e05dff485fec0de2","date":1342630362,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand,SolrInputDocument).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","sourceNew":"  /**\n   * @param cmd\n   * @param cloneDoc needs the version if it's assigned\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd, SolrInputDocument cloneDoc) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            cloneDoc.setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @param cmd\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand,SolrInputDocument).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * @param cmd\n   * @param cloneDoc needs the version if it's assigned\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd, SolrInputDocument cloneDoc) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            cloneDoc.setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand,SolrInputDocument).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * @param cmd\n   * @param cloneDoc needs the version if it's assigned\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd, SolrInputDocument cloneDoc) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            cloneDoc.setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e19067e820b148e8dc0b240da4f2771cf7b68252","date":1347730768,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionAdd(AddUpdateCommand,SolrInputDocument).mjava","sourceNew":"  /**\n   * @param cmd\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n        \n        boolean willDistrib = isLeader && nodes != null && nodes.size() > 0;\n        \n        SolrInputDocument clonedDoc = null;\n        if (willDistrib) {\n          clonedDoc = cmd.solrDoc.deepCopy();\n        }\n        \n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n        \n        if (willDistrib) {\n          cmd.solrDoc = clonedDoc;\n        }\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * @param cmd\n   * @param cloneDoc needs the version if it's assigned\n   * @return whether or not to drop this cmd\n   * @throws IOException\n   */\n  private boolean versionAdd(AddUpdateCommand cmd, SolrInputDocument cloneDoc) throws IOException {\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processAdd(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find any existing version in the document\n    // TODO: don't reuse update commands any more!\n    long versionOnUpdate = cmd.getVersion();\n\n    if (versionOnUpdate == 0) {\n      SolrInputField versionField = cmd.getSolrInputDocument().getField(VersionInfo.VERSION_FIELD);\n      if (versionField != null) {\n        Object o = versionField.getValue();\n        versionOnUpdate = o instanceof Number ? ((Number) o).longValue() : Long.parseLong(o.toString());\n      } else {\n        // Find the version\n        String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n        versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n      }\n    }\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        // we obtain the version when synchronized and then do the add so we can ensure that\n        // if version1 < version2 then version1 is actually added before version2.\n\n        // even if we don't store the version field, synchronizing on the bucket\n        // will enable us to know what version happened first, and thus enable\n        // realtime-get to work reliably.\n        // TODO: if versions aren't stored, do we need to set on the cmd anyway for some reason?\n        // there may be other reasons in the future for a version on the commands\n\n        boolean checkDeleteByQueries = false;\n\n        if (versionsStored) {\n\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            boolean updated = getUpdatedDocument(cmd, versionOnUpdate);\n\n            if (versionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( versionOnUpdate == foundVersion || (versionOnUpdate < 0 && foundVersion < 0) || (versionOnUpdate==1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getPrintableId() + \" expected=\" + versionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(version);\n            cmd.getSolrInputDocument().setField(VersionInfo.VERSION_FIELD, version);\n            cloneDoc.setField(VersionInfo.VERSION_FIELD, version);\n            bucket.updateHighest(version);\n          } else {\n            // The leader forwarded us this update.\n            cmd.setVersion(versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.add(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n\n              // also need to re-apply newer deleteByQuery commands\n              checkDeleteByQueries = true;\n            }\n          }\n        }\n\n        // TODO: possibly set checkDeleteByQueries as a flag on the command?\n        doLocalAdd(cmd);\n\n      }  // end synchronized (bucket)\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"aba371508186796cc6151d8223a5b4e16d02e26e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c5fa11bf621ab6d2af49b9e9e05dff485fec0de2"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c5fa11bf621ab6d2af49b9e9e05dff485fec0de2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e19067e820b148e8dc0b240da4f2771cf7b68252":["c5fa11bf621ab6d2af49b9e9e05dff485fec0de2"],"c5fa11bf621ab6d2af49b9e9e05dff485fec0de2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e19067e820b148e8dc0b240da4f2771cf7b68252"]},"commit2Childs":{"aba371508186796cc6151d8223a5b4e16d02e26e":[],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","c5fa11bf621ab6d2af49b9e9e05dff485fec0de2"],"e19067e820b148e8dc0b240da4f2771cf7b68252":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c5fa11bf621ab6d2af49b9e9e05dff485fec0de2":["aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","e19067e820b148e8dc0b240da4f2771cf7b68252"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}