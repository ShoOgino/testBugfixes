{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadSource().mjava","commits":[{"id":"e03de8487b5529b7efe527294d12d2c2afa5b6ed","date":1352486832,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadSource().mjava","pathOld":"/dev/null","sourceNew":"      @Override\n      public Source loadSource() throws IOException {\n        // nocommit todo\n        return null;\n      }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"782e2ccafc915d902cf8783903e81871f49d08b3","date":1352487519,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadSource().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadSource().mjava","sourceNew":"      @Override\n      public Source loadSource() throws IOException {\n        // nocommit todo\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        if (DocValues.isNumber(dvType)) {\n          Source source = loadDirectSource();\n          long[] values = new long[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            values[docID] = source.getInt(docID);\n          }\n          return DocValuesArraySource.forType(DocValues.Type.FIXED_INTS_64).newFromArray(values);\n        } else if (DocValues.isBytes(dvType)) {\n          // nocommit\n          return null;\n        } else if (DocValues.isSortedBytes(dvType)) {\n          // nocommit\n          return null;\n        }\n        // nocommit\n        return null;\n      }\n\n","sourceOld":"      @Override\n      public Source loadSource() throws IOException {\n        // nocommit todo\n        return null;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3df0b32deea7de1aa88a87ebd41a6d4679b3f66e","date":1352516698,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadSource().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadSource().mjava","sourceNew":"      @Override\n      public Source loadSource() throws IOException {\n        // nocommit todo\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        if (DocValues.isNumber(dvType)) {\n          Source source = loadDirectSource();\n          long[] values = new long[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            values[docID] = source.getInt(docID);\n          }\n          return DocValuesArraySource.forType(DocValues.Type.FIXED_INTS_64).newFromArray(values);\n        } else if (DocValues.isBytes(dvType)) {\n          Source source = loadDirectSource();\n          final byte[][] values = new byte[maxDoc][];\n          for(int docID=0;docID<maxDoc;docID++) {\n            BytesRef value = source.getBytes(docID, null);\n            byte[] bytes = new byte[value.length];\n            System.arraycopy(value.bytes, value.offset, bytes, 0, value.length);\n            values[docID] = bytes;\n          }\n\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef bytesIn) {\n              return new BytesRef(values[docID]);\n            }\n          };\n\n        } else if (DocValues.isSortedBytes(dvType)) {\n          // nocommit\n          return null;\n        }\n        // nocommit\n        return null;\n      }\n\n","sourceOld":"      @Override\n      public Source loadSource() throws IOException {\n        // nocommit todo\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        if (DocValues.isNumber(dvType)) {\n          Source source = loadDirectSource();\n          long[] values = new long[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            values[docID] = source.getInt(docID);\n          }\n          return DocValuesArraySource.forType(DocValues.Type.FIXED_INTS_64).newFromArray(values);\n        } else if (DocValues.isBytes(dvType)) {\n          // nocommit\n          return null;\n        } else if (DocValues.isSortedBytes(dvType)) {\n          // nocommit\n          return null;\n        }\n        // nocommit\n        return null;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a739a0e263ee8fbb9f15a2ace678e14cc7c614ec","date":1352568536,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadSource().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadSource().mjava","sourceNew":"      @Override\n      public Source loadSource() throws IOException {\n        // nocommit todo\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        if (DocValues.isNumber(dvType)) {\n          Source source = loadDirectSource();\n          long[] values = new long[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            values[docID] = source.getInt(docID);\n          }\n          return DocValuesArraySource.forType(DocValues.Type.FIXED_INTS_64).newFromArray(values);\n        } else if (DocValues.isBytes(dvType)) {\n          Source source = loadDirectSource();\n          final byte[][] values = new byte[maxDoc][];\n          for(int docID=0;docID<maxDoc;docID++) {\n            BytesRef value = source.getBytes(docID, null);\n            byte[] bytes = new byte[value.length];\n            System.arraycopy(value.bytes, value.offset, bytes, 0, value.length);\n            values[docID] = bytes;\n          }\n\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              result.bytes = values[docID];\n              result.offset = 0;\n              result.length = result.bytes.length;\n              return result;\n            }\n          };\n\n        } else if (DocValues.isSortedBytes(dvType)) {\n          SortedSource source = (SortedSource) loadDirectSource();\n          final byte[][] values = new byte[field.numValues][];\n          BytesRef scratch = new BytesRef();\n          for(int ord=0;ord<field.numValues;ord++) {\n            source.getByOrd(ord, scratch);\n            values[ord] = new byte[scratch.length];\n            System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n          }\n\n          final int[] ords = new int[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            ords[docID] = source.ord(docID);\n          }\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              return ords[docID];\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              result.bytes = values[ord];\n              result.offset = 0;\n              result.length = result.bytes.length;\n              return result;\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","sourceOld":"      @Override\n      public Source loadSource() throws IOException {\n        // nocommit todo\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        if (DocValues.isNumber(dvType)) {\n          Source source = loadDirectSource();\n          long[] values = new long[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            values[docID] = source.getInt(docID);\n          }\n          return DocValuesArraySource.forType(DocValues.Type.FIXED_INTS_64).newFromArray(values);\n        } else if (DocValues.isBytes(dvType)) {\n          Source source = loadDirectSource();\n          final byte[][] values = new byte[maxDoc][];\n          for(int docID=0;docID<maxDoc;docID++) {\n            BytesRef value = source.getBytes(docID, null);\n            byte[] bytes = new byte[value.length];\n            System.arraycopy(value.bytes, value.offset, bytes, 0, value.length);\n            values[docID] = bytes;\n          }\n\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef bytesIn) {\n              return new BytesRef(values[docID]);\n            }\n          };\n\n        } else if (DocValues.isSortedBytes(dvType)) {\n          // nocommit\n          return null;\n        }\n        // nocommit\n        return null;\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36c0f6c09668001b298edab167cfc244c906de1a","date":1352953421,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadSource().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadSource().mjava","sourceNew":"      @Override\n      public Source loadSource() throws IOException {\n        // nocommit todo\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        if (DocValues.isNumber(dvType)) {\n          Source source = loadDirectSource();\n          long[] values = new long[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            values[docID] = source.getInt(docID);\n          }\n          return DocValuesArraySource.forType(DocValues.Type.FIXED_INTS_64).newFromArray(values);\n        } else if (DocValues.isBytes(dvType)) {\n          Source source = loadDirectSource();\n          final byte[][] values = new byte[maxDoc][];\n          for(int docID=0;docID<maxDoc;docID++) {\n            // nocommit: who passes null!!!\n            BytesRef value = source.getBytes(docID, new BytesRef());\n            byte[] bytes = new byte[value.length];\n            System.arraycopy(value.bytes, value.offset, bytes, 0, value.length);\n            values[docID] = bytes;\n          }\n\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              result.bytes = values[docID];\n              result.offset = 0;\n              result.length = result.bytes.length;\n              return result;\n            }\n          };\n\n        } else if (DocValues.isSortedBytes(dvType)) {\n          SortedSource source = (SortedSource) loadDirectSource();\n          final byte[][] values = new byte[field.numValues][];\n          BytesRef scratch = new BytesRef();\n          for(int ord=0;ord<field.numValues;ord++) {\n            source.getByOrd(ord, scratch);\n            values[ord] = new byte[scratch.length];\n            System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n          }\n\n          final int[] ords = new int[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            ords[docID] = source.ord(docID);\n          }\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              return ords[docID];\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              result.bytes = values[ord];\n              result.offset = 0;\n              result.length = result.bytes.length;\n              return result;\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","sourceOld":"      @Override\n      public Source loadSource() throws IOException {\n        // nocommit todo\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        if (DocValues.isNumber(dvType)) {\n          Source source = loadDirectSource();\n          long[] values = new long[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            values[docID] = source.getInt(docID);\n          }\n          return DocValuesArraySource.forType(DocValues.Type.FIXED_INTS_64).newFromArray(values);\n        } else if (DocValues.isBytes(dvType)) {\n          Source source = loadDirectSource();\n          final byte[][] values = new byte[maxDoc][];\n          for(int docID=0;docID<maxDoc;docID++) {\n            BytesRef value = source.getBytes(docID, null);\n            byte[] bytes = new byte[value.length];\n            System.arraycopy(value.bytes, value.offset, bytes, 0, value.length);\n            values[docID] = bytes;\n          }\n\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              result.bytes = values[docID];\n              result.offset = 0;\n              result.length = result.bytes.length;\n              return result;\n            }\n          };\n\n        } else if (DocValues.isSortedBytes(dvType)) {\n          SortedSource source = (SortedSource) loadDirectSource();\n          final byte[][] values = new byte[field.numValues][];\n          BytesRef scratch = new BytesRef();\n          for(int ord=0;ord<field.numValues;ord++) {\n            source.getByOrd(ord, scratch);\n            values[ord] = new byte[scratch.length];\n            System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n          }\n\n          final int[] ords = new int[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            ords[docID] = source.ord(docID);\n          }\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              return ords[docID];\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              result.bytes = values[ord];\n              result.offset = 0;\n              result.length = result.bytes.length;\n              return result;\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a47efa78e788c0e07f09493b2dc8e027f8dc6e67","date":1352956175,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadSource().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadSource().mjava","sourceNew":"      @Override\n      public Source loadSource() throws IOException {\n        // nocommit todo\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        if (DocValues.isNumber(dvType)) {\n          Source source = loadDirectSource();\n          System.out.println(maxDoc);\n          long[] values = new long[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            values[docID] = source.getInt(docID);\n          }\n          return DocValuesArraySource.forType(DocValues.Type.FIXED_INTS_64).newFromArray(values);\n        } else if (DocValues.isBytes(dvType)) {\n          Source source = loadDirectSource();\n          final byte[][] values = new byte[maxDoc][];\n          for(int docID=0;docID<maxDoc;docID++) {\n            // nocommit: who passes null!!!\n            BytesRef value = source.getBytes(docID, new BytesRef());\n            byte[] bytes = new byte[value.length];\n            System.arraycopy(value.bytes, value.offset, bytes, 0, value.length);\n            values[docID] = bytes;\n          }\n\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              result.bytes = values[docID];\n              result.offset = 0;\n              result.length = result.bytes.length;\n              return result;\n            }\n          };\n\n        } else if (DocValues.isSortedBytes(dvType)) {\n          SortedSource source = (SortedSource) loadDirectSource();\n          final byte[][] values = new byte[field.numValues][];\n          BytesRef scratch = new BytesRef();\n          for(int ord=0;ord<field.numValues;ord++) {\n            source.getByOrd(ord, scratch);\n            values[ord] = new byte[scratch.length];\n            System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n          }\n\n          final int[] ords = new int[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            ords[docID] = source.ord(docID);\n          }\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              return ords[docID];\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              result.bytes = values[ord];\n              result.offset = 0;\n              result.length = result.bytes.length;\n              return result;\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","sourceOld":"      @Override\n      public Source loadSource() throws IOException {\n        // nocommit todo\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        if (DocValues.isNumber(dvType)) {\n          Source source = loadDirectSource();\n          long[] values = new long[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            values[docID] = source.getInt(docID);\n          }\n          return DocValuesArraySource.forType(DocValues.Type.FIXED_INTS_64).newFromArray(values);\n        } else if (DocValues.isBytes(dvType)) {\n          Source source = loadDirectSource();\n          final byte[][] values = new byte[maxDoc][];\n          for(int docID=0;docID<maxDoc;docID++) {\n            // nocommit: who passes null!!!\n            BytesRef value = source.getBytes(docID, new BytesRef());\n            byte[] bytes = new byte[value.length];\n            System.arraycopy(value.bytes, value.offset, bytes, 0, value.length);\n            values[docID] = bytes;\n          }\n\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              result.bytes = values[docID];\n              result.offset = 0;\n              result.length = result.bytes.length;\n              return result;\n            }\n          };\n\n        } else if (DocValues.isSortedBytes(dvType)) {\n          SortedSource source = (SortedSource) loadDirectSource();\n          final byte[][] values = new byte[field.numValues][];\n          BytesRef scratch = new BytesRef();\n          for(int ord=0;ord<field.numValues;ord++) {\n            source.getByOrd(ord, scratch);\n            values[ord] = new byte[scratch.length];\n            System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n          }\n\n          final int[] ords = new int[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            ords[docID] = source.ord(docID);\n          }\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              return ords[docID];\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              result.bytes = values[ord];\n              result.offset = 0;\n              result.length = result.bytes.length;\n              return result;\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e4eaed6f1c6b9414b862b32281f53ef421918dcf","date":1353000825,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadSource().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadSource().mjava","sourceNew":"      @Override\n      public Source loadSource() throws IOException {\n        // nocommit todo\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        if (DocValues.isNumber(dvType)) {\n          Source source = loadDirectSource();\n          long[] values = new long[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            values[docID] = source.getInt(docID);\n          }\n          return DocValuesArraySource.forType(DocValues.Type.FIXED_INTS_64).newFromArray(values);\n        } else if (DocValues.isBytes(dvType)) {\n          Source source = loadDirectSource();\n          final byte[][] values = new byte[maxDoc][];\n          for(int docID=0;docID<maxDoc;docID++) {\n            // nocommit: who passes null!!!\n            BytesRef value = source.getBytes(docID, new BytesRef());\n            byte[] bytes = new byte[value.length];\n            System.arraycopy(value.bytes, value.offset, bytes, 0, value.length);\n            values[docID] = bytes;\n          }\n\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              result.bytes = values[docID];\n              result.offset = 0;\n              result.length = result.bytes.length;\n              return result;\n            }\n          };\n\n        } else if (DocValues.isSortedBytes(dvType)) {\n          SortedSource source = (SortedSource) loadDirectSource();\n          final byte[][] values = new byte[field.numValues][];\n          BytesRef scratch = new BytesRef();\n          for(int ord=0;ord<field.numValues;ord++) {\n            source.getByOrd(ord, scratch);\n            values[ord] = new byte[scratch.length];\n            System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n          }\n\n          final int[] ords = new int[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            ords[docID] = source.ord(docID);\n          }\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              return ords[docID];\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              result.bytes = values[ord];\n              result.offset = 0;\n              result.length = result.bytes.length;\n              return result;\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","sourceOld":"      @Override\n      public Source loadSource() throws IOException {\n        // nocommit todo\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        if (DocValues.isNumber(dvType)) {\n          Source source = loadDirectSource();\n          System.out.println(maxDoc);\n          long[] values = new long[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            values[docID] = source.getInt(docID);\n          }\n          return DocValuesArraySource.forType(DocValues.Type.FIXED_INTS_64).newFromArray(values);\n        } else if (DocValues.isBytes(dvType)) {\n          Source source = loadDirectSource();\n          final byte[][] values = new byte[maxDoc][];\n          for(int docID=0;docID<maxDoc;docID++) {\n            // nocommit: who passes null!!!\n            BytesRef value = source.getBytes(docID, new BytesRef());\n            byte[] bytes = new byte[value.length];\n            System.arraycopy(value.bytes, value.offset, bytes, 0, value.length);\n            values[docID] = bytes;\n          }\n\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              result.bytes = values[docID];\n              result.offset = 0;\n              result.length = result.bytes.length;\n              return result;\n            }\n          };\n\n        } else if (DocValues.isSortedBytes(dvType)) {\n          SortedSource source = (SortedSource) loadDirectSource();\n          final byte[][] values = new byte[field.numValues][];\n          BytesRef scratch = new BytesRef();\n          for(int ord=0;ord<field.numValues;ord++) {\n            source.getByOrd(ord, scratch);\n            values[ord] = new byte[scratch.length];\n            System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n          }\n\n          final int[] ords = new int[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            ords[docID] = source.ord(docID);\n          }\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              return ords[docID];\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              result.bytes = values[ord];\n              result.offset = 0;\n              result.length = result.bytes.length;\n              return result;\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"737c1bba990ea3999c9cebd84ee765f8d95f29fc","date":1353002499,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadSource().mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadSource().mjava","sourceNew":"      @Override\n      public Source loadSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        if (DocValues.isNumber(dvType)) {\n          Source source = loadDirectSource();\n          long[] values = new long[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            values[docID] = source.getInt(docID);\n          }\n          return DocValuesArraySource.forType(DocValues.Type.FIXED_INTS_64).newFromArray(values);\n        } else if (DocValues.isBytes(dvType)) {\n          Source source = loadDirectSource();\n          final byte[][] values = new byte[maxDoc][];\n          for(int docID=0;docID<maxDoc;docID++) {\n            // nocommit: who passes null!!!\n            BytesRef value = source.getBytes(docID, new BytesRef());\n            byte[] bytes = new byte[value.length];\n            System.arraycopy(value.bytes, value.offset, bytes, 0, value.length);\n            values[docID] = bytes;\n          }\n\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              result.bytes = values[docID];\n              result.offset = 0;\n              result.length = result.bytes.length;\n              return result;\n            }\n          };\n\n        } else if (DocValues.isSortedBytes(dvType)) {\n          SortedSource source = (SortedSource) loadDirectSource();\n          final byte[][] values = new byte[field.numValues][];\n          BytesRef scratch = new BytesRef();\n          for(int ord=0;ord<field.numValues;ord++) {\n            source.getByOrd(ord, scratch);\n            values[ord] = new byte[scratch.length];\n            System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n          }\n\n          final int[] ords = new int[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            ords[docID] = source.ord(docID);\n          }\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              return ords[docID];\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              result.bytes = values[ord];\n              result.offset = 0;\n              result.length = result.bytes.length;\n              return result;\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","sourceOld":"      @Override\n      public Source loadSource() throws IOException {\n        // nocommit todo\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        if (DocValues.isNumber(dvType)) {\n          Source source = loadDirectSource();\n          long[] values = new long[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            values[docID] = source.getInt(docID);\n          }\n          return DocValuesArraySource.forType(DocValues.Type.FIXED_INTS_64).newFromArray(values);\n        } else if (DocValues.isBytes(dvType)) {\n          Source source = loadDirectSource();\n          final byte[][] values = new byte[maxDoc][];\n          for(int docID=0;docID<maxDoc;docID++) {\n            // nocommit: who passes null!!!\n            BytesRef value = source.getBytes(docID, new BytesRef());\n            byte[] bytes = new byte[value.length];\n            System.arraycopy(value.bytes, value.offset, bytes, 0, value.length);\n            values[docID] = bytes;\n          }\n\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              result.bytes = values[docID];\n              result.offset = 0;\n              result.length = result.bytes.length;\n              return result;\n            }\n          };\n\n        } else if (DocValues.isSortedBytes(dvType)) {\n          SortedSource source = (SortedSource) loadDirectSource();\n          final byte[][] values = new byte[field.numValues][];\n          BytesRef scratch = new BytesRef();\n          for(int ord=0;ord<field.numValues;ord++) {\n            source.getByOrd(ord, scratch);\n            values[ord] = new byte[scratch.length];\n            System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n          }\n\n          final int[] ords = new int[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            ords[docID] = source.ord(docID);\n          }\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              return ords[docID];\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              result.bytes = values[ord];\n              result.offset = 0;\n              result.length = result.bytes.length;\n              return result;\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7cd329bd749496f6c58b586a6c0dd0dc8201206f","date":1353092226,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.SimpleTextDocValuesReader.SimpleTextDocValues#loadSource().mjava","sourceNew":null,"sourceOld":"      @Override\n      public Source loadSource() throws IOException {\n        DocValues.Type dvType = field.fieldInfo.getDocValuesType();\n        if (DocValues.isNumber(dvType)) {\n          Source source = loadDirectSource();\n          long[] values = new long[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            values[docID] = source.getInt(docID);\n          }\n          return DocValuesArraySource.forType(DocValues.Type.FIXED_INTS_64).newFromArray(values);\n        } else if (DocValues.isBytes(dvType)) {\n          Source source = loadDirectSource();\n          final byte[][] values = new byte[maxDoc][];\n          for(int docID=0;docID<maxDoc;docID++) {\n            // nocommit: who passes null!!!\n            BytesRef value = source.getBytes(docID, new BytesRef());\n            byte[] bytes = new byte[value.length];\n            System.arraycopy(value.bytes, value.offset, bytes, 0, value.length);\n            values[docID] = bytes;\n          }\n\n          return new Source(dvType) {\n            @Override\n            public BytesRef getBytes(int docID, BytesRef result) {\n              result.bytes = values[docID];\n              result.offset = 0;\n              result.length = result.bytes.length;\n              return result;\n            }\n          };\n\n        } else if (DocValues.isSortedBytes(dvType)) {\n          SortedSource source = (SortedSource) loadDirectSource();\n          final byte[][] values = new byte[field.numValues][];\n          BytesRef scratch = new BytesRef();\n          for(int ord=0;ord<field.numValues;ord++) {\n            source.getByOrd(ord, scratch);\n            values[ord] = new byte[scratch.length];\n            System.arraycopy(scratch.bytes, scratch.offset, values[ord], 0, scratch.length);\n          }\n\n          final int[] ords = new int[maxDoc];\n          for(int docID=0;docID<maxDoc;docID++) {\n            ords[docID] = source.ord(docID);\n          }\n\n          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {\n            @Override\n            public int ord(int docID) {\n              return ords[docID];\n            }\n\n            @Override\n            public BytesRef getByOrd(int ord, BytesRef result) {\n              result.bytes = values[ord];\n              result.offset = 0;\n              result.length = result.bytes.length;\n              return result;\n            }\n\n            @Override\n            public int getValueCount() {\n              return field.numValues;\n            }\n\n            @Override\n            public PackedInts.Reader getDocToOrd() {\n              return null;\n            }\n          };\n\n        } else if (DocValues.isFloat(dvType)) {\n          // nocommit\n          return null;\n        } else {\n          throw new AssertionError();\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"782e2ccafc915d902cf8783903e81871f49d08b3":["e03de8487b5529b7efe527294d12d2c2afa5b6ed"],"a739a0e263ee8fbb9f15a2ace678e14cc7c614ec":["3df0b32deea7de1aa88a87ebd41a6d4679b3f66e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7cd329bd749496f6c58b586a6c0dd0dc8201206f":["737c1bba990ea3999c9cebd84ee765f8d95f29fc"],"a47efa78e788c0e07f09493b2dc8e027f8dc6e67":["36c0f6c09668001b298edab167cfc244c906de1a"],"737c1bba990ea3999c9cebd84ee765f8d95f29fc":["e4eaed6f1c6b9414b862b32281f53ef421918dcf"],"36c0f6c09668001b298edab167cfc244c906de1a":["a739a0e263ee8fbb9f15a2ace678e14cc7c614ec"],"3df0b32deea7de1aa88a87ebd41a6d4679b3f66e":["782e2ccafc915d902cf8783903e81871f49d08b3"],"e03de8487b5529b7efe527294d12d2c2afa5b6ed":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e4eaed6f1c6b9414b862b32281f53ef421918dcf":["a47efa78e788c0e07f09493b2dc8e027f8dc6e67"]},"commit2Childs":{"782e2ccafc915d902cf8783903e81871f49d08b3":["3df0b32deea7de1aa88a87ebd41a6d4679b3f66e"],"a739a0e263ee8fbb9f15a2ace678e14cc7c614ec":["36c0f6c09668001b298edab167cfc244c906de1a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e03de8487b5529b7efe527294d12d2c2afa5b6ed","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7cd329bd749496f6c58b586a6c0dd0dc8201206f":[],"a47efa78e788c0e07f09493b2dc8e027f8dc6e67":["e4eaed6f1c6b9414b862b32281f53ef421918dcf"],"737c1bba990ea3999c9cebd84ee765f8d95f29fc":["7cd329bd749496f6c58b586a6c0dd0dc8201206f"],"e03de8487b5529b7efe527294d12d2c2afa5b6ed":["782e2ccafc915d902cf8783903e81871f49d08b3"],"3df0b32deea7de1aa88a87ebd41a6d4679b3f66e":["a739a0e263ee8fbb9f15a2ace678e14cc7c614ec"],"36c0f6c09668001b298edab167cfc244c906de1a":["a47efa78e788c0e07f09493b2dc8e027f8dc6e67"],"e4eaed6f1c6b9414b862b32281f53ef421918dcf":["737c1bba990ea3999c9cebd84ee765f8d95f29fc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7cd329bd749496f6c58b586a6c0dd0dc8201206f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}