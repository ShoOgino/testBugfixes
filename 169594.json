{"path":"lucene/core/src/test/org/apache/lucene/index/TestPointValues#testBigIntNDims().mjava","commits":[{"id":"cab7a79353f33d1a94cd307bf33aa5148601ebe6","date":1453391888,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestPointValues#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDimensionalValues#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, DimensionalValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, DimensionalValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new DimensionalBinaryField(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      DimensionalValues dimValues = MultiDimensionalValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25b2820b242e28867a2f4edae536382216c511dc","date":1454059647,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPointValues#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8d15e34266d75e4e8b95da046cd0afc812367b38","date":1454246129,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPointValues#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":5,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestPointValues#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToBytes(values[dim], bytes[dim], 0, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      PointValues dimValues = MultiPointValues.get(r);\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        dimValues.intersect(\"field\", new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"25b2820b242e28867a2f4edae536382216c511dc":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["cab7a79353f33d1a94cd307bf33aa5148601ebe6","8d15e34266d75e4e8b95da046cd0afc812367b38"],"8d15e34266d75e4e8b95da046cd0afc812367b38":["cab7a79353f33d1a94cd307bf33aa5148601ebe6","25b2820b242e28867a2f4edae536382216c511dc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8d15e34266d75e4e8b95da046cd0afc812367b38"]},"commit2Childs":{"25b2820b242e28867a2f4edae536382216c511dc":["8d15e34266d75e4e8b95da046cd0afc812367b38"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["25b2820b242e28867a2f4edae536382216c511dc","1e6acbaae7af722f17204ceccf0f7db5753eccf3","8d15e34266d75e4e8b95da046cd0afc812367b38"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"8d15e34266d75e4e8b95da046cd0afc812367b38":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}