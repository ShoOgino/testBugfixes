{"path":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Values,List[Values],boolean,int).mjava","commits":[{"id":"b5c559c875836474bafae7243263d93b1b1965db","date":1289581659,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Values,List[Values],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestIndexValues#indexValues(IndexWriter,int,Values,List[Values],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Values value,\n      List<Values> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    Fieldable field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n\n    ValuesAttribute valuesAttribute = ValuesField.values(field);\n    valuesAttribute.setType(value);\n    final LongsRef intsRef = valuesAttribute.ints();\n    final FloatsRef floatsRef = valuesAttribute.floats();\n    final BytesRef bytesRef = valuesAttribute.bytes();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    // \n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n        case PACKED_INTS_FIXED:\n          intsRef.set(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          floatsRef.set(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Values val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        w.commit();\n\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize();\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Values value,\n      List<Values> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    Fieldable field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n\n    ValuesAttribute valuesAttribute = ValuesField.values(field);\n    valuesAttribute.setType(value);\n    final LongsRef intsRef = valuesAttribute.ints();\n    final FloatsRef floatsRef = valuesAttribute.floats();\n    final BytesRef bytesRef = valuesAttribute.bytes();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    // \n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n        case PACKED_INTS_FIXED:\n          intsRef.set(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          floatsRef.set(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Values val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        w.commit();\n\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize();\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23b28eea49e75cc98d5b2b3301999539352e3fdc","date":1290004199,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Values,List[Values],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Values,List[Values],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Values value,\n      List<Values> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    Fieldable field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n\n    ValuesAttribute valuesAttribute = ValuesField.values(field);\n    valuesAttribute.setType(value);\n    final LongsRef intsRef = valuesAttribute.ints();\n    final FloatsRef floatsRef = valuesAttribute.floats();\n    final BytesRef bytesRef = valuesAttribute.bytes();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n        case PACKED_INTS_FIXED:\n          intsRef.set(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          floatsRef.set(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Values val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        w.commit();\n\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize();\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Values value,\n      List<Values> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    Fieldable field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n\n    ValuesAttribute valuesAttribute = ValuesField.values(field);\n    valuesAttribute.setType(value);\n    final LongsRef intsRef = valuesAttribute.ints();\n    final FloatsRef floatsRef = valuesAttribute.floats();\n    final BytesRef bytesRef = valuesAttribute.bytes();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    // \n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n        case PACKED_INTS_FIXED:\n          intsRef.set(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          floatsRef.set(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Values val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        w.commit();\n\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize();\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2d84736c4614acce6720851cbd2c823d7cd516e4","date":1290551630,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Values,List[Values],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Values,List[Values],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Values value,\n      List<Values> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    Fieldable field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n\n    ValuesAttribute valuesAttribute = ValuesField.values(field);\n    valuesAttribute.setType(value);\n    final LongsRef intsRef = valuesAttribute.ints();\n    final FloatsRef floatsRef = valuesAttribute.floats();\n    final BytesRef bytesRef = valuesAttribute.bytes();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n          intsRef.set(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          floatsRef.set(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Values val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize();\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Values value,\n      List<Values> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    Fieldable field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n\n    ValuesAttribute valuesAttribute = ValuesField.values(field);\n    valuesAttribute.setType(value);\n    final LongsRef intsRef = valuesAttribute.ints();\n    final FloatsRef floatsRef = valuesAttribute.floats();\n    final BytesRef bytesRef = valuesAttribute.bytes();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n        case PACKED_INTS_FIXED:\n          intsRef.set(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          floatsRef.set(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Values val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        w.commit();\n\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize();\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Values,List[Values],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Values,List[Values],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Values value,\n      List<Values> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    ValuesField valField = new ValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n          valField.setInt(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          valField.setFloat(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        valField.setBytes(bytesRef, value);\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Values val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize();\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Values value,\n      List<Values> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    Fieldable field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n\n    ValuesAttribute valuesAttribute = ValuesField.values(field);\n    valuesAttribute.setType(value);\n    final LongsRef intsRef = valuesAttribute.ints();\n    final FloatsRef floatsRef = valuesAttribute.floats();\n    final BytesRef bytesRef = valuesAttribute.bytes();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n          intsRef.set(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          floatsRef.set(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Values val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize();\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":["fa0f44f887719e97183771e977cfc4bfb485b766","fa0f44f887719e97183771e977cfc4bfb485b766","fa0f44f887719e97183771e977cfc4bfb485b766"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aa2fc2eb37a1f19e90850f787d9e085950ebfa04","date":1291597075,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Type,List[Type],boolean,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing#indexValues(IndexWriter,int,Values,List[Values],boolean,int).mjava","sourceNew":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Type value,\n      List<Type> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    ValuesField valField = new ValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n          valField.setInt(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          valField.setFloat(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        valField.setBytes(bytesRef, value);\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Type val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize();\n    return deleted;\n  }\n\n","sourceOld":"  private OpenBitSet indexValues(IndexWriter w, int numValues, Values value,\n      List<Values> valueVarList, boolean withDeletions, int multOfSeven)\n      throws CorruptIndexException, IOException {\n    final boolean isNumeric = NUMERICS.contains(value);\n    OpenBitSet deleted = new OpenBitSet(numValues);\n    Document doc = new Document();\n    Index idx = IDX_VALUES[random.nextInt(IDX_VALUES.length)];\n    AbstractField field = random.nextBoolean() ? new ValuesField(value.name())\n        : newField(value.name(), _TestUtil.randomRealisticUnicodeString(random,\n            10), idx == Index.NO ? Store.YES : Store.NO, idx);\n    doc.add(field);\n    ValuesField valField = new ValuesField(\"prototype\");\n    final BytesRef bytesRef = new BytesRef();\n\n    final String idBase = value.name() + \"_\";\n    final byte[] b = new byte[multOfSeven];\n    if (bytesRef != null) {\n      bytesRef.bytes = b;\n      bytesRef.length = b.length;\n      bytesRef.offset = 0;\n    }\n    byte upto = 0;\n    for (int i = 0; i < numValues; i++) {\n      if (isNumeric) {\n        switch (value) {\n        case PACKED_INTS:\n          valField.setInt(i);\n          break;\n        case SIMPLE_FLOAT_4BYTE:\n        case SIMPLE_FLOAT_8BYTE:\n          valField.setFloat(2.0f * i);\n          break;\n        default:\n          fail(\"unexpected value \" + value);\n        }\n      } else {\n        for (int j = 0; j < b.length; j++) {\n          b[j] = upto++;\n        }\n        valField.setBytes(bytesRef, value);\n      }\n      doc.removeFields(\"id\");\n      doc.add(new Field(\"id\", idBase + i, Store.YES,\n          Index.NOT_ANALYZED_NO_NORMS));\n      valField.set(field);\n      w.addDocument(doc);\n\n      if (i % 7 == 0) {\n        if (withDeletions && random.nextBoolean()) {\n          Values val = valueVarList.get(random.nextInt(1 + valueVarList\n              .indexOf(value)));\n          final int randInt = val == value ? random.nextInt(1 + i) : random\n              .nextInt(numValues);\n          w.deleteDocuments(new Term(\"id\", val.name() + \"_\" + randInt));\n          if (val == value) {\n            deleted.set(randInt);\n          }\n        }\n        if (random.nextInt(10) == 0) {\n          w.commit();\n        }\n      }\n    }\n    w.commit();\n\n    // TODO test unoptimized with deletions\n    if (withDeletions || random.nextBoolean())\n      w.optimize();\n    return deleted;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"2d84736c4614acce6720851cbd2c823d7cd516e4":["23b28eea49e75cc98d5b2b3301999539352e3fdc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"aa2fc2eb37a1f19e90850f787d9e085950ebfa04":["3bb13258feba31ab676502787ab2e1779f129b7a"],"23b28eea49e75cc98d5b2b3301999539352e3fdc":["b5c559c875836474bafae7243263d93b1b1965db"],"3bb13258feba31ab676502787ab2e1779f129b7a":["2d84736c4614acce6720851cbd2c823d7cd516e4","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b5c559c875836474bafae7243263d93b1b1965db":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"2d84736c4614acce6720851cbd2c823d7cd516e4":["3bb13258feba31ab676502787ab2e1779f129b7a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3bb13258feba31ab676502787ab2e1779f129b7a","cd5edd1f2b162a5cfa08efd17851a07373a96817","b5c559c875836474bafae7243263d93b1b1965db"],"aa2fc2eb37a1f19e90850f787d9e085950ebfa04":[],"23b28eea49e75cc98d5b2b3301999539352e3fdc":["2d84736c4614acce6720851cbd2c823d7cd516e4"],"3bb13258feba31ab676502787ab2e1779f129b7a":["aa2fc2eb37a1f19e90850f787d9e085950ebfa04"],"b5c559c875836474bafae7243263d93b1b1965db":["23b28eea49e75cc98d5b2b3301999539352e3fdc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aa2fc2eb37a1f19e90850f787d9e085950ebfa04","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}