{"path":"lucene/core/src/java/org/apache/lucene/codecs/lucene84/ForUtil#encode(long[],int,DataOutput).mjava","commits":[{"id":"9a0cc86697753659ac5e7f55243ccdcbf44d8a36","date":1574100512,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene84/ForUtil#encode(long[],int,DataOutput).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Encode 128 integers from {@code longs} into {@code out}.\n   */\n  void encode(long[] longs, int bitsPerValue, DataOutput out) throws IOException {\n    final int nextPrimitive;\n    final int numLongs;\n    if (bitsPerValue <= 8) {\n      nextPrimitive = 8;\n      numLongs = BLOCK_SIZE / 8;\n      collapse8(longs);\n    } else if (bitsPerValue <= 16) {\n      nextPrimitive = 16;\n      numLongs = BLOCK_SIZE / 4;\n      collapse16(longs);\n    } else {\n      nextPrimitive = 32;\n      numLongs = BLOCK_SIZE / 2;\n      collapse32(longs);\n    }\n\n    final int numLongsPerShift = bitsPerValue * 2;\n    Arrays.fill(tmp, 0L);\n    int idx = 0;\n    for (int shift = nextPrimitive - bitsPerValue; shift >= 0; shift -= bitsPerValue) {\n      for (int i = 0; i < numLongsPerShift; ++i) {\n        tmp[i] |= longs[idx++] << shift;\n      }\n    }\n\n    final int remainingBitsPerLong = nextPrimitive % bitsPerValue;\n    final long maskRemainingBitsPerLong;\n    if (nextPrimitive == 8) {\n      maskRemainingBitsPerLong = mask8(remainingBitsPerLong);\n    } else if (nextPrimitive == 16) {\n      maskRemainingBitsPerLong = mask16(remainingBitsPerLong);\n    } else {\n      maskRemainingBitsPerLong = mask32(remainingBitsPerLong);\n    }\n    int tmpIdx = 0;\n    int remainingBitsPerValue = bitsPerValue;\n    while (idx < numLongs) {\n      if (remainingBitsPerValue > remainingBitsPerLong) {\n        remainingBitsPerValue -= remainingBitsPerLong;\n        tmp[tmpIdx++] |= (longs[idx] >>> remainingBitsPerValue) & maskRemainingBitsPerLong;\n        if (remainingBitsPerValue == 0) {\n          idx++;\n          remainingBitsPerValue = bitsPerValue;\n        }\n      } else {\n        final long mask1, mask2;\n        if (nextPrimitive == 8) {\n          mask1 = mask8(remainingBitsPerValue);\n          mask2 = mask8(remainingBitsPerLong - remainingBitsPerValue);\n        } else if (nextPrimitive == 16) {\n          mask1 = mask16(remainingBitsPerValue);\n          mask2 = mask16(remainingBitsPerLong - remainingBitsPerValue);\n        } else {\n          mask1 = mask32(remainingBitsPerValue);\n          mask2 = mask32(remainingBitsPerLong - remainingBitsPerValue);\n        }\n        tmp[tmpIdx] |= (longs[idx++] & mask1) << (remainingBitsPerLong - remainingBitsPerValue);\n        remainingBitsPerValue = bitsPerValue - remainingBitsPerLong + remainingBitsPerValue;\n        tmp[tmpIdx++] |= (longs[idx] >>> remainingBitsPerValue) & mask2;\n      }\n    }\n\n    for (int i = 0; i < numLongsPerShift; ++i) {\n      // Java longs are big endian and we want to read little endian longs, so we need to reverse bytes\n      long l = Long.reverseBytes(tmp[i]);\n      out.writeLong(l);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3270c8036d92f23d84b526bdcb07d645d3102eb7","date":1574438988,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene84/ForUtil#encode(long[],int,DataOutput).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene84/ForUtil#encode(long[],int,DataOutput).mjava","sourceNew":"  /**\n   * Encode 128 integers from {@code longs} into {@code out}.\n   */\n  void encode(long[] longs, int bitsPerValue, DataOutput out) throws IOException {\n    final int nextPrimitive;\n    final int numLongs;\n    if (bitsPerValue <= 8) {\n      nextPrimitive = 8;\n      numLongs = BLOCK_SIZE / 8;\n      collapse8(longs);\n    } else if (bitsPerValue <= 16) {\n      nextPrimitive = 16;\n      numLongs = BLOCK_SIZE / 4;\n      collapse16(longs);\n    } else {\n      nextPrimitive = 32;\n      numLongs = BLOCK_SIZE / 2;\n      collapse32(longs);\n    }\n\n    final int numLongsPerShift = bitsPerValue * 2;\n    int idx = 0;\n    int shift = nextPrimitive - bitsPerValue;\n    for (int i = 0; i < numLongsPerShift; ++i) {\n      tmp[i] = longs[idx++] << shift;\n    }\n    for (shift = shift - bitsPerValue; shift >= 0; shift -= bitsPerValue) {\n      for (int i = 0; i < numLongsPerShift; ++i) {\n        tmp[i] |= longs[idx++] << shift;\n      }\n    }\n\n    final int remainingBitsPerLong = shift + bitsPerValue;\n    final long maskRemainingBitsPerLong;\n    if (nextPrimitive == 8) {\n      maskRemainingBitsPerLong = mask8(remainingBitsPerLong);\n    } else if (nextPrimitive == 16) {\n      maskRemainingBitsPerLong = mask16(remainingBitsPerLong);\n    } else {\n      maskRemainingBitsPerLong = mask32(remainingBitsPerLong);\n    }\n\n    int tmpIdx = 0;\n    int remainingBitsPerValue = bitsPerValue;\n    while (idx < numLongs) {\n      if (remainingBitsPerValue > remainingBitsPerLong) {\n        remainingBitsPerValue -= remainingBitsPerLong;\n        tmp[tmpIdx++] |= (longs[idx] >>> remainingBitsPerValue) & maskRemainingBitsPerLong;\n        if (remainingBitsPerValue == 0) {\n          idx++;\n          remainingBitsPerValue = bitsPerValue;\n        }\n      } else {\n        final long mask1, mask2;\n        if (nextPrimitive == 8) {\n          mask1 = mask8(remainingBitsPerValue);\n          mask2 = mask8(remainingBitsPerLong - remainingBitsPerValue);\n        } else if (nextPrimitive == 16) {\n          mask1 = mask16(remainingBitsPerValue);\n          mask2 = mask16(remainingBitsPerLong - remainingBitsPerValue);\n        } else {\n          mask1 = mask32(remainingBitsPerValue);\n          mask2 = mask32(remainingBitsPerLong - remainingBitsPerValue);\n        }\n        tmp[tmpIdx] |= (longs[idx++] & mask1) << (remainingBitsPerLong - remainingBitsPerValue);\n        remainingBitsPerValue = bitsPerValue - remainingBitsPerLong + remainingBitsPerValue;\n        tmp[tmpIdx++] |= (longs[idx] >>> remainingBitsPerValue) & mask2;\n      }\n    }\n\n    for (int i = 0; i < numLongsPerShift; ++i) {\n      // Java longs are big endian and we want to read little endian longs, so we need to reverse bytes\n      long l = Long.reverseBytes(tmp[i]);\n      out.writeLong(l);\n    }\n  }\n\n","sourceOld":"  /**\n   * Encode 128 integers from {@code longs} into {@code out}.\n   */\n  void encode(long[] longs, int bitsPerValue, DataOutput out) throws IOException {\n    final int nextPrimitive;\n    final int numLongs;\n    if (bitsPerValue <= 8) {\n      nextPrimitive = 8;\n      numLongs = BLOCK_SIZE / 8;\n      collapse8(longs);\n    } else if (bitsPerValue <= 16) {\n      nextPrimitive = 16;\n      numLongs = BLOCK_SIZE / 4;\n      collapse16(longs);\n    } else {\n      nextPrimitive = 32;\n      numLongs = BLOCK_SIZE / 2;\n      collapse32(longs);\n    }\n\n    final int numLongsPerShift = bitsPerValue * 2;\n    Arrays.fill(tmp, 0L);\n    int idx = 0;\n    for (int shift = nextPrimitive - bitsPerValue; shift >= 0; shift -= bitsPerValue) {\n      for (int i = 0; i < numLongsPerShift; ++i) {\n        tmp[i] |= longs[idx++] << shift;\n      }\n    }\n\n    final int remainingBitsPerLong = nextPrimitive % bitsPerValue;\n    final long maskRemainingBitsPerLong;\n    if (nextPrimitive == 8) {\n      maskRemainingBitsPerLong = mask8(remainingBitsPerLong);\n    } else if (nextPrimitive == 16) {\n      maskRemainingBitsPerLong = mask16(remainingBitsPerLong);\n    } else {\n      maskRemainingBitsPerLong = mask32(remainingBitsPerLong);\n    }\n    int tmpIdx = 0;\n    int remainingBitsPerValue = bitsPerValue;\n    while (idx < numLongs) {\n      if (remainingBitsPerValue > remainingBitsPerLong) {\n        remainingBitsPerValue -= remainingBitsPerLong;\n        tmp[tmpIdx++] |= (longs[idx] >>> remainingBitsPerValue) & maskRemainingBitsPerLong;\n        if (remainingBitsPerValue == 0) {\n          idx++;\n          remainingBitsPerValue = bitsPerValue;\n        }\n      } else {\n        final long mask1, mask2;\n        if (nextPrimitive == 8) {\n          mask1 = mask8(remainingBitsPerValue);\n          mask2 = mask8(remainingBitsPerLong - remainingBitsPerValue);\n        } else if (nextPrimitive == 16) {\n          mask1 = mask16(remainingBitsPerValue);\n          mask2 = mask16(remainingBitsPerLong - remainingBitsPerValue);\n        } else {\n          mask1 = mask32(remainingBitsPerValue);\n          mask2 = mask32(remainingBitsPerLong - remainingBitsPerValue);\n        }\n        tmp[tmpIdx] |= (longs[idx++] & mask1) << (remainingBitsPerLong - remainingBitsPerValue);\n        remainingBitsPerValue = bitsPerValue - remainingBitsPerLong + remainingBitsPerValue;\n        tmp[tmpIdx++] |= (longs[idx] >>> remainingBitsPerValue) & mask2;\n      }\n    }\n\n    for (int i = 0; i < numLongsPerShift; ++i) {\n      // Java longs are big endian and we want to read little endian longs, so we need to reverse bytes\n      long l = Long.reverseBytes(tmp[i]);\n      out.writeLong(l);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3270c8036d92f23d84b526bdcb07d645d3102eb7":["9a0cc86697753659ac5e7f55243ccdcbf44d8a36"],"9a0cc86697753659ac5e7f55243ccdcbf44d8a36":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3270c8036d92f23d84b526bdcb07d645d3102eb7"]},"commit2Childs":{"3270c8036d92f23d84b526bdcb07d645d3102eb7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9a0cc86697753659ac5e7f55243ccdcbf44d8a36":["3270c8036d92f23d84b526bdcb07d645d3102eb7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9a0cc86697753659ac5e7f55243ccdcbf44d8a36"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}