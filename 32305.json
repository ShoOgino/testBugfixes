{"path":"lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.LinearFuzzyTermsEnum#similarity(int[],int,int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.LinearFuzzyTermsEnum#similarity(int[],int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.LinearFuzzyTermsEnum#similarity(int[],int,int).mjava","sourceNew":"    /**\n     * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n     * based on how similar the Term is compared to a target term.  It returns\n     * exactly 0.0f when\n     * <pre>\n     *    editDistance &gt; maximumEditDistance</pre>\n     * Otherwise it returns:\n     * <pre>\n     *    1 - (editDistance / length)</pre>\n     * where length is the length of the shortest term (text or target) including a\n     * prefix that are identical and editDistance is the Levenshtein distance for\n     * the two words.</p>\n     *\n     * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n     * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n     * distance algorithm in that it is aborted if it is discovered that the\n     * minimum distance between the words is greater than some threshold.\n     *\n     * <p>To calculate the maximum distance threshold we use the following formula:\n     * <pre>\n     *     (1 - minimumSimilarity) * length</pre>\n     * where length is the shortest term including any prefix that is not part of the\n     * similarity comparison.  This formula was derived by solving for what maximum value\n     * of distance returns false for the following statements:\n     * <pre>\n     *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n     *   return (similarity > minimumSimilarity);</pre>\n     * where distance is the Levenshtein distance for the two words.\n     * </p>\n     * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n     * between two strings where the distance is measured as the number of character\n     * deletions, insertions or substitutions required to transform one string to\n     * the other string.\n     * @param target the target word or phrase\n     * @return the similarity,  0.0 or less indicates that it matches less than the required\n     * threshold and 1.0 indicates that the text and target are identical\n     */\n    private final float similarity(final int[] target, int offset, int length) {\n      final int m = length;\n      final int n = text.length;\n      if (n == 0)  {\n        //we don't have anything to compare.  That means if we just add\n        //the letters for m we get the new word\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) m / realPrefixLength);\n      }\n      if (m == 0) {\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) n / realPrefixLength);\n      }\n      \n      final int maxDistance = calculateMaxDistance(m);\n      \n      if (maxDistance < Math.abs(m-n)) {\n        //just adding the characters of m to n or vice-versa results in\n        //too many edits\n        //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n        //given this optimal circumstance, the edit distance cannot be less than 5.\n        //which is 8-3 or more precisely Math.abs(3-8).\n        //if our maximum edit distance is 4, then we can discard this word\n        //without looking at it.\n        return Float.NEGATIVE_INFINITY;\n      }\n      \n      // init matrix d\n      for (int i = 0; i <=n; ++i) {\n        p[i] = i;\n      }\n      \n      // start computing edit distance\n      for (int j = 1; j<=m; ++j) { // iterates through target\n        int bestPossibleEditDistance = m;\n        final int t_j = target[offset+j-1]; // jth character of t\n        d[0] = j;\n\n        for (int i=1; i<=n; ++i) { // iterates through text\n          // minimum of cell to the left+1, to the top+1, diagonally left and up +(0|1)\n          if (t_j != text[i-1]) {\n            d[i] = Math.min(Math.min(d[i-1], p[i]),  p[i-1]) + 1;\n          } else {\n            d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]);\n          }\n          bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i]);\n        }\n\n        //After calculating row i, the best possible edit distance\n        //can be found by found by finding the smallest value in a given column.\n        //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n        if (j > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n          //the closest the target can be to the text is just too far away.\n          //this target is leaving the party early.\n          return Float.NEGATIVE_INFINITY;\n        }\n\n        // copy current distance counts to 'previous row' distance counts: swap p and d\n        int _d[] = p;\n        p = d;\n        d = _d;\n      }\n      \n      // our last action in the above loop was to switch d and p, so p now\n      // actually has the most recent cost counts\n\n      // this will return less than 0.0 when the edit distance is\n      // greater than the number of characters in the shorter word.\n      // but this was the formula that was previously used in FuzzyTermEnum,\n      // so it has not been changed (even though minimumSimilarity must be\n      // greater than 0.0)\n      return 1.0f - ((float)p[n] / (float) (realPrefixLength + Math.min(n, m)));\n    }\n\n","sourceOld":"    /**\n     * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n     * based on how similar the Term is compared to a target term.  It returns\n     * exactly 0.0f when\n     * <pre>\n     *    editDistance &gt; maximumEditDistance</pre>\n     * Otherwise it returns:\n     * <pre>\n     *    1 - (editDistance / length)</pre>\n     * where length is the length of the shortest term (text or target) including a\n     * prefix that are identical and editDistance is the Levenshtein distance for\n     * the two words.</p>\n     *\n     * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n     * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n     * distance algorithm in that it is aborted if it is discovered that the\n     * minimum distance between the words is greater than some threshold.\n     *\n     * <p>To calculate the maximum distance threshold we use the following formula:\n     * <pre>\n     *     (1 - minimumSimilarity) * length</pre>\n     * where length is the shortest term including any prefix that is not part of the\n     * similarity comparison.  This formula was derived by solving for what maximum value\n     * of distance returns false for the following statements:\n     * <pre>\n     *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n     *   return (similarity > minimumSimilarity);</pre>\n     * where distance is the Levenshtein distance for the two words.\n     * </p>\n     * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n     * between two strings where the distance is measured as the number of character\n     * deletions, insertions or substitutions required to transform one string to\n     * the other string.\n     * @param target the target word or phrase\n     * @return the similarity,  0.0 or less indicates that it matches less than the required\n     * threshold and 1.0 indicates that the text and target are identical\n     */\n    private final float similarity(final int[] target, int offset, int length) {\n      final int m = length;\n      final int n = text.length;\n      if (n == 0)  {\n        //we don't have anything to compare.  That means if we just add\n        //the letters for m we get the new word\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) m / realPrefixLength);\n      }\n      if (m == 0) {\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) n / realPrefixLength);\n      }\n      \n      final int maxDistance = calculateMaxDistance(m);\n      \n      if (maxDistance < Math.abs(m-n)) {\n        //just adding the characters of m to n or vice-versa results in\n        //too many edits\n        //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n        //given this optimal circumstance, the edit distance cannot be less than 5.\n        //which is 8-3 or more precisely Math.abs(3-8).\n        //if our maximum edit distance is 4, then we can discard this word\n        //without looking at it.\n        return Float.NEGATIVE_INFINITY;\n      }\n      \n      // init matrix d\n      for (int i = 0; i <=n; ++i) {\n        p[i] = i;\n      }\n      \n      // start computing edit distance\n      for (int j = 1; j<=m; ++j) { // iterates through target\n        int bestPossibleEditDistance = m;\n        final int t_j = target[offset+j-1]; // jth character of t\n        d[0] = j;\n\n        for (int i=1; i<=n; ++i) { // iterates through text\n          // minimum of cell to the left+1, to the top+1, diagonally left and up +(0|1)\n          if (t_j != text[i-1]) {\n            d[i] = Math.min(Math.min(d[i-1], p[i]),  p[i-1]) + 1;\n          } else {\n            d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]);\n          }\n          bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i]);\n        }\n\n        //After calculating row i, the best possible edit distance\n        //can be found by found by finding the smallest value in a given column.\n        //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n        if (j > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n          //the closest the target can be to the text is just too far away.\n          //this target is leaving the party early.\n          return Float.NEGATIVE_INFINITY;\n        }\n\n        // copy current distance counts to 'previous row' distance counts: swap p and d\n        int _d[] = p;\n        p = d;\n        d = _d;\n      }\n      \n      // our last action in the above loop was to switch d and p, so p now\n      // actually has the most recent cost counts\n\n      // this will return less than 0.0 when the edit distance is\n      // greater than the number of characters in the shorter word.\n      // but this was the formula that was previously used in FuzzyTermEnum,\n      // so it has not been changed (even though minimumSimilarity must be\n      // greater than 0.0)\n      return 1.0f - ((float)p[n] / (float) (realPrefixLength + Math.min(n, m)));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d374631bb6f5665bd5907a6186a9bb283a315f7d","date":1336345692,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/SlowFuzzyTermsEnum.LinearFuzzyTermsEnum#similarity(int[],int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.LinearFuzzyTermsEnum#similarity(int[],int,int).mjava","sourceNew":"    /**\n     * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n     * based on how similar the Term is compared to a target term.  It returns\n     * exactly 0.0f when\n     * <pre>\n     *    editDistance &gt; maximumEditDistance</pre>\n     * Otherwise it returns:\n     * <pre>\n     *    1 - (editDistance / length)</pre>\n     * where length is the length of the shortest term (text or target) including a\n     * prefix that are identical and editDistance is the Levenshtein distance for\n     * the two words.</p>\n     *\n     * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n     * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n     * distance algorithm in that it is aborted if it is discovered that the\n     * minimum distance between the words is greater than some threshold.\n     *\n     * <p>To calculate the maximum distance threshold we use the following formula:\n     * <pre>\n     *     (1 - minimumSimilarity) * length</pre>\n     * where length is the shortest term including any prefix that is not part of the\n     * similarity comparison.  This formula was derived by solving for what maximum value\n     * of distance returns false for the following statements:\n     * <pre>\n     *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n     *   return (similarity > minimumSimilarity);</pre>\n     * where distance is the Levenshtein distance for the two words.\n     * </p>\n     * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n     * between two strings where the distance is measured as the number of character\n     * deletions, insertions or substitutions required to transform one string to\n     * the other string.\n     * @param target the target word or phrase\n     * @return the similarity,  0.0 or less indicates that it matches less than the required\n     * threshold and 1.0 indicates that the text and target are identical\n     */\n    private final float similarity(final int[] target, int offset, int length) {\n      final int m = length;\n      final int n = text.length;\n      if (n == 0)  {\n        //we don't have anything to compare.  That means if we just add\n        //the letters for m we get the new word\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) m / realPrefixLength);\n      }\n      if (m == 0) {\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) n / realPrefixLength);\n      }\n      \n      final int maxDistance = calculateMaxDistance(m);\n      \n      if (maxDistance < Math.abs(m-n)) {\n        //just adding the characters of m to n or vice-versa results in\n        //too many edits\n        //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n        //given this optimal circumstance, the edit distance cannot be less than 5.\n        //which is 8-3 or more precisely Math.abs(3-8).\n        //if our maximum edit distance is 4, then we can discard this word\n        //without looking at it.\n        return Float.NEGATIVE_INFINITY;\n      }\n      \n      // init matrix d\n      for (int i = 0; i <=n; ++i) {\n        p[i] = i;\n      }\n      \n      // start computing edit distance\n      for (int j = 1; j<=m; ++j) { // iterates through target\n        int bestPossibleEditDistance = m;\n        final int t_j = target[offset+j-1]; // jth character of t\n        d[0] = j;\n\n        for (int i=1; i<=n; ++i) { // iterates through text\n          // minimum of cell to the left+1, to the top+1, diagonally left and up +(0|1)\n          if (t_j != text[i-1]) {\n            d[i] = Math.min(Math.min(d[i-1], p[i]),  p[i-1]) + 1;\n          } else {\n            d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]);\n          }\n          bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i]);\n        }\n\n        //After calculating row i, the best possible edit distance\n        //can be found by found by finding the smallest value in a given column.\n        //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n        if (j > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n          //the closest the target can be to the text is just too far away.\n          //this target is leaving the party early.\n          return Float.NEGATIVE_INFINITY;\n        }\n\n        // copy current distance counts to 'previous row' distance counts: swap p and d\n        int _d[] = p;\n        p = d;\n        d = _d;\n      }\n      \n      // our last action in the above loop was to switch d and p, so p now\n      // actually has the most recent cost counts\n\n      // this will return less than 0.0 when the edit distance is\n      // greater than the number of characters in the shorter word.\n      // but this was the formula that was previously used in FuzzyTermEnum,\n      // so it has not been changed (even though minimumSimilarity must be\n      // greater than 0.0)\n      return 1.0f - ((float)p[n] / (float) (realPrefixLength + Math.min(n, m)));\n    }\n\n","sourceOld":"    /**\n     * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n     * based on how similar the Term is compared to a target term.  It returns\n     * exactly 0.0f when\n     * <pre>\n     *    editDistance &gt; maximumEditDistance</pre>\n     * Otherwise it returns:\n     * <pre>\n     *    1 - (editDistance / length)</pre>\n     * where length is the length of the shortest term (text or target) including a\n     * prefix that are identical and editDistance is the Levenshtein distance for\n     * the two words.</p>\n     *\n     * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n     * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n     * distance algorithm in that it is aborted if it is discovered that the\n     * minimum distance between the words is greater than some threshold.\n     *\n     * <p>To calculate the maximum distance threshold we use the following formula:\n     * <pre>\n     *     (1 - minimumSimilarity) * length</pre>\n     * where length is the shortest term including any prefix that is not part of the\n     * similarity comparison.  This formula was derived by solving for what maximum value\n     * of distance returns false for the following statements:\n     * <pre>\n     *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n     *   return (similarity > minimumSimilarity);</pre>\n     * where distance is the Levenshtein distance for the two words.\n     * </p>\n     * <p>Levenshtein distance (also known as edit distance) is a measure of similarity\n     * between two strings where the distance is measured as the number of character\n     * deletions, insertions or substitutions required to transform one string to\n     * the other string.\n     * @param target the target word or phrase\n     * @return the similarity,  0.0 or less indicates that it matches less than the required\n     * threshold and 1.0 indicates that the text and target are identical\n     */\n    private final float similarity(final int[] target, int offset, int length) {\n      final int m = length;\n      final int n = text.length;\n      if (n == 0)  {\n        //we don't have anything to compare.  That means if we just add\n        //the letters for m we get the new word\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) m / realPrefixLength);\n      }\n      if (m == 0) {\n        return realPrefixLength == 0 ? 0.0f : 1.0f - ((float) n / realPrefixLength);\n      }\n      \n      final int maxDistance = calculateMaxDistance(m);\n      \n      if (maxDistance < Math.abs(m-n)) {\n        //just adding the characters of m to n or vice-versa results in\n        //too many edits\n        //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n        //given this optimal circumstance, the edit distance cannot be less than 5.\n        //which is 8-3 or more precisely Math.abs(3-8).\n        //if our maximum edit distance is 4, then we can discard this word\n        //without looking at it.\n        return Float.NEGATIVE_INFINITY;\n      }\n      \n      // init matrix d\n      for (int i = 0; i <=n; ++i) {\n        p[i] = i;\n      }\n      \n      // start computing edit distance\n      for (int j = 1; j<=m; ++j) { // iterates through target\n        int bestPossibleEditDistance = m;\n        final int t_j = target[offset+j-1]; // jth character of t\n        d[0] = j;\n\n        for (int i=1; i<=n; ++i) { // iterates through text\n          // minimum of cell to the left+1, to the top+1, diagonally left and up +(0|1)\n          if (t_j != text[i-1]) {\n            d[i] = Math.min(Math.min(d[i-1], p[i]),  p[i-1]) + 1;\n          } else {\n            d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]);\n          }\n          bestPossibleEditDistance = Math.min(bestPossibleEditDistance, d[i]);\n        }\n\n        //After calculating row i, the best possible edit distance\n        //can be found by found by finding the smallest value in a given column.\n        //If the bestPossibleEditDistance is greater than the max distance, abort.\n\n        if (j > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater\n          //the closest the target can be to the text is just too far away.\n          //this target is leaving the party early.\n          return Float.NEGATIVE_INFINITY;\n        }\n\n        // copy current distance counts to 'previous row' distance counts: swap p and d\n        int _d[] = p;\n        p = d;\n        d = _d;\n      }\n      \n      // our last action in the above loop was to switch d and p, so p now\n      // actually has the most recent cost counts\n\n      // this will return less than 0.0 when the edit distance is\n      // greater than the number of characters in the shorter word.\n      // but this was the formula that was previously used in FuzzyTermEnum,\n      // so it has not been changed (even though minimumSimilarity must be\n      // greater than 0.0)\n      return 1.0f - ((float)p[n] / (float) (realPrefixLength + Math.min(n, m)));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d374631bb6f5665bd5907a6186a9bb283a315f7d":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d374631bb6f5665bd5907a6186a9bb283a315f7d"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["d374631bb6f5665bd5907a6186a9bb283a315f7d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d374631bb6f5665bd5907a6186a9bb283a315f7d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}