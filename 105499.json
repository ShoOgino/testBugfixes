{"path":"lucene/benchmark/src/test/org/apache/lucene/benchmark/byTask/feeds/LineDocSourceTest#doIndexAndSearchTestWithRepeats(File,Class[#-extends-LineParser],int,String).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/benchmark/src/test/org/apache/lucene/benchmark/byTask/feeds/LineDocSourceTest#doIndexAndSearchTestWithRepeats(File,Class[#-extends-LineParser],int,String).mjava","pathOld":"modules/benchmark/src/test/org/apache/lucene/benchmark/byTask/feeds/LineDocSourceTest#doIndexAndSearchTestWithRepeats(File,Class[#-extends-LineParser],int,String).mjava","sourceNew":"  private void doIndexAndSearchTestWithRepeats(File file, \n      Class<? extends LineParser> lineParserClass, int numAdds, String storedField) throws Exception {\n    \n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    PerfRunData runData = null;\n    try {\n      Properties props = new Properties();\n      \n      // LineDocSource specific settings.\n      props.setProperty(\"docs.file\", file.getAbsolutePath());\n      if (lineParserClass != null) {\n        props.setProperty(\"line.parser\", lineParserClass.getName());\n      }\n      \n      // Indexing configuration.\n      props.setProperty(\"analyzer\", WhitespaceAnalyzer.class.getName());\n      props.setProperty(\"content.source\", LineDocSource.class.getName());\n      props.setProperty(\"directory\", \"RAMDirectory\");\n      props.setProperty(\"doc.stored\", \"true\");\n      props.setProperty(\"doc.index.props\", \"true\");\n      \n      // Create PerfRunData\n      Config config = new Config(props);\n      runData = new PerfRunData(config);\n\n      TaskSequence tasks = new TaskSequence(runData, \"testBzip2\", null, false);\n      tasks.addTask(new CreateIndexTask(runData));\n      for (int i=0; i<numAdds; i++) {\n        tasks.addTask(new AddDocTask(runData));\n      }\n      tasks.addTask(new CloseIndexTask(runData));\n      try {\n        tasks.doLogic();\n      } finally {\n        tasks.close(); \n      }\n      \n      reader = IndexReader.open(runData.getDirectory());\n      searcher = new IndexSearcher(reader);\n      TopDocs td = searcher.search(new TermQuery(new Term(\"body\", \"body\")), 10);\n      assertEquals(numAdds, td.totalHits);\n      assertNotNull(td.scoreDocs[0]);\n      \n      if (storedField==null) {\n        storedField = DocMaker.BODY_FIELD; // added to all docs and satisfies field-name == value\n      }\n      assertEquals(\"Wrong field value\", storedField, searcher.doc(0).get(storedField));\n    } finally {\n      IOUtils.close(reader, runData);\n    }\n\n  }\n\n","sourceOld":"  private void doIndexAndSearchTestWithRepeats(File file, \n      Class<? extends LineParser> lineParserClass, int numAdds, String storedField) throws Exception {\n    \n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    PerfRunData runData = null;\n    try {\n      Properties props = new Properties();\n      \n      // LineDocSource specific settings.\n      props.setProperty(\"docs.file\", file.getAbsolutePath());\n      if (lineParserClass != null) {\n        props.setProperty(\"line.parser\", lineParserClass.getName());\n      }\n      \n      // Indexing configuration.\n      props.setProperty(\"analyzer\", WhitespaceAnalyzer.class.getName());\n      props.setProperty(\"content.source\", LineDocSource.class.getName());\n      props.setProperty(\"directory\", \"RAMDirectory\");\n      props.setProperty(\"doc.stored\", \"true\");\n      props.setProperty(\"doc.index.props\", \"true\");\n      \n      // Create PerfRunData\n      Config config = new Config(props);\n      runData = new PerfRunData(config);\n\n      TaskSequence tasks = new TaskSequence(runData, \"testBzip2\", null, false);\n      tasks.addTask(new CreateIndexTask(runData));\n      for (int i=0; i<numAdds; i++) {\n        tasks.addTask(new AddDocTask(runData));\n      }\n      tasks.addTask(new CloseIndexTask(runData));\n      try {\n        tasks.doLogic();\n      } finally {\n        tasks.close(); \n      }\n      \n      reader = IndexReader.open(runData.getDirectory());\n      searcher = new IndexSearcher(reader);\n      TopDocs td = searcher.search(new TermQuery(new Term(\"body\", \"body\")), 10);\n      assertEquals(numAdds, td.totalHits);\n      assertNotNull(td.scoreDocs[0]);\n      \n      if (storedField==null) {\n        storedField = DocMaker.BODY_FIELD; // added to all docs and satisfies field-name == value\n      }\n      assertEquals(\"Wrong field value\", storedField, searcher.doc(0).get(storedField));\n    } finally {\n      IOUtils.close(reader, runData);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","date":1338430031,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/benchmark/src/test/org/apache/lucene/benchmark/byTask/feeds/LineDocSourceTest#doIndexAndSearchTestWithRepeats(File,Class[#-extends-LineParser],int,String).mjava","pathOld":"lucene/benchmark/src/test/org/apache/lucene/benchmark/byTask/feeds/LineDocSourceTest#doIndexAndSearchTestWithRepeats(File,Class[#-extends-LineParser],int,String).mjava","sourceNew":"  private void doIndexAndSearchTestWithRepeats(File file, \n      Class<? extends LineParser> lineParserClass, int numAdds, String storedField) throws Exception {\n    \n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    PerfRunData runData = null;\n    try {\n      Properties props = new Properties();\n      \n      // LineDocSource specific settings.\n      props.setProperty(\"docs.file\", file.getAbsolutePath());\n      if (lineParserClass != null) {\n        props.setProperty(\"line.parser\", lineParserClass.getName());\n      }\n      \n      // Indexing configuration.\n      props.setProperty(\"analyzer\", WhitespaceAnalyzer.class.getName());\n      props.setProperty(\"content.source\", LineDocSource.class.getName());\n      props.setProperty(\"directory\", \"RAMDirectory\");\n      props.setProperty(\"doc.stored\", \"true\");\n      props.setProperty(\"doc.index.props\", \"true\");\n      \n      // Create PerfRunData\n      Config config = new Config(props);\n      runData = new PerfRunData(config);\n\n      TaskSequence tasks = new TaskSequence(runData, \"testBzip2\", null, false);\n      tasks.addTask(new CreateIndexTask(runData));\n      for (int i=0; i<numAdds; i++) {\n        tasks.addTask(new AddDocTask(runData));\n      }\n      tasks.addTask(new CloseIndexTask(runData));\n      try {\n        tasks.doLogic();\n      } finally {\n        tasks.close(); \n      }\n      \n      reader = DirectoryReader.open(runData.getDirectory());\n      searcher = new IndexSearcher(reader);\n      TopDocs td = searcher.search(new TermQuery(new Term(\"body\", \"body\")), 10);\n      assertEquals(numAdds, td.totalHits);\n      assertNotNull(td.scoreDocs[0]);\n      \n      if (storedField==null) {\n        storedField = DocMaker.BODY_FIELD; // added to all docs and satisfies field-name == value\n      }\n      assertEquals(\"Wrong field value\", storedField, searcher.doc(0).get(storedField));\n    } finally {\n      IOUtils.close(reader, runData);\n    }\n\n  }\n\n","sourceOld":"  private void doIndexAndSearchTestWithRepeats(File file, \n      Class<? extends LineParser> lineParserClass, int numAdds, String storedField) throws Exception {\n    \n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    PerfRunData runData = null;\n    try {\n      Properties props = new Properties();\n      \n      // LineDocSource specific settings.\n      props.setProperty(\"docs.file\", file.getAbsolutePath());\n      if (lineParserClass != null) {\n        props.setProperty(\"line.parser\", lineParserClass.getName());\n      }\n      \n      // Indexing configuration.\n      props.setProperty(\"analyzer\", WhitespaceAnalyzer.class.getName());\n      props.setProperty(\"content.source\", LineDocSource.class.getName());\n      props.setProperty(\"directory\", \"RAMDirectory\");\n      props.setProperty(\"doc.stored\", \"true\");\n      props.setProperty(\"doc.index.props\", \"true\");\n      \n      // Create PerfRunData\n      Config config = new Config(props);\n      runData = new PerfRunData(config);\n\n      TaskSequence tasks = new TaskSequence(runData, \"testBzip2\", null, false);\n      tasks.addTask(new CreateIndexTask(runData));\n      for (int i=0; i<numAdds; i++) {\n        tasks.addTask(new AddDocTask(runData));\n      }\n      tasks.addTask(new CloseIndexTask(runData));\n      try {\n        tasks.doLogic();\n      } finally {\n        tasks.close(); \n      }\n      \n      reader = IndexReader.open(runData.getDirectory());\n      searcher = new IndexSearcher(reader);\n      TopDocs td = searcher.search(new TermQuery(new Term(\"body\", \"body\")), 10);\n      assertEquals(numAdds, td.totalHits);\n      assertNotNull(td.scoreDocs[0]);\n      \n      if (storedField==null) {\n        storedField = DocMaker.BODY_FIELD; // added to all docs and satisfies field-name == value\n      }\n      assertEquals(\"Wrong field value\", storedField, searcher.doc(0).get(storedField));\n    } finally {\n      IOUtils.close(reader, runData);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad1f7eb1a6bbf19f3d32b3baf2dee3db844eccdc","date":1366056945,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/benchmark/src/test/org/apache/lucene/benchmark/byTask/feeds/LineDocSourceTest#doIndexAndSearchTestWithRepeats(File,Class[#-extends-LineParser],int,String).mjava","pathOld":"lucene/benchmark/src/test/org/apache/lucene/benchmark/byTask/feeds/LineDocSourceTest#doIndexAndSearchTestWithRepeats(File,Class[#-extends-LineParser],int,String).mjava","sourceNew":"  private void doIndexAndSearchTestWithRepeats(File file, \n      Class<? extends LineParser> lineParserClass, int numAdds, String storedField) throws Exception {\n    \n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    PerfRunData runData = null;\n    try {\n      Properties props = new Properties();\n      \n      // LineDocSource specific settings.\n      props.setProperty(\"docs.file\", file.getAbsolutePath());\n      if (lineParserClass != null) {\n        props.setProperty(\"line.parser\", lineParserClass.getName());\n      }\n      \n      // Indexing configuration.\n      props.setProperty(\"analyzer\", WhitespaceAnalyzer.class.getName());\n      props.setProperty(\"content.source\", LineDocSource.class.getName());\n      props.setProperty(\"directory\", \"RAMDirectory\");\n      props.setProperty(\"doc.stored\", \"true\");\n      props.setProperty(\"doc.index.props\", \"true\");\n      \n      // Create PerfRunData\n      Config config = new Config(props);\n      runData = new PerfRunData(config);\n\n      TaskSequence tasks = new TaskSequence(runData, \"testBzip2\", null, false);\n      tasks.addTask(new CreateIndexTask(runData));\n      for (int i=0; i<numAdds; i++) {\n        tasks.addTask(new AddDocTask(runData));\n      }\n      tasks.addTask(new CloseIndexTask(runData));\n      try {\n        tasks.doLogic();\n      } finally {\n        tasks.close(); \n      }\n      \n      reader = DirectoryReader.open(runData.getDirectory());\n      searcher = newSearcher(reader);\n      TopDocs td = searcher.search(new TermQuery(new Term(\"body\", \"body\")), 10);\n      assertEquals(numAdds, td.totalHits);\n      assertNotNull(td.scoreDocs[0]);\n      \n      if (storedField==null) {\n        storedField = DocMaker.BODY_FIELD; // added to all docs and satisfies field-name == value\n      }\n      assertEquals(\"Wrong field value\", storedField, searcher.doc(0).get(storedField));\n    } finally {\n      IOUtils.close(reader, runData);\n    }\n\n  }\n\n","sourceOld":"  private void doIndexAndSearchTestWithRepeats(File file, \n      Class<? extends LineParser> lineParserClass, int numAdds, String storedField) throws Exception {\n    \n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    PerfRunData runData = null;\n    try {\n      Properties props = new Properties();\n      \n      // LineDocSource specific settings.\n      props.setProperty(\"docs.file\", file.getAbsolutePath());\n      if (lineParserClass != null) {\n        props.setProperty(\"line.parser\", lineParserClass.getName());\n      }\n      \n      // Indexing configuration.\n      props.setProperty(\"analyzer\", WhitespaceAnalyzer.class.getName());\n      props.setProperty(\"content.source\", LineDocSource.class.getName());\n      props.setProperty(\"directory\", \"RAMDirectory\");\n      props.setProperty(\"doc.stored\", \"true\");\n      props.setProperty(\"doc.index.props\", \"true\");\n      \n      // Create PerfRunData\n      Config config = new Config(props);\n      runData = new PerfRunData(config);\n\n      TaskSequence tasks = new TaskSequence(runData, \"testBzip2\", null, false);\n      tasks.addTask(new CreateIndexTask(runData));\n      for (int i=0; i<numAdds; i++) {\n        tasks.addTask(new AddDocTask(runData));\n      }\n      tasks.addTask(new CloseIndexTask(runData));\n      try {\n        tasks.doLogic();\n      } finally {\n        tasks.close(); \n      }\n      \n      reader = DirectoryReader.open(runData.getDirectory());\n      searcher = new IndexSearcher(reader);\n      TopDocs td = searcher.search(new TermQuery(new Term(\"body\", \"body\")), 10);\n      assertEquals(numAdds, td.totalHits);\n      assertNotNull(td.scoreDocs[0]);\n      \n      if (storedField==null) {\n        storedField = DocMaker.BODY_FIELD; // added to all docs and satisfies field-name == value\n      }\n      assertEquals(\"Wrong field value\", storedField, searcher.doc(0).get(storedField));\n    } finally {\n      IOUtils.close(reader, runData);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4abec28b874149a7223e32cc7a01704c27790de","date":1410644789,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/benchmark/src/test/org/apache/lucene/benchmark/byTask/feeds/LineDocSourceTest#doIndexAndSearchTestWithRepeats(Path,Class[#-extends-LineParser],int,String).mjava","pathOld":"lucene/benchmark/src/test/org/apache/lucene/benchmark/byTask/feeds/LineDocSourceTest#doIndexAndSearchTestWithRepeats(File,Class[#-extends-LineParser],int,String).mjava","sourceNew":"  private void doIndexAndSearchTestWithRepeats(Path file, \n      Class<? extends LineParser> lineParserClass, int numAdds, String storedField) throws Exception {\n    \n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    PerfRunData runData = null;\n    try {\n      Properties props = new Properties();\n      \n      // LineDocSource specific settings.\n      props.setProperty(\"docs.file\", file.toAbsolutePath().toString());\n      if (lineParserClass != null) {\n        props.setProperty(\"line.parser\", lineParserClass.getName());\n      }\n      \n      // Indexing configuration.\n      props.setProperty(\"analyzer\", WhitespaceAnalyzer.class.getName());\n      props.setProperty(\"content.source\", LineDocSource.class.getName());\n      props.setProperty(\"directory\", \"RAMDirectory\");\n      props.setProperty(\"doc.stored\", \"true\");\n      props.setProperty(\"doc.index.props\", \"true\");\n      \n      // Create PerfRunData\n      Config config = new Config(props);\n      runData = new PerfRunData(config);\n\n      TaskSequence tasks = new TaskSequence(runData, \"testBzip2\", null, false);\n      tasks.addTask(new CreateIndexTask(runData));\n      for (int i=0; i<numAdds; i++) {\n        tasks.addTask(new AddDocTask(runData));\n      }\n      tasks.addTask(new CloseIndexTask(runData));\n      try {\n        tasks.doLogic();\n      } finally {\n        tasks.close(); \n      }\n      \n      reader = DirectoryReader.open(runData.getDirectory());\n      searcher = newSearcher(reader);\n      TopDocs td = searcher.search(new TermQuery(new Term(\"body\", \"body\")), 10);\n      assertEquals(numAdds, td.totalHits);\n      assertNotNull(td.scoreDocs[0]);\n      \n      if (storedField==null) {\n        storedField = DocMaker.BODY_FIELD; // added to all docs and satisfies field-name == value\n      }\n      assertEquals(\"Wrong field value\", storedField, searcher.doc(0).get(storedField));\n    } finally {\n      IOUtils.close(reader, runData);\n    }\n\n  }\n\n","sourceOld":"  private void doIndexAndSearchTestWithRepeats(File file, \n      Class<? extends LineParser> lineParserClass, int numAdds, String storedField) throws Exception {\n    \n    IndexReader reader = null;\n    IndexSearcher searcher = null;\n    PerfRunData runData = null;\n    try {\n      Properties props = new Properties();\n      \n      // LineDocSource specific settings.\n      props.setProperty(\"docs.file\", file.getAbsolutePath());\n      if (lineParserClass != null) {\n        props.setProperty(\"line.parser\", lineParserClass.getName());\n      }\n      \n      // Indexing configuration.\n      props.setProperty(\"analyzer\", WhitespaceAnalyzer.class.getName());\n      props.setProperty(\"content.source\", LineDocSource.class.getName());\n      props.setProperty(\"directory\", \"RAMDirectory\");\n      props.setProperty(\"doc.stored\", \"true\");\n      props.setProperty(\"doc.index.props\", \"true\");\n      \n      // Create PerfRunData\n      Config config = new Config(props);\n      runData = new PerfRunData(config);\n\n      TaskSequence tasks = new TaskSequence(runData, \"testBzip2\", null, false);\n      tasks.addTask(new CreateIndexTask(runData));\n      for (int i=0; i<numAdds; i++) {\n        tasks.addTask(new AddDocTask(runData));\n      }\n      tasks.addTask(new CloseIndexTask(runData));\n      try {\n        tasks.doLogic();\n      } finally {\n        tasks.close(); \n      }\n      \n      reader = DirectoryReader.open(runData.getDirectory());\n      searcher = newSearcher(reader);\n      TopDocs td = searcher.search(new TermQuery(new Term(\"body\", \"body\")), 10);\n      assertEquals(numAdds, td.totalHits);\n      assertNotNull(td.scoreDocs[0]);\n      \n      if (storedField==null) {\n        storedField = DocMaker.BODY_FIELD; // added to all docs and satisfies field-name == value\n      }\n      assertEquals(\"Wrong field value\", storedField, searcher.doc(0).get(storedField));\n    } finally {\n      IOUtils.close(reader, runData);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f4abec28b874149a7223e32cc7a01704c27790de":["ad1f7eb1a6bbf19f3d32b3baf2dee3db844eccdc"],"ad1f7eb1a6bbf19f3d32b3baf2dee3db844eccdc":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f4abec28b874149a7223e32cc7a01704c27790de"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["ad1f7eb1a6bbf19f3d32b3baf2dee3db844eccdc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"f4abec28b874149a7223e32cc7a01704c27790de":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ad1f7eb1a6bbf19f3d32b3baf2dee3db844eccdc":["f4abec28b874149a7223e32cc7a01704c27790de"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}