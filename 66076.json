{"path":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#avoidPathologicalMerging(IndexWriterConfig).mjava","commits":[{"id":"4bb5791a757485f13c42e3d32746a440306f28c4","date":1412765145,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#avoidPathologicalMerging(IndexWriterConfig).mjava","pathOld":"/dev/null","sourceNew":"  private static void avoidPathologicalMerging(IndexWriterConfig iwc) {\n    // Don't allow \"tiny\" flushed segments with \"big\" merge\n    // floor: this leads to pathological O(N^2) merge costs:\n    long estFlushSizeBytes = Long.MAX_VALUE;\n    if (iwc.getMaxBufferedDocs() != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // Gross estimation of 1 KB segment bytes for each doc indexed:\n      estFlushSizeBytes = Math.min(estFlushSizeBytes, iwc.getMaxBufferedDocs() * 1024);\n    }\n    if (iwc.getRAMBufferSizeMB() != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      estFlushSizeBytes = Math.min(estFlushSizeBytes, (long) (iwc.getRAMBufferSizeMB() * 1024 * 1024));\n    }\n    assert estFlushSizeBytes > 0;\n\n    MergePolicy mp = iwc.getMergePolicy();\n    if (mp instanceof TieredMergePolicy) {\n      TieredMergePolicy tmp = (TieredMergePolicy) mp;\n      long floorSegBytes = (long) (tmp.getFloorSegmentMB() * 1024 * 1024);\n      if (floorSegBytes / estFlushSizeBytes > 10) {\n        double newValue = estFlushSizeBytes * 10.0 / 1024 / 1024;\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase: changing TieredMergePolicy.floorSegmentMB from \" + tmp.getFloorSegmentMB() + \" to \" + newValue + \" to avoid pathological merging\");\n        }\n        tmp.setFloorSegmentMB(newValue);\n      }\n    } else if (mp instanceof LogByteSizeMergePolicy) {\n      LogByteSizeMergePolicy lmp = (LogByteSizeMergePolicy) mp;\n      if ((lmp.getMinMergeMB()*1024*1024) / estFlushSizeBytes > 10) {\n        double newValue = estFlushSizeBytes * 10.0 / 1024 / 1024;\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase: changing LogByteSizeMergePolicy.minMergeMB from \" + lmp.getMinMergeMB() + \" to \" + newValue + \" to avoid pathological merging\");\n        }\n        lmp.setMinMergeMB(newValue);\n      }\n    } else if (mp instanceof LogDocMergePolicy) {\n      LogDocMergePolicy lmp = (LogDocMergePolicy) mp;\n      assert estFlushSizeBytes / 1024 < Integer.MAX_VALUE/10;\n      int estFlushDocs = Math.max(1, (int) (estFlushSizeBytes / 1024));\n      if (lmp.getMinMergeDocs() / estFlushDocs > 10) {\n        int newValue = estFlushDocs * 10;\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase: changing LogDocMergePolicy.minMergeDocs from \" + lmp.getMinMergeDocs() + \" to \" + newValue + \" to avoid pathological merging\");\n        }\n        lmp.setMinMergeDocs(newValue);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#avoidPathologicalMerging(IndexWriterConfig).mjava","pathOld":"/dev/null","sourceNew":"  private static void avoidPathologicalMerging(IndexWriterConfig iwc) {\n    // Don't allow \"tiny\" flushed segments with \"big\" merge\n    // floor: this leads to pathological O(N^2) merge costs:\n    long estFlushSizeBytes = Long.MAX_VALUE;\n    if (iwc.getMaxBufferedDocs() != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      // Gross estimation of 1 KB segment bytes for each doc indexed:\n      estFlushSizeBytes = Math.min(estFlushSizeBytes, iwc.getMaxBufferedDocs() * 1024);\n    }\n    if (iwc.getRAMBufferSizeMB() != IndexWriterConfig.DISABLE_AUTO_FLUSH) {\n      estFlushSizeBytes = Math.min(estFlushSizeBytes, (long) (iwc.getRAMBufferSizeMB() * 1024 * 1024));\n    }\n    assert estFlushSizeBytes > 0;\n\n    MergePolicy mp = iwc.getMergePolicy();\n    if (mp instanceof TieredMergePolicy) {\n      TieredMergePolicy tmp = (TieredMergePolicy) mp;\n      long floorSegBytes = (long) (tmp.getFloorSegmentMB() * 1024 * 1024);\n      if (floorSegBytes / estFlushSizeBytes > 10) {\n        double newValue = estFlushSizeBytes * 10.0 / 1024 / 1024;\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase: changing TieredMergePolicy.floorSegmentMB from \" + tmp.getFloorSegmentMB() + \" to \" + newValue + \" to avoid pathological merging\");\n        }\n        tmp.setFloorSegmentMB(newValue);\n      }\n    } else if (mp instanceof LogByteSizeMergePolicy) {\n      LogByteSizeMergePolicy lmp = (LogByteSizeMergePolicy) mp;\n      if ((lmp.getMinMergeMB()*1024*1024) / estFlushSizeBytes > 10) {\n        double newValue = estFlushSizeBytes * 10.0 / 1024 / 1024;\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase: changing LogByteSizeMergePolicy.minMergeMB from \" + lmp.getMinMergeMB() + \" to \" + newValue + \" to avoid pathological merging\");\n        }\n        lmp.setMinMergeMB(newValue);\n      }\n    } else if (mp instanceof LogDocMergePolicy) {\n      LogDocMergePolicy lmp = (LogDocMergePolicy) mp;\n      assert estFlushSizeBytes / 1024 < Integer.MAX_VALUE/10;\n      int estFlushDocs = Math.max(1, (int) (estFlushSizeBytes / 1024));\n      if (lmp.getMinMergeDocs() / estFlushDocs > 10) {\n        int newValue = estFlushDocs * 10;\n        if (VERBOSE) {\n          System.out.println(\"NOTE: LuceneTestCase: changing LogDocMergePolicy.minMergeDocs from \" + lmp.getMinMergeDocs() + \" to \" + newValue + \" to avoid pathological merging\");\n        }\n        lmp.setMinMergeDocs(newValue);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"55980207f1977bd1463465de1659b821347e2fa8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4bb5791a757485f13c42e3d32746a440306f28c4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4bb5791a757485f13c42e3d32746a440306f28c4"],"4bb5791a757485f13c42e3d32746a440306f28c4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"55980207f1977bd1463465de1659b821347e2fa8":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["55980207f1977bd1463465de1659b821347e2fa8","4bb5791a757485f13c42e3d32746a440306f28c4"],"4bb5791a757485f13c42e3d32746a440306f28c4":["55980207f1977bd1463465de1659b821347e2fa8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["55980207f1977bd1463465de1659b821347e2fa8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}