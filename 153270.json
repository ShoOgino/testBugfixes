{"path":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","commits":[{"id":"e2fe60a17a7a0cfd101b1169acf089221bc6c166","date":1412767493,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosWriter#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, Lucene50FieldInfosFormat.EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeSegmentHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n        IndexOptions indexOptions = fi.getIndexOptions();\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= Lucene50FieldInfosFormat.STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= Lucene50FieldInfosFormat.OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= Lucene50FieldInfosFormat.STORE_PAYLOADS;\n        if (fi.isIndexed()) {\n          bits |= Lucene50FieldInfosFormat.IS_INDEXED;\n          assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !fi.hasPayloads();\n          if (indexOptions == IndexOptions.DOCS_ONLY) {\n            bits |= Lucene50FieldInfosFormat.OMIT_TERM_FREQ_AND_POSITIONS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) {\n            bits |= Lucene50FieldInfosFormat.STORE_OFFSETS_IN_POSTINGS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS) {\n            bits |= Lucene50FieldInfosFormat.OMIT_POSITIONS;\n          }\n        }\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n        output.writeByte(bits);\n\n        // pack the DV types in one byte\n        final byte dv = docValuesByte(fi.getDocValuesType());\n        final byte nrm = docValuesByte(fi.getNormType());\n        assert (dv & (~0xF)) == 0 && (nrm & (~0x0F)) == 0;\n        byte val = (byte) (0xff & ((nrm << 4) | dv));\n        output.writeByte(val);\n        output.writeLong(fi.getDocValuesGen());\n        output.writeStringStringMap(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, Lucene50FieldInfosFormat.EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeSegmentHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n        IndexOptions indexOptions = fi.getIndexOptions();\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= Lucene50FieldInfosFormat.STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= Lucene50FieldInfosFormat.OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= Lucene50FieldInfosFormat.STORE_PAYLOADS;\n        if (fi.isIndexed()) {\n          bits |= Lucene50FieldInfosFormat.IS_INDEXED;\n          assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !fi.hasPayloads();\n          if (indexOptions == IndexOptions.DOCS_ONLY) {\n            bits |= Lucene50FieldInfosFormat.OMIT_TERM_FREQ_AND_POSITIONS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) {\n            bits |= Lucene50FieldInfosFormat.STORE_OFFSETS_IN_POSTINGS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS) {\n            bits |= Lucene50FieldInfosFormat.OMIT_POSITIONS;\n          }\n        }\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n        output.writeByte(bits);\n\n        // pack the DV types in one byte\n        final byte dv = docValuesByte(fi.getDocValuesType());\n        final byte nrm = docValuesByte(fi.getNormType());\n        assert (dv & (~0xF)) == 0 && (nrm & (~0x0F)) == 0;\n        byte val = (byte) (0xff & ((nrm << 4) | dv));\n        output.writeByte(val);\n        output.writeLong(fi.getDocValuesGen());\n        output.writeStringStringMap(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosWriter#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, Lucene50FieldInfosFormat.EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeSegmentHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n        IndexOptions indexOptions = fi.getIndexOptions();\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= Lucene50FieldInfosFormat.STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= Lucene50FieldInfosFormat.OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= Lucene50FieldInfosFormat.STORE_PAYLOADS;\n        if (fi.isIndexed()) {\n          bits |= Lucene50FieldInfosFormat.IS_INDEXED;\n          assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !fi.hasPayloads();\n          if (indexOptions == IndexOptions.DOCS_ONLY) {\n            bits |= Lucene50FieldInfosFormat.OMIT_TERM_FREQ_AND_POSITIONS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) {\n            bits |= Lucene50FieldInfosFormat.STORE_OFFSETS_IN_POSTINGS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS) {\n            bits |= Lucene50FieldInfosFormat.OMIT_POSITIONS;\n          }\n        }\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n        output.writeByte(bits);\n\n        // pack the DV types in one byte\n        final byte dv = docValuesByte(fi.getDocValuesType());\n        final byte nrm = docValuesByte(fi.getNormType());\n        assert (dv & (~0xF)) == 0 && (nrm & (~0x0F)) == 0;\n        byte val = (byte) (0xff & ((nrm << 4) | dv));\n        output.writeByte(val);\n        output.writeLong(fi.getDocValuesGen());\n        output.writeStringStringMap(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, Lucene50FieldInfosFormat.EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeSegmentHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n        IndexOptions indexOptions = fi.getIndexOptions();\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= Lucene50FieldInfosFormat.STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= Lucene50FieldInfosFormat.OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= Lucene50FieldInfosFormat.STORE_PAYLOADS;\n        if (fi.isIndexed()) {\n          bits |= Lucene50FieldInfosFormat.IS_INDEXED;\n          assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !fi.hasPayloads();\n          if (indexOptions == IndexOptions.DOCS_ONLY) {\n            bits |= Lucene50FieldInfosFormat.OMIT_TERM_FREQ_AND_POSITIONS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) {\n            bits |= Lucene50FieldInfosFormat.STORE_OFFSETS_IN_POSTINGS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS) {\n            bits |= Lucene50FieldInfosFormat.OMIT_POSITIONS;\n          }\n        }\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n        output.writeByte(bits);\n\n        // pack the DV types in one byte\n        final byte dv = docValuesByte(fi.getDocValuesType());\n        final byte nrm = docValuesByte(fi.getNormType());\n        assert (dv & (~0xF)) == 0 && (nrm & (~0x0F)) == 0;\n        byte val = (byte) (0xff & ((nrm << 4) | dv));\n        output.writeByte(val);\n        output.writeLong(fi.getDocValuesGen());\n        output.writeStringStringMap(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05da2d758a6089e737cdfc230e57a51b472b94b6","date":1413392310,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, Lucene50FieldInfosFormat.EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeSegmentHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n        IndexOptions indexOptions = fi.getIndexOptions();\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= Lucene50FieldInfosFormat.STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= Lucene50FieldInfosFormat.OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= Lucene50FieldInfosFormat.STORE_PAYLOADS;\n        if (fi.isIndexed()) {\n          bits |= Lucene50FieldInfosFormat.IS_INDEXED;\n          assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !fi.hasPayloads();\n          if (indexOptions == IndexOptions.DOCS_ONLY) {\n            bits |= Lucene50FieldInfosFormat.OMIT_TERM_FREQ_AND_POSITIONS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) {\n            bits |= Lucene50FieldInfosFormat.STORE_OFFSETS_IN_POSTINGS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS) {\n            bits |= Lucene50FieldInfosFormat.OMIT_POSITIONS;\n          }\n        }\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n        output.writeByte(bits);\n\n        // pack the DV type and hasNorms in one byte\n        final byte dv = docValuesByte(fi.getDocValuesType());\n        assert (dv & (~0xF)) == 0;\n        output.writeByte(dv);\n        output.writeLong(fi.getDocValuesGen());\n        output.writeStringStringMap(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, Lucene50FieldInfosFormat.EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeSegmentHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n        IndexOptions indexOptions = fi.getIndexOptions();\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= Lucene50FieldInfosFormat.STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= Lucene50FieldInfosFormat.OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= Lucene50FieldInfosFormat.STORE_PAYLOADS;\n        if (fi.isIndexed()) {\n          bits |= Lucene50FieldInfosFormat.IS_INDEXED;\n          assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !fi.hasPayloads();\n          if (indexOptions == IndexOptions.DOCS_ONLY) {\n            bits |= Lucene50FieldInfosFormat.OMIT_TERM_FREQ_AND_POSITIONS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) {\n            bits |= Lucene50FieldInfosFormat.STORE_OFFSETS_IN_POSTINGS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS) {\n            bits |= Lucene50FieldInfosFormat.OMIT_POSITIONS;\n          }\n        }\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n        output.writeByte(bits);\n\n        // pack the DV types in one byte\n        final byte dv = docValuesByte(fi.getDocValuesType());\n        final byte nrm = docValuesByte(fi.getNormType());\n        assert (dv & (~0xF)) == 0 && (nrm & (~0x0F)) == 0;\n        byte val = (byte) (0xff & ((nrm << 4) | dv));\n        output.writeByte(val);\n        output.writeLong(fi.getDocValuesGen());\n        output.writeStringStringMap(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","date":1413458798,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, Lucene50FieldInfosFormat.EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeSegmentHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n        IndexOptions indexOptions = fi.getIndexOptions();\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= Lucene50FieldInfosFormat.STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= Lucene50FieldInfosFormat.OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= Lucene50FieldInfosFormat.STORE_PAYLOADS;\n        if (fi.isIndexed()) {\n          bits |= Lucene50FieldInfosFormat.IS_INDEXED;\n          assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !fi.hasPayloads();\n          if (indexOptions == IndexOptions.DOCS_ONLY) {\n            bits |= Lucene50FieldInfosFormat.OMIT_TERM_FREQ_AND_POSITIONS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) {\n            bits |= Lucene50FieldInfosFormat.STORE_OFFSETS_IN_POSTINGS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS) {\n            bits |= Lucene50FieldInfosFormat.OMIT_POSITIONS;\n          }\n        }\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n        output.writeByte(bits);\n\n        // pack the DV type and hasNorms in one byte\n        final byte dv = docValuesByte(fi.getDocValuesType());\n        assert (dv & (~0xF)) == 0;\n        output.writeByte(dv);\n        output.writeLong(fi.getDocValuesGen());\n        output.writeStringStringMap(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, Lucene50FieldInfosFormat.EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeSegmentHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n        IndexOptions indexOptions = fi.getIndexOptions();\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= Lucene50FieldInfosFormat.STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= Lucene50FieldInfosFormat.OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= Lucene50FieldInfosFormat.STORE_PAYLOADS;\n        if (fi.isIndexed()) {\n          bits |= Lucene50FieldInfosFormat.IS_INDEXED;\n          assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !fi.hasPayloads();\n          if (indexOptions == IndexOptions.DOCS_ONLY) {\n            bits |= Lucene50FieldInfosFormat.OMIT_TERM_FREQ_AND_POSITIONS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) {\n            bits |= Lucene50FieldInfosFormat.STORE_OFFSETS_IN_POSTINGS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS) {\n            bits |= Lucene50FieldInfosFormat.OMIT_POSITIONS;\n          }\n        }\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n        output.writeByte(bits);\n\n        // pack the DV types in one byte\n        final byte dv = docValuesByte(fi.getDocValuesType());\n        final byte nrm = docValuesByte(fi.getNormType());\n        assert (dv & (~0xF)) == 0 && (nrm & (~0x0F)) == 0;\n        byte val = (byte) (0xff & ((nrm << 4) | dv));\n        output.writeByte(val);\n        output.writeLong(fi.getDocValuesGen());\n        output.writeStringStringMap(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3184874f7f3aca850248483485b4995343066875","date":1413876758,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeSegmentHeader(output, CODEC_NAME, FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= STORE_PAYLOADS;\n        output.writeByte(bits);\n\n        output.writeByte(indexOptionsByte(fi.getIndexOptions()));\n\n        // pack the DV type and hasNorms in one byte\n        output.writeByte(docValuesByte(fi.getDocValuesType()));\n        output.writeLong(fi.getDocValuesGen());\n        output.writeStringStringMap(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, Lucene50FieldInfosFormat.EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeSegmentHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n        IndexOptions indexOptions = fi.getIndexOptions();\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= Lucene50FieldInfosFormat.STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= Lucene50FieldInfosFormat.OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= Lucene50FieldInfosFormat.STORE_PAYLOADS;\n        if (fi.isIndexed()) {\n          bits |= Lucene50FieldInfosFormat.IS_INDEXED;\n          assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !fi.hasPayloads();\n          if (indexOptions == IndexOptions.DOCS_ONLY) {\n            bits |= Lucene50FieldInfosFormat.OMIT_TERM_FREQ_AND_POSITIONS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) {\n            bits |= Lucene50FieldInfosFormat.STORE_OFFSETS_IN_POSTINGS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS) {\n            bits |= Lucene50FieldInfosFormat.OMIT_POSITIONS;\n          }\n        }\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n        output.writeByte(bits);\n\n        // pack the DV type and hasNorms in one byte\n        final byte dv = docValuesByte(fi.getDocValuesType());\n        assert (dv & (~0xF)) == 0;\n        output.writeByte(dv);\n        output.writeLong(fi.getDocValuesGen());\n        output.writeStringStringMap(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3384e6013a93e4d11b7d75388693f8d0388602bf","date":1413951663,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, Lucene50FieldInfosFormat.EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeIndexHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n        IndexOptions indexOptions = fi.getIndexOptions();\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= Lucene50FieldInfosFormat.STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= Lucene50FieldInfosFormat.OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= Lucene50FieldInfosFormat.STORE_PAYLOADS;\n        if (fi.isIndexed()) {\n          bits |= Lucene50FieldInfosFormat.IS_INDEXED;\n          assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !fi.hasPayloads();\n          if (indexOptions == IndexOptions.DOCS_ONLY) {\n            bits |= Lucene50FieldInfosFormat.OMIT_TERM_FREQ_AND_POSITIONS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) {\n            bits |= Lucene50FieldInfosFormat.STORE_OFFSETS_IN_POSTINGS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS) {\n            bits |= Lucene50FieldInfosFormat.OMIT_POSITIONS;\n          }\n        }\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n        output.writeByte(bits);\n\n        // pack the DV type and hasNorms in one byte\n        final byte dv = docValuesByte(fi.getDocValuesType());\n        assert (dv & (~0xF)) == 0;\n        output.writeByte(dv);\n        output.writeLong(fi.getDocValuesGen());\n        output.writeStringStringMap(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, Lucene50FieldInfosFormat.EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeSegmentHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n        IndexOptions indexOptions = fi.getIndexOptions();\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= Lucene50FieldInfosFormat.STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= Lucene50FieldInfosFormat.OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= Lucene50FieldInfosFormat.STORE_PAYLOADS;\n        if (fi.isIndexed()) {\n          bits |= Lucene50FieldInfosFormat.IS_INDEXED;\n          assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !fi.hasPayloads();\n          if (indexOptions == IndexOptions.DOCS_ONLY) {\n            bits |= Lucene50FieldInfosFormat.OMIT_TERM_FREQ_AND_POSITIONS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) {\n            bits |= Lucene50FieldInfosFormat.STORE_OFFSETS_IN_POSTINGS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS) {\n            bits |= Lucene50FieldInfosFormat.OMIT_POSITIONS;\n          }\n        }\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n        output.writeByte(bits);\n\n        // pack the DV type and hasNorms in one byte\n        final byte dv = docValuesByte(fi.getDocValuesType());\n        assert (dv & (~0xF)) == 0;\n        output.writeByte(dv);\n        output.writeLong(fi.getDocValuesGen());\n        output.writeStringStringMap(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a22eafe3f72a4c2945eaad9547e6c78816978f4","date":1413956657,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeIndexHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= STORE_PAYLOADS;\n        output.writeByte(bits);\n\n        output.writeByte(indexOptionsByte(fi.getIndexOptions()));\n\n        // pack the DV type and hasNorms in one byte\n        output.writeByte(docValuesByte(fi.getDocValuesType()));\n        output.writeLong(fi.getDocValuesGen());\n        output.writeStringStringMap(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, Lucene50FieldInfosFormat.EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeIndexHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n        IndexOptions indexOptions = fi.getIndexOptions();\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= Lucene50FieldInfosFormat.STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= Lucene50FieldInfosFormat.OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= Lucene50FieldInfosFormat.STORE_PAYLOADS;\n        if (fi.isIndexed()) {\n          bits |= Lucene50FieldInfosFormat.IS_INDEXED;\n          assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !fi.hasPayloads();\n          if (indexOptions == IndexOptions.DOCS_ONLY) {\n            bits |= Lucene50FieldInfosFormat.OMIT_TERM_FREQ_AND_POSITIONS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) {\n            bits |= Lucene50FieldInfosFormat.STORE_OFFSETS_IN_POSTINGS;\n          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS) {\n            bits |= Lucene50FieldInfosFormat.OMIT_POSITIONS;\n          }\n        }\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n        output.writeByte(bits);\n\n        // pack the DV type and hasNorms in one byte\n        final byte dv = docValuesByte(fi.getDocValuesType());\n        assert (dv & (~0xF)) == 0;\n        output.writeByte(dv);\n        output.writeLong(fi.getDocValuesGen());\n        output.writeStringStringMap(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeIndexHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= STORE_PAYLOADS;\n        output.writeByte(bits);\n\n        output.writeByte(indexOptionsByte(fi.getIndexOptions()));\n\n        // pack the DV type and hasNorms in one byte\n        output.writeByte(docValuesByte(fi.getDocValuesType()));\n        output.writeLong(fi.getDocValuesGen());\n        output.writeStringStringMap(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeSegmentHeader(output, CODEC_NAME, FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= STORE_PAYLOADS;\n        output.writeByte(bits);\n\n        output.writeByte(indexOptionsByte(fi.getIndexOptions()));\n\n        // pack the DV type and hasNorms in one byte\n        output.writeByte(docValuesByte(fi.getDocValuesType()));\n        output.writeLong(fi.getDocValuesGen());\n        output.writeStringStringMap(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"79700663e164dece87bed4adfd3e28bab6cb1385","date":1425241849,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeIndexHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= STORE_PAYLOADS;\n        output.writeByte(bits);\n\n        output.writeByte(indexOptionsByte(fi.getIndexOptions()));\n\n        // pack the DV type and hasNorms in one byte\n        output.writeByte(docValuesByte(fi.getDocValuesType()));\n        output.writeLong(fi.getDocValuesGen());\n        output.writeMapOfStrings(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeIndexHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= STORE_PAYLOADS;\n        output.writeByte(bits);\n\n        output.writeByte(indexOptionsByte(fi.getIndexOptions()));\n\n        // pack the DV type and hasNorms in one byte\n        output.writeByte(docValuesByte(fi.getDocValuesType()));\n        output.writeLong(fi.getDocValuesGen());\n        output.writeStringStringMap(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"299a2348fa24151d150182211b6208a38e5e3450","date":1425304608,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeIndexHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= STORE_PAYLOADS;\n        output.writeByte(bits);\n\n        output.writeByte(indexOptionsByte(fi.getIndexOptions()));\n\n        // pack the DV type and hasNorms in one byte\n        output.writeByte(docValuesByte(fi.getDocValuesType()));\n        output.writeLong(fi.getDocValuesGen());\n        output.writeMapOfStrings(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeIndexHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= STORE_PAYLOADS;\n        output.writeByte(bits);\n\n        output.writeByte(indexOptionsByte(fi.getIndexOptions()));\n\n        // pack the DV type and hasNorms in one byte\n        output.writeByte(docValuesByte(fi.getDocValuesType()));\n        output.writeLong(fi.getDocValuesGen());\n        output.writeStringStringMap(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeIndexHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= STORE_PAYLOADS;\n        output.writeByte(bits);\n\n        output.writeByte(indexOptionsByte(fi.getIndexOptions()));\n\n        // pack the DV type and hasNorms in one byte\n        output.writeByte(docValuesByte(fi.getDocValuesType()));\n        output.writeLong(fi.getDocValuesGen());\n        output.writeMapOfStrings(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeIndexHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= STORE_PAYLOADS;\n        output.writeByte(bits);\n\n        output.writeByte(indexOptionsByte(fi.getIndexOptions()));\n\n        // pack the DV type and hasNorms in one byte\n        output.writeByte(docValuesByte(fi.getDocValuesType()));\n        output.writeLong(fi.getDocValuesGen());\n        output.writeStringStringMap(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f8973f28b29873ff0d7a016e562c9036ae649a9","date":1428098193,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat#write(Directory,SegmentInfo,String,FieldInfos,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeIndexHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= STORE_PAYLOADS;\n        output.writeByte(bits);\n\n        output.writeByte(indexOptionsByte(fi.getIndexOptions()));\n\n        // pack the DV type and hasNorms in one byte\n        output.writeByte(docValuesByte(fi.getDocValuesType()));\n        output.writeLong(fi.getDocValuesGen());\n        output.writeMapOfStrings(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, EXTENSION);\n    try (IndexOutput output = directory.createOutput(fileName, context)) {\n      CodecUtil.writeIndexHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId(), segmentSuffix);\n      output.writeVInt(infos.size());\n      for (FieldInfo fi : infos) {\n        fi.checkConsistency();\n\n        output.writeString(fi.name);\n        output.writeVInt(fi.number);\n\n        byte bits = 0x0;\n        if (fi.hasVectors()) bits |= STORE_TERMVECTOR;\n        if (fi.omitsNorms()) bits |= OMIT_NORMS;\n        if (fi.hasPayloads()) bits |= STORE_PAYLOADS;\n        output.writeByte(bits);\n\n        output.writeByte(indexOptionsByte(fi.getIndexOptions()));\n\n        // pack the DV type and hasNorms in one byte\n        output.writeByte(docValuesByte(fi.getDocValuesType()));\n        output.writeLong(fi.getDocValuesGen());\n        output.writeMapOfStrings(fi.attributes());\n      }\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"05da2d758a6089e737cdfc230e57a51b472b94b6":["e2fe60a17a7a0cfd101b1169acf089221bc6c166"],"e2fe60a17a7a0cfd101b1169acf089221bc6c166":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84":["55980207f1977bd1463465de1659b821347e2fa8","05da2d758a6089e737cdfc230e57a51b472b94b6"],"55980207f1977bd1463465de1659b821347e2fa8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e2fe60a17a7a0cfd101b1169acf089221bc6c166"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84"],"3f8973f28b29873ff0d7a016e562c9036ae649a9":["79700663e164dece87bed4adfd3e28bab6cb1385"],"3184874f7f3aca850248483485b4995343066875":["05da2d758a6089e737cdfc230e57a51b472b94b6"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238","79700663e164dece87bed4adfd3e28bab6cb1385"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["3384e6013a93e4d11b7d75388693f8d0388602bf","3184874f7f3aca850248483485b4995343066875"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"79700663e164dece87bed4adfd3e28bab6cb1385":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["3184874f7f3aca850248483485b4995343066875","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"299a2348fa24151d150182211b6208a38e5e3450":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238","79700663e164dece87bed4adfd3e28bab6cb1385"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f8973f28b29873ff0d7a016e562c9036ae649a9"]},"commit2Childs":{"05da2d758a6089e737cdfc230e57a51b472b94b6":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","3184874f7f3aca850248483485b4995343066875"],"e2fe60a17a7a0cfd101b1169acf089221bc6c166":["05da2d758a6089e737cdfc230e57a51b472b94b6","55980207f1977bd1463465de1659b821347e2fa8"],"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84":["3384e6013a93e4d11b7d75388693f8d0388602bf"],"55980207f1977bd1463465de1659b821347e2fa8":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"3f8973f28b29873ff0d7a016e562c9036ae649a9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3184874f7f3aca850248483485b4995343066875":["0a22eafe3f72a4c2945eaad9547e6c78816978f4","db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e2fe60a17a7a0cfd101b1169acf089221bc6c166","55980207f1977bd1463465de1659b821347e2fa8"],"79700663e164dece87bed4adfd3e28bab6cb1385":["3f8973f28b29873ff0d7a016e562c9036ae649a9","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","299a2348fa24151d150182211b6208a38e5e3450"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","79700663e164dece87bed4adfd3e28bab6cb1385","299a2348fa24151d150182211b6208a38e5e3450"],"299a2348fa24151d150182211b6208a38e5e3450":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","299a2348fa24151d150182211b6208a38e5e3450","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}