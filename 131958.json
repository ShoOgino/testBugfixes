{"path":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#deployCollectionPackage(SolrPackageInstance,boolean,boolean,boolean,List[String],String[]).mjava","commits":[{"id":"4ea3ef3f76ecd22ead5b83d015adf8c16476a0f4","date":1594087785,"type":1,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#deployCollectionPackage(SolrPackageInstance,boolean,boolean,boolean,List[String],String[]).mjava","pathOld":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#deployCollectionPackage(SolrPackageInstance,boolean,boolean,boolean,List[String],boolean,String[]).mjava","sourceNew":"  /**\n   * @return list of collections on which packages deployed on\n   */\n  private Pair<List<String>, List<String>> deployCollectionPackage(SolrPackageInstance packageInstance, boolean pegToLatest, boolean isUpdate,\n      boolean noprompt, List<String> collections, String[] overrides) {\n    List<String> previouslyDeployed =  new ArrayList<>(); // collections where package is already deployed in\n    for (String collection: collections) {\n      SolrPackageInstance deployedPackage = getPackagesDeployed(collection).get(packageInstance.name);\n      if (packageInstance.equals(deployedPackage)) {\n        if (!pegToLatest) {\n          PackageUtils.printRed(\"Package \" + packageInstance + \" already deployed on \"+collection);\n          previouslyDeployed.add(collection);\n          continue;\n        }\n      } else {\n        if (deployedPackage != null && !isUpdate) {\n          PackageUtils.printRed(\"Package \" + deployedPackage + \" already deployed on \"+collection+\". To update to \"+packageInstance+\", pass --update parameter.\");\n          previouslyDeployed.add(collection);\n          continue;\n        }\n      }\n\n      Map<String,String> collectionParameterOverrides = getCollectionParameterOverrides(packageInstance, isUpdate, overrides, collection);\n\n      // Get package params\n      try {\n        @SuppressWarnings(\"unchecked\")\n        boolean packageParamsExist = ((Map<Object, Object>)PackageUtils.getJson(solrClient.getHttpClient(), solrBaseUrl + PackageUtils.getCollectionParamsPath(collection) + \"/packages\", Map.class)\n            .getOrDefault(\"response\", Collections.emptyMap())).containsKey(\"params\");\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            getMapper().writeValueAsString(Collections.singletonMap(packageParamsExist? \"update\": \"set\",\n                Collections.singletonMap(\"packages\", Collections.singletonMap(packageInstance.name, collectionParameterOverrides)))));\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, e);\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            \"{set:{PKG_VERSIONS:{\" + packageInstance.name+\": '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version)+\"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n\n      // If updating, refresh the package version for this to take effect\n      if (isUpdate || pegToLatest) {\n        try {\n          SolrCLI.postJsonToSolr(solrClient, PackageUtils.PACKAGE_PATH, \"{\\\"refresh\\\": \\\"\" + packageInstance.name + \"\\\"}\");\n        } catch (Exception ex) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n        }\n      }\n\n      // If it is a fresh deploy on a collection, run setup commands all the plugins in the package\n      if (!isUpdate) {\n        for (Plugin plugin: packageInstance.plugins) {\n          if (\"collection\".equalsIgnoreCase(plugin.type) == false || collections.isEmpty()) continue;\n          Map<String, String> systemParams = Map.of(\"collection\", collection, \"package-name\", packageInstance.name, \"package-version\", packageInstance.version, \"plugin-name\", plugin.name);\n\n          Command cmd = plugin.setupCommand;\n          if (cmd != null && !Strings.isNullOrEmpty(cmd.method)) {\n            if (\"POST\".equalsIgnoreCase(cmd.method)) {\n              try {\n                String payload = PackageUtils.resolve(getMapper().writeValueAsString(cmd.payload), packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                String path = PackageUtils.resolve(cmd.path, packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                PackageUtils.printGreen(\"Executing \" + payload + \" for path:\" + path);\n                boolean shouldExecute = prompt(noprompt);\n                if (shouldExecute) {\n                  SolrCLI.postJsonToSolr(solrClient, path, payload);\n                }\n              } catch (Exception ex) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n              }\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"Non-POST method not supported for setup commands\");\n            }\n          } else {\n            PackageUtils.printRed(\"There is no setup command to execute for plugin: \" + plugin.name);\n          }\n        }\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            \"{update:{PKG_VERSIONS:{'\" + packageInstance.name + \"' : '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version) + \"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n    }\n\n    if (previouslyDeployed.isEmpty() == false) {\n      PackageUtils.printRed(\"Already Deployed on \" + previouslyDeployed + \", package: \" + packageInstance.name + \", version: \" + packageInstance.version);\n    }\n\n    List<String> deployedCollections = collections.stream().filter(c -> !previouslyDeployed.contains(c)).collect(Collectors.toList());\n    return new Pair<List<String>, List<String>>(deployedCollections, previouslyDeployed);\n  }\n\n","sourceOld":"  /**\n   * @return list of collections on which packages deployed on\n   */\n  private Pair<List<String>, List<String>> deployCollectionPackage(SolrPackageInstance packageInstance, boolean pegToLatest, boolean isUpdate,\n      boolean noprompt, List<String> collections, boolean shouldDeployClusterPlugins, String[] overrides) {\n    List<String> previouslyDeployed =  new ArrayList<>(); // collections where package is already deployed in\n    for (String collection: collections) {\n      SolrPackageInstance deployedPackage = getPackagesDeployed(collection).get(packageInstance.name);\n      if (packageInstance.equals(deployedPackage)) {\n        if (!pegToLatest) {\n          PackageUtils.printRed(\"Package \" + packageInstance + \" already deployed on \"+collection);\n          previouslyDeployed.add(collection);\n          continue;\n        }\n      } else {\n        if (deployedPackage != null && !isUpdate) {\n          PackageUtils.printRed(\"Package \" + deployedPackage + \" already deployed on \"+collection+\". To update to \"+packageInstance+\", pass --update parameter.\");\n          previouslyDeployed.add(collection);\n          continue;\n        }\n      }\n\n      Map<String,String> collectionParameterOverrides = getCollectionParameterOverrides(packageInstance, isUpdate, overrides, collection);\n\n      // Get package params\n      try {\n        @SuppressWarnings(\"unchecked\")\n        boolean packageParamsExist = ((Map<Object, Object>)PackageUtils.getJson(solrClient.getHttpClient(), solrBaseUrl + PackageUtils.getCollectionParamsPath(collection) + \"/packages\", Map.class)\n            .getOrDefault(\"response\", Collections.emptyMap())).containsKey(\"params\");\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            getMapper().writeValueAsString(Collections.singletonMap(packageParamsExist? \"update\": \"set\",\n                Collections.singletonMap(\"packages\", Collections.singletonMap(packageInstance.name, collectionParameterOverrides)))));\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, e);\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            \"{set:{PKG_VERSIONS:{\" + packageInstance.name+\": '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version)+\"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n\n      // If updating, refresh the package version for this to take effect\n      if (isUpdate || pegToLatest) {\n        try {\n          SolrCLI.postJsonToSolr(solrClient, PackageUtils.PACKAGE_PATH, \"{\\\"refresh\\\": \\\"\" + packageInstance.name + \"\\\"}\");\n        } catch (Exception ex) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n        }\n      }\n\n      // If it is a fresh deploy on a collection, run setup commands all the plugins in the package\n      if (!isUpdate) {\n        for (Plugin plugin: packageInstance.plugins) {\n          if (\"collection\".equalsIgnoreCase(plugin.type) == false || collections.isEmpty()) continue;\n          Map<String, String> systemParams = Map.of(\"collection\", collection, \"package-name\", packageInstance.name, \"package-version\", packageInstance.version, \"plugin-name\", plugin.name);\n\n          Command cmd = plugin.setupCommand;\n          if (cmd != null && !Strings.isNullOrEmpty(cmd.method)) {\n            if (\"POST\".equalsIgnoreCase(cmd.method)) {\n              try {\n                String payload = PackageUtils.resolve(getMapper().writeValueAsString(cmd.payload), packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                String path = PackageUtils.resolve(cmd.path, packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                PackageUtils.printGreen(\"Executing \" + payload + \" for path:\" + path);\n                boolean shouldExecute = true;\n                if (!noprompt) { // show a prompt asking user to execute the setup command for the plugin\n                  PackageUtils.print(PackageUtils.YELLOW, \"Execute this command (y/n): \");\n                  try (Scanner scanner = new Scanner(System.in, \"UTF-8\")) {\n                    String userInput = scanner.next();\n                    if (!\"yes\".equalsIgnoreCase(userInput) && !\"y\".equalsIgnoreCase(userInput)) {\n                      shouldExecute = false;\n                      PackageUtils.printRed(\"Skipping setup command for deploying (deployment verification may fail).\"\n                          + \" Please run this step manually or refer to package documentation.\");\n                    }\n                  }\n                }\n                if (shouldExecute) {\n                  SolrCLI.postJsonToSolr(solrClient, path, payload);\n                }\n              } catch (Exception ex) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n              }\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"Non-POST method not supported for setup commands\");\n            }\n          } else {\n            PackageUtils.printRed(\"There is no setup command to execute for plugin: \" + plugin.name);\n          }\n        }\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            \"{update:{PKG_VERSIONS:{'\" + packageInstance.name + \"' : '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version) + \"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n    }\n\n    if (previouslyDeployed.isEmpty() == false) {\n      PackageUtils.printRed(\"Already Deployed on \" + previouslyDeployed + \", package: \" + packageInstance.name + \", version: \" + packageInstance.version);\n    }\n\n    List<String> deployedCollections = collections.stream().filter(c -> !previouslyDeployed.contains(c)).collect(Collectors.toList());\n    return new Pair<List<String>, List<String>>(deployedCollections, previouslyDeployed);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2ed9b72e5fa27a7bd4857f222ca815341979d4a","date":1594879524,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#deployCollectionPackage(SolrPackageInstance,boolean,boolean,boolean,List[String],String[]).mjava","pathOld":"solr/core/src/java/org/apache/solr/packagemanager/PackageManager#deployCollectionPackage(SolrPackageInstance,boolean,boolean,boolean,List[String],String[]).mjava","sourceNew":"  /**\n   * @return list of collections on which packages deployed on\n   */\n  private Pair<List<String>, List<String>> deployCollectionPackage(SolrPackageInstance packageInstance, boolean pegToLatest, boolean isUpdate,\n      boolean noprompt, List<String> collections, String[] overrides) {\n    List<String> previouslyDeployed =  new ArrayList<>(); // collections where package is already deployed in\n    for (String collection: collections) {\n      SolrPackageInstance deployedPackage = getPackagesDeployed(collection).get(packageInstance.name);\n      if (packageInstance.equals(deployedPackage)) {\n        if (!pegToLatest) {\n          PackageUtils.printRed(\"Package \" + packageInstance + \" already deployed on \"+collection);\n          previouslyDeployed.add(collection);\n          continue;\n        }\n      } else {\n        if (deployedPackage != null && !isUpdate) {\n          PackageUtils.printRed(\"Package \" + deployedPackage + \" already deployed on \"+collection+\". To update to \"+packageInstance+\", pass --update parameter.\");\n          previouslyDeployed.add(collection);\n          continue;\n        }\n      }\n\n      Map<String,String> collectionParameterOverrides = getCollectionParameterOverrides(packageInstance, isUpdate, overrides, collection);\n\n      // Get package params\n      try {\n        @SuppressWarnings(\"unchecked\")\n        boolean packageParamsExist = ((Map<Object, Object>)PackageUtils.getJson(solrClient.getHttpClient(), solrBaseUrl + PackageUtils.getCollectionParamsPath(collection) + \"/packages\", Map.class)\n            .getOrDefault(\"response\", Collections.emptyMap())).containsKey(\"params\");\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            getMapper().writeValueAsString(Collections.singletonMap(packageParamsExist? \"update\": \"set\",\n                Collections.singletonMap(\"packages\", Collections.singletonMap(packageInstance.name, collectionParameterOverrides)))));\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, e);\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            \"{set:{PKG_VERSIONS:{\" + packageInstance.name+\": '\" + (pegToLatest? PackageLoader.LATEST: packageInstance.version)+\"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n\n      // If updating, refresh the package version for this to take effect\n      if (isUpdate || pegToLatest) {\n        try {\n          SolrCLI.postJsonToSolr(solrClient, PackageUtils.PACKAGE_PATH, \"{\\\"refresh\\\": \\\"\" + packageInstance.name + \"\\\"}\");\n        } catch (Exception ex) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n        }\n      }\n\n      // If it is a fresh deploy on a collection, run setup commands all the plugins in the package\n      if (!isUpdate) {\n        for (Plugin plugin: packageInstance.plugins) {\n          if (\"collection\".equalsIgnoreCase(plugin.type) == false || collections.isEmpty()) continue;\n          Map<String, String> systemParams = Map.of(\"collection\", collection, \"package-name\", packageInstance.name, \"package-version\", packageInstance.version, \"plugin-name\", plugin.name);\n\n          Command cmd = plugin.setupCommand;\n          if (cmd != null && !Strings.isNullOrEmpty(cmd.method)) {\n            if (\"POST\".equalsIgnoreCase(cmd.method)) {\n              try {\n                String payload = PackageUtils.resolve(getMapper().writeValueAsString(cmd.payload), packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                String path = PackageUtils.resolve(cmd.path, packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                PackageUtils.printGreen(\"Executing \" + payload + \" for path:\" + path);\n                boolean shouldExecute = prompt(noprompt);\n                if (shouldExecute) {\n                  SolrCLI.postJsonToSolr(solrClient, path, payload);\n                }\n              } catch (Exception ex) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n              }\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"Non-POST method not supported for setup commands\");\n            }\n          } else {\n            PackageUtils.printRed(\"There is no setup command to execute for plugin: \" + plugin.name);\n          }\n        }\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            \"{update:{PKG_VERSIONS:{'\" + packageInstance.name + \"' : '\" + (pegToLatest? PackageLoader.LATEST: packageInstance.version) + \"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n    }\n\n    if (previouslyDeployed.isEmpty() == false) {\n      PackageUtils.printRed(\"Already Deployed on \" + previouslyDeployed + \", package: \" + packageInstance.name + \", version: \" + packageInstance.version);\n    }\n\n    List<String> deployedCollections = collections.stream().filter(c -> !previouslyDeployed.contains(c)).collect(Collectors.toList());\n    return new Pair<List<String>, List<String>>(deployedCollections, previouslyDeployed);\n  }\n\n","sourceOld":"  /**\n   * @return list of collections on which packages deployed on\n   */\n  private Pair<List<String>, List<String>> deployCollectionPackage(SolrPackageInstance packageInstance, boolean pegToLatest, boolean isUpdate,\n      boolean noprompt, List<String> collections, String[] overrides) {\n    List<String> previouslyDeployed =  new ArrayList<>(); // collections where package is already deployed in\n    for (String collection: collections) {\n      SolrPackageInstance deployedPackage = getPackagesDeployed(collection).get(packageInstance.name);\n      if (packageInstance.equals(deployedPackage)) {\n        if (!pegToLatest) {\n          PackageUtils.printRed(\"Package \" + packageInstance + \" already deployed on \"+collection);\n          previouslyDeployed.add(collection);\n          continue;\n        }\n      } else {\n        if (deployedPackage != null && !isUpdate) {\n          PackageUtils.printRed(\"Package \" + deployedPackage + \" already deployed on \"+collection+\". To update to \"+packageInstance+\", pass --update parameter.\");\n          previouslyDeployed.add(collection);\n          continue;\n        }\n      }\n\n      Map<String,String> collectionParameterOverrides = getCollectionParameterOverrides(packageInstance, isUpdate, overrides, collection);\n\n      // Get package params\n      try {\n        @SuppressWarnings(\"unchecked\")\n        boolean packageParamsExist = ((Map<Object, Object>)PackageUtils.getJson(solrClient.getHttpClient(), solrBaseUrl + PackageUtils.getCollectionParamsPath(collection) + \"/packages\", Map.class)\n            .getOrDefault(\"response\", Collections.emptyMap())).containsKey(\"params\");\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            getMapper().writeValueAsString(Collections.singletonMap(packageParamsExist? \"update\": \"set\",\n                Collections.singletonMap(\"packages\", Collections.singletonMap(packageInstance.name, collectionParameterOverrides)))));\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, e);\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            \"{set:{PKG_VERSIONS:{\" + packageInstance.name+\": '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version)+\"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n\n      // If updating, refresh the package version for this to take effect\n      if (isUpdate || pegToLatest) {\n        try {\n          SolrCLI.postJsonToSolr(solrClient, PackageUtils.PACKAGE_PATH, \"{\\\"refresh\\\": \\\"\" + packageInstance.name + \"\\\"}\");\n        } catch (Exception ex) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n        }\n      }\n\n      // If it is a fresh deploy on a collection, run setup commands all the plugins in the package\n      if (!isUpdate) {\n        for (Plugin plugin: packageInstance.plugins) {\n          if (\"collection\".equalsIgnoreCase(plugin.type) == false || collections.isEmpty()) continue;\n          Map<String, String> systemParams = Map.of(\"collection\", collection, \"package-name\", packageInstance.name, \"package-version\", packageInstance.version, \"plugin-name\", plugin.name);\n\n          Command cmd = plugin.setupCommand;\n          if (cmd != null && !Strings.isNullOrEmpty(cmd.method)) {\n            if (\"POST\".equalsIgnoreCase(cmd.method)) {\n              try {\n                String payload = PackageUtils.resolve(getMapper().writeValueAsString(cmd.payload), packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                String path = PackageUtils.resolve(cmd.path, packageInstance.parameterDefaults, collectionParameterOverrides, systemParams);\n                PackageUtils.printGreen(\"Executing \" + payload + \" for path:\" + path);\n                boolean shouldExecute = prompt(noprompt);\n                if (shouldExecute) {\n                  SolrCLI.postJsonToSolr(solrClient, path, payload);\n                }\n              } catch (Exception ex) {\n                throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n              }\n            } else {\n              throw new SolrException(ErrorCode.BAD_REQUEST, \"Non-POST method not supported for setup commands\");\n            }\n          } else {\n            PackageUtils.printRed(\"There is no setup command to execute for plugin: \" + plugin.name);\n          }\n        }\n      }\n\n      // Set the package version in the collection's parameters\n      try {\n        SolrCLI.postJsonToSolr(solrClient, PackageUtils.getCollectionParamsPath(collection),\n            \"{update:{PKG_VERSIONS:{'\" + packageInstance.name + \"' : '\" + (pegToLatest? PackagePluginHolder.LATEST: packageInstance.version) + \"'}}}\");\n      } catch (Exception ex) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, ex);\n      }\n    }\n\n    if (previouslyDeployed.isEmpty() == false) {\n      PackageUtils.printRed(\"Already Deployed on \" + previouslyDeployed + \", package: \" + packageInstance.name + \", version: \" + packageInstance.version);\n    }\n\n    List<String> deployedCollections = collections.stream().filter(c -> !previouslyDeployed.contains(c)).collect(Collectors.toList());\n    return new Pair<List<String>, List<String>>(deployedCollections, previouslyDeployed);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b2ed9b72e5fa27a7bd4857f222ca815341979d4a":["4ea3ef3f76ecd22ead5b83d015adf8c16476a0f4"],"4ea3ef3f76ecd22ead5b83d015adf8c16476a0f4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b2ed9b72e5fa27a7bd4857f222ca815341979d4a"]},"commit2Childs":{"b2ed9b72e5fa27a7bd4857f222ca815341979d4a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4ea3ef3f76ecd22ead5b83d015adf8c16476a0f4":["b2ed9b72e5fa27a7bd4857f222ca815341979d4a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4ea3ef3f76ecd22ead5b83d015adf8c16476a0f4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}