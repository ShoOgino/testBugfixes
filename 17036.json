{"path":"lucene/core/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","sourceNew":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by obj.getFieldCacheKey()\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<Object>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      Object obj = all.get(i);\n      if (obj instanceof CompositeReader) {\n        IndexReader[] subs = ((CompositeReader)obj).getSequentialSubReaders();\n        for (int j = 0; (null != subs) && (j < subs.length); j++) {\n          all.add(subs[j].getCoreCacheKey());\n        }\n      }\n      \n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","sourceOld":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by obj.getFieldCacheKey()\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<Object>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      Object obj = all.get(i);\n      if (obj instanceof CompositeReader) {\n        IndexReader[] subs = ((CompositeReader)obj).getSequentialSubReaders();\n        for (int j = 0; (null != subs) && (j < subs.length); j++) {\n          all.add(subs[j].getCoreCacheKey());\n        }\n      }\n      \n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","date":1340090669,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","sourceNew":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by obj.getFieldCacheKey()\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<Object>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      Object obj = all.get(i);\n      if (obj instanceof CompositeReader) {\n        List<? extends IndexReader> subs = ((CompositeReader)obj).getSequentialSubReaders();\n        for (int j = 0; (null != subs) && (j < subs.size()); j++) {\n          all.add(subs.get(j).getCoreCacheKey());\n        }\n      }\n      \n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","sourceOld":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by obj.getFieldCacheKey()\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<Object>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      Object obj = all.get(i);\n      if (obj instanceof CompositeReader) {\n        IndexReader[] subs = ((CompositeReader)obj).getSequentialSubReaders();\n        for (int j = 0; (null != subs) && (j < subs.length); j++) {\n          all.add(subs[j].getCoreCacheKey());\n        }\n      }\n      \n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","bugFix":null,"bugIntro":["ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ced66195b26fdb1f77ee00e2a77ec6918dedd766","date":1344948886,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","sourceNew":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by {@code seed.getCoreCacheKey()}\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<Object>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      final Object obj = all.get(i);\n      // TODO: We don't check closed readers here (as getTopReaderContext\n      // throws AlreadyClosedException), what should we do? Reflection?\n      if (obj instanceof IndexReader) {\n        try {\n          final List<IndexReaderContext> childs =\n            ((IndexReader) obj).getTopReaderContext().children();\n          if (childs != null) { // it is composite reader\n            for (final IndexReaderContext ctx : childs) {\n              all.add(ctx.reader().getCoreCacheKey());\n            }\n          }\n        } catch (AlreadyClosedException ace) {\n          // ignore this reader\n        }\n      }\n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","sourceOld":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by obj.getFieldCacheKey()\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<Object>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      Object obj = all.get(i);\n      if (obj instanceof CompositeReader) {\n        List<? extends IndexReader> subs = ((CompositeReader)obj).getSequentialSubReaders();\n        for (int j = 0; (null != subs) && (j < subs.size()); j++) {\n          all.add(subs.get(j).getCoreCacheKey());\n        }\n      }\n      \n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","bugFix":["8fa38e5ecc85303dce7ded93b3cc9a48b3d546d9","4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"211b1506e56f7860762fbd4698f6d1d1b57f672c","date":1344976996,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","sourceNew":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by {@code seed.getCoreCacheKey()}\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<Object>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      final Object obj = all.get(i);\n      // TODO: We don't check closed readers here (as getTopReaderContext\n      // throws AlreadyClosedException), what should we do? Reflection?\n      if (obj instanceof IndexReader) {\n        try {\n          final List<IndexReaderContext> childs =\n            ((IndexReader) obj).getContext().children();\n          if (childs != null) { // it is composite reader\n            for (final IndexReaderContext ctx : childs) {\n              all.add(ctx.reader().getCoreCacheKey());\n            }\n          }\n        } catch (AlreadyClosedException ace) {\n          // ignore this reader\n        }\n      }\n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","sourceOld":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by {@code seed.getCoreCacheKey()}\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<Object>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      final Object obj = all.get(i);\n      // TODO: We don't check closed readers here (as getTopReaderContext\n      // throws AlreadyClosedException), what should we do? Reflection?\n      if (obj instanceof IndexReader) {\n        try {\n          final List<IndexReaderContext> childs =\n            ((IndexReader) obj).getTopReaderContext().children();\n          if (childs != null) { // it is composite reader\n            for (final IndexReaderContext ctx : childs) {\n              all.add(ctx.reader().getCoreCacheKey());\n            }\n          }\n        } catch (AlreadyClosedException ace) {\n          // ignore this reader\n        }\n      }\n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","sourceNew":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by {@code seed.getCoreCacheKey()}\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<Object>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      final Object obj = all.get(i);\n      // TODO: We don't check closed readers here (as getTopReaderContext\n      // throws AlreadyClosedException), what should we do? Reflection?\n      if (obj instanceof IndexReader) {\n        try {\n          final List<IndexReaderContext> childs =\n            ((IndexReader) obj).getContext().children();\n          if (childs != null) { // it is composite reader\n            for (final IndexReaderContext ctx : childs) {\n              all.add(ctx.reader().getCoreCacheKey());\n            }\n          }\n        } catch (AlreadyClosedException ace) {\n          // ignore this reader\n        }\n      }\n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","sourceOld":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by obj.getFieldCacheKey()\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<Object>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      Object obj = all.get(i);\n      if (obj instanceof CompositeReader) {\n        List<? extends IndexReader> subs = ((CompositeReader)obj).getSequentialSubReaders();\n        for (int j = 0; (null != subs) && (j < subs.size()); j++) {\n          all.add(subs.get(j).getCoreCacheKey());\n        }\n      }\n      \n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3c188105a9aae04f56c24996f98f8333fc825d2e","date":1345031914,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","sourceNew":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by {@code seed.getCoreCacheKey()}\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<Object>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      final Object obj = all.get(i);\n      // TODO: We don't check closed readers here (as getTopReaderContext\n      // throws AlreadyClosedException), what should we do? Reflection?\n      if (obj instanceof IndexReader) {\n        try {\n          final List<IndexReaderContext> childs =\n            ((IndexReader) obj).getContext().children();\n          if (childs != null) { // it is composite reader\n            for (final IndexReaderContext ctx : childs) {\n              all.add(ctx.reader().getCoreCacheKey());\n            }\n          }\n        } catch (AlreadyClosedException ace) {\n          // ignore this reader\n        }\n      }\n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","sourceOld":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by obj.getFieldCacheKey()\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<Object>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      Object obj = all.get(i);\n      if (obj instanceof CompositeReader) {\n        List<? extends IndexReader> subs = ((CompositeReader)obj).getSequentialSubReaders();\n        for (int j = 0; (null != subs) && (j < subs.size()); j++) {\n          all.add(subs.get(j).getCoreCacheKey());\n        }\n      }\n      \n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1c93396a1df03720cb20e2c2f513a6fa59b21e4c","date":1345032673,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","sourceNew":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by obj.getFieldCacheKey()\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<Object>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      Object obj = all.get(i);\n      if (obj instanceof CompositeReader) {\n        List<? extends IndexReader> subs = ((CompositeReader)obj).getSequentialSubReaders();\n        for (int j = 0; (null != subs) && (j < subs.size()); j++) {\n          all.add(subs.get(j).getCoreCacheKey());\n        }\n      }\n      \n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","sourceOld":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by {@code seed.getCoreCacheKey()}\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<Object>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      final Object obj = all.get(i);\n      // TODO: We don't check closed readers here (as getTopReaderContext\n      // throws AlreadyClosedException), what should we do? Reflection?\n      if (obj instanceof IndexReader) {\n        try {\n          final List<IndexReaderContext> childs =\n            ((IndexReader) obj).getContext().children();\n          if (childs != null) { // it is composite reader\n            for (final IndexReaderContext ctx : childs) {\n              all.add(ctx.reader().getCoreCacheKey());\n            }\n          }\n        } catch (AlreadyClosedException ace) {\n          // ignore this reader\n        }\n      }\n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","sourceNew":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by {@code seed.getCoreCacheKey()}\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<Object>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      final Object obj = all.get(i);\n      // TODO: We don't check closed readers here (as getTopReaderContext\n      // throws AlreadyClosedException), what should we do? Reflection?\n      if (obj instanceof IndexReader) {\n        try {\n          final List<IndexReaderContext> childs =\n            ((IndexReader) obj).getContext().children();\n          if (childs != null) { // it is composite reader\n            for (final IndexReaderContext ctx : childs) {\n              all.add(ctx.reader().getCoreCacheKey());\n            }\n          }\n        } catch (AlreadyClosedException ace) {\n          // ignore this reader\n        }\n      }\n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","sourceOld":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by obj.getFieldCacheKey()\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<Object>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      Object obj = all.get(i);\n      if (obj instanceof CompositeReader) {\n        List<? extends IndexReader> subs = ((CompositeReader)obj).getSequentialSubReaders();\n        for (int j = 0; (null != subs) && (j < subs.size()); j++) {\n          all.add(subs.get(j).getCoreCacheKey());\n        }\n      }\n      \n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","sourceNew":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by {@code seed.getCoreCacheKey()}\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      final Object obj = all.get(i);\n      // TODO: We don't check closed readers here (as getTopReaderContext\n      // throws AlreadyClosedException), what should we do? Reflection?\n      if (obj instanceof IndexReader) {\n        try {\n          final List<IndexReaderContext> childs =\n            ((IndexReader) obj).getContext().children();\n          if (childs != null) { // it is composite reader\n            for (final IndexReaderContext ctx : childs) {\n              all.add(ctx.reader().getCoreCacheKey());\n            }\n          }\n        } catch (AlreadyClosedException ace) {\n          // ignore this reader\n        }\n      }\n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","sourceOld":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by {@code seed.getCoreCacheKey()}\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<Object>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      final Object obj = all.get(i);\n      // TODO: We don't check closed readers here (as getTopReaderContext\n      // throws AlreadyClosedException), what should we do? Reflection?\n      if (obj instanceof IndexReader) {\n        try {\n          final List<IndexReaderContext> childs =\n            ((IndexReader) obj).getContext().children();\n          if (childs != null) { // it is composite reader\n            for (final IndexReaderContext ctx : childs) {\n              all.add(ctx.reader().getCoreCacheKey());\n            }\n          }\n        } catch (AlreadyClosedException ace) {\n          // ignore this reader\n        }\n      }\n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","date":1399816179,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/uninverting/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","sourceNew":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by {@code seed.getCoreCacheKey()}\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      final Object obj = all.get(i);\n      // TODO: We don't check closed readers here (as getTopReaderContext\n      // throws AlreadyClosedException), what should we do? Reflection?\n      if (obj instanceof IndexReader) {\n        try {\n          final List<IndexReaderContext> childs =\n            ((IndexReader) obj).getContext().children();\n          if (childs != null) { // it is composite reader\n            for (final IndexReaderContext ctx : childs) {\n              all.add(ctx.reader().getCoreCacheKey());\n            }\n          }\n        } catch (AlreadyClosedException ace) {\n          // ignore this reader\n        }\n      }\n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","sourceOld":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by {@code seed.getCoreCacheKey()}\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      final Object obj = all.get(i);\n      // TODO: We don't check closed readers here (as getTopReaderContext\n      // throws AlreadyClosedException), what should we do? Reflection?\n      if (obj instanceof IndexReader) {\n        try {\n          final List<IndexReaderContext> childs =\n            ((IndexReader) obj).getContext().children();\n          if (childs != null) { // it is composite reader\n            for (final IndexReaderContext ctx : childs) {\n              all.add(ctx.reader().getCoreCacheKey());\n            }\n          }\n        } catch (AlreadyClosedException ace) {\n          // ignore this reader\n        }\n      }\n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/misc/src/java/org/apache/lucene/uninverting/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","sourceNew":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by {@code seed.getCoreCacheKey()}\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      final Object obj = all.get(i);\n      // TODO: We don't check closed readers here (as getTopReaderContext\n      // throws AlreadyClosedException), what should we do? Reflection?\n      if (obj instanceof IndexReader) {\n        try {\n          final List<IndexReaderContext> childs =\n            ((IndexReader) obj).getContext().children();\n          if (childs != null) { // it is composite reader\n            for (final IndexReaderContext ctx : childs) {\n              all.add(ctx.reader().getCoreCacheKey());\n            }\n          }\n        } catch (AlreadyClosedException ace) {\n          // ignore this reader\n        }\n      }\n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","sourceOld":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by {@code seed.getCoreCacheKey()}\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      final Object obj = all.get(i);\n      // TODO: We don't check closed readers here (as getTopReaderContext\n      // throws AlreadyClosedException), what should we do? Reflection?\n      if (obj instanceof IndexReader) {\n        try {\n          final List<IndexReaderContext> childs =\n            ((IndexReader) obj).getContext().children();\n          if (childs != null) { // it is composite reader\n            for (final IndexReaderContext ctx : childs) {\n              all.add(ctx.reader().getCoreCacheKey());\n            }\n          }\n        } catch (AlreadyClosedException ace) {\n          // ignore this reader\n        }\n      }\n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":5,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/misc/src/java/org/apache/lucene/uninverting/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/FieldCacheSanityChecker#getAllDescendantReaderKeys(Object).mjava","sourceNew":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by {@code seed.getCoreCacheKey()}\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      final Object obj = all.get(i);\n      // TODO: We don't check closed readers here (as getTopReaderContext\n      // throws AlreadyClosedException), what should we do? Reflection?\n      if (obj instanceof IndexReader) {\n        try {\n          final List<IndexReaderContext> childs =\n            ((IndexReader) obj).getContext().children();\n          if (childs != null) { // it is composite reader\n            for (final IndexReaderContext ctx : childs) {\n              all.add(ctx.reader().getCoreCacheKey());\n            }\n          }\n        } catch (AlreadyClosedException ace) {\n          // ignore this reader\n        }\n      }\n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","sourceOld":"  /**\n   * Checks if the seed is an IndexReader, and if so will walk\n   * the hierarchy of subReaders building up a list of the objects \n   * returned by {@code seed.getCoreCacheKey()}\n   */\n  private List<Object> getAllDescendantReaderKeys(Object seed) {\n    List<Object> all = new ArrayList<>(17); // will grow as we iter\n    all.add(seed);\n    for (int i = 0; i < all.size(); i++) {\n      final Object obj = all.get(i);\n      // TODO: We don't check closed readers here (as getTopReaderContext\n      // throws AlreadyClosedException), what should we do? Reflection?\n      if (obj instanceof IndexReader) {\n        try {\n          final List<IndexReaderContext> childs =\n            ((IndexReader) obj).getContext().children();\n          if (childs != null) { // it is composite reader\n            for (final IndexReaderContext ctx : childs) {\n              all.add(ctx.reader().getCoreCacheKey());\n            }\n          }\n        } catch (AlreadyClosedException ace) {\n          // ignore this reader\n        }\n      }\n    }\n    // need to skip the first, because it was the seed\n    return all.subList(1, all.size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["211b1506e56f7860762fbd4698f6d1d1b57f672c"],"3c188105a9aae04f56c24996f98f8333fc825d2e":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c","211b1506e56f7860762fbd4698f6d1d1b57f672c"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["3c188105a9aae04f56c24996f98f8333fc825d2e"],"211b1506e56f7860762fbd4698f6d1d1b57f672c":["ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","211b1506e56f7860762fbd4698f6d1d1b57f672c"],"56572ec06f1407c066d6b7399413178b33176cd8":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","93dd449115a9247533e44bab47e8429e5dccbc6d"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ced66195b26fdb1f77ee00e2a77ec6918dedd766":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["93dd449115a9247533e44bab47e8429e5dccbc6d"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","56572ec06f1407c066d6b7399413178b33176cd8","93dd449115a9247533e44bab47e8429e5dccbc6d"],"3c188105a9aae04f56c24996f98f8333fc825d2e":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["3c188105a9aae04f56c24996f98f8333fc825d2e","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["b05c56a41b733e02a189c48895922b5bd8c7f3d1"],"211b1506e56f7860762fbd4698f6d1d1b57f672c":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":[],"56572ec06f1407c066d6b7399413178b33176cd8":[],"93dd449115a9247533e44bab47e8429e5dccbc6d":["56572ec06f1407c066d6b7399413178b33176cd8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"ced66195b26fdb1f77ee00e2a77ec6918dedd766":["211b1506e56f7860762fbd4698f6d1d1b57f672c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","56572ec06f1407c066d6b7399413178b33176cd8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}