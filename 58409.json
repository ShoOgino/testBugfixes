{"path":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#addShingledPhraseQueries(BooleanQuery,List[Clause],Collection[FieldParams],int,float,int).mjava","commits":[{"id":"acb10061e140a7f3d5035b8be54d966ebcb672ad","date":1407934573,"type":1,"author":"Erik Hatcher","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#addShingledPhraseQueries(BooleanQuery,List[Clause],Collection[FieldParams],int,float,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#addShingledPhraseQueries(BooleanQuery,List[Clause],Map[String,Float],int,float,int).mjava","sourceNew":"  /**\n   * Modifies the main query by adding a new optional Query consisting\n   * of shingled phrase queries across the specified clauses using the \n   * specified field =&gt; boost mappings.\n   *\n   * @param mainQuery Where the phrase boosting queries will be added\n   * @param clauses Clauses that will be used to construct the phrases\n   * @param fields Field =&gt; boost mappings for the phrase queries\n   * @param shingleSize how big the phrases should be, 0 means a single phrase\n   * @param tiebreaker tie breaker value for the DisjunctionMaxQueries\n   */\n  protected void addShingledPhraseQueries(final BooleanQuery mainQuery, \n      final List<Clause> clauses,\n      final Collection<FieldParams> fields,\n      int shingleSize,\n      final float tiebreaker,\n      final int slop)\n          throws SyntaxError {\n    \n    if (null == fields || fields.isEmpty() || \n        null == clauses || clauses.size() < shingleSize ) \n      return;\n    \n    if (0 == shingleSize) shingleSize = clauses.size();\n    \n    final int lastClauseIndex = shingleSize-1;\n    \n    StringBuilder userPhraseQuery = new StringBuilder();\n    for (int i=0; i < clauses.size() - lastClauseIndex; i++) {\n      userPhraseQuery.append('\"');\n      for (int j=0; j <= lastClauseIndex; j++) {\n        userPhraseQuery.append(clauses.get(i + j).val);\n        userPhraseQuery.append(' ');\n      }\n      userPhraseQuery.append('\"');\n      userPhraseQuery.append(' ');\n    }\n    \n    /* for parsing sloppy phrases using DisjunctionMaxQueries */\n    ExtendedSolrQueryParser pp = createEdismaxQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n\n    pp.addAlias(IMPOSSIBLE_FIELD_NAME, tiebreaker, getFieldBoosts(fields));\n    pp.setPhraseSlop(slop);\n    pp.setRemoveStopFilter(true);  // remove stop filter and keep stopwords\n    \n    /* :TODO: reevaluate using makeDismax=true vs false...\n     * \n     * The DismaxQueryParser always used DisjunctionMaxQueries for the \n     * pf boost, for the same reasons it used them for the qf fields.\n     * When Yonik first wrote the ExtendedDismaxQParserPlugin, he added\n     * the \"makeDismax=false\" property to use BooleanQueries instead, but \n     * when asked why his response was \"I honestly don't recall\" ...\n     *\n     * https://issues.apache.org/jira/browse/SOLR-1553?focusedCommentId=12793813#action_12793813\n     *\n     * so for now, we continue to use dismax style queries because it \n     * seems the most logical and is back compatible, but we should \n     * try to figure out what Yonik was thinking at the time (because he \n     * rarely does things for no reason)\n     */\n    pp.makeDismax = true; \n    \n    \n    // minClauseSize is independent of the shingleSize because of stop words\n    // (if they are removed from the middle, so be it, but we need at least \n    // two or there shouldn't be a boost)\n    pp.minClauseSize = 2;  \n    \n    // TODO: perhaps we shouldn't use synonyms either...\n    \n    Query phrase = pp.parse(userPhraseQuery.toString());\n    if (phrase != null) {\n      mainQuery.add(phrase, BooleanClause.Occur.SHOULD);\n    }\n  }\n\n","sourceOld":"  /**\n   * Modifies the main query by adding a new optional Query consisting\n   * of shingled phrase queries across the specified clauses using the \n   * specified field =&gt; boost mappings.\n   *\n   * @param mainQuery Where the phrase boosting queries will be added\n   * @param clauses Clauses that will be used to construct the phrases\n   * @param fields Field =&gt; boost mappings for the phrase queries\n   * @param shingleSize how big the phrases should be, 0 means a single phrase\n   * @param tiebreaker tie breaker value for the DisjunctionMaxQueries\n   * @param slop slop value for the constructed phrases\n   */\n  protected void addShingledPhraseQueries(final BooleanQuery mainQuery, \n      final List<Clause> clauses,\n      final Map<String,Float> fields,\n      int shingleSize,\n      final float tiebreaker,\n      final int slop) \n          throws SyntaxError {\n    \n    if (null == fields || fields.isEmpty() || \n        null == clauses || clauses.size() < shingleSize ) \n      return;\n    \n    if (0 == shingleSize) shingleSize = clauses.size();\n    \n    final int goat = shingleSize-1; // :TODO: better name for var?\n    \n    StringBuilder userPhraseQuery = new StringBuilder();\n    for (int i=0; i < clauses.size() - goat; i++) {\n      userPhraseQuery.append('\"');\n      for (int j=0; j <= goat; j++) {\n        userPhraseQuery.append(clauses.get(i + j).val);\n        userPhraseQuery.append(' ');\n      }\n      userPhraseQuery.append('\"');\n      userPhraseQuery.append(' ');\n    }\n    \n    /* for parsing sloppy phrases using DisjunctionMaxQueries */\n    ExtendedSolrQueryParser pp = createEdismaxQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n    \n    pp.addAlias(IMPOSSIBLE_FIELD_NAME, tiebreaker, fields);\n    pp.setPhraseSlop(slop);\n    pp.setRemoveStopFilter(true);  // remove stop filter and keep stopwords\n    \n    /* :TODO: reevaluate using makeDismax=true vs false...\n     * \n     * The DismaxQueryParser always used DisjunctionMaxQueries for the \n     * pf boost, for the same reasons it used them for the qf fields.\n     * When Yonik first wrote the ExtendedDismaxQParserPlugin, he added\n     * the \"makeDismax=false\" property to use BooleanQueries instead, but \n     * when asked why his response was \"I honestly don't recall\" ...\n     *\n     * https://issues.apache.org/jira/browse/SOLR-1553?focusedCommentId=12793813#action_12793813\n     *\n     * so for now, we continue to use dismax style queries because it \n     * seems the most logical and is back compatible, but we should \n     * try to figure out what Yonik was thinking at the time (because he \n     * rarely does things for no reason)\n     */\n    pp.makeDismax = true; \n    \n    \n    // minClauseSize is independent of the shingleSize because of stop words\n    // (if they are removed from the middle, so be it, but we need at least \n    // two or there shouldn't be a boost)\n    pp.minClauseSize = 2;  \n    \n    // TODO: perhaps we shouldn't use synonyms either...\n    \n    Query phrase = pp.parse(userPhraseQuery.toString());\n    if (phrase != null) {\n      mainQuery.add(phrase, BooleanClause.Occur.SHOULD);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#addShingledPhraseQueries(BooleanQuery.Builder,List[Clause],Collection[FieldParams],int,float,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/ExtendedDismaxQParser#addShingledPhraseQueries(BooleanQuery,List[Clause],Collection[FieldParams],int,float,int).mjava","sourceNew":"  /**\n   * Modifies the main query by adding a new optional Query consisting\n   * of shingled phrase queries across the specified clauses using the \n   * specified field =&gt; boost mappings.\n   *\n   * @param mainQuery Where the phrase boosting queries will be added\n   * @param clauses Clauses that will be used to construct the phrases\n   * @param fields Field =&gt; boost mappings for the phrase queries\n   * @param shingleSize how big the phrases should be, 0 means a single phrase\n   * @param tiebreaker tie breaker value for the DisjunctionMaxQueries\n   */\n  protected void addShingledPhraseQueries(final BooleanQuery.Builder mainQuery, \n      final List<Clause> clauses,\n      final Collection<FieldParams> fields,\n      int shingleSize,\n      final float tiebreaker,\n      final int slop)\n          throws SyntaxError {\n    \n    if (null == fields || fields.isEmpty() || \n        null == clauses || clauses.size() < shingleSize ) \n      return;\n    \n    if (0 == shingleSize) shingleSize = clauses.size();\n    \n    final int lastClauseIndex = shingleSize-1;\n    \n    StringBuilder userPhraseQuery = new StringBuilder();\n    for (int i=0; i < clauses.size() - lastClauseIndex; i++) {\n      userPhraseQuery.append('\"');\n      for (int j=0; j <= lastClauseIndex; j++) {\n        userPhraseQuery.append(clauses.get(i + j).val);\n        userPhraseQuery.append(' ');\n      }\n      userPhraseQuery.append('\"');\n      userPhraseQuery.append(' ');\n    }\n    \n    /* for parsing sloppy phrases using DisjunctionMaxQueries */\n    ExtendedSolrQueryParser pp = createEdismaxQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n\n    pp.addAlias(IMPOSSIBLE_FIELD_NAME, tiebreaker, getFieldBoosts(fields));\n    pp.setPhraseSlop(slop);\n    pp.setRemoveStopFilter(true);  // remove stop filter and keep stopwords\n    \n    /* :TODO: reevaluate using makeDismax=true vs false...\n     * \n     * The DismaxQueryParser always used DisjunctionMaxQueries for the \n     * pf boost, for the same reasons it used them for the qf fields.\n     * When Yonik first wrote the ExtendedDismaxQParserPlugin, he added\n     * the \"makeDismax=false\" property to use BooleanQueries instead, but \n     * when asked why his response was \"I honestly don't recall\" ...\n     *\n     * https://issues.apache.org/jira/browse/SOLR-1553?focusedCommentId=12793813#action_12793813\n     *\n     * so for now, we continue to use dismax style queries because it \n     * seems the most logical and is back compatible, but we should \n     * try to figure out what Yonik was thinking at the time (because he \n     * rarely does things for no reason)\n     */\n    pp.makeDismax = true; \n    \n    \n    // minClauseSize is independent of the shingleSize because of stop words\n    // (if they are removed from the middle, so be it, but we need at least \n    // two or there shouldn't be a boost)\n    pp.minClauseSize = 2;  \n    \n    // TODO: perhaps we shouldn't use synonyms either...\n    \n    Query phrase = pp.parse(userPhraseQuery.toString());\n    if (phrase != null) {\n      mainQuery.add(phrase, BooleanClause.Occur.SHOULD);\n    }\n  }\n\n","sourceOld":"  /**\n   * Modifies the main query by adding a new optional Query consisting\n   * of shingled phrase queries across the specified clauses using the \n   * specified field =&gt; boost mappings.\n   *\n   * @param mainQuery Where the phrase boosting queries will be added\n   * @param clauses Clauses that will be used to construct the phrases\n   * @param fields Field =&gt; boost mappings for the phrase queries\n   * @param shingleSize how big the phrases should be, 0 means a single phrase\n   * @param tiebreaker tie breaker value for the DisjunctionMaxQueries\n   */\n  protected void addShingledPhraseQueries(final BooleanQuery mainQuery, \n      final List<Clause> clauses,\n      final Collection<FieldParams> fields,\n      int shingleSize,\n      final float tiebreaker,\n      final int slop)\n          throws SyntaxError {\n    \n    if (null == fields || fields.isEmpty() || \n        null == clauses || clauses.size() < shingleSize ) \n      return;\n    \n    if (0 == shingleSize) shingleSize = clauses.size();\n    \n    final int lastClauseIndex = shingleSize-1;\n    \n    StringBuilder userPhraseQuery = new StringBuilder();\n    for (int i=0; i < clauses.size() - lastClauseIndex; i++) {\n      userPhraseQuery.append('\"');\n      for (int j=0; j <= lastClauseIndex; j++) {\n        userPhraseQuery.append(clauses.get(i + j).val);\n        userPhraseQuery.append(' ');\n      }\n      userPhraseQuery.append('\"');\n      userPhraseQuery.append(' ');\n    }\n    \n    /* for parsing sloppy phrases using DisjunctionMaxQueries */\n    ExtendedSolrQueryParser pp = createEdismaxQueryParser(this, IMPOSSIBLE_FIELD_NAME);\n\n    pp.addAlias(IMPOSSIBLE_FIELD_NAME, tiebreaker, getFieldBoosts(fields));\n    pp.setPhraseSlop(slop);\n    pp.setRemoveStopFilter(true);  // remove stop filter and keep stopwords\n    \n    /* :TODO: reevaluate using makeDismax=true vs false...\n     * \n     * The DismaxQueryParser always used DisjunctionMaxQueries for the \n     * pf boost, for the same reasons it used them for the qf fields.\n     * When Yonik first wrote the ExtendedDismaxQParserPlugin, he added\n     * the \"makeDismax=false\" property to use BooleanQueries instead, but \n     * when asked why his response was \"I honestly don't recall\" ...\n     *\n     * https://issues.apache.org/jira/browse/SOLR-1553?focusedCommentId=12793813#action_12793813\n     *\n     * so for now, we continue to use dismax style queries because it \n     * seems the most logical and is back compatible, but we should \n     * try to figure out what Yonik was thinking at the time (because he \n     * rarely does things for no reason)\n     */\n    pp.makeDismax = true; \n    \n    \n    // minClauseSize is independent of the shingleSize because of stop words\n    // (if they are removed from the middle, so be it, but we need at least \n    // two or there shouldn't be a boost)\n    pp.minClauseSize = 2;  \n    \n    // TODO: perhaps we shouldn't use synonyms either...\n    \n    Query phrase = pp.parse(userPhraseQuery.toString());\n    if (phrase != null) {\n      mainQuery.add(phrase, BooleanClause.Occur.SHOULD);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["acb10061e140a7f3d5035b8be54d966ebcb672ad"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"acb10061e140a7f3d5035b8be54d966ebcb672ad":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"]},"commit2Childs":{"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["acb10061e140a7f3d5035b8be54d966ebcb672ad"],"acb10061e140a7f3d5035b8be54d966ebcb672ad":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}