{"path":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testUTF8toUTF32().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testUTF8toUTF32().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/TestUnicodeUtil#testUTF8toUTF32().mjava","sourceNew":"  public void testUTF8toUTF32() {\n    BytesRef utf8 = new BytesRef(20);\n    IntsRef utf32 = new IntsRef(20);\n    int[] codePoints = new int[20];\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = _TestUtil.randomUnicodeString(random);\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      UnicodeUtil.UTF8toUTF32(utf8, utf32);\n      \n      int charUpto = 0;\n      int intUpto = 0;\n      while(charUpto < s.length()) {\n        final int cp = s.codePointAt(charUpto);\n        codePoints[intUpto++] = cp;\n        charUpto += Character.charCount(cp);\n      }\n      if (!ArrayUtil.equals(codePoints, 0, utf32.ints, utf32.offset, intUpto)) {\n        System.out.println(\"FAILED\");\n        for(int j=0;j<s.length();j++) {\n          System.out.println(\"  char[\" + j + \"]=\" + Integer.toHexString(s.charAt(j)));\n        }\n        System.out.println();\n        assertEquals(intUpto, utf32.length);\n        for(int j=0;j<intUpto;j++) {\n          System.out.println(\"  \" + Integer.toHexString(utf32.ints[j]) + \" vs \" + Integer.toHexString(codePoints[j]));\n        }\n        fail(\"mismatch\");\n      }\n    }\n  }\n\n","sourceOld":"  public void testUTF8toUTF32() {\n    BytesRef utf8 = new BytesRef(20);\n    IntsRef utf32 = new IntsRef(20);\n    int[] codePoints = new int[20];\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = _TestUtil.randomUnicodeString(random);\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      UnicodeUtil.UTF8toUTF32(utf8, utf32);\n      \n      int charUpto = 0;\n      int intUpto = 0;\n      while(charUpto < s.length()) {\n        final int cp = s.codePointAt(charUpto);\n        codePoints[intUpto++] = cp;\n        charUpto += Character.charCount(cp);\n      }\n      if (!ArrayUtil.equals(codePoints, 0, utf32.ints, utf32.offset, intUpto)) {\n        System.out.println(\"FAILED\");\n        for(int j=0;j<s.length();j++) {\n          System.out.println(\"  char[\" + j + \"]=\" + Integer.toHexString(s.charAt(j)));\n        }\n        System.out.println();\n        assertEquals(intUpto, utf32.length);\n        for(int j=0;j<intUpto;j++) {\n          System.out.println(\"  \" + Integer.toHexString(utf32.ints[j]) + \" vs \" + Integer.toHexString(codePoints[j]));\n        }\n        fail(\"mismatch\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testUTF8toUTF32().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testUTF8toUTF32().mjava","sourceNew":"  public void testUTF8toUTF32() {\n    BytesRef utf8 = new BytesRef(20);\n    IntsRef utf32 = new IntsRef(20);\n    int[] codePoints = new int[20];\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = _TestUtil.randomUnicodeString(random());\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      UnicodeUtil.UTF8toUTF32(utf8, utf32);\n      \n      int charUpto = 0;\n      int intUpto = 0;\n      while(charUpto < s.length()) {\n        final int cp = s.codePointAt(charUpto);\n        codePoints[intUpto++] = cp;\n        charUpto += Character.charCount(cp);\n      }\n      if (!ArrayUtil.equals(codePoints, 0, utf32.ints, utf32.offset, intUpto)) {\n        System.out.println(\"FAILED\");\n        for(int j=0;j<s.length();j++) {\n          System.out.println(\"  char[\" + j + \"]=\" + Integer.toHexString(s.charAt(j)));\n        }\n        System.out.println();\n        assertEquals(intUpto, utf32.length);\n        for(int j=0;j<intUpto;j++) {\n          System.out.println(\"  \" + Integer.toHexString(utf32.ints[j]) + \" vs \" + Integer.toHexString(codePoints[j]));\n        }\n        fail(\"mismatch\");\n      }\n    }\n  }\n\n","sourceOld":"  public void testUTF8toUTF32() {\n    BytesRef utf8 = new BytesRef(20);\n    IntsRef utf32 = new IntsRef(20);\n    int[] codePoints = new int[20];\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = _TestUtil.randomUnicodeString(random);\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      UnicodeUtil.UTF8toUTF32(utf8, utf32);\n      \n      int charUpto = 0;\n      int intUpto = 0;\n      while(charUpto < s.length()) {\n        final int cp = s.codePointAt(charUpto);\n        codePoints[intUpto++] = cp;\n        charUpto += Character.charCount(cp);\n      }\n      if (!ArrayUtil.equals(codePoints, 0, utf32.ints, utf32.offset, intUpto)) {\n        System.out.println(\"FAILED\");\n        for(int j=0;j<s.length();j++) {\n          System.out.println(\"  char[\" + j + \"]=\" + Integer.toHexString(s.charAt(j)));\n        }\n        System.out.println();\n        assertEquals(intUpto, utf32.length);\n        for(int j=0;j<intUpto;j++) {\n          System.out.println(\"  \" + Integer.toHexString(utf32.ints[j]) + \" vs \" + Integer.toHexString(codePoints[j]));\n        }\n        fail(\"mismatch\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testUTF8toUTF32().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testUTF8toUTF32().mjava","sourceNew":"  public void testUTF8toUTF32() {\n    BytesRef utf8 = new BytesRef(20);\n    IntsRef utf32 = new IntsRef(20);\n    int[] codePoints = new int[20];\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      UnicodeUtil.UTF8toUTF32(utf8, utf32);\n      \n      int charUpto = 0;\n      int intUpto = 0;\n      while(charUpto < s.length()) {\n        final int cp = s.codePointAt(charUpto);\n        codePoints[intUpto++] = cp;\n        charUpto += Character.charCount(cp);\n      }\n      if (!ArrayUtil.equals(codePoints, 0, utf32.ints, utf32.offset, intUpto)) {\n        System.out.println(\"FAILED\");\n        for(int j=0;j<s.length();j++) {\n          System.out.println(\"  char[\" + j + \"]=\" + Integer.toHexString(s.charAt(j)));\n        }\n        System.out.println();\n        assertEquals(intUpto, utf32.length);\n        for(int j=0;j<intUpto;j++) {\n          System.out.println(\"  \" + Integer.toHexString(utf32.ints[j]) + \" vs \" + Integer.toHexString(codePoints[j]));\n        }\n        fail(\"mismatch\");\n      }\n    }\n  }\n\n","sourceOld":"  public void testUTF8toUTF32() {\n    BytesRef utf8 = new BytesRef(20);\n    IntsRef utf32 = new IntsRef(20);\n    int[] codePoints = new int[20];\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = _TestUtil.randomUnicodeString(random());\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      UnicodeUtil.UTF8toUTF32(utf8, utf32);\n      \n      int charUpto = 0;\n      int intUpto = 0;\n      while(charUpto < s.length()) {\n        final int cp = s.codePointAt(charUpto);\n        codePoints[intUpto++] = cp;\n        charUpto += Character.charCount(cp);\n      }\n      if (!ArrayUtil.equals(codePoints, 0, utf32.ints, utf32.offset, intUpto)) {\n        System.out.println(\"FAILED\");\n        for(int j=0;j<s.length();j++) {\n          System.out.println(\"  char[\" + j + \"]=\" + Integer.toHexString(s.charAt(j)));\n        }\n        System.out.println();\n        assertEquals(intUpto, utf32.length);\n        for(int j=0;j<intUpto;j++) {\n          System.out.println(\"  \" + Integer.toHexString(utf32.ints[j]) + \" vs \" + Integer.toHexString(codePoints[j]));\n        }\n        fail(\"mismatch\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testUTF8toUTF32().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testUTF8toUTF32().mjava","sourceNew":"  public void testUTF8toUTF32() {\n    int[] utf32 = new int[0];\n    int[] codePoints = new int[20];\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      final byte[] utf8 = new byte[s.length() * UnicodeUtil.MAX_UTF8_BYTES_PER_CHAR];\n      final int utf8Len = UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      utf32 = ArrayUtil.grow(utf32, utf8Len);\n      final int utf32Len = UnicodeUtil.UTF8toUTF32(new BytesRef(utf8, 0, utf8Len), utf32);\n      \n      int charUpto = 0;\n      int intUpto = 0;\n      while(charUpto < s.length()) {\n        final int cp = s.codePointAt(charUpto);\n        codePoints[intUpto++] = cp;\n        charUpto += Character.charCount(cp);\n      }\n      if (!ArrayUtil.equals(codePoints, 0, utf32, 0, intUpto)) {\n        System.out.println(\"FAILED\");\n        for(int j=0;j<s.length();j++) {\n          System.out.println(\"  char[\" + j + \"]=\" + Integer.toHexString(s.charAt(j)));\n        }\n        System.out.println();\n        assertEquals(intUpto, utf32Len);\n        for(int j=0;j<intUpto;j++) {\n          System.out.println(\"  \" + Integer.toHexString(utf32[j]) + \" vs \" + Integer.toHexString(codePoints[j]));\n        }\n        fail(\"mismatch\");\n      }\n    }\n  }\n\n","sourceOld":"  public void testUTF8toUTF32() {\n    BytesRef utf8 = new BytesRef(20);\n    IntsRef utf32 = new IntsRef(20);\n    int[] codePoints = new int[20];\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      UnicodeUtil.UTF8toUTF32(utf8, utf32);\n      \n      int charUpto = 0;\n      int intUpto = 0;\n      while(charUpto < s.length()) {\n        final int cp = s.codePointAt(charUpto);\n        codePoints[intUpto++] = cp;\n        charUpto += Character.charCount(cp);\n      }\n      if (!ArrayUtil.equals(codePoints, 0, utf32.ints, utf32.offset, intUpto)) {\n        System.out.println(\"FAILED\");\n        for(int j=0;j<s.length();j++) {\n          System.out.println(\"  char[\" + j + \"]=\" + Integer.toHexString(s.charAt(j)));\n        }\n        System.out.println();\n        assertEquals(intUpto, utf32.length);\n        for(int j=0;j<intUpto;j++) {\n          System.out.println(\"  \" + Integer.toHexString(utf32.ints[j]) + \" vs \" + Integer.toHexString(codePoints[j]));\n        }\n        fail(\"mismatch\");\n      }\n    }\n  }\n\n","bugFix":["5acb0ee59cc50caf85402e92d148fdb2af61bc19"],"bugIntro":["c49ea3d4279fbc211c84a5d81ff591b5f8d18e83"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b51ee14e04858fe1f47f241ac29486de23b215b5","date":1456734355,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testUTF8toUTF32().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testUTF8toUTF32().mjava","sourceNew":"  public void testUTF8toUTF32() {\n    int[] utf32 = new int[0];\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      final byte[] utf8 = new byte[s.length() * UnicodeUtil.MAX_UTF8_BYTES_PER_CHAR];\n      final int utf8Len = UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      utf32 = ArrayUtil.grow(utf32, utf8Len);\n      final int utf32Len = UnicodeUtil.UTF8toUTF32(new BytesRef(utf8, 0, utf8Len), utf32);\n      \n      int[] codePoints = s.codePoints().toArray();\n      if (!ArrayUtil.equals(codePoints, 0, utf32, 0, codePoints.length)) {\n        System.out.println(\"FAILED\");\n        for(int j=0;j<s.length();j++) {\n          System.out.println(\"  char[\" + j + \"]=\" + Integer.toHexString(s.charAt(j)));\n        }\n        System.out.println();\n        assertEquals(codePoints.length, utf32Len);\n        for(int j=0;j<codePoints.length;j++) {\n          System.out.println(\"  \" + Integer.toHexString(utf32[j]) + \" vs \" + Integer.toHexString(codePoints[j]));\n        }\n        fail(\"mismatch\");\n      }\n    }\n  }\n\n","sourceOld":"  public void testUTF8toUTF32() {\n    int[] utf32 = new int[0];\n    int[] codePoints = new int[20];\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      final byte[] utf8 = new byte[s.length() * UnicodeUtil.MAX_UTF8_BYTES_PER_CHAR];\n      final int utf8Len = UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      utf32 = ArrayUtil.grow(utf32, utf8Len);\n      final int utf32Len = UnicodeUtil.UTF8toUTF32(new BytesRef(utf8, 0, utf8Len), utf32);\n      \n      int charUpto = 0;\n      int intUpto = 0;\n      while(charUpto < s.length()) {\n        final int cp = s.codePointAt(charUpto);\n        codePoints[intUpto++] = cp;\n        charUpto += Character.charCount(cp);\n      }\n      if (!ArrayUtil.equals(codePoints, 0, utf32, 0, intUpto)) {\n        System.out.println(\"FAILED\");\n        for(int j=0;j<s.length();j++) {\n          System.out.println(\"  char[\" + j + \"]=\" + Integer.toHexString(s.charAt(j)));\n        }\n        System.out.println();\n        assertEquals(intUpto, utf32Len);\n        for(int j=0;j<intUpto;j++) {\n          System.out.println(\"  \" + Integer.toHexString(utf32[j]) + \" vs \" + Integer.toHexString(codePoints[j]));\n        }\n        fail(\"mismatch\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testUTF8toUTF32().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testUTF8toUTF32().mjava","sourceNew":"  public void testUTF8toUTF32() {\n    int[] utf32 = new int[0];\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      final byte[] utf8 = new byte[s.length() * UnicodeUtil.MAX_UTF8_BYTES_PER_CHAR];\n      final int utf8Len = UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      utf32 = ArrayUtil.grow(utf32, utf8Len);\n      final int utf32Len = UnicodeUtil.UTF8toUTF32(new BytesRef(utf8, 0, utf8Len), utf32);\n      \n      int[] codePoints = s.codePoints().toArray();\n      if (!ArrayUtil.equals(codePoints, 0, utf32, 0, codePoints.length)) {\n        System.out.println(\"FAILED\");\n        for(int j=0;j<s.length();j++) {\n          System.out.println(\"  char[\" + j + \"]=\" + Integer.toHexString(s.charAt(j)));\n        }\n        System.out.println();\n        assertEquals(codePoints.length, utf32Len);\n        for(int j=0;j<codePoints.length;j++) {\n          System.out.println(\"  \" + Integer.toHexString(utf32[j]) + \" vs \" + Integer.toHexString(codePoints[j]));\n        }\n        fail(\"mismatch\");\n      }\n    }\n  }\n\n","sourceOld":"  public void testUTF8toUTF32() {\n    int[] utf32 = new int[0];\n    int[] codePoints = new int[20];\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      final byte[] utf8 = new byte[s.length() * UnicodeUtil.MAX_UTF8_BYTES_PER_CHAR];\n      final int utf8Len = UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      utf32 = ArrayUtil.grow(utf32, utf8Len);\n      final int utf32Len = UnicodeUtil.UTF8toUTF32(new BytesRef(utf8, 0, utf8Len), utf32);\n      \n      int charUpto = 0;\n      int intUpto = 0;\n      while(charUpto < s.length()) {\n        final int cp = s.codePointAt(charUpto);\n        codePoints[intUpto++] = cp;\n        charUpto += Character.charCount(cp);\n      }\n      if (!ArrayUtil.equals(codePoints, 0, utf32, 0, intUpto)) {\n        System.out.println(\"FAILED\");\n        for(int j=0;j<s.length();j++) {\n          System.out.println(\"  char[\" + j + \"]=\" + Integer.toHexString(s.charAt(j)));\n        }\n        System.out.println();\n        assertEquals(intUpto, utf32Len);\n        for(int j=0;j<intUpto;j++) {\n          System.out.println(\"  \" + Integer.toHexString(utf32[j]) + \" vs \" + Integer.toHexString(codePoints[j]));\n        }\n        fail(\"mismatch\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c49ea3d4279fbc211c84a5d81ff591b5f8d18e83","date":1478775068,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testUTF8toUTF32().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testUTF8toUTF32().mjava","sourceNew":"  public void testUTF8toUTF32() {\n    int[] utf32 = new int[0];\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      final byte[] utf8 = new byte[UnicodeUtil.maxUTF8Length(s.length())];\n      final int utf8Len = UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      utf32 = ArrayUtil.grow(utf32, utf8Len);\n      final int utf32Len = UnicodeUtil.UTF8toUTF32(new BytesRef(utf8, 0, utf8Len), utf32);\n      \n      int[] codePoints = s.codePoints().toArray();\n      if (!ArrayUtil.equals(codePoints, 0, utf32, 0, codePoints.length)) {\n        System.out.println(\"FAILED\");\n        for(int j=0;j<s.length();j++) {\n          System.out.println(\"  char[\" + j + \"]=\" + Integer.toHexString(s.charAt(j)));\n        }\n        System.out.println();\n        assertEquals(codePoints.length, utf32Len);\n        for(int j=0;j<codePoints.length;j++) {\n          System.out.println(\"  \" + Integer.toHexString(utf32[j]) + \" vs \" + Integer.toHexString(codePoints[j]));\n        }\n        fail(\"mismatch\");\n      }\n    }\n  }\n\n","sourceOld":"  public void testUTF8toUTF32() {\n    int[] utf32 = new int[0];\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      final byte[] utf8 = new byte[s.length() * UnicodeUtil.MAX_UTF8_BYTES_PER_CHAR];\n      final int utf8Len = UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      utf32 = ArrayUtil.grow(utf32, utf8Len);\n      final int utf32Len = UnicodeUtil.UTF8toUTF32(new BytesRef(utf8, 0, utf8Len), utf32);\n      \n      int[] codePoints = s.codePoints().toArray();\n      if (!ArrayUtil.equals(codePoints, 0, utf32, 0, codePoints.length)) {\n        System.out.println(\"FAILED\");\n        for(int j=0;j<s.length();j++) {\n          System.out.println(\"  char[\" + j + \"]=\" + Integer.toHexString(s.charAt(j)));\n        }\n        System.out.println();\n        assertEquals(codePoints.length, utf32Len);\n        for(int j=0;j<codePoints.length;j++) {\n          System.out.println(\"  \" + Integer.toHexString(utf32[j]) + \" vs \" + Integer.toHexString(codePoints[j]));\n        }\n        fail(\"mismatch\");\n      }\n    }\n  }\n\n","bugFix":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testUTF8toUTF32().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testUTF8toUTF32().mjava","sourceNew":"  public void testUTF8toUTF32() {\n    int[] utf32 = new int[0];\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      final byte[] utf8 = new byte[UnicodeUtil.maxUTF8Length(s.length())];\n      final int utf8Len = UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      utf32 = ArrayUtil.grow(utf32, utf8Len);\n      final int utf32Len = UnicodeUtil.UTF8toUTF32(new BytesRef(utf8, 0, utf8Len), utf32);\n      \n      int[] codePoints = s.codePoints().toArray();\n      if (!ArrayUtil.equals(codePoints, 0, utf32, 0, codePoints.length)) {\n        System.out.println(\"FAILED\");\n        for(int j=0;j<s.length();j++) {\n          System.out.println(\"  char[\" + j + \"]=\" + Integer.toHexString(s.charAt(j)));\n        }\n        System.out.println();\n        assertEquals(codePoints.length, utf32Len);\n        for(int j=0;j<codePoints.length;j++) {\n          System.out.println(\"  \" + Integer.toHexString(utf32[j]) + \" vs \" + Integer.toHexString(codePoints[j]));\n        }\n        fail(\"mismatch\");\n      }\n    }\n  }\n\n","sourceOld":"  public void testUTF8toUTF32() {\n    int[] utf32 = new int[0];\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      final byte[] utf8 = new byte[s.length() * UnicodeUtil.MAX_UTF8_BYTES_PER_CHAR];\n      final int utf8Len = UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      utf32 = ArrayUtil.grow(utf32, utf8Len);\n      final int utf32Len = UnicodeUtil.UTF8toUTF32(new BytesRef(utf8, 0, utf8Len), utf32);\n      \n      int[] codePoints = s.codePoints().toArray();\n      if (!ArrayUtil.equals(codePoints, 0, utf32, 0, codePoints.length)) {\n        System.out.println(\"FAILED\");\n        for(int j=0;j<s.length();j++) {\n          System.out.println(\"  char[\" + j + \"]=\" + Integer.toHexString(s.charAt(j)));\n        }\n        System.out.println();\n        assertEquals(codePoints.length, utf32Len);\n        for(int j=0;j<codePoints.length;j++) {\n          System.out.println(\"  \" + Integer.toHexString(utf32[j]) + \" vs \" + Integer.toHexString(codePoints[j]));\n        }\n        fail(\"mismatch\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"456d7e7092cb043c740b4674301660ee8abc26fe","date":1517645879,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testUTF8toUTF32().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testUTF8toUTF32().mjava","sourceNew":"  public void testUTF8toUTF32() {\n    int[] utf32 = new int[0];\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      final byte[] utf8 = new byte[UnicodeUtil.maxUTF8Length(s.length())];\n      final int utf8Len = UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      utf32 = ArrayUtil.grow(utf32, utf8Len);\n      final int utf32Len = UnicodeUtil.UTF8toUTF32(new BytesRef(utf8, 0, utf8Len), utf32);\n      \n      int[] codePoints = s.codePoints().toArray();\n      if (!FutureArrays.equals(codePoints, 0, codePoints.length, utf32, 0, codePoints.length)) {\n        System.out.println(\"FAILED\");\n        for(int j=0;j<s.length();j++) {\n          System.out.println(\"  char[\" + j + \"]=\" + Integer.toHexString(s.charAt(j)));\n        }\n        System.out.println();\n        assertEquals(codePoints.length, utf32Len);\n        for(int j=0;j<codePoints.length;j++) {\n          System.out.println(\"  \" + Integer.toHexString(utf32[j]) + \" vs \" + Integer.toHexString(codePoints[j]));\n        }\n        fail(\"mismatch\");\n      }\n    }\n  }\n\n","sourceOld":"  public void testUTF8toUTF32() {\n    int[] utf32 = new int[0];\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      final byte[] utf8 = new byte[UnicodeUtil.maxUTF8Length(s.length())];\n      final int utf8Len = UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      utf32 = ArrayUtil.grow(utf32, utf8Len);\n      final int utf32Len = UnicodeUtil.UTF8toUTF32(new BytesRef(utf8, 0, utf8Len), utf32);\n      \n      int[] codePoints = s.codePoints().toArray();\n      if (!ArrayUtil.equals(codePoints, 0, utf32, 0, codePoints.length)) {\n        System.out.println(\"FAILED\");\n        for(int j=0;j<s.length();j++) {\n          System.out.println(\"  char[\" + j + \"]=\" + Integer.toHexString(s.charAt(j)));\n        }\n        System.out.println();\n        assertEquals(codePoints.length, utf32Len);\n        for(int j=0;j<codePoints.length;j++) {\n          System.out.println(\"  \" + Integer.toHexString(utf32[j]) + \" vs \" + Integer.toHexString(codePoints[j]));\n        }\n        fail(\"mismatch\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testUTF8toUTF32().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil#testUTF8toUTF32().mjava","sourceNew":"  public void testUTF8toUTF32() {\n    int[] utf32 = new int[0];\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      final byte[] utf8 = new byte[UnicodeUtil.maxUTF8Length(s.length())];\n      final int utf8Len = UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      utf32 = ArrayUtil.grow(utf32, utf8Len);\n      final int utf32Len = UnicodeUtil.UTF8toUTF32(new BytesRef(utf8, 0, utf8Len), utf32);\n      \n      int[] codePoints = s.codePoints().toArray();\n      if (!Arrays.equals(codePoints, 0, codePoints.length, utf32, 0, codePoints.length)) {\n        System.out.println(\"FAILED\");\n        for(int j=0;j<s.length();j++) {\n          System.out.println(\"  char[\" + j + \"]=\" + Integer.toHexString(s.charAt(j)));\n        }\n        System.out.println();\n        assertEquals(codePoints.length, utf32Len);\n        for(int j=0;j<codePoints.length;j++) {\n          System.out.println(\"  \" + Integer.toHexString(utf32[j]) + \" vs \" + Integer.toHexString(codePoints[j]));\n        }\n        fail(\"mismatch\");\n      }\n    }\n  }\n\n","sourceOld":"  public void testUTF8toUTF32() {\n    int[] utf32 = new int[0];\n    int num = atLeast(50000);\n    for (int i = 0; i < num; i++) {\n      final String s = TestUtil.randomUnicodeString(random());\n      final byte[] utf8 = new byte[UnicodeUtil.maxUTF8Length(s.length())];\n      final int utf8Len = UnicodeUtil.UTF16toUTF8(s, 0, s.length(), utf8);\n      utf32 = ArrayUtil.grow(utf32, utf8Len);\n      final int utf32Len = UnicodeUtil.UTF8toUTF32(new BytesRef(utf8, 0, utf8Len), utf32);\n      \n      int[] codePoints = s.codePoints().toArray();\n      if (!FutureArrays.equals(codePoints, 0, codePoints.length, utf32, 0, codePoints.length)) {\n        System.out.println(\"FAILED\");\n        for(int j=0;j<s.length();j++) {\n          System.out.println(\"  char[\" + j + \"]=\" + Integer.toHexString(s.charAt(j)));\n        }\n        System.out.println();\n        assertEquals(codePoints.length, utf32Len);\n        for(int j=0;j<codePoints.length;j++) {\n          System.out.println(\"  \" + Integer.toHexString(utf32[j]) + \" vs \" + Integer.toHexString(codePoints[j]));\n        }\n        fail(\"mismatch\");\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","b51ee14e04858fe1f47f241ac29486de23b215b5"],"b51ee14e04858fe1f47f241ac29486de23b215b5":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["456d7e7092cb043c740b4674301660ee8abc26fe"],"456d7e7092cb043c740b4674301660ee8abc26fe":["c49ea3d4279fbc211c84a5d81ff591b5f8d18e83"],"c49ea3d4279fbc211c84a5d81ff591b5f8d18e83":["af2638813028b254a88b418ebeafb541afb49653"],"6613659748fe4411a7dcf85266e55db1f95f7315":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["af2638813028b254a88b418ebeafb541afb49653","c49ea3d4279fbc211c84a5d81ff591b5f8d18e83"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["6613659748fe4411a7dcf85266e55db1f95f7315"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b88a121b875f9ae2ac50f85cf46dcb680f126357"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["c49ea3d4279fbc211c84a5d81ff591b5f8d18e83","199dfa410f1fdbfd3294106b04096cce5ed34b21"],"b51ee14e04858fe1f47f241ac29486de23b215b5":["af2638813028b254a88b418ebeafb541afb49653"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"456d7e7092cb043c740b4674301660ee8abc26fe":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"c49ea3d4279fbc211c84a5d81ff591b5f8d18e83":["456d7e7092cb043c740b4674301660ee8abc26fe","199dfa410f1fdbfd3294106b04096cce5ed34b21"],"6613659748fe4411a7dcf85266e55db1f95f7315":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["af2638813028b254a88b418ebeafb541afb49653","b51ee14e04858fe1f47f241ac29486de23b215b5"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["6613659748fe4411a7dcf85266e55db1f95f7315"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["199dfa410f1fdbfd3294106b04096cce5ed34b21","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}