{"path":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","commits":[{"id":"7a880067b581fc84516f159379b1345bb9740261","date":1351217082,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","pathOld":"/dev/null","sourceNew":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new StringField(\"value\", \"\", Field.Store.YES);\n    doc.add(field);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setStringValue(Integer.toString(val));\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = new IndexSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, Integer.MAX_VALUE, orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, Integer.MAX_VALUE, orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["450d0bc37c59f2de7743066469a444243907fd75"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","pathOld":"/dev/null","sourceNew":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new StringField(\"value\", \"\", Field.Store.YES);\n    doc.add(field);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setStringValue(Integer.toString(val));\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = new IndexSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, Integer.MAX_VALUE, orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, Integer.MAX_VALUE, orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad1f7eb1a6bbf19f3d32b3baf2dee3db844eccdc","date":1366056945,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","pathOld":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","sourceNew":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new StringField(\"value\", \"\", Field.Store.YES);\n    doc.add(field);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setStringValue(Integer.toString(val));\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, Integer.MAX_VALUE, orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, Integer.MAX_VALUE, orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new StringField(\"value\", \"\", Field.Store.YES);\n    doc.add(field);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setStringValue(Integer.toString(val));\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = new IndexSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, Integer.MAX_VALUE, orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, Integer.MAX_VALUE, orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"450d0bc37c59f2de7743066469a444243907fd75","date":1366384804,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","pathOld":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","sourceNew":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new StringField(\"value\", \"\", Field.Store.YES);\n    doc.add(field);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setStringValue(Integer.toString(val));\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new StringField(\"value\", \"\", Field.Store.YES);\n    doc.add(field);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setStringValue(Integer.toString(val));\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, Integer.MAX_VALUE, orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, Integer.MAX_VALUE, orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":["7a880067b581fc84516f159379b1345bb9740261"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59a0020b413d44dd79d85d7a66ed5004265fb453","date":1371758877,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","pathOld":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","sourceNew":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new IntField(\"value\", 0, Field.Store.YES);\n    doc.add(field);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setIntValue(val);\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new StringField(\"value\", \"\", Field.Store.YES);\n    doc.add(field);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setStringValue(Integer.toString(val));\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","pathOld":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","sourceNew":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new IntField(\"value\", 0, Field.Store.YES);\n    doc.add(field);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setIntValue(val);\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new StringField(\"value\", \"\", Field.Store.YES);\n    doc.add(field);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setStringValue(Integer.toString(val));\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","pathOld":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","sourceNew":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new IntField(\"value\", 0, Field.Store.YES);\n    doc.add(field);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setIntValue(val);\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.shutdown();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new IntField(\"value\", 0, Field.Store.YES);\n    doc.add(field);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setIntValue(val);\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","date":1399816179,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","pathOld":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","sourceNew":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new IntField(\"value\", 0, Field.Store.YES);\n    Field dvField = new NumericDocValuesField(\"value\", 0);\n    doc.add(field);\n    doc.add(dvField);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setIntValue(val);\n      dvField.setLongValue(val);\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.shutdown();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new IntField(\"value\", 0, Field.Store.YES);\n    doc.add(field);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setIntValue(val);\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.shutdown();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","pathOld":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","sourceNew":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new IntField(\"value\", 0, Field.Store.YES);\n    Field dvField = new NumericDocValuesField(\"value\", 0);\n    doc.add(field);\n    doc.add(dvField);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setIntValue(val);\n      dvField.setLongValue(val);\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.shutdown();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new IntField(\"value\", 0, Field.Store.YES);\n    doc.add(field);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setIntValue(val);\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.shutdown();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","pathOld":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","sourceNew":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new IntField(\"value\", 0, Field.Store.YES);\n    Field dvField = new NumericDocValuesField(\"value\", 0);\n    doc.add(field);\n    doc.add(dvField);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setIntValue(val);\n      dvField.setLongValue(val);\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.shutdown();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new IntField(\"value\", 0, Field.Store.YES);\n    doc.add(field);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setIntValue(val);\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.shutdown();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","pathOld":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","sourceNew":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new IntField(\"value\", 0, Field.Store.YES);\n    Field dvField = new NumericDocValuesField(\"value\", 0);\n    doc.add(field);\n    doc.add(dvField);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setIntValue(val);\n      dvField.setLongValue(val);\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.shutdown();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new IntField(\"value\", 0, Field.Store.YES);\n    Field dvField = new NumericDocValuesField(\"value\", 0);\n    doc.add(field);\n    doc.add(dvField);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setIntValue(val);\n      dvField.setLongValue(val);\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.shutdown();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","pathOld":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","sourceNew":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new IntField(\"value\", 0, Field.Store.YES);\n    Field dvField = new NumericDocValuesField(\"value\", 0);\n    doc.add(field);\n    doc.add(dvField);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setIntValue(val);\n      dvField.setLongValue(val);\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new IntField(\"value\", 0, Field.Store.YES);\n    Field dvField = new NumericDocValuesField(\"value\", 0);\n    doc.add(field);\n    doc.add(dvField);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setIntValue(val);\n      dvField.setLongValue(val);\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.shutdown();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f7f81a15cd0183e4e6262806b2e491a130e63db","date":1438643602,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","pathOld":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","sourceNew":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new IntField(\"value\", 0, Field.Store.YES);\n    Field dvField = new NumericDocValuesField(\"value\", 0);\n    doc.add(field);\n    doc.add(dvField);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setIntValue(val);\n      dvField.setLongValue(val);\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Trivial ValueSource function that bypasses single field ValueSource sort optimization\n    ValueSource src = new SumFloatFunction(new ValueSource[] { new IntFieldSource(\"value\"),\n                                                               new DoubleConstValueSource(1.0D) });\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new IntField(\"value\", 0, Field.Store.YES);\n    Field dvField = new NumericDocValuesField(\"value\", 0);\n    doc.add(field);\n    doc.add(dvField);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setIntValue(val);\n      dvField.setLongValue(val);\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Get ValueSource from FieldCache\n    IntFieldSource src = new IntFieldSource(\"value\");\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","pathOld":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","sourceNew":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new LegacyIntField(\"value\", 0, Field.Store.YES);\n    Field dvField = new NumericDocValuesField(\"value\", 0);\n    doc.add(field);\n    doc.add(dvField);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setIntValue(val);\n      dvField.setLongValue(val);\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Trivial ValueSource function that bypasses single field ValueSource sort optimization\n    ValueSource src = new SumFloatFunction(new ValueSource[] { new IntFieldSource(\"value\"),\n                                                               new DoubleConstValueSource(1.0D) });\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new IntField(\"value\", 0, Field.Store.YES);\n    Field dvField = new NumericDocValuesField(\"value\", 0);\n    doc.add(field);\n    doc.add(dvField);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setIntValue(val);\n      dvField.setLongValue(val);\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Trivial ValueSource function that bypasses single field ValueSource sort optimization\n    ValueSource src = new SumFloatFunction(new ValueSource[] { new IntFieldSource(\"value\"),\n                                                               new DoubleConstValueSource(1.0D) });\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0858e338cc7ed91cff3bae1cb26df0fba2b4f254","date":1457453832,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","pathOld":"lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionQuerySort#testSearchAfterWhenSortingByFunctionValues().mjava","sourceNew":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new StoredField(\"value\", 0);\n    Field dvField = new NumericDocValuesField(\"value\", 0);\n    doc.add(field);\n    doc.add(dvField);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setIntValue(val);\n      dvField.setLongValue(val);\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Trivial ValueSource function that bypasses single field ValueSource sort optimization\n    ValueSource src = new SumFloatFunction(new ValueSource[] { new IntFieldSource(\"value\"),\n                                                               new DoubleConstValueSource(1.0D) });\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSearchAfterWhenSortingByFunctionValues() throws IOException {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(null);\n    iwc.setMergePolicy(newLogMergePolicy()); // depends on docid order\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, iwc);\n\n    Document doc = new Document();\n    Field field = new LegacyIntField(\"value\", 0, Field.Store.YES);\n    Field dvField = new NumericDocValuesField(\"value\", 0);\n    doc.add(field);\n    doc.add(dvField);\n\n    // Save docs unsorted (decreasing value n, n-1, ...)\n    final int NUM_VALS = 5;\n    for (int val = NUM_VALS; val > 0; val--) {\n      field.setIntValue(val);\n      dvField.setLongValue(val);\n      writer.addDocument(doc);\n    }\n\n    // Open index\n    IndexReader reader = writer.getReader();\n    writer.close();\n    IndexSearcher searcher = newSearcher(reader);\n\n    // Trivial ValueSource function that bypasses single field ValueSource sort optimization\n    ValueSource src = new SumFloatFunction(new ValueSource[] { new IntFieldSource(\"value\"),\n                                                               new DoubleConstValueSource(1.0D) });\n    // ...and make it a sort criterion\n    SortField sf = src.getSortField(false).rewrite(searcher);\n    Sort orderBy = new Sort(sf);\n\n    // Get hits sorted by our FunctionValues (ascending values)\n    Query q = new MatchAllDocsQuery();\n    TopDocs hits = searcher.search(q, reader.maxDoc(), orderBy);\n    assertEquals(NUM_VALS, hits.scoreDocs.length);\n    // Verify that sorting works in general\n    int i = 0;\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int valueFromDoc = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertEquals(++i, valueFromDoc);\n    }\n\n    // Now get hits after hit #2 using IS.searchAfter()\n    int afterIdx = 1;\n    FieldDoc afterHit = (FieldDoc) hits.scoreDocs[afterIdx];\n    hits = searcher.searchAfter(afterHit, q, reader.maxDoc(), orderBy);\n\n    // Expected # of hits: NUM_VALS - 2\n    assertEquals(NUM_VALS - (afterIdx + 1), hits.scoreDocs.length);\n\n    // Verify that hits are actually \"after\"\n    int afterValue = ((Double) afterHit.fields[0]).intValue();\n    for (ScoreDoc hit : hits.scoreDocs) {\n      int val = Integer.parseInt(reader.document(hit.doc).get(\"value\"));\n      assertTrue(afterValue <= val);\n      assertFalse(hit.doc == afterHit.doc);\n    }\n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["450d0bc37c59f2de7743066469a444243907fd75","59a0020b413d44dd79d85d7a66ed5004265fb453"],"0858e338cc7ed91cff3bae1cb26df0fba2b4f254":["770342641f7b505eaa8dccdc666158bff2419109"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"56572ec06f1407c066d6b7399413178b33176cd8":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","93dd449115a9247533e44bab47e8429e5dccbc6d"],"770342641f7b505eaa8dccdc666158bff2419109":["3f7f81a15cd0183e4e6262806b2e491a130e63db"],"3f7f81a15cd0183e4e6262806b2e491a130e63db":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"59a0020b413d44dd79d85d7a66ed5004265fb453":["450d0bc37c59f2de7743066469a444243907fd75"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["59a0020b413d44dd79d85d7a66ed5004265fb453"],"7a880067b581fc84516f159379b1345bb9740261":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f2126b84bd093fa3d921582a109a0ee578c28126":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7a880067b581fc84516f159379b1345bb9740261"],"450d0bc37c59f2de7743066469a444243907fd75":["ad1f7eb1a6bbf19f3d32b3baf2dee3db844eccdc"],"ad1f7eb1a6bbf19f3d32b3baf2dee3db844eccdc":["7a880067b581fc84516f159379b1345bb9740261"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0858e338cc7ed91cff3bae1cb26df0fba2b4f254"]},"commit2Childs":{"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"0858e338cc7ed91cff3bae1cb26df0fba2b4f254":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"770342641f7b505eaa8dccdc666158bff2419109":["0858e338cc7ed91cff3bae1cb26df0fba2b4f254"],"3f7f81a15cd0183e4e6262806b2e491a130e63db":["770342641f7b505eaa8dccdc666158bff2419109"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","56572ec06f1407c066d6b7399413178b33176cd8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7a880067b581fc84516f159379b1345bb9740261","f2126b84bd093fa3d921582a109a0ee578c28126"],"59a0020b413d44dd79d85d7a66ed5004265fb453":["37a0f60745e53927c4c876cfe5b5a58170f0646c","ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["3f7f81a15cd0183e4e6262806b2e491a130e63db"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","56572ec06f1407c066d6b7399413178b33176cd8","93dd449115a9247533e44bab47e8429e5dccbc6d"],"7a880067b581fc84516f159379b1345bb9740261":["f2126b84bd093fa3d921582a109a0ee578c28126","ad1f7eb1a6bbf19f3d32b3baf2dee3db844eccdc"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"450d0bc37c59f2de7743066469a444243907fd75":["37a0f60745e53927c4c876cfe5b5a58170f0646c","59a0020b413d44dd79d85d7a66ed5004265fb453"],"ad1f7eb1a6bbf19f3d32b3baf2dee3db844eccdc":["450d0bc37c59f2de7743066469a444243907fd75"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","56572ec06f1407c066d6b7399413178b33176cd8","f2126b84bd093fa3d921582a109a0ee578c28126","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}