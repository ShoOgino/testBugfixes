{"path":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAcquireReleaseRace().mjava","commits":[{"id":"4208ed8e426ae5f75a41d8b4ae53f4587e413061","date":1580475454,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAcquireReleaseRace().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl#testAccquireReleaseRace().mjava","sourceNew":"  public void testAcquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchronizer sync = new Synchronizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = TEST_NIGHTLY ? atLeast(10000) : atLeast(1000);\n    final float checkPointProbability = TEST_NIGHTLY ? 0.5f : 0.1f;\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (checkPointProbability >= random().nextFloat()) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      ctrl.updateStalled(false);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testAccquireReleaseRace() throws InterruptedException {\n    final DocumentsWriterStallControl ctrl = new DocumentsWriterStallControl();\n    ctrl.updateStalled(false);\n    final AtomicBoolean stop = new AtomicBoolean(false);\n    final AtomicBoolean checkPoint = new AtomicBoolean(true);\n    \n    int numStallers = atLeast(1);\n    int numReleasers = atLeast(1);\n    int numWaiters = atLeast(1);\n    final Synchronizer sync = new Synchronizer(numStallers + numReleasers, numStallers + numReleasers+numWaiters);\n    Thread[] threads = new Thread[numReleasers + numStallers + numWaiters];\n    List<Throwable> exceptions =  Collections.synchronizedList(new ArrayList<Throwable>());\n    for (int i = 0; i < numReleasers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, true, exceptions);\n    }\n    for (int i = numReleasers; i < numReleasers + numStallers; i++) {\n      threads[i] = new Updater(stop, checkPoint, ctrl, sync, false, exceptions);\n      \n    }\n    for (int i = numReleasers + numStallers; i < numReleasers + numStallers\n        + numWaiters; i++) {\n      threads[i] = new Waiter(stop, checkPoint, ctrl, sync, exceptions);\n      \n    }\n    \n    start(threads);\n    int iters = atLeast(10000);\n    final float checkPointProbability = TEST_NIGHTLY ? 0.5f : 0.1f;\n    for (int i = 0; i < iters; i++) {\n      if (checkPoint.get()) {\n       \n        assertTrue(\"timed out waiting for update threads - deadlock?\", sync.updateJoin.await(10, TimeUnit.SECONDS));\n        if (!exceptions.isEmpty()) {\n          for (Throwable throwable : exceptions) {\n            throwable.printStackTrace();\n          }\n          fail(\"got exceptions in threads\");\n        }\n        \n        if (ctrl.hasBlocked() && ctrl.isHealthy()) {\n          assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n          \n           \n          }\n        \n        checkPoint.set(false);\n        sync.waiter.countDown();\n        sync.leftCheckpoint.await();\n      }\n      assertFalse(checkPoint.get());\n      assertEquals(0, sync.waiter.getCount());\n      if (checkPointProbability >= random().nextFloat()) {\n        sync.reset(numStallers + numReleasers, numStallers + numReleasers\n            + numWaiters);\n        checkPoint.set(true);\n      }\n  \n    }\n    if (!checkPoint.get()) {\n      sync.reset(numStallers + numReleasers, numStallers + numReleasers\n          + numWaiters);\n      checkPoint.set(true);\n    }\n    \n    assertTrue(sync.updateJoin.await(10, TimeUnit.SECONDS));\n    assertState(numReleasers, numStallers, numWaiters, threads, ctrl);\n    checkPoint.set(false);\n    stop.set(true);\n    sync.waiter.countDown();\n    sync.leftCheckpoint.await();\n    \n    \n    for (int i = 0; i < threads.length; i++) {\n      ctrl.updateStalled(false);\n      threads[i].join(2000);\n      if (threads[i].isAlive() && threads[i] instanceof Waiter) {\n        if (threads[i].getState() == Thread.State.WAITING) {\n          fail(\"waiter is not released - anyThreadsStalled: \"\n              + ctrl.anyStalledThreads());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4208ed8e426ae5f75a41d8b4ae53f4587e413061"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4208ed8e426ae5f75a41d8b4ae53f4587e413061"],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}