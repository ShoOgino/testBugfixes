{"path":"lucene/test-framework/src/java/org/apache/lucene/analysis/MockGraphTokenFilter#incrementToken().mjava","commits":[{"id":"6795c6bc2f5a6b2a2230cb20ff4744003faf7802","date":1333839972,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/MockGraphTokenFilter#incrementToken().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n\n    if (DEBUG) {\n      System.out.println(\"MockGraphTF.incr inputPos=\" + inputPos + \" outputPos=\" + outputPos);\n    }\n\n    while (true) {\n      final Position posData = positions.get(outputPos);\n      if (posData.nextRead < posData.states.size()) {\n        // Serve up all buffered tokens from this position:\n        if (DEBUG) {\n          System.out.println(\"  restore buffered nextRead=\" + posData.nextRead + \" vs \" + posData.states.size());\n        }\n        restoreState(posData.states.get(posData.nextRead++));\n        if (DEBUG) {\n          System.out.println(\"    term=\" + termAtt + \" outputPos=\" + outputPos);\n        }\n        pushOutputPos();\n        return true;\n      }\n\n      boolean tokenPending = false;\n\n      final int prevInputPos = inputPos;\n\n      if (inputPos == -1 || inputPos == outputPos) {\n        // We've used up the buffered tokens; pull the next\n        // input token:\n        if (end) {\n          return false;\n        }\n        final TOKEN_POS result = nextInputToken();\n        if (result == TOKEN_POS.SAME) {\n          return true;\n        } else if (result == TOKEN_POS.NEXT) {\n          tokenPending = true;\n        } else {\n          // NOTE: we don't set end=true here... because we\n          // are immediately passing through \"the end\" to\n          // caller (return false), and caller must not call\n          // us again:\n          return false;\n        }\n      } else {\n        assert inputPos > outputPos;\n        if (DEBUG) {\n          System.out.println(\"  done @ outputPos=\" + outputPos);\n        }\n      }\n\n      // We're done (above) serving up all tokens leaving\n      // from the same position; now maybe insert a token.\n      // Note that we may insert more than one token leaving\n      // from this position.  We only inject tokens at\n      // positions where we've seen at least one input token\n      // (ie, we cannot inject inside holes):\n\n      if (prevInputPos != -1  && positions.get(outputPos).startOffset != -1 && random.nextInt(7) == 5) {\n        if (DEBUG) {\n          System.out.println(\"  inject @ outputPos=\" + outputPos);\n        }\n\n        if (tokenPending) {\n          positions.get(inputPos).captureState();\n        }\n        final int posLength = _TestUtil.nextInt(random, 1, 5);\n        final Position posEndData = positions.get(outputPos + posLength);\n\n        // Pull enough tokens until we discover what our\n        // endOffset should be:\n        while (!end && posEndData.endOffset == -1 && inputPos <= (outputPos + posLength)) {\n          if (DEBUG) {\n            System.out.println(\"  lookahead [endPos=\" + (outputPos + posLength) + \"]...\");\n          }\n          final TOKEN_POS result = nextInputToken();\n          if (result != TOKEN_POS.END) {\n            positions.get(inputPos).captureState();\n          } else {\n            end = true;\n            if (DEBUG) {\n              System.out.println(\"    force end lookahead\");\n            }\n            break;\n          }\n        }\n\n        // TODO: really, here, on hitting end-of-tokens,\n        // we'd like to know the ending \"posInc\", and allow\n        // our token to extend up until that.  But: a\n        // TokenFilter is not allowed to call end() from\n        // within its incrementToken, so we can't do that.\n        // It may have been better if the ending\n        // posInc/offsets were set when incrementToken\n        // returned false (ie, without having to call the\n        // special end method):\n\n        if (posEndData.endOffset != -1) {\n          assert posEndData.endOffset != -1;\n          clearAttributes();\n          posLengthAtt.setPositionLength(posLength);\n          termAtt.append(_TestUtil.randomUnicodeString(random));\n          pushOutputPos();\n          offsetAtt.setOffset(positions.get(outputPos).startOffset,\n                              positions.get(outputPos + posLength).endOffset);\n          if (DEBUG) {\n            System.out.println(\"  inject: outputPos=\" + outputPos + \" startOffset=\" + offsetAtt.startOffset() +\n                               \" endOffset=\" + offsetAtt.endOffset() +\n                               \" posLength=\" + posLengthAtt.getPositionLength());\n          }\n          // TODO: set TypeAtt too?\n          return true;\n\n        } else {\n          // Either, we hit the end of the tokens (ie, our\n          // attempted posLength is too long because it\n          // hangs out over the end), or, our attempted\n          // posLength ended in the middle of a hole; just\n          // skip injecting in these cases.  We will still\n          // test these cases by having a StopFilter after\n          // MockGraphTokenFilter...\n        }\n\n      } else if (tokenPending) {\n        outputPos = inputPos;\n        if (DEBUG) {\n          System.out.println(\"  pass-through\");\n        }\n        pushOutputPos();\n        return true;\n      } else {\n        // We are skipping over a hole (posInc > 1) from our input:\n        outputPos++;\n        if (DEBUG) {\n          System.out.println(\"  incr outputPos=\" + outputPos);\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"914394e583f0258b2fe327df337ea44c908a0aab","date":1333904214,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/MockGraphTokenFilter#incrementToken().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/analysis/MockGraphTokenFilter#incrementToken().mjava","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (DEBUG) {\n      System.out.println(\"MockGraphTF.incr inputPos=\" + inputPos + \" outputPos=\" + outputPos);\n    }\n    return nextToken();\n  }\n\n","sourceOld":"  @Override\n  public boolean incrementToken() throws IOException {\n\n    if (DEBUG) {\n      System.out.println(\"MockGraphTF.incr inputPos=\" + inputPos + \" outputPos=\" + outputPos);\n    }\n\n    while (true) {\n      final Position posData = positions.get(outputPos);\n      if (posData.nextRead < posData.states.size()) {\n        // Serve up all buffered tokens from this position:\n        if (DEBUG) {\n          System.out.println(\"  restore buffered nextRead=\" + posData.nextRead + \" vs \" + posData.states.size());\n        }\n        restoreState(posData.states.get(posData.nextRead++));\n        if (DEBUG) {\n          System.out.println(\"    term=\" + termAtt + \" outputPos=\" + outputPos);\n        }\n        pushOutputPos();\n        return true;\n      }\n\n      boolean tokenPending = false;\n\n      final int prevInputPos = inputPos;\n\n      if (inputPos == -1 || inputPos == outputPos) {\n        // We've used up the buffered tokens; pull the next\n        // input token:\n        if (end) {\n          return false;\n        }\n        final TOKEN_POS result = nextInputToken();\n        if (result == TOKEN_POS.SAME) {\n          return true;\n        } else if (result == TOKEN_POS.NEXT) {\n          tokenPending = true;\n        } else {\n          // NOTE: we don't set end=true here... because we\n          // are immediately passing through \"the end\" to\n          // caller (return false), and caller must not call\n          // us again:\n          return false;\n        }\n      } else {\n        assert inputPos > outputPos;\n        if (DEBUG) {\n          System.out.println(\"  done @ outputPos=\" + outputPos);\n        }\n      }\n\n      // We're done (above) serving up all tokens leaving\n      // from the same position; now maybe insert a token.\n      // Note that we may insert more than one token leaving\n      // from this position.  We only inject tokens at\n      // positions where we've seen at least one input token\n      // (ie, we cannot inject inside holes):\n\n      if (prevInputPos != -1  && positions.get(outputPos).startOffset != -1 && random.nextInt(7) == 5) {\n        if (DEBUG) {\n          System.out.println(\"  inject @ outputPos=\" + outputPos);\n        }\n\n        if (tokenPending) {\n          positions.get(inputPos).captureState();\n        }\n        final int posLength = _TestUtil.nextInt(random, 1, 5);\n        final Position posEndData = positions.get(outputPos + posLength);\n\n        // Pull enough tokens until we discover what our\n        // endOffset should be:\n        while (!end && posEndData.endOffset == -1 && inputPos <= (outputPos + posLength)) {\n          if (DEBUG) {\n            System.out.println(\"  lookahead [endPos=\" + (outputPos + posLength) + \"]...\");\n          }\n          final TOKEN_POS result = nextInputToken();\n          if (result != TOKEN_POS.END) {\n            positions.get(inputPos).captureState();\n          } else {\n            end = true;\n            if (DEBUG) {\n              System.out.println(\"    force end lookahead\");\n            }\n            break;\n          }\n        }\n\n        // TODO: really, here, on hitting end-of-tokens,\n        // we'd like to know the ending \"posInc\", and allow\n        // our token to extend up until that.  But: a\n        // TokenFilter is not allowed to call end() from\n        // within its incrementToken, so we can't do that.\n        // It may have been better if the ending\n        // posInc/offsets were set when incrementToken\n        // returned false (ie, without having to call the\n        // special end method):\n\n        if (posEndData.endOffset != -1) {\n          assert posEndData.endOffset != -1;\n          clearAttributes();\n          posLengthAtt.setPositionLength(posLength);\n          termAtt.append(_TestUtil.randomUnicodeString(random));\n          pushOutputPos();\n          offsetAtt.setOffset(positions.get(outputPos).startOffset,\n                              positions.get(outputPos + posLength).endOffset);\n          if (DEBUG) {\n            System.out.println(\"  inject: outputPos=\" + outputPos + \" startOffset=\" + offsetAtt.startOffset() +\n                               \" endOffset=\" + offsetAtt.endOffset() +\n                               \" posLength=\" + posLengthAtt.getPositionLength());\n          }\n          // TODO: set TypeAtt too?\n          return true;\n\n        } else {\n          // Either, we hit the end of the tokens (ie, our\n          // attempted posLength is too long because it\n          // hangs out over the end), or, our attempted\n          // posLength ended in the middle of a hole; just\n          // skip injecting in these cases.  We will still\n          // test these cases by having a StopFilter after\n          // MockGraphTokenFilter...\n        }\n\n      } else if (tokenPending) {\n        outputPos = inputPos;\n        if (DEBUG) {\n          System.out.println(\"  pass-through\");\n        }\n        pushOutputPos();\n        return true;\n      } else {\n        // We are skipping over a hole (posInc > 1) from our input:\n        outputPos++;\n        if (DEBUG) {\n          System.out.println(\"  incr outputPos=\" + outputPos);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1d0ae9ce208801ae2cb5347c873c0fe4b1444f6","date":1379975117,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/analysis/MockGraphTokenFilter#incrementToken().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/analysis/MockGraphTokenFilter#incrementToken().mjava","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (DEBUG) {\n      System.out.println(\"MockGraphTF.incr inputPos=\" + inputPos + \" outputPos=\" + outputPos);\n    }\n    if (random == null) {\n      throw new IllegalStateException(\"incrementToken called in wrong state!\");\n    }\n    return nextToken();\n  }\n\n","sourceOld":"  @Override\n  public boolean incrementToken() throws IOException {\n    if (DEBUG) {\n      System.out.println(\"MockGraphTF.incr inputPos=\" + inputPos + \" outputPos=\" + outputPos);\n    }\n    return nextToken();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"914394e583f0258b2fe327df337ea44c908a0aab":["6795c6bc2f5a6b2a2230cb20ff4744003faf7802"],"c1d0ae9ce208801ae2cb5347c873c0fe4b1444f6":["914394e583f0258b2fe327df337ea44c908a0aab"],"6795c6bc2f5a6b2a2230cb20ff4744003faf7802":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c1d0ae9ce208801ae2cb5347c873c0fe4b1444f6"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6795c6bc2f5a6b2a2230cb20ff4744003faf7802"],"914394e583f0258b2fe327df337ea44c908a0aab":["c1d0ae9ce208801ae2cb5347c873c0fe4b1444f6"],"6795c6bc2f5a6b2a2230cb20ff4744003faf7802":["914394e583f0258b2fe327df337ea44c908a0aab"],"c1d0ae9ce208801ae2cb5347c873c0fe4b1444f6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}