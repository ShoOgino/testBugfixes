{"path":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testIllegallyModifyRootArc().mjava","commits":[{"id":"7f32ed90e12610550e1363aea43afe3d6e292cf9","date":1418230105,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testIllegallyModifyRootArc().mjava","pathOld":"/dev/null","sourceNew":"  public void testIllegallyModifyRootArc() throws Exception {\n    assumeTrue(\"test relies on assertions\", assertsAreEnabled);\n\n    Set<BytesRef> terms = new HashSet<>();\n    for(int i=0;i<100;i++) {\n      String prefix = Character.toString((char) ('a' + i));\n      terms.add(new BytesRef(prefix));\n      if (prefix.equals(\"m\") == false) {\n        for(int j=0;j<20;j++) {\n          // Make a big enough FST that the root cache will be created:\n          String suffix = TestUtil.randomRealisticUnicodeString(random(), 10, 20);\n          terms.add(new BytesRef(prefix + suffix));\n        }\n      }\n    }\n\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    Collections.sort(termsList);\n\n    ByteSequenceOutputs outputs = ByteSequenceOutputs.getSingleton();\n    Builder<BytesRef> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    IntsRefBuilder input = new IntsRefBuilder();\n    for(BytesRef term : termsList) {\n      Util.toIntsRef(term, input);\n      builder.add(input.get(), term);\n    }\n\n    FST<BytesRef> fst = builder.finish();\n    \n    Arc<BytesRef> arc = new FST.Arc<>();\n    fst.getFirstArc(arc);\n    FST.BytesReader reader = fst.getBytesReader();\n    arc = fst.findTargetArc((int) 'm', arc, arc, reader);\n    assertNotNull(arc);\n    assertEquals(new BytesRef(\"m\"), arc.output);\n\n    // NOTE: illegal:\n    arc.output.length = 0;\n\n    fst.getFirstArc(arc);\n    try {\n      arc = fst.findTargetArc((int) 'm', arc, arc, reader);\n    } catch (AssertionError ae) {\n      // expected\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54204c8a3ca26aeafd273139fc29baf70d0f6786","date":1564170395,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testIllegallyModifyRootArc().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testIllegallyModifyRootArc().mjava","sourceNew":"  public void testIllegallyModifyRootArc() throws Exception {\n    assumeTrue(\"test relies on assertions\", assertsAreEnabled);\n\n    Set<BytesRef> terms = new HashSet<>();\n    for(int i=0;i<100;i++) {\n      String prefix = Character.toString((char) ('a' + i));\n      terms.add(new BytesRef(prefix));\n      if (prefix.equals(\"m\") == false) {\n        for(int j=0;j<20;j++) {\n          // Make a big enough FST that the root cache will be created:\n          String suffix = TestUtil.randomRealisticUnicodeString(random(), 10, 20);\n          terms.add(new BytesRef(prefix + suffix));\n        }\n      }\n    }\n\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    Collections.sort(termsList);\n\n    ByteSequenceOutputs outputs = ByteSequenceOutputs.getSingleton();\n    Builder<BytesRef> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    IntsRefBuilder input = new IntsRefBuilder();\n    for(BytesRef term : termsList) {\n      Util.toIntsRef(term, input);\n      builder.add(input.get(), term);\n    }\n\n    FST<BytesRef> fst = builder.finish();\n    \n    Arc<BytesRef> arc = new FST.Arc<>();\n    fst.getFirstArc(arc);\n    FST.BytesReader reader = fst.getBytesReader();\n    arc = fst.findTargetArc((int) 'm', arc, arc, reader);\n    assertNotNull(arc);\n    assertEquals(new BytesRef(\"m\"), arc.output());\n\n    // NOTE: illegal:\n    arc.output().length = 0;\n\n    fst.getFirstArc(arc);\n    try {\n      arc = fst.findTargetArc((int) 'm', arc, arc, reader);\n    } catch (AssertionError ae) {\n      // expected\n    }\n  }\n\n","sourceOld":"  public void testIllegallyModifyRootArc() throws Exception {\n    assumeTrue(\"test relies on assertions\", assertsAreEnabled);\n\n    Set<BytesRef> terms = new HashSet<>();\n    for(int i=0;i<100;i++) {\n      String prefix = Character.toString((char) ('a' + i));\n      terms.add(new BytesRef(prefix));\n      if (prefix.equals(\"m\") == false) {\n        for(int j=0;j<20;j++) {\n          // Make a big enough FST that the root cache will be created:\n          String suffix = TestUtil.randomRealisticUnicodeString(random(), 10, 20);\n          terms.add(new BytesRef(prefix + suffix));\n        }\n      }\n    }\n\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    Collections.sort(termsList);\n\n    ByteSequenceOutputs outputs = ByteSequenceOutputs.getSingleton();\n    Builder<BytesRef> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    IntsRefBuilder input = new IntsRefBuilder();\n    for(BytesRef term : termsList) {\n      Util.toIntsRef(term, input);\n      builder.add(input.get(), term);\n    }\n\n    FST<BytesRef> fst = builder.finish();\n    \n    Arc<BytesRef> arc = new FST.Arc<>();\n    fst.getFirstArc(arc);\n    FST.BytesReader reader = fst.getBytesReader();\n    arc = fst.findTargetArc((int) 'm', arc, arc, reader);\n    assertNotNull(arc);\n    assertEquals(new BytesRef(\"m\"), arc.output);\n\n    // NOTE: illegal:\n    arc.output.length = 0;\n\n    fst.getFirstArc(arc);\n    try {\n      arc = fst.findTargetArc((int) 'm', arc, arc, reader);\n    } catch (AssertionError ae) {\n      // expected\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testIllegallyModifyRootArc().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testIllegallyModifyRootArc().mjava","sourceNew":"  public void testIllegallyModifyRootArc() throws Exception {\n    assumeTrue(\"test relies on assertions\", assertsAreEnabled);\n\n    Set<BytesRef> terms = new HashSet<>();\n    for(int i=0;i<100;i++) {\n      String prefix = Character.toString((char) ('a' + i));\n      terms.add(new BytesRef(prefix));\n      if (prefix.equals(\"m\") == false) {\n        for(int j=0;j<20;j++) {\n          // Make a big enough FST that the root cache will be created:\n          String suffix = TestUtil.randomRealisticUnicodeString(random(), 10, 20);\n          terms.add(new BytesRef(prefix + suffix));\n        }\n      }\n    }\n\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    Collections.sort(termsList);\n\n    ByteSequenceOutputs outputs = ByteSequenceOutputs.getSingleton();\n    Builder<BytesRef> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    IntsRefBuilder input = new IntsRefBuilder();\n    for(BytesRef term : termsList) {\n      Util.toIntsRef(term, input);\n      builder.add(input.get(), term);\n    }\n\n    FST<BytesRef> fst = builder.finish();\n    \n    Arc<BytesRef> arc = new FST.Arc<>();\n    fst.getFirstArc(arc);\n    FST.BytesReader reader = fst.getBytesReader();\n    arc = fst.findTargetArc((int) 'm', arc, arc, reader);\n    assertNotNull(arc);\n    assertEquals(new BytesRef(\"m\"), arc.output());\n\n    // NOTE: illegal:\n    arc.output().length = 0;\n\n    fst.getFirstArc(arc);\n    try {\n      arc = fst.findTargetArc((int) 'm', arc, arc, reader);\n    } catch (AssertionError ae) {\n      // expected\n    }\n  }\n\n","sourceOld":"  public void testIllegallyModifyRootArc() throws Exception {\n    assumeTrue(\"test relies on assertions\", assertsAreEnabled);\n\n    Set<BytesRef> terms = new HashSet<>();\n    for(int i=0;i<100;i++) {\n      String prefix = Character.toString((char) ('a' + i));\n      terms.add(new BytesRef(prefix));\n      if (prefix.equals(\"m\") == false) {\n        for(int j=0;j<20;j++) {\n          // Make a big enough FST that the root cache will be created:\n          String suffix = TestUtil.randomRealisticUnicodeString(random(), 10, 20);\n          terms.add(new BytesRef(prefix + suffix));\n        }\n      }\n    }\n\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    Collections.sort(termsList);\n\n    ByteSequenceOutputs outputs = ByteSequenceOutputs.getSingleton();\n    Builder<BytesRef> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    IntsRefBuilder input = new IntsRefBuilder();\n    for(BytesRef term : termsList) {\n      Util.toIntsRef(term, input);\n      builder.add(input.get(), term);\n    }\n\n    FST<BytesRef> fst = builder.finish();\n    \n    Arc<BytesRef> arc = new FST.Arc<>();\n    fst.getFirstArc(arc);\n    FST.BytesReader reader = fst.getBytesReader();\n    arc = fst.findTargetArc((int) 'm', arc, arc, reader);\n    assertNotNull(arc);\n    assertEquals(new BytesRef(\"m\"), arc.output);\n\n    // NOTE: illegal:\n    arc.output.length = 0;\n\n    fst.getFirstArc(arc);\n    try {\n      arc = fst.findTargetArc((int) 'm', arc, arc, reader);\n    } catch (AssertionError ae) {\n      // expected\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f5661e6a04d3172e262ad741b717924f2f1b6a5","date":1576244274,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testIllegallyModifyRootArc().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testIllegallyModifyRootArc().mjava","sourceNew":"  public void testIllegallyModifyRootArc() throws Exception {\n    assumeTrue(\"test relies on assertions\", assertsAreEnabled);\n\n    Set<BytesRef> terms = new HashSet<>();\n    for(int i=0;i<100;i++) {\n      String prefix = Character.toString((char) ('a' + i));\n      terms.add(new BytesRef(prefix));\n      if (prefix.equals(\"m\") == false) {\n        for(int j=0;j<20;j++) {\n          // Make a big enough FST that the root cache will be created:\n          String suffix = TestUtil.randomRealisticUnicodeString(random(), 10, 20);\n          terms.add(new BytesRef(prefix + suffix));\n        }\n      }\n    }\n\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    Collections.sort(termsList);\n\n    ByteSequenceOutputs outputs = ByteSequenceOutputs.getSingleton();\n    FSTCompiler<BytesRef> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    IntsRefBuilder input = new IntsRefBuilder();\n    for(BytesRef term : termsList) {\n      Util.toIntsRef(term, input);\n      fstCompiler.add(input.get(), term);\n    }\n\n    FST<BytesRef> fst = fstCompiler.compile();\n    \n    Arc<BytesRef> arc = new FST.Arc<>();\n    fst.getFirstArc(arc);\n    FST.BytesReader reader = fst.getBytesReader();\n    arc = fst.findTargetArc((int) 'm', arc, arc, reader);\n    assertNotNull(arc);\n    assertEquals(new BytesRef(\"m\"), arc.output());\n\n    // NOTE: illegal:\n    arc.output().length = 0;\n\n    fst.getFirstArc(arc);\n    try {\n      arc = fst.findTargetArc((int) 'm', arc, arc, reader);\n    } catch (AssertionError ae) {\n      // expected\n    }\n  }\n\n","sourceOld":"  public void testIllegallyModifyRootArc() throws Exception {\n    assumeTrue(\"test relies on assertions\", assertsAreEnabled);\n\n    Set<BytesRef> terms = new HashSet<>();\n    for(int i=0;i<100;i++) {\n      String prefix = Character.toString((char) ('a' + i));\n      terms.add(new BytesRef(prefix));\n      if (prefix.equals(\"m\") == false) {\n        for(int j=0;j<20;j++) {\n          // Make a big enough FST that the root cache will be created:\n          String suffix = TestUtil.randomRealisticUnicodeString(random(), 10, 20);\n          terms.add(new BytesRef(prefix + suffix));\n        }\n      }\n    }\n\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    Collections.sort(termsList);\n\n    ByteSequenceOutputs outputs = ByteSequenceOutputs.getSingleton();\n    Builder<BytesRef> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    IntsRefBuilder input = new IntsRefBuilder();\n    for(BytesRef term : termsList) {\n      Util.toIntsRef(term, input);\n      builder.add(input.get(), term);\n    }\n\n    FST<BytesRef> fst = builder.finish();\n    \n    Arc<BytesRef> arc = new FST.Arc<>();\n    fst.getFirstArc(arc);\n    FST.BytesReader reader = fst.getBytesReader();\n    arc = fst.findTargetArc((int) 'm', arc, arc, reader);\n    assertNotNull(arc);\n    assertEquals(new BytesRef(\"m\"), arc.output());\n\n    // NOTE: illegal:\n    arc.output().length = 0;\n\n    fst.getFirstArc(arc);\n    try {\n      arc = fst.findTargetArc((int) 'm', arc, arc, reader);\n    } catch (AssertionError ae) {\n      // expected\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","date":1576247714,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testIllegallyModifyRootArc().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testIllegallyModifyRootArc().mjava","sourceNew":"  public void testIllegallyModifyRootArc() throws Exception {\n    assumeTrue(\"test relies on assertions\", assertsAreEnabled);\n\n    Set<BytesRef> terms = new HashSet<>();\n    for(int i=0;i<100;i++) {\n      String prefix = Character.toString((char) ('a' + i));\n      terms.add(new BytesRef(prefix));\n      if (prefix.equals(\"m\") == false) {\n        for(int j=0;j<20;j++) {\n          // Make a big enough FST that the root cache will be created:\n          String suffix = TestUtil.randomRealisticUnicodeString(random(), 10, 20);\n          terms.add(new BytesRef(prefix + suffix));\n        }\n      }\n    }\n\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    Collections.sort(termsList);\n\n    ByteSequenceOutputs outputs = ByteSequenceOutputs.getSingleton();\n    FSTCompiler<BytesRef> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    IntsRefBuilder input = new IntsRefBuilder();\n    for(BytesRef term : termsList) {\n      Util.toIntsRef(term, input);\n      fstCompiler.add(input.get(), term);\n    }\n\n    FST<BytesRef> fst = fstCompiler.compile();\n    \n    Arc<BytesRef> arc = new FST.Arc<>();\n    fst.getFirstArc(arc);\n    FST.BytesReader reader = fst.getBytesReader();\n    arc = fst.findTargetArc((int) 'm', arc, arc, reader);\n    assertNotNull(arc);\n    assertEquals(new BytesRef(\"m\"), arc.output());\n\n    // NOTE: illegal:\n    arc.output().length = 0;\n\n    fst.getFirstArc(arc);\n    try {\n      arc = fst.findTargetArc((int) 'm', arc, arc, reader);\n    } catch (AssertionError ae) {\n      // expected\n    }\n  }\n\n","sourceOld":"  public void testIllegallyModifyRootArc() throws Exception {\n    assumeTrue(\"test relies on assertions\", assertsAreEnabled);\n\n    Set<BytesRef> terms = new HashSet<>();\n    for(int i=0;i<100;i++) {\n      String prefix = Character.toString((char) ('a' + i));\n      terms.add(new BytesRef(prefix));\n      if (prefix.equals(\"m\") == false) {\n        for(int j=0;j<20;j++) {\n          // Make a big enough FST that the root cache will be created:\n          String suffix = TestUtil.randomRealisticUnicodeString(random(), 10, 20);\n          terms.add(new BytesRef(prefix + suffix));\n        }\n      }\n    }\n\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    Collections.sort(termsList);\n\n    ByteSequenceOutputs outputs = ByteSequenceOutputs.getSingleton();\n    Builder<BytesRef> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    IntsRefBuilder input = new IntsRefBuilder();\n    for(BytesRef term : termsList) {\n      Util.toIntsRef(term, input);\n      builder.add(input.get(), term);\n    }\n\n    FST<BytesRef> fst = builder.finish();\n    \n    Arc<BytesRef> arc = new FST.Arc<>();\n    fst.getFirstArc(arc);\n    FST.BytesReader reader = fst.getBytesReader();\n    arc = fst.findTargetArc((int) 'm', arc, arc, reader);\n    assertNotNull(arc);\n    assertEquals(new BytesRef(\"m\"), arc.output());\n\n    // NOTE: illegal:\n    arc.output().length = 0;\n\n    fst.getFirstArc(arc);\n    try {\n      arc = fst.findTargetArc((int) 'm', arc, arc, reader);\n    } catch (AssertionError ae) {\n      // expected\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54204c8a3ca26aeafd273139fc29baf70d0f6786":["7f32ed90e12610550e1363aea43afe3d6e292cf9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":["54204c8a3ca26aeafd273139fc29baf70d0f6786","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["54204c8a3ca26aeafd273139fc29baf70d0f6786"],"f8061ddd97f3352007d927dae445884a6f3d857b":["7f32ed90e12610550e1363aea43afe3d6e292cf9","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"7f32ed90e12610550e1363aea43afe3d6e292cf9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"54204c8a3ca26aeafd273139fc29baf70d0f6786":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","0f5661e6a04d3172e262ad741b717924f2f1b6a5","f8061ddd97f3352007d927dae445884a6f3d857b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7f32ed90e12610550e1363aea43afe3d6e292cf9"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":[],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"7f32ed90e12610550e1363aea43afe3d6e292cf9":["54204c8a3ca26aeafd273139fc29baf70d0f6786","f8061ddd97f3352007d927dae445884a6f3d857b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}