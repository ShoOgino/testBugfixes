{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteReplicaBasedOnCount(ClusterState,ZkNodeProps,NamedList,Runnable,boolean).mjava","commits":[{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteReplicaBasedOnCount(ClusterState,ZkNodeProps,NamedList,Runnable,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DeleteReplicaCmd#deleteReplicaBasedOnCount(ClusterState,ZkNodeProps,NamedList,Runnable,boolean).mjava","sourceNew":"  /**\n   * Delete replicas based on count for a given collection. If a shard is passed, uses that\n   * else deletes given num replicas across all shards for the given collection.\n   */\n  void deleteReplicaBasedOnCount(ClusterState clusterState,\n                                 ZkNodeProps message,\n                                 NamedList results,\n                                 Runnable onComplete,\n                                 boolean parallel)\n          throws KeeperException, InterruptedException {\n    ocmh.checkRequired(message, COLLECTION_PROP, COUNT_PROP);\n    int count = Integer.parseInt(message.getStr(COUNT_PROP));\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = null;\n    //Validate if shard is passed.\n    if (shard != null) {\n      slice = coll.getSlice(shard);\n      if (slice == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Invalid shard name : \" +  shard +  \" in collection : \" + collectionName);\n      }\n    }\n\n    Map<Slice, Set<String>> shardToReplicasMapping = new HashMap<Slice, Set<String>>();\n    if (slice != null) {\n      Set<String> replicasToBeDeleted = pickReplicasTobeDeleted(slice, shard, collectionName, count);\n      shardToReplicasMapping.put(slice,replicasToBeDeleted);\n    } else {\n\n      //If there are many replicas left, remove the rest based on count.\n      Collection<Slice> allSlices = coll.getSlices();\n      for (Slice individualSlice : allSlices) {\n        Set<String> replicasToBeDeleted = pickReplicasTobeDeleted(individualSlice, individualSlice.getName(), collectionName, count);\n        shardToReplicasMapping.put(individualSlice, replicasToBeDeleted);\n      }\n    }\n\n    for (Slice shardSlice: shardToReplicasMapping.keySet()) {\n      String shardId = shardSlice.getName();\n      Set<String> replicas = shardToReplicasMapping.get(shardSlice);\n      //callDeleteReplica on all replicas\n      for (String replica: replicas) {\n        log.debug(\"Deleting replica {}  for shard {} based on count {}\", replica, shardId, count);\n        deleteCore(shardSlice, collectionName, replica, message, shard, results, onComplete, parallel);\n      }\n      results.add(\"shard_id\", shardId);\n      results.add(\"replicas_deleted\", replicas);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Delete replicas based on count for a given collection. If a shard is passed, uses that\n   * else deletes given num replicas across all shards for the given collection.\n   */\n  void deleteReplicaBasedOnCount(ClusterState clusterState,\n                                 ZkNodeProps message,\n                                 NamedList results,\n                                 Runnable onComplete,\n                                 boolean parallel)\n          throws KeeperException, InterruptedException {\n    ocmh.checkRequired(message, COLLECTION_PROP, COUNT_PROP);\n    int count = Integer.parseInt(message.getStr(COUNT_PROP));\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = null;\n    //Validate if shard is passed.\n    if (shard != null) {\n      slice = coll.getSlice(shard);\n      if (slice == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Invalid shard name : \" +  shard +  \" in collection : \" + collectionName);\n      }\n    }\n\n    Map<Slice, Set<String>> shardToReplicasMapping = new HashMap<Slice, Set<String>>();\n    if (slice != null) {\n      Set<String> replicasToBeDeleted = pickReplicasTobeDeleted(slice, shard, collectionName, count);\n      shardToReplicasMapping.put(slice,replicasToBeDeleted);\n    } else {\n\n      //If there are many replicas left, remove the rest based on count.\n      Collection<Slice> allSlices = coll.getSlices();\n      for (Slice individualSlice : allSlices) {\n        Set<String> replicasToBeDeleted = pickReplicasTobeDeleted(individualSlice, individualSlice.getName(), collectionName, count);\n        shardToReplicasMapping.put(individualSlice, replicasToBeDeleted);\n      }\n    }\n\n    for (Slice shardSlice: shardToReplicasMapping.keySet()) {\n      String shardId = shardSlice.getName();\n      Set<String> replicas = shardToReplicasMapping.get(shardSlice);\n      //callDeleteReplica on all replicas\n      for (String replica: replicas) {\n        log.debug(\"Deleting replica {}  for shard {} based on count {}\", replica, shardId, count);\n        deleteCore(shardSlice, collectionName, replica, message, shard, results, onComplete, parallel);\n      }\n      results.add(\"shard_id\", shardId);\n      results.add(\"replicas_deleted\", replicas);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteReplicaBasedOnCount(ClusterState,ZkNodeProps,NamedList,Runnable,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DeleteReplicaCmd#deleteReplicaBasedOnCount(ClusterState,ZkNodeProps,NamedList,Runnable,boolean).mjava","sourceNew":"  /**\n   * Delete replicas based on count for a given collection. If a shard is passed, uses that\n   * else deletes given num replicas across all shards for the given collection.\n   */\n  void deleteReplicaBasedOnCount(ClusterState clusterState,\n                                 ZkNodeProps message,\n                                 NamedList results,\n                                 Runnable onComplete,\n                                 boolean parallel)\n          throws KeeperException, InterruptedException {\n    ocmh.checkRequired(message, COLLECTION_PROP, COUNT_PROP);\n    int count = Integer.parseInt(message.getStr(COUNT_PROP));\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = null;\n    //Validate if shard is passed.\n    if (shard != null) {\n      slice = coll.getSlice(shard);\n      if (slice == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Invalid shard name : \" +  shard +  \" in collection : \" + collectionName);\n      }\n    }\n\n    Map<Slice, Set<String>> shardToReplicasMapping = new HashMap<Slice, Set<String>>();\n    if (slice != null) {\n      Set<String> replicasToBeDeleted = pickReplicasTobeDeleted(slice, shard, collectionName, count);\n      shardToReplicasMapping.put(slice,replicasToBeDeleted);\n    } else {\n\n      //If there are many replicas left, remove the rest based on count.\n      Collection<Slice> allSlices = coll.getSlices();\n      for (Slice individualSlice : allSlices) {\n        Set<String> replicasToBeDeleted = pickReplicasTobeDeleted(individualSlice, individualSlice.getName(), collectionName, count);\n        shardToReplicasMapping.put(individualSlice, replicasToBeDeleted);\n      }\n    }\n\n    for (Slice shardSlice: shardToReplicasMapping.keySet()) {\n      String shardId = shardSlice.getName();\n      Set<String> replicas = shardToReplicasMapping.get(shardSlice);\n      //callDeleteReplica on all replicas\n      for (String replica: replicas) {\n        log.debug(\"Deleting replica {}  for shard {} based on count {}\", replica, shardId, count);\n        deleteCore(shardSlice, collectionName, replica, message, shard, results, onComplete, parallel);\n      }\n      results.add(\"shard_id\", shardId);\n      results.add(\"replicas_deleted\", replicas);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Delete replicas based on count for a given collection. If a shard is passed, uses that\n   * else deletes given num replicas across all shards for the given collection.\n   */\n  void deleteReplicaBasedOnCount(ClusterState clusterState,\n                                 ZkNodeProps message,\n                                 NamedList results,\n                                 Runnable onComplete,\n                                 boolean parallel)\n          throws KeeperException, InterruptedException {\n    ocmh.checkRequired(message, COLLECTION_PROP, COUNT_PROP);\n    int count = Integer.parseInt(message.getStr(COUNT_PROP));\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = null;\n    //Validate if shard is passed.\n    if (shard != null) {\n      slice = coll.getSlice(shard);\n      if (slice == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Invalid shard name : \" +  shard +  \" in collection : \" + collectionName);\n      }\n    }\n\n    Map<Slice, Set<String>> shardToReplicasMapping = new HashMap<Slice, Set<String>>();\n    if (slice != null) {\n      Set<String> replicasToBeDeleted = pickReplicasTobeDeleted(slice, shard, collectionName, count);\n      shardToReplicasMapping.put(slice,replicasToBeDeleted);\n    } else {\n\n      //If there are many replicas left, remove the rest based on count.\n      Collection<Slice> allSlices = coll.getSlices();\n      for (Slice individualSlice : allSlices) {\n        Set<String> replicasToBeDeleted = pickReplicasTobeDeleted(individualSlice, individualSlice.getName(), collectionName, count);\n        shardToReplicasMapping.put(individualSlice, replicasToBeDeleted);\n      }\n    }\n\n    for (Slice shardSlice: shardToReplicasMapping.keySet()) {\n      String shardId = shardSlice.getName();\n      Set<String> replicas = shardToReplicasMapping.get(shardSlice);\n      //callDeleteReplica on all replicas\n      for (String replica: replicas) {\n        log.debug(\"Deleting replica {}  for shard {} based on count {}\", replica, shardId, count);\n        deleteCore(shardSlice, collectionName, replica, message, shard, results, onComplete, parallel);\n      }\n      results.add(\"shard_id\", shardId);\n      results.add(\"replicas_deleted\", replicas);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0","date":1571070979,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteReplicaBasedOnCount(ClusterState,ZkNodeProps,NamedList,Runnable,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteReplicaBasedOnCount(ClusterState,ZkNodeProps,NamedList,Runnable,boolean).mjava","sourceNew":"  /**\n   * Delete replicas based on count for a given collection. If a shard is passed, uses that\n   * else deletes given num replicas across all shards for the given collection.\n   */\n  void deleteReplicaBasedOnCount(ClusterState clusterState,\n                                 ZkNodeProps message,\n                                 NamedList results,\n                                 Runnable onComplete,\n                                 boolean parallel)\n          throws KeeperException, InterruptedException {\n    ocmh.checkRequired(message, COLLECTION_PROP, COUNT_PROP);\n    int count = Integer.parseInt(message.getStr(COUNT_PROP));\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = null;\n    //Validate if shard is passed.\n    if (shard != null) {\n      slice = coll.getSlice(shard);\n      if (slice == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Invalid shard name : \" +  shard +  \" in collection : \" + collectionName);\n      }\n    }\n\n    Map<Slice, Set<String>> shardToReplicasMapping = new HashMap<Slice, Set<String>>();\n    if (slice != null) {\n      Set<String> replicasToBeDeleted = pickReplicasTobeDeleted(slice, shard, collectionName, count);\n      shardToReplicasMapping.put(slice,replicasToBeDeleted);\n    } else {\n\n      //If there are many replicas left, remove the rest based on count.\n      Collection<Slice> allSlices = coll.getSlices();\n      for (Slice individualSlice : allSlices) {\n        Set<String> replicasToBeDeleted = pickReplicasTobeDeleted(individualSlice, individualSlice.getName(), collectionName, count);\n        shardToReplicasMapping.put(individualSlice, replicasToBeDeleted);\n      }\n    }\n\n    for (Map.Entry<Slice, Set<String>> entry : shardToReplicasMapping.entrySet()) {\n      Slice shardSlice = entry.getKey();\n      String shardId = shardSlice.getName();\n      Set<String> replicas = entry.getValue();\n      //callDeleteReplica on all replicas\n      for (String replica: replicas) {\n        log.debug(\"Deleting replica {}  for shard {} based on count {}\", replica, shardId, count);\n        deleteCore(shardSlice, collectionName, replica, message, shard, results, onComplete, parallel);\n      }\n      results.add(\"shard_id\", shardId);\n      results.add(\"replicas_deleted\", replicas);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Delete replicas based on count for a given collection. If a shard is passed, uses that\n   * else deletes given num replicas across all shards for the given collection.\n   */\n  void deleteReplicaBasedOnCount(ClusterState clusterState,\n                                 ZkNodeProps message,\n                                 NamedList results,\n                                 Runnable onComplete,\n                                 boolean parallel)\n          throws KeeperException, InterruptedException {\n    ocmh.checkRequired(message, COLLECTION_PROP, COUNT_PROP);\n    int count = Integer.parseInt(message.getStr(COUNT_PROP));\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = null;\n    //Validate if shard is passed.\n    if (shard != null) {\n      slice = coll.getSlice(shard);\n      if (slice == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Invalid shard name : \" +  shard +  \" in collection : \" + collectionName);\n      }\n    }\n\n    Map<Slice, Set<String>> shardToReplicasMapping = new HashMap<Slice, Set<String>>();\n    if (slice != null) {\n      Set<String> replicasToBeDeleted = pickReplicasTobeDeleted(slice, shard, collectionName, count);\n      shardToReplicasMapping.put(slice,replicasToBeDeleted);\n    } else {\n\n      //If there are many replicas left, remove the rest based on count.\n      Collection<Slice> allSlices = coll.getSlices();\n      for (Slice individualSlice : allSlices) {\n        Set<String> replicasToBeDeleted = pickReplicasTobeDeleted(individualSlice, individualSlice.getName(), collectionName, count);\n        shardToReplicasMapping.put(individualSlice, replicasToBeDeleted);\n      }\n    }\n\n    for (Slice shardSlice: shardToReplicasMapping.keySet()) {\n      String shardId = shardSlice.getName();\n      Set<String> replicas = shardToReplicasMapping.get(shardSlice);\n      //callDeleteReplica on all replicas\n      for (String replica: replicas) {\n        log.debug(\"Deleting replica {}  for shard {} based on count {}\", replica, shardId, count);\n        deleteCore(shardSlice, collectionName, replica, message, shard, results, onComplete, parallel);\n      }\n      results.add(\"shard_id\", shardId);\n      results.add(\"replicas_deleted\", replicas);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteReplicaBasedOnCount(ClusterState,ZkNodeProps,NamedList,Runnable,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteReplicaBasedOnCount(ClusterState,ZkNodeProps,NamedList,Runnable,boolean).mjava","sourceNew":"  /**\n   * Delete replicas based on count for a given collection. If a shard is passed, uses that\n   * else deletes given num replicas across all shards for the given collection.\n   */\n  void deleteReplicaBasedOnCount(ClusterState clusterState,\n                                 ZkNodeProps message,\n                                 NamedList results,\n                                 Runnable onComplete,\n                                 boolean parallel)\n          throws KeeperException, InterruptedException {\n    ocmh.checkRequired(message, COLLECTION_PROP, COUNT_PROP);\n    int count = Integer.parseInt(message.getStr(COUNT_PROP));\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = null;\n    //Validate if shard is passed.\n    if (shard != null) {\n      slice = coll.getSlice(shard);\n      if (slice == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Invalid shard name : \" +  shard +  \" in collection : \" + collectionName);\n      }\n    }\n\n    Map<Slice, Set<String>> shardToReplicasMapping = new HashMap<Slice, Set<String>>();\n    if (slice != null) {\n      Set<String> replicasToBeDeleted = pickReplicasTobeDeleted(slice, shard, collectionName, count);\n      shardToReplicasMapping.put(slice,replicasToBeDeleted);\n    } else {\n\n      //If there are many replicas left, remove the rest based on count.\n      Collection<Slice> allSlices = coll.getSlices();\n      for (Slice individualSlice : allSlices) {\n        Set<String> replicasToBeDeleted = pickReplicasTobeDeleted(individualSlice, individualSlice.getName(), collectionName, count);\n        shardToReplicasMapping.put(individualSlice, replicasToBeDeleted);\n      }\n    }\n\n    for (Map.Entry<Slice, Set<String>> entry : shardToReplicasMapping.entrySet()) {\n      Slice shardSlice = entry.getKey();\n      String shardId = shardSlice.getName();\n      Set<String> replicas = entry.getValue();\n      //callDeleteReplica on all replicas\n      for (String replica: replicas) {\n        log.debug(\"Deleting replica {}  for shard {} based on count {}\", replica, shardId, count);\n        deleteCore(shardSlice, collectionName, replica, message, shard, results, onComplete, parallel);\n      }\n      results.add(\"shard_id\", shardId);\n      results.add(\"replicas_deleted\", replicas);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Delete replicas based on count for a given collection. If a shard is passed, uses that\n   * else deletes given num replicas across all shards for the given collection.\n   */\n  void deleteReplicaBasedOnCount(ClusterState clusterState,\n                                 ZkNodeProps message,\n                                 NamedList results,\n                                 Runnable onComplete,\n                                 boolean parallel)\n          throws KeeperException, InterruptedException {\n    ocmh.checkRequired(message, COLLECTION_PROP, COUNT_PROP);\n    int count = Integer.parseInt(message.getStr(COUNT_PROP));\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = null;\n    //Validate if shard is passed.\n    if (shard != null) {\n      slice = coll.getSlice(shard);\n      if (slice == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Invalid shard name : \" +  shard +  \" in collection : \" + collectionName);\n      }\n    }\n\n    Map<Slice, Set<String>> shardToReplicasMapping = new HashMap<Slice, Set<String>>();\n    if (slice != null) {\n      Set<String> replicasToBeDeleted = pickReplicasTobeDeleted(slice, shard, collectionName, count);\n      shardToReplicasMapping.put(slice,replicasToBeDeleted);\n    } else {\n\n      //If there are many replicas left, remove the rest based on count.\n      Collection<Slice> allSlices = coll.getSlices();\n      for (Slice individualSlice : allSlices) {\n        Set<String> replicasToBeDeleted = pickReplicasTobeDeleted(individualSlice, individualSlice.getName(), collectionName, count);\n        shardToReplicasMapping.put(individualSlice, replicasToBeDeleted);\n      }\n    }\n\n    for (Slice shardSlice: shardToReplicasMapping.keySet()) {\n      String shardId = shardSlice.getName();\n      Set<String> replicas = shardToReplicasMapping.get(shardSlice);\n      //callDeleteReplica on all replicas\n      for (String replica: replicas) {\n        log.debug(\"Deleting replica {}  for shard {} based on count {}\", replica, shardId, count);\n        deleteCore(shardSlice, collectionName, replica, message, shard, results, onComplete, parallel);\n      }\n      results.add(\"shard_id\", shardId);\n      results.add(\"replicas_deleted\", replicas);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86968c6cf51846df861b8f29bd85b6d9a7c9f19c","date":1591481497,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteReplicaBasedOnCount(ClusterState,ZkNodeProps,NamedList,Runnable,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteReplicaCmd#deleteReplicaBasedOnCount(ClusterState,ZkNodeProps,NamedList,Runnable,boolean).mjava","sourceNew":"  /**\n   * Delete replicas based on count for a given collection. If a shard is passed, uses that\n   * else deletes given num replicas across all shards for the given collection.\n   */\n  @SuppressWarnings({\"unchecked\"})\n  void deleteReplicaBasedOnCount(ClusterState clusterState,\n                                 ZkNodeProps message,\n                                 @SuppressWarnings({\"rawtypes\"})NamedList results,\n                                 Runnable onComplete,\n                                 boolean parallel)\n          throws KeeperException, InterruptedException {\n    ocmh.checkRequired(message, COLLECTION_PROP, COUNT_PROP);\n    int count = Integer.parseInt(message.getStr(COUNT_PROP));\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = null;\n    //Validate if shard is passed.\n    if (shard != null) {\n      slice = coll.getSlice(shard);\n      if (slice == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Invalid shard name : \" +  shard +  \" in collection : \" + collectionName);\n      }\n    }\n\n    Map<Slice, Set<String>> shardToReplicasMapping = new HashMap<Slice, Set<String>>();\n    if (slice != null) {\n      Set<String> replicasToBeDeleted = pickReplicasTobeDeleted(slice, shard, collectionName, count);\n      shardToReplicasMapping.put(slice,replicasToBeDeleted);\n    } else {\n\n      //If there are many replicas left, remove the rest based on count.\n      Collection<Slice> allSlices = coll.getSlices();\n      for (Slice individualSlice : allSlices) {\n        Set<String> replicasToBeDeleted = pickReplicasTobeDeleted(individualSlice, individualSlice.getName(), collectionName, count);\n        shardToReplicasMapping.put(individualSlice, replicasToBeDeleted);\n      }\n    }\n\n    for (Map.Entry<Slice, Set<String>> entry : shardToReplicasMapping.entrySet()) {\n      Slice shardSlice = entry.getKey();\n      String shardId = shardSlice.getName();\n      Set<String> replicas = entry.getValue();\n      //callDeleteReplica on all replicas\n      for (String replica: replicas) {\n        log.debug(\"Deleting replica {}  for shard {} based on count {}\", replica, shardId, count);\n        deleteCore(shardSlice, collectionName, replica, message, shard, results, onComplete, parallel);\n      }\n      results.add(\"shard_id\", shardId);\n      results.add(\"replicas_deleted\", replicas);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Delete replicas based on count for a given collection. If a shard is passed, uses that\n   * else deletes given num replicas across all shards for the given collection.\n   */\n  void deleteReplicaBasedOnCount(ClusterState clusterState,\n                                 ZkNodeProps message,\n                                 NamedList results,\n                                 Runnable onComplete,\n                                 boolean parallel)\n          throws KeeperException, InterruptedException {\n    ocmh.checkRequired(message, COLLECTION_PROP, COUNT_PROP);\n    int count = Integer.parseInt(message.getStr(COUNT_PROP));\n    String collectionName = message.getStr(COLLECTION_PROP);\n    String shard = message.getStr(SHARD_ID_PROP);\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Slice slice = null;\n    //Validate if shard is passed.\n    if (shard != null) {\n      slice = coll.getSlice(shard);\n      if (slice == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                \"Invalid shard name : \" +  shard +  \" in collection : \" + collectionName);\n      }\n    }\n\n    Map<Slice, Set<String>> shardToReplicasMapping = new HashMap<Slice, Set<String>>();\n    if (slice != null) {\n      Set<String> replicasToBeDeleted = pickReplicasTobeDeleted(slice, shard, collectionName, count);\n      shardToReplicasMapping.put(slice,replicasToBeDeleted);\n    } else {\n\n      //If there are many replicas left, remove the rest based on count.\n      Collection<Slice> allSlices = coll.getSlices();\n      for (Slice individualSlice : allSlices) {\n        Set<String> replicasToBeDeleted = pickReplicasTobeDeleted(individualSlice, individualSlice.getName(), collectionName, count);\n        shardToReplicasMapping.put(individualSlice, replicasToBeDeleted);\n      }\n    }\n\n    for (Map.Entry<Slice, Set<String>> entry : shardToReplicasMapping.entrySet()) {\n      Slice shardSlice = entry.getKey();\n      String shardId = shardSlice.getName();\n      Set<String> replicas = entry.getValue();\n      //callDeleteReplica on all replicas\n      for (String replica: replicas) {\n        log.debug(\"Deleting replica {}  for shard {} based on count {}\", replica, shardId, count);\n        deleteCore(shardSlice, collectionName, replica, message, shard, results, onComplete, parallel);\n      }\n      results.add(\"shard_id\", shardId);\n      results.add(\"replicas_deleted\", replicas);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0":["b94236357aaa22b76c10629851fe4e376e0cea82"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"b0b597c65628ca9e73913a07e81691f8229bae35":["b94236357aaa22b76c10629851fe4e376e0cea82","7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0","b0b597c65628ca9e73913a07e81691f8229bae35"],"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c","b0b597c65628ca9e73913a07e81691f8229bae35"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}