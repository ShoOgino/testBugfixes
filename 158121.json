{"path":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#toString().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#toString().mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#toString().mjava","sourceNew":"  /**\n   * Returns a String representation of the index data for debugging purposes.\n   * \n   * @return the string representation\n   */\n  @Override\n  public String toString() {\n    StringBuilder result = new StringBuilder(256);    \n    sortFields();   \n    int sumChars = 0;\n    int sumPositions = 0;\n    int sumTerms = 0;\n    \n    for (int i=0; i < sortedFields.length; i++) {\n      Map.Entry<String,Info> entry = sortedFields[i];\n      String fieldName = entry.getKey();\n      Info info = entry.getValue();\n      info.sortTerms();\n      result.append(fieldName + \":\\n\");\n      \n      int numChars = 0;\n      int numPositions = 0;\n      for (int j=0; j < info.sortedTerms.length; j++) {\n        Map.Entry<String,ArrayIntList> e = info.sortedTerms[j];\n        String term = e.getKey();\n        ArrayIntList positions = e.getValue();\n        result.append(\"\\t'\" + term + \"':\" + numPositions(positions) + \":\");\n        result.append(positions.toString(stride)); // ignore offsets\n        result.append(\"\\n\");\n        numPositions += numPositions(positions);\n        numChars += term.length();\n      }\n      \n      result.append(\"\\tterms=\" + info.sortedTerms.length);\n      result.append(\", positions=\" + numPositions);\n      result.append(\", Kchars=\" + (numChars/1000.0f));\n      result.append(\"\\n\");\n      sumPositions += numPositions;\n      sumChars += numChars;\n      sumTerms += info.sortedTerms.length;\n    }\n    \n    result.append(\"\\nfields=\" + sortedFields.length);\n    result.append(\", terms=\" + sumTerms);\n    result.append(\", positions=\" + sumPositions);\n    result.append(\", Kchars=\" + (sumChars/1000.0f));\n    return result.toString();\n  }\n\n","sourceOld":"  /**\n   * Returns a String representation of the index data for debugging purposes.\n   * \n   * @return the string representation\n   */\n  @Override\n  public String toString() {\n    StringBuilder result = new StringBuilder(256);    \n    sortFields();   \n    int sumChars = 0;\n    int sumPositions = 0;\n    int sumTerms = 0;\n    \n    for (int i=0; i < sortedFields.length; i++) {\n      Map.Entry<String,Info> entry = sortedFields[i];\n      String fieldName = entry.getKey();\n      Info info = entry.getValue();\n      info.sortTerms();\n      result.append(fieldName + \":\\n\");\n      \n      int numChars = 0;\n      int numPositions = 0;\n      for (int j=0; j < info.sortedTerms.length; j++) {\n        Map.Entry<String,ArrayIntList> e = info.sortedTerms[j];\n        String term = e.getKey();\n        ArrayIntList positions = e.getValue();\n        result.append(\"\\t'\" + term + \"':\" + numPositions(positions) + \":\");\n        result.append(positions.toString(stride)); // ignore offsets\n        result.append(\"\\n\");\n        numPositions += numPositions(positions);\n        numChars += term.length();\n      }\n      \n      result.append(\"\\tterms=\" + info.sortedTerms.length);\n      result.append(\", positions=\" + numPositions);\n      result.append(\", Kchars=\" + (numChars/1000.0f));\n      result.append(\"\\n\");\n      sumPositions += numPositions;\n      sumChars += numChars;\n      sumTerms += info.sortedTerms.length;\n    }\n    \n    result.append(\"\\nfields=\" + sortedFields.length);\n    result.append(\", terms=\" + sumTerms);\n    result.append(\", positions=\" + sumPositions);\n    result.append(\", Kchars=\" + (sumChars/1000.0f));\n    return result.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f29ba80b723649f5feb7e37afe1a558dd2c1304","date":1278318805,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#toString().mjava","pathOld":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#toString().mjava","sourceNew":"  /**\n   * Returns a String representation of the index data for debugging purposes.\n   * \n   * @return the string representation\n   */\n  @Override\n  public String toString() {\n    StringBuilder result = new StringBuilder(256);    \n    sortFields();   \n    int sumBytes = 0;\n    int sumPositions = 0;\n    int sumTerms = 0;\n    \n    for (int i=0; i < sortedFields.length; i++) {\n      Map.Entry<String,Info> entry = sortedFields[i];\n      String fieldName = entry.getKey();\n      Info info = entry.getValue();\n      info.sortTerms();\n      result.append(fieldName + \":\\n\");\n      \n      int numBytes = 0;\n      int numPositions = 0;\n      for (int j=0; j < info.sortedTerms.length; j++) {\n        Map.Entry<BytesRef,ArrayIntList> e = info.sortedTerms[j];\n        BytesRef term = e.getKey();\n        ArrayIntList positions = e.getValue();\n        result.append(\"\\t'\" + term + \"':\" + numPositions(positions) + \":\");\n        result.append(positions.toString(stride)); // ignore offsets\n        result.append(\"\\n\");\n        numPositions += numPositions(positions);\n        numBytes += term.length;\n      }\n      \n      result.append(\"\\tterms=\" + info.sortedTerms.length);\n      result.append(\", positions=\" + numPositions);\n      result.append(\", Kbytes=\" + (numBytes/1000.0f));\n      result.append(\"\\n\");\n      sumPositions += numPositions;\n      sumBytes += numBytes;\n      sumTerms += info.sortedTerms.length;\n    }\n    \n    result.append(\"\\nfields=\" + sortedFields.length);\n    result.append(\", terms=\" + sumTerms);\n    result.append(\", positions=\" + sumPositions);\n    result.append(\", Kbytes=\" + (sumBytes/1000.0f));\n    return result.toString();\n  }\n\n","sourceOld":"  /**\n   * Returns a String representation of the index data for debugging purposes.\n   * \n   * @return the string representation\n   */\n  @Override\n  public String toString() {\n    StringBuilder result = new StringBuilder(256);    \n    sortFields();   \n    int sumChars = 0;\n    int sumPositions = 0;\n    int sumTerms = 0;\n    \n    for (int i=0; i < sortedFields.length; i++) {\n      Map.Entry<String,Info> entry = sortedFields[i];\n      String fieldName = entry.getKey();\n      Info info = entry.getValue();\n      info.sortTerms();\n      result.append(fieldName + \":\\n\");\n      \n      int numChars = 0;\n      int numPositions = 0;\n      for (int j=0; j < info.sortedTerms.length; j++) {\n        Map.Entry<String,ArrayIntList> e = info.sortedTerms[j];\n        String term = e.getKey();\n        ArrayIntList positions = e.getValue();\n        result.append(\"\\t'\" + term + \"':\" + numPositions(positions) + \":\");\n        result.append(positions.toString(stride)); // ignore offsets\n        result.append(\"\\n\");\n        numPositions += numPositions(positions);\n        numChars += term.length();\n      }\n      \n      result.append(\"\\tterms=\" + info.sortedTerms.length);\n      result.append(\", positions=\" + numPositions);\n      result.append(\", Kchars=\" + (numChars/1000.0f));\n      result.append(\"\\n\");\n      sumPositions += numPositions;\n      sumChars += numChars;\n      sumTerms += info.sortedTerms.length;\n    }\n    \n    result.append(\"\\nfields=\" + sortedFields.length);\n    result.append(\", terms=\" + sumTerms);\n    result.append(\", positions=\" + sumPositions);\n    result.append(\", Kchars=\" + (sumChars/1000.0f));\n    return result.toString();\n  }\n\n","bugFix":null,"bugIntro":["9a835874e67543fc296ab80a78ba389811392393"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#toString().mjava","pathOld":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#toString().mjava","sourceNew":"  /**\n   * Returns a String representation of the index data for debugging purposes.\n   * \n   * @return the string representation\n   */\n  @Override\n  public String toString() {\n    StringBuilder result = new StringBuilder(256);    \n    sortFields();   \n    int sumBytes = 0;\n    int sumPositions = 0;\n    int sumTerms = 0;\n    \n    for (int i=0; i < sortedFields.length; i++) {\n      Map.Entry<String,Info> entry = sortedFields[i];\n      String fieldName = entry.getKey();\n      Info info = entry.getValue();\n      info.sortTerms();\n      result.append(fieldName + \":\\n\");\n      \n      int numBytes = 0;\n      int numPositions = 0;\n      for (int j=0; j < info.sortedTerms.length; j++) {\n        Map.Entry<BytesRef,ArrayIntList> e = info.sortedTerms[j];\n        BytesRef term = e.getKey();\n        ArrayIntList positions = e.getValue();\n        result.append(\"\\t'\" + term + \"':\" + numPositions(positions) + \":\");\n        result.append(positions.toString(stride)); // ignore offsets\n        result.append(\"\\n\");\n        numPositions += numPositions(positions);\n        numBytes += term.length;\n      }\n      \n      result.append(\"\\tterms=\" + info.sortedTerms.length);\n      result.append(\", positions=\" + numPositions);\n      result.append(\", Kbytes=\" + (numBytes/1000.0f));\n      result.append(\"\\n\");\n      sumPositions += numPositions;\n      sumBytes += numBytes;\n      sumTerms += info.sortedTerms.length;\n    }\n    \n    result.append(\"\\nfields=\" + sortedFields.length);\n    result.append(\", terms=\" + sumTerms);\n    result.append(\", positions=\" + sumPositions);\n    result.append(\", Kbytes=\" + (sumBytes/1000.0f));\n    return result.toString();\n  }\n\n","sourceOld":"  /**\n   * Returns a String representation of the index data for debugging purposes.\n   * \n   * @return the string representation\n   */\n  @Override\n  public String toString() {\n    StringBuilder result = new StringBuilder(256);    \n    sortFields();   \n    int sumChars = 0;\n    int sumPositions = 0;\n    int sumTerms = 0;\n    \n    for (int i=0; i < sortedFields.length; i++) {\n      Map.Entry<String,Info> entry = sortedFields[i];\n      String fieldName = entry.getKey();\n      Info info = entry.getValue();\n      info.sortTerms();\n      result.append(fieldName + \":\\n\");\n      \n      int numChars = 0;\n      int numPositions = 0;\n      for (int j=0; j < info.sortedTerms.length; j++) {\n        Map.Entry<String,ArrayIntList> e = info.sortedTerms[j];\n        String term = e.getKey();\n        ArrayIntList positions = e.getValue();\n        result.append(\"\\t'\" + term + \"':\" + numPositions(positions) + \":\");\n        result.append(positions.toString(stride)); // ignore offsets\n        result.append(\"\\n\");\n        numPositions += numPositions(positions);\n        numChars += term.length();\n      }\n      \n      result.append(\"\\tterms=\" + info.sortedTerms.length);\n      result.append(\", positions=\" + numPositions);\n      result.append(\", Kchars=\" + (numChars/1000.0f));\n      result.append(\"\\n\");\n      sumPositions += numPositions;\n      sumChars += numChars;\n      sumTerms += info.sortedTerms.length;\n    }\n    \n    result.append(\"\\nfields=\" + sortedFields.length);\n    result.append(\", terms=\" + sumTerms);\n    result.append(\", positions=\" + sumPositions);\n    result.append(\", Kchars=\" + (sumChars/1000.0f));\n    return result.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a835874e67543fc296ab80a78ba389811392393","date":1332198923,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#toString().mjava","pathOld":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#toString().mjava","sourceNew":"  /**\n   * Returns a String representation of the index data for debugging purposes.\n   * \n   * @return the string representation\n   */\n  @Override\n  public String toString() {\n    StringBuilder result = new StringBuilder(256);    \n    sortFields();   \n    int sumPositions = 0;\n    int sumTerms = 0;\n    \n    for (int i=0; i < sortedFields.length; i++) {\n      Map.Entry<String,Info> entry = sortedFields[i];\n      String fieldName = entry.getKey();\n      Info info = entry.getValue();\n      info.sortTerms();\n      result.append(fieldName + \":\\n\");\n      \n      int numPositions = 0;\n      for (int j=0; j < info.sortedTerms.length; j++) {\n        Map.Entry<BytesRef,ArrayIntList> e = info.sortedTerms[j];\n        BytesRef term = e.getKey();\n        ArrayIntList positions = e.getValue();\n        result.append(\"\\t'\" + term + \"':\" + numPositions(positions) + \":\");\n        result.append(positions.toString(stride)); // ignore offsets\n        result.append(\"\\n\");\n        numPositions += numPositions(positions);\n      }\n      \n      result.append(\"\\tterms=\" + info.sortedTerms.length);\n      result.append(\", positions=\" + numPositions);\n      result.append(\", memory=\" + RamUsageEstimator.humanReadableUnits(RamUsageEstimator.sizeOf(info)));\n      result.append(\"\\n\");\n      sumPositions += numPositions;\n      sumTerms += info.sortedTerms.length;\n    }\n    \n    result.append(\"\\nfields=\" + sortedFields.length);\n    result.append(\", terms=\" + sumTerms);\n    result.append(\", positions=\" + sumPositions);\n    result.append(\", memory=\" + RamUsageEstimator.humanReadableUnits(getMemorySize()));\n    return result.toString();\n  }\n\n","sourceOld":"  /**\n   * Returns a String representation of the index data for debugging purposes.\n   * \n   * @return the string representation\n   */\n  @Override\n  public String toString() {\n    StringBuilder result = new StringBuilder(256);    \n    sortFields();   \n    int sumBytes = 0;\n    int sumPositions = 0;\n    int sumTerms = 0;\n    \n    for (int i=0; i < sortedFields.length; i++) {\n      Map.Entry<String,Info> entry = sortedFields[i];\n      String fieldName = entry.getKey();\n      Info info = entry.getValue();\n      info.sortTerms();\n      result.append(fieldName + \":\\n\");\n      \n      int numBytes = 0;\n      int numPositions = 0;\n      for (int j=0; j < info.sortedTerms.length; j++) {\n        Map.Entry<BytesRef,ArrayIntList> e = info.sortedTerms[j];\n        BytesRef term = e.getKey();\n        ArrayIntList positions = e.getValue();\n        result.append(\"\\t'\" + term + \"':\" + numPositions(positions) + \":\");\n        result.append(positions.toString(stride)); // ignore offsets\n        result.append(\"\\n\");\n        numPositions += numPositions(positions);\n        numBytes += term.length;\n      }\n      \n      result.append(\"\\tterms=\" + info.sortedTerms.length);\n      result.append(\", positions=\" + numPositions);\n      result.append(\", Kbytes=\" + (numBytes/1000.0f));\n      result.append(\"\\n\");\n      sumPositions += numPositions;\n      sumBytes += numBytes;\n      sumTerms += info.sortedTerms.length;\n    }\n    \n    result.append(\"\\nfields=\" + sortedFields.length);\n    result.append(\", terms=\" + sumTerms);\n    result.append(\", positions=\" + sumPositions);\n    result.append(\", Kbytes=\" + (sumBytes/1000.0f));\n    return result.toString();\n  }\n\n","bugFix":["4f29ba80b723649f5feb7e37afe1a558dd2c1304"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#toString().mjava","pathOld":"lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex#toString().mjava","sourceNew":"  /**\n   * Returns a String representation of the index data for debugging purposes.\n   * \n   * @return the string representation\n   */\n  @Override\n  public String toString() {\n    StringBuilder result = new StringBuilder(256);    \n    sortFields();   \n    int sumPositions = 0;\n    int sumTerms = 0;\n    \n    for (int i=0; i < sortedFields.length; i++) {\n      Map.Entry<String,Info> entry = sortedFields[i];\n      String fieldName = entry.getKey();\n      Info info = entry.getValue();\n      info.sortTerms();\n      result.append(fieldName + \":\\n\");\n      \n      int numPositions = 0;\n      for (int j=0; j < info.sortedTerms.length; j++) {\n        Map.Entry<BytesRef,ArrayIntList> e = info.sortedTerms[j];\n        BytesRef term = e.getKey();\n        ArrayIntList positions = e.getValue();\n        result.append(\"\\t'\" + term + \"':\" + numPositions(positions) + \":\");\n        result.append(positions.toString(stride)); // ignore offsets\n        result.append(\"\\n\");\n        numPositions += numPositions(positions);\n      }\n      \n      result.append(\"\\tterms=\" + info.sortedTerms.length);\n      result.append(\", positions=\" + numPositions);\n      result.append(\", memory=\" + RamUsageEstimator.humanReadableUnits(RamUsageEstimator.sizeOf(info)));\n      result.append(\"\\n\");\n      sumPositions += numPositions;\n      sumTerms += info.sortedTerms.length;\n    }\n    \n    result.append(\"\\nfields=\" + sortedFields.length);\n    result.append(\", terms=\" + sumTerms);\n    result.append(\", positions=\" + sumPositions);\n    result.append(\", memory=\" + RamUsageEstimator.humanReadableUnits(getMemorySize()));\n    return result.toString();\n  }\n\n","sourceOld":"  /**\n   * Returns a String representation of the index data for debugging purposes.\n   * \n   * @return the string representation\n   */\n  @Override\n  public String toString() {\n    StringBuilder result = new StringBuilder(256);    \n    sortFields();   \n    int sumPositions = 0;\n    int sumTerms = 0;\n    \n    for (int i=0; i < sortedFields.length; i++) {\n      Map.Entry<String,Info> entry = sortedFields[i];\n      String fieldName = entry.getKey();\n      Info info = entry.getValue();\n      info.sortTerms();\n      result.append(fieldName + \":\\n\");\n      \n      int numPositions = 0;\n      for (int j=0; j < info.sortedTerms.length; j++) {\n        Map.Entry<BytesRef,ArrayIntList> e = info.sortedTerms[j];\n        BytesRef term = e.getKey();\n        ArrayIntList positions = e.getValue();\n        result.append(\"\\t'\" + term + \"':\" + numPositions(positions) + \":\");\n        result.append(positions.toString(stride)); // ignore offsets\n        result.append(\"\\n\");\n        numPositions += numPositions(positions);\n      }\n      \n      result.append(\"\\tterms=\" + info.sortedTerms.length);\n      result.append(\", positions=\" + numPositions);\n      result.append(\", memory=\" + RamUsageEstimator.humanReadableUnits(RamUsageEstimator.sizeOf(info)));\n      result.append(\"\\n\");\n      sumPositions += numPositions;\n      sumTerms += info.sortedTerms.length;\n    }\n    \n    result.append(\"\\nfields=\" + sortedFields.length);\n    result.append(\", terms=\" + sumTerms);\n    result.append(\", positions=\" + sumPositions);\n    result.append(\", memory=\" + RamUsageEstimator.humanReadableUnits(getMemorySize()));\n    return result.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["9a835874e67543fc296ab80a78ba389811392393"],"4f29ba80b723649f5feb7e37afe1a558dd2c1304":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9a835874e67543fc296ab80a78ba389811392393":["4f29ba80b723649f5feb7e37afe1a558dd2c1304"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5f4e87790277826a2aea119328600dfb07761f32":["9454a6510e2db155fb01faa5c049b06ece95fab9","4f29ba80b723649f5feb7e37afe1a558dd2c1304"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4f29ba80b723649f5feb7e37afe1a558dd2c1304":["9a835874e67543fc296ab80a78ba389811392393","5f4e87790277826a2aea119328600dfb07761f32"],"9a835874e67543fc296ab80a78ba389811392393":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"5f4e87790277826a2aea119328600dfb07761f32":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["4f29ba80b723649f5feb7e37afe1a558dd2c1304","5f4e87790277826a2aea119328600dfb07761f32"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5f4e87790277826a2aea119328600dfb07761f32","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}