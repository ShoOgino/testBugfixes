{"path":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","commits":[{"id":"1800b996d8677670482a071dcb7a48b08c423ace","date":1456955558,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","pathOld":"/dev/null","sourceNew":"  public void testRectBoundariesAreInclusive() throws Exception {\n    GeoRect rect = randomRect(random().nextBoolean(), false);\n    Query query = newRectQuery(FIELD_NAME, rect);\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect)));\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c422e924212367b334b4938f1fd3e44438e88c40","date":1456962933,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","pathOld":"/dev/null","sourceNew":"  public void testRectBoundariesAreInclusive() throws Exception {\n    GeoRect rect = randomRect(random().nextBoolean(), false);\n    Query query = newRectQuery(FIELD_NAME, rect);\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect)));\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","pathOld":"/dev/null","sourceNew":"  public void testRectBoundariesAreInclusive() throws Exception {\n    GeoRect rect = randomRect(random().nextBoolean(), false);\n    Query query = newRectQuery(FIELD_NAME, rect);\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect)));\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"278394e71c5c3727ff5225bafdde73d7454d0012","date":1458392644,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","sourceNew":"  public void testRectBoundariesAreInclusive() throws Exception {\n    GeoRect rect = randomRect(random().nextBoolean(), false);\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect)));\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRectBoundariesAreInclusive() throws Exception {\n    GeoRect rect = randomRect(random().nextBoolean(), false);\n    Query query = newRectQuery(FIELD_NAME, rect);\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect)));\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6c59bc551f4e523ce6a321280cc6733424fb824","date":1458837690,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","sourceNew":"  public void testRectBoundariesAreInclusive() throws Exception {\n    GeoRect rect = randomRect(random().nextBoolean(), false);\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon)));\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRectBoundariesAreInclusive() throws Exception {\n    GeoRect rect = randomRect(random().nextBoolean(), false);\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect)));\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1419d3974886c9518c259c786492b4d3660b0b8e","date":1459180094,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","sourceNew":"  public void testRectBoundariesAreInclusive() throws Exception {\n    GeoRect rect;\n    // TODO: why this dateline leniency???\n    while (true) {\n      rect = randomRect(random().nextBoolean());\n      if (rect.crossesDateline() == false) {\n        break;\n      }\n    }\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon)));\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRectBoundariesAreInclusive() throws Exception {\n    GeoRect rect = randomRect(random().nextBoolean(), false);\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon)));\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b9e52892242a8c82e1b0c1bd4f1d404366b0501c","date":1459531691,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","sourceNew":"  public void testRectBoundariesAreInclusive() throws Exception {\n    GeoRect rect;\n    // TODO: why this dateline leniency???\n    while (true) {\n      rect = randomRect(random().nextBoolean());\n      if (rect.crossesDateline() == false) {\n        break;\n      }\n    }\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon)));\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRectBoundariesAreInclusive() throws Exception {\n    GeoRect rect;\n    // TODO: why this dateline leniency???\n    while (true) {\n      rect = randomRect(random().nextBoolean());\n      if (rect.crossesDateline() == false) {\n        break;\n      }\n    }\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon)));\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"03bffb520caf6e9833c4b9a82ac67d19a1f3fc97","date":1459595815,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","sourceNew":"  public void testRectBoundariesAreInclusive() throws Exception {\n    GeoRect rect;\n    // TODO: why this dateline leniency???\n    while (true) {\n      rect = randomRect(random().nextBoolean());\n      if (rect.crossesDateline() == false) {\n        break;\n      }\n    }\n    // this test works in quantized space: for testing inclusiveness of exact edges it must be aware of index-time quantization!\n    rect = new GeoRect(quantizeLat(rect.minLat), quantizeLat(rect.maxLat), quantizeLon(rect.minLon), quantizeLon(rect.maxLon));\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    // exact edge cases\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon)));\n    \n    // expand 1 ulp in each direction\n    assumeFalse(\"can't expand box, its too big already\", rect.minLat ==  -90);\n    assumeFalse(\"can't expand box, its too big already\", rect.maxLat ==   90);\n    assumeFalse(\"can't expand box, its too big already\", rect.minLon == -180);\n    assumeFalse(\"can't expand box, its too big already\", rect.maxLon ==  180);\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, Math.nextDown(rect.minLat), rect.maxLat, rect.minLon, rect.maxLon)));\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, Math.nextUp(rect.maxLat), rect.minLon, rect.maxLon)));\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, Math.nextDown(rect.minLon), rect.maxLon)));\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, Math.nextUp(rect.maxLon))));\n    \n    // now shrink 1 ulp in each direction: it should not include bogus stuff\n    assumeFalse(\"can't shrink box, its too small already\", rect.minLat ==   90);\n    assumeFalse(\"can't shrink box, its too small already\", rect.maxLat ==  -90);\n    assumeFalse(\"can't shrink box, its too small already\", rect.minLon ==  180);\n    assumeFalse(\"can't shrink box, its too small already\", rect.maxLon == -180);\n    // note we put points on \"sides\" not just \"corners\" so we just shrink all 4 at once for now: it should exclude all points!\n    assertEquals(0, s.count(newRectQuery(FIELD_NAME, Math.nextUp(rect.minLat), \n                                                     Math.nextDown(rect.maxLat), \n                                                     Math.nextUp(rect.minLon), \n                                                     Math.nextDown(rect.maxLon))));\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRectBoundariesAreInclusive() throws Exception {\n    GeoRect rect;\n    // TODO: why this dateline leniency???\n    while (true) {\n      rect = randomRect(random().nextBoolean());\n      if (rect.crossesDateline() == false) {\n        break;\n      }\n    }\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon)));\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe","date":1459623422,"type":3,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","sourceNew":"  public void testRectBoundariesAreInclusive() throws Exception {\n    Rectangle rect;\n    // TODO: why this dateline leniency???\n    while (true) {\n      rect = randomRect(random().nextBoolean());\n      if (rect.crossesDateline() == false) {\n        break;\n      }\n    }\n    // this test works in quantized space: for testing inclusiveness of exact edges it must be aware of index-time quantization!\n    rect = new Rectangle(quantizeLat(rect.minLat), quantizeLat(rect.maxLat), quantizeLon(rect.minLon), quantizeLon(rect.maxLon));\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    // exact edge cases\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon)));\n    \n    // expand 1 ulp in each direction\n    assumeFalse(\"can't expand box, its too big already\", rect.minLat ==  -90);\n    assumeFalse(\"can't expand box, its too big already\", rect.maxLat ==   90);\n    assumeFalse(\"can't expand box, its too big already\", rect.minLon == -180);\n    assumeFalse(\"can't expand box, its too big already\", rect.maxLon ==  180);\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, Math.nextDown(rect.minLat), rect.maxLat, rect.minLon, rect.maxLon)));\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, Math.nextUp(rect.maxLat), rect.minLon, rect.maxLon)));\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, Math.nextDown(rect.minLon), rect.maxLon)));\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, Math.nextUp(rect.maxLon))));\n    \n    // now shrink 1 ulp in each direction: it should not include bogus stuff\n    assumeFalse(\"can't shrink box, its too small already\", rect.minLat ==   90);\n    assumeFalse(\"can't shrink box, its too small already\", rect.maxLat ==  -90);\n    assumeFalse(\"can't shrink box, its too small already\", rect.minLon ==  180);\n    assumeFalse(\"can't shrink box, its too small already\", rect.maxLon == -180);\n    // note we put points on \"sides\" not just \"corners\" so we just shrink all 4 at once for now: it should exclude all points!\n    assertEquals(0, s.count(newRectQuery(FIELD_NAME, Math.nextUp(rect.minLat), \n                                                     Math.nextDown(rect.maxLat), \n                                                     Math.nextUp(rect.minLon), \n                                                     Math.nextDown(rect.maxLon))));\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRectBoundariesAreInclusive() throws Exception {\n    GeoRect rect;\n    // TODO: why this dateline leniency???\n    while (true) {\n      rect = randomRect(random().nextBoolean());\n      if (rect.crossesDateline() == false) {\n        break;\n      }\n    }\n    // this test works in quantized space: for testing inclusiveness of exact edges it must be aware of index-time quantization!\n    rect = new GeoRect(quantizeLat(rect.minLat), quantizeLat(rect.maxLat), quantizeLon(rect.minLon), quantizeLon(rect.maxLon));\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    // exact edge cases\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon)));\n    \n    // expand 1 ulp in each direction\n    assumeFalse(\"can't expand box, its too big already\", rect.minLat ==  -90);\n    assumeFalse(\"can't expand box, its too big already\", rect.maxLat ==   90);\n    assumeFalse(\"can't expand box, its too big already\", rect.minLon == -180);\n    assumeFalse(\"can't expand box, its too big already\", rect.maxLon ==  180);\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, Math.nextDown(rect.minLat), rect.maxLat, rect.minLon, rect.maxLon)));\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, Math.nextUp(rect.maxLat), rect.minLon, rect.maxLon)));\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, Math.nextDown(rect.minLon), rect.maxLon)));\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, Math.nextUp(rect.maxLon))));\n    \n    // now shrink 1 ulp in each direction: it should not include bogus stuff\n    assumeFalse(\"can't shrink box, its too small already\", rect.minLat ==   90);\n    assumeFalse(\"can't shrink box, its too small already\", rect.maxLat ==  -90);\n    assumeFalse(\"can't shrink box, its too small already\", rect.minLon ==  180);\n    assumeFalse(\"can't shrink box, its too small already\", rect.maxLon == -180);\n    // note we put points on \"sides\" not just \"corners\" so we just shrink all 4 at once for now: it should exclude all points!\n    assertEquals(0, s.count(newRectQuery(FIELD_NAME, Math.nextUp(rect.minLat), \n                                                     Math.nextDown(rect.maxLat), \n                                                     Math.nextUp(rect.minLon), \n                                                     Math.nextDown(rect.maxLon))));\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38068a32aca0cc59645b1b249276f39e608d80bc","date":1460002083,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","sourceNew":"  public void testRectBoundariesAreInclusive() throws Exception {\n    Rectangle rect;\n    // TODO: why this dateline leniency???\n    while (true) {\n      rect = randomRect(random().nextBoolean());\n      if (rect.crossesDateline() == false) {\n        break;\n      }\n    }\n    // this test works in quantized space: for testing inclusiveness of exact edges it must be aware of index-time quantization!\n    rect = new Rectangle(quantizeLat(rect.minLat), quantizeLat(rect.maxLat), quantizeLon(rect.minLon), quantizeLon(rect.maxLon));\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    // exact edge cases\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon)));\n    \n    // expand 1 ulp in each direction if possible and test a slightly larger box!\n    if (rect.minLat != -90) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, Math.nextDown(rect.minLat), rect.maxLat, rect.minLon, rect.maxLon)));\n    }\n    if (rect.maxLat != 90) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, Math.nextUp(rect.maxLat), rect.minLon, rect.maxLon)));\n    }\n    if (rect.minLon != -180) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, Math.nextDown(rect.minLon), rect.maxLon)));\n    }\n    if (rect.maxLon != 180) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, Math.nextUp(rect.maxLon))));\n    }\n    \n    // now shrink 1 ulp in each direction if possible: it should not include bogus stuff\n    if (rect.minLat != 90 && rect.maxLat != -90 && rect.minLon != 80 && rect.maxLon != -180) {\n      // note we put points on \"sides\" not just \"corners\" so we just shrink all 4 at once for now: it should exclude all points!\n      assertEquals(0, s.count(newRectQuery(FIELD_NAME, Math.nextUp(rect.minLat), \n                                                     Math.nextDown(rect.maxLat), \n                                                     Math.nextUp(rect.minLon), \n                                                     Math.nextDown(rect.maxLon))));\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRectBoundariesAreInclusive() throws Exception {\n    Rectangle rect;\n    // TODO: why this dateline leniency???\n    while (true) {\n      rect = randomRect(random().nextBoolean());\n      if (rect.crossesDateline() == false) {\n        break;\n      }\n    }\n    // this test works in quantized space: for testing inclusiveness of exact edges it must be aware of index-time quantization!\n    rect = new Rectangle(quantizeLat(rect.minLat), quantizeLat(rect.maxLat), quantizeLon(rect.minLon), quantizeLon(rect.maxLon));\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    // exact edge cases\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon)));\n    \n    // expand 1 ulp in each direction\n    assumeFalse(\"can't expand box, its too big already\", rect.minLat ==  -90);\n    assumeFalse(\"can't expand box, its too big already\", rect.maxLat ==   90);\n    assumeFalse(\"can't expand box, its too big already\", rect.minLon == -180);\n    assumeFalse(\"can't expand box, its too big already\", rect.maxLon ==  180);\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, Math.nextDown(rect.minLat), rect.maxLat, rect.minLon, rect.maxLon)));\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, Math.nextUp(rect.maxLat), rect.minLon, rect.maxLon)));\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, Math.nextDown(rect.minLon), rect.maxLon)));\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, Math.nextUp(rect.maxLon))));\n    \n    // now shrink 1 ulp in each direction: it should not include bogus stuff\n    assumeFalse(\"can't shrink box, its too small already\", rect.minLat ==   90);\n    assumeFalse(\"can't shrink box, its too small already\", rect.maxLat ==  -90);\n    assumeFalse(\"can't shrink box, its too small already\", rect.minLon ==  180);\n    assumeFalse(\"can't shrink box, its too small already\", rect.maxLon == -180);\n    // note we put points on \"sides\" not just \"corners\" so we just shrink all 4 at once for now: it should exclude all points!\n    assertEquals(0, s.count(newRectQuery(FIELD_NAME, Math.nextUp(rect.minLat), \n                                                     Math.nextDown(rect.maxLat), \n                                                     Math.nextUp(rect.minLon), \n                                                     Math.nextDown(rect.maxLon))));\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["c01a1a39789d39c19b13b707a22a08ad8901a614"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c01a1a39789d39c19b13b707a22a08ad8901a614","date":1460467650,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","sourceNew":"  public void testRectBoundariesAreInclusive() throws Exception {\n    Rectangle rect;\n    // TODO: why this dateline leniency???\n    while (true) {\n      rect = randomRect(random().nextBoolean());\n      if (rect.crossesDateline() == false) {\n        break;\n      }\n    }\n    // this test works in quantized space: for testing inclusiveness of exact edges it must be aware of index-time quantization!\n    rect = new Rectangle(quantizeLat(rect.minLat), quantizeLat(rect.maxLat), quantizeLon(rect.minLon), quantizeLon(rect.maxLon));\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    // exact edge cases\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon)));\n    \n    // expand 1 ulp in each direction if possible and test a slightly larger box!\n    if (rect.minLat != -90) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, Math.nextDown(rect.minLat), rect.maxLat, rect.minLon, rect.maxLon)));\n    }\n    if (rect.maxLat != 90) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, Math.nextUp(rect.maxLat), rect.minLon, rect.maxLon)));\n    }\n    if (rect.minLon != -180) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, Math.nextDown(rect.minLon), rect.maxLon)));\n    }\n    if (rect.maxLon != 180) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, Math.nextUp(rect.maxLon))));\n    }\n    \n    // now shrink 1 ulp in each direction if possible: it should not include bogus stuff\n    // we can't shrink if values are already at extremes, and\n    // we can't do this if rectangle is actually a line or we will create a cross-dateline query\n    if (rect.minLat != 90 && rect.maxLat != -90 && rect.minLon != 80 && rect.maxLon != -180 && rect.minLon != rect.maxLon) {\n      // note we put points on \"sides\" not just \"corners\" so we just shrink all 4 at once for now: it should exclude all points!\n      assertEquals(0, s.count(newRectQuery(FIELD_NAME, Math.nextUp(rect.minLat), \n                                                     Math.nextDown(rect.maxLat), \n                                                     Math.nextUp(rect.minLon), \n                                                     Math.nextDown(rect.maxLon))));\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRectBoundariesAreInclusive() throws Exception {\n    Rectangle rect;\n    // TODO: why this dateline leniency???\n    while (true) {\n      rect = randomRect(random().nextBoolean());\n      if (rect.crossesDateline() == false) {\n        break;\n      }\n    }\n    // this test works in quantized space: for testing inclusiveness of exact edges it must be aware of index-time quantization!\n    rect = new Rectangle(quantizeLat(rect.minLat), quantizeLat(rect.maxLat), quantizeLon(rect.minLon), quantizeLon(rect.maxLon));\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    // exact edge cases\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon)));\n    \n    // expand 1 ulp in each direction if possible and test a slightly larger box!\n    if (rect.minLat != -90) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, Math.nextDown(rect.minLat), rect.maxLat, rect.minLon, rect.maxLon)));\n    }\n    if (rect.maxLat != 90) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, Math.nextUp(rect.maxLat), rect.minLon, rect.maxLon)));\n    }\n    if (rect.minLon != -180) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, Math.nextDown(rect.minLon), rect.maxLon)));\n    }\n    if (rect.maxLon != 180) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, Math.nextUp(rect.maxLon))));\n    }\n    \n    // now shrink 1 ulp in each direction if possible: it should not include bogus stuff\n    if (rect.minLat != 90 && rect.maxLat != -90 && rect.minLon != 80 && rect.maxLon != -180) {\n      // note we put points on \"sides\" not just \"corners\" so we just shrink all 4 at once for now: it should exclude all points!\n      assertEquals(0, s.count(newRectQuery(FIELD_NAME, Math.nextUp(rect.minLat), \n                                                     Math.nextDown(rect.maxLat), \n                                                     Math.nextUp(rect.minLon), \n                                                     Math.nextDown(rect.maxLon))));\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":["38068a32aca0cc59645b1b249276f39e608d80bc"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca6d9b7ccfba9ef2a57cee7b019ad8e6e1d467ef","date":1460489867,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","sourceNew":"  public void testRectBoundariesAreInclusive() throws Exception {\n    Rectangle rect;\n    // TODO: why this dateline leniency???\n    while (true) {\n      rect = randomRect(random().nextBoolean());\n      if (rect.crossesDateline() == false) {\n        break;\n      }\n    }\n    // this test works in quantized space: for testing inclusiveness of exact edges it must be aware of index-time quantization!\n    rect = new Rectangle(quantizeLat(rect.minLat), quantizeLat(rect.maxLat), quantizeLon(rect.minLon), quantizeLon(rect.maxLon));\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    // exact edge cases\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon)));\n    \n    // expand 1 ulp in each direction if possible and test a slightly larger box!\n    if (rect.minLat != -90) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, Math.nextDown(rect.minLat), rect.maxLat, rect.minLon, rect.maxLon)));\n    }\n    if (rect.maxLat != 90) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, Math.nextUp(rect.maxLat), rect.minLon, rect.maxLon)));\n    }\n    if (rect.minLon != -180) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, Math.nextDown(rect.minLon), rect.maxLon)));\n    }\n    if (rect.maxLon != 180) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, Math.nextUp(rect.maxLon))));\n    }\n    \n    // now shrink 1 ulp in each direction if possible: it should not include bogus stuff\n    // we can't shrink if values are already at extremes, and\n    // we can't do this if rectangle is actually a line or we will create a cross-dateline query\n    if (rect.minLat != 90 && rect.maxLat != -90 && rect.minLon != 80 && rect.maxLon != -180 && rect.minLon != rect.maxLon) {\n      // note we put points on \"sides\" not just \"corners\" so we just shrink all 4 at once for now: it should exclude all points!\n      assertEquals(0, s.count(newRectQuery(FIELD_NAME, Math.nextUp(rect.minLat), \n                                                     Math.nextDown(rect.maxLat), \n                                                     Math.nextUp(rect.minLon), \n                                                     Math.nextDown(rect.maxLon))));\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRectBoundariesAreInclusive() throws Exception {\n    Rectangle rect;\n    // TODO: why this dateline leniency???\n    while (true) {\n      rect = randomRect(random().nextBoolean());\n      if (rect.crossesDateline() == false) {\n        break;\n      }\n    }\n    // this test works in quantized space: for testing inclusiveness of exact edges it must be aware of index-time quantization!\n    rect = new Rectangle(quantizeLat(rect.minLat), quantizeLat(rect.maxLat), quantizeLon(rect.minLon), quantizeLon(rect.maxLon));\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    // exact edge cases\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon)));\n    \n    // expand 1 ulp in each direction if possible and test a slightly larger box!\n    if (rect.minLat != -90) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, Math.nextDown(rect.minLat), rect.maxLat, rect.minLon, rect.maxLon)));\n    }\n    if (rect.maxLat != 90) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, Math.nextUp(rect.maxLat), rect.minLon, rect.maxLon)));\n    }\n    if (rect.minLon != -180) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, Math.nextDown(rect.minLon), rect.maxLon)));\n    }\n    if (rect.maxLon != 180) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, Math.nextUp(rect.maxLon))));\n    }\n    \n    // now shrink 1 ulp in each direction if possible: it should not include bogus stuff\n    if (rect.minLat != 90 && rect.maxLat != -90 && rect.minLon != 80 && rect.maxLon != -180) {\n      // note we put points on \"sides\" not just \"corners\" so we just shrink all 4 at once for now: it should exclude all points!\n      assertEquals(0, s.count(newRectQuery(FIELD_NAME, Math.nextUp(rect.minLat), \n                                                     Math.nextDown(rect.maxLat), \n                                                     Math.nextUp(rect.minLon), \n                                                     Math.nextDown(rect.maxLon))));\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e21d7642ee7e0c00429964e5b47504602fe218c","date":1460897579,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","sourceNew":"  public void testRectBoundariesAreInclusive() throws Exception {\n    Rectangle rect;\n    // TODO: why this dateline leniency???\n    while (true) {\n      rect = randomRect(random().nextBoolean());\n      if (rect.crossesDateline() == false) {\n        break;\n      }\n    }\n    // this test works in quantized space: for testing inclusiveness of exact edges it must be aware of index-time quantization!\n    rect = new Rectangle(quantizeLat(rect.minLat), quantizeLat(rect.maxLat), quantizeLon(rect.minLon), quantizeLon(rect.maxLon));\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    // exact edge cases\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon)));\n    \n    // expand 1 ulp in each direction if possible and test a slightly larger box!\n    if (rect.minLat != -90) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, Math.nextDown(rect.minLat), rect.maxLat, rect.minLon, rect.maxLon)));\n    }\n    if (rect.maxLat != 90) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, Math.nextUp(rect.maxLat), rect.minLon, rect.maxLon)));\n    }\n    if (rect.minLon != -180) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, Math.nextDown(rect.minLon), rect.maxLon)));\n    }\n    if (rect.maxLon != 180) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, Math.nextUp(rect.maxLon))));\n    }\n    \n    // now shrink 1 ulp in each direction if possible: it should not include bogus stuff\n    // we can't shrink if values are already at extremes, and\n    // we can't do this if rectangle is actually a line or we will create a cross-dateline query\n    if (rect.minLat != 90 && rect.maxLat != -90 && rect.minLon != 80 && rect.maxLon != -180 && rect.minLon != rect.maxLon) {\n      // note we put points on \"sides\" not just \"corners\" so we just shrink all 4 at once for now: it should exclude all points!\n      assertEquals(0, s.count(newRectQuery(FIELD_NAME, Math.nextUp(rect.minLat), \n                                                     Math.nextDown(rect.maxLat), \n                                                     Math.nextUp(rect.minLon), \n                                                     Math.nextDown(rect.maxLon))));\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRectBoundariesAreInclusive() throws Exception {\n    Rectangle rect;\n    // TODO: why this dateline leniency???\n    while (true) {\n      rect = randomRect(random().nextBoolean());\n      if (rect.crossesDateline() == false) {\n        break;\n      }\n    }\n    // this test works in quantized space: for testing inclusiveness of exact edges it must be aware of index-time quantization!\n    rect = new Rectangle(quantizeLat(rect.minLat), quantizeLat(rect.maxLat), quantizeLon(rect.minLon), quantizeLon(rect.maxLon));\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    // exact edge cases\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon)));\n    \n    // expand 1 ulp in each direction if possible and test a slightly larger box!\n    if (rect.minLat != -90) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, Math.nextDown(rect.minLat), rect.maxLat, rect.minLon, rect.maxLon)));\n    }\n    if (rect.maxLat != 90) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, Math.nextUp(rect.maxLat), rect.minLon, rect.maxLon)));\n    }\n    if (rect.minLon != -180) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, Math.nextDown(rect.minLon), rect.maxLon)));\n    }\n    if (rect.maxLon != 180) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, Math.nextUp(rect.maxLon))));\n    }\n    \n    // now shrink 1 ulp in each direction if possible: it should not include bogus stuff\n    // we can't shrink if values are already at extremes, and\n    // we can't do this if rectangle is actually a line or we will create a cross-dateline query\n    if (rect.minLat != 90 && rect.maxLat != -90 && rect.minLon != 80 && rect.maxLon != -180 && rect.minLon != rect.maxLon) {\n      // note we put points on \"sides\" not just \"corners\" so we just shrink all 4 at once for now: it should exclude all points!\n      assertEquals(0, s.count(newRectQuery(FIELD_NAME, Math.nextUp(rect.minLat), \n                                                     Math.nextDown(rect.maxLat), \n                                                     Math.nextUp(rect.minLon), \n                                                     Math.nextDown(rect.maxLon))));\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8cb57c50beb99a1245256e866350af8e5ea1f36","date":1460921840,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/geo/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#testRectBoundariesAreInclusive().mjava","sourceNew":"  public void testRectBoundariesAreInclusive() throws Exception {\n    Rectangle rect;\n    // TODO: why this dateline leniency???\n    while (true) {\n      rect = randomRect(random().nextBoolean());\n      if (rect.crossesDateline() == false) {\n        break;\n      }\n    }\n    // this test works in quantized space: for testing inclusiveness of exact edges it must be aware of index-time quantization!\n    rect = new Rectangle(quantizeLat(rect.minLat), quantizeLat(rect.maxLat), quantizeLon(rect.minLon), quantizeLon(rect.maxLon));\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    // exact edge cases\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon)));\n    \n    // expand 1 ulp in each direction if possible and test a slightly larger box!\n    if (rect.minLat != -90) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, Math.nextDown(rect.minLat), rect.maxLat, rect.minLon, rect.maxLon)));\n    }\n    if (rect.maxLat != 90) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, Math.nextUp(rect.maxLat), rect.minLon, rect.maxLon)));\n    }\n    if (rect.minLon != -180) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, Math.nextDown(rect.minLon), rect.maxLon)));\n    }\n    if (rect.maxLon != 180) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, Math.nextUp(rect.maxLon))));\n    }\n    \n    // now shrink 1 ulp in each direction if possible: it should not include bogus stuff\n    // we can't shrink if values are already at extremes, and\n    // we can't do this if rectangle is actually a line or we will create a cross-dateline query\n    if (rect.minLat != 90 && rect.maxLat != -90 && rect.minLon != 80 && rect.maxLon != -180 && rect.minLon != rect.maxLon) {\n      // note we put points on \"sides\" not just \"corners\" so we just shrink all 4 at once for now: it should exclude all points!\n      assertEquals(0, s.count(newRectQuery(FIELD_NAME, Math.nextUp(rect.minLat), \n                                                     Math.nextDown(rect.maxLat), \n                                                     Math.nextUp(rect.minLon), \n                                                     Math.nextDown(rect.maxLon))));\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRectBoundariesAreInclusive() throws Exception {\n    Rectangle rect;\n    // TODO: why this dateline leniency???\n    while (true) {\n      rect = randomRect(random().nextBoolean());\n      if (rect.crossesDateline() == false) {\n        break;\n      }\n    }\n    // this test works in quantized space: for testing inclusiveness of exact edges it must be aware of index-time quantization!\n    rect = new Rectangle(quantizeLat(rect.minLat), quantizeLat(rect.maxLat), quantizeLon(rect.minLon), quantizeLon(rect.maxLon));\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else seeds may not reproduce:\n    iwc.setMergeScheduler(new SerialMergeScheduler());\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    for(int x=0;x<3;x++) {\n      double lat;\n      if (x == 0) {\n        lat = rect.minLat;\n      } else if (x == 1) {\n        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);\n      } else {\n        lat = rect.maxLat;\n      }\n      for(int y=0;y<3;y++) {\n        double lon;\n        if (y == 0) {\n          lon = rect.minLon;\n        } else if (y == 1) {\n          if (x == 1) {\n            continue;\n          }\n          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);\n        } else {\n          lon = rect.maxLon;\n        }\n\n        Document doc = new Document();\n        addPointToDoc(FIELD_NAME, doc, lat, lon);\n        w.addDocument(doc);\n      }\n    }\n    IndexReader r = w.getReader();\n    IndexSearcher s = newSearcher(r, false);\n    // exact edge cases\n    assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon)));\n    \n    // expand 1 ulp in each direction if possible and test a slightly larger box!\n    if (rect.minLat != -90) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, Math.nextDown(rect.minLat), rect.maxLat, rect.minLon, rect.maxLon)));\n    }\n    if (rect.maxLat != 90) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, Math.nextUp(rect.maxLat), rect.minLon, rect.maxLon)));\n    }\n    if (rect.minLon != -180) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, Math.nextDown(rect.minLon), rect.maxLon)));\n    }\n    if (rect.maxLon != 180) {\n      assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, Math.nextUp(rect.maxLon))));\n    }\n    \n    // now shrink 1 ulp in each direction if possible: it should not include bogus stuff\n    // we can't shrink if values are already at extremes, and\n    // we can't do this if rectangle is actually a line or we will create a cross-dateline query\n    if (rect.minLat != 90 && rect.maxLat != -90 && rect.minLon != 80 && rect.maxLon != -180 && rect.minLon != rect.maxLon) {\n      // note we put points on \"sides\" not just \"corners\" so we just shrink all 4 at once for now: it should exclude all points!\n      assertEquals(0, s.count(newRectQuery(FIELD_NAME, Math.nextUp(rect.minLat), \n                                                     Math.nextDown(rect.maxLat), \n                                                     Math.nextUp(rect.minLon), \n                                                     Math.nextDown(rect.maxLon))));\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ca6d9b7ccfba9ef2a57cee7b019ad8e6e1d467ef":["38068a32aca0cc59645b1b249276f39e608d80bc","c01a1a39789d39c19b13b707a22a08ad8901a614"],"38068a32aca0cc59645b1b249276f39e608d80bc":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe"],"1419d3974886c9518c259c786492b4d3660b0b8e":["d6c59bc551f4e523ce6a321280cc6733424fb824"],"278394e71c5c3727ff5225bafdde73d7454d0012":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"03bffb520caf6e9833c4b9a82ac67d19a1f3fc97":["b9e52892242a8c82e1b0c1bd4f1d404366b0501c"],"c422e924212367b334b4938f1fd3e44438e88c40":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1800b996d8677670482a071dcb7a48b08c423ace"],"1800b996d8677670482a071dcb7a48b08c423ace":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f8cb57c50beb99a1245256e866350af8e5ea1f36":["ca6d9b7ccfba9ef2a57cee7b019ad8e6e1d467ef","3e21d7642ee7e0c00429964e5b47504602fe218c"],"d6c59bc551f4e523ce6a321280cc6733424fb824":["278394e71c5c3727ff5225bafdde73d7454d0012"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b9e52892242a8c82e1b0c1bd4f1d404366b0501c":["1419d3974886c9518c259c786492b4d3660b0b8e"],"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe":["03bffb520caf6e9833c4b9a82ac67d19a1f3fc97"],"c01a1a39789d39c19b13b707a22a08ad8901a614":["38068a32aca0cc59645b1b249276f39e608d80bc"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c422e924212367b334b4938f1fd3e44438e88c40"],"3e21d7642ee7e0c00429964e5b47504602fe218c":["ca6d9b7ccfba9ef2a57cee7b019ad8e6e1d467ef"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f8cb57c50beb99a1245256e866350af8e5ea1f36"]},"commit2Childs":{"ca6d9b7ccfba9ef2a57cee7b019ad8e6e1d467ef":["f8cb57c50beb99a1245256e866350af8e5ea1f36","3e21d7642ee7e0c00429964e5b47504602fe218c"],"38068a32aca0cc59645b1b249276f39e608d80bc":["ca6d9b7ccfba9ef2a57cee7b019ad8e6e1d467ef","c01a1a39789d39c19b13b707a22a08ad8901a614"],"1419d3974886c9518c259c786492b4d3660b0b8e":["b9e52892242a8c82e1b0c1bd4f1d404366b0501c"],"278394e71c5c3727ff5225bafdde73d7454d0012":["d6c59bc551f4e523ce6a321280cc6733424fb824"],"03bffb520caf6e9833c4b9a82ac67d19a1f3fc97":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe"],"c422e924212367b334b4938f1fd3e44438e88c40":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"1800b996d8677670482a071dcb7a48b08c423ace":["c422e924212367b334b4938f1fd3e44438e88c40"],"f8cb57c50beb99a1245256e866350af8e5ea1f36":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d6c59bc551f4e523ce6a321280cc6733424fb824":["1419d3974886c9518c259c786492b4d3660b0b8e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c422e924212367b334b4938f1fd3e44438e88c40","1800b996d8677670482a071dcb7a48b08c423ace","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"b9e52892242a8c82e1b0c1bd4f1d404366b0501c":["03bffb520caf6e9833c4b9a82ac67d19a1f3fc97"],"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe":["38068a32aca0cc59645b1b249276f39e608d80bc"],"c01a1a39789d39c19b13b707a22a08ad8901a614":["ca6d9b7ccfba9ef2a57cee7b019ad8e6e1d467ef"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["278394e71c5c3727ff5225bafdde73d7454d0012"],"3e21d7642ee7e0c00429964e5b47504602fe218c":["f8cb57c50beb99a1245256e866350af8e5ea1f36"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}