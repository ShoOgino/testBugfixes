{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","commits":[{"id":"7ca08c071cb75a8796c36ae6a1c90d7473c2a6df","date":1425554964,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection, clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionNames = getCollectionNames(clusterState, collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(clusterState, collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if(s!=null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request,\n            clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      String collection = reqParams.get(UpdateParams.COLLECTION, defaultCollection);\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionNames = getCollectionNames(clusterState, collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(clusterState, collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || (sendToLeaders && coreNodeProps.isLeader())) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else if (sendToLeaders) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(\n                    nodeProps.getStr(ZkStateReader.BASE_URL_PROP),\n                    defaultCollection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if(s!=null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n    \n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","pathOld":"/dev/null","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection, clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionNames = getCollectionNames(clusterState, collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(clusterState, collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if(s!=null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection, clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionNames = getCollectionNames(clusterState, collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(clusterState, collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if(s!=null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection, clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionNames = getCollectionNames(clusterState, collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(clusterState, collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || !coreNodeProps.getState().equals(ZkStateReader.ACTIVE)) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if(s!=null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"275019a81d0883a1db4560391b072d1fbe272ec4","date":1432741049,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection, clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionNames = getCollectionNames(clusterState, collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(clusterState, collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if(s!=null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Could not find a healthy node to handle the request.\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection, clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionNames = getCollectionNames(clusterState, collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(clusterState, collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if(s!=null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Not enough nodes to handle the request\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":["bafca15d8e408346a67f4282ad1143b88023893b"],"bugIntro":["e6c86133b70c1a2f86eca01da72b4357774d2b5c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6bdcb86c29922edae9a14852e636303bc52df094","date":1438887454,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection, clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().startsWith(\"/admin/\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionNames = getCollectionNames(clusterState, collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(clusterState, collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if(s!=null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Could not find a healthy node to handle the request.\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection, clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().equals(\"/admin/collections\")\n        || request.getPath().equals(\"/admin/cores\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionNames = getCollectionNames(clusterState, collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(clusterState, collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if(s!=null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Could not find a healthy node to handle the request.\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":["e78c35bca3e32dfc7a695136fa2b5de1ae135c22"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e78c35bca3e32dfc7a695136fa2b5de1ae135c22","date":1441118240,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection, clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionNames = getCollectionNames(clusterState, collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(clusterState, collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if(s!=null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Could not find a healthy node to handle the request.\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection, clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request.getPath().startsWith(\"/admin/\")) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionNames = getCollectionNames(clusterState, collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(clusterState, collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if(s!=null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Could not find a healthy node to handle the request.\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":["6bdcb86c29922edae9a14852e636303bc52df094"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e6c86133b70c1a2f86eca01da72b4357774d2b5c","date":1455889879,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection, clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionNames = getCollectionNames(clusterState, collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(clusterState, collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n      if (theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if (s != null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection, clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionNames = getCollectionNames(clusterState, collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(clusterState, collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n      if(theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if(s!=null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE, \"Could not find a healthy node to handle the request.\");\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":["bafca15d8e408346a67f4282ad1143b88023893b","275019a81d0883a1db4560391b072d1fbe272ec4","4c2f5223cebd58879933670af3e599b10d7e8f1a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3eaeb36333664e8cb92108ef03f68a7b90beb759","date":1480015298,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = stateProvider.liveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperties().getOrDefault(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n\n      Set<String> collectionNames = getCollectionNames(collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = stateProvider.liveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n      if (theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if (s != null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection, clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionNames = getCollectionNames(clusterState, collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(clusterState, collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n      if (theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if (s != null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"727bb765ff2542275f6d31f67be18d7104bae148","date":1480353976,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = stateProvider.liveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperties().getOrDefault(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n\n      Set<String> collectionNames = getCollectionNames(collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = stateProvider.liveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n      if (theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if (s != null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    \n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection, clusterState);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = clusterState.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(zkStateReader.getBaseUrlForNodeName(liveNode));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n      \n      Set<String> collectionNames = getCollectionNames(clusterState, collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(clusterState, collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = clusterState.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n      if (theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if (s != null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a64b273d51a6540272668680ece9f8b686ff0004","date":1492404078,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = stateProvider.liveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n\n      Set<String> collectionNames = getCollectionNames(collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = stateProvider.liveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n      if (theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if (s != null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = stateProvider.liveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperties().getOrDefault(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n\n      Set<String> collectionNames = getCollectionNames(collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = stateProvider.liveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n      if (theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if (s != null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = stateProvider.liveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n\n      Set<String> collectionNames = getCollectionNames(collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = stateProvider.liveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n      if (theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if (s != null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = stateProvider.liveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperties().getOrDefault(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n\n      Set<String> collectionNames = getCollectionNames(collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = stateProvider.liveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n      if (theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if (s != null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"767d389403b701039ee599ec2ac8a838f45d8cb7","date":1494468363,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request instanceof V2Request) {\n      Set<String> liveNodes = stateProvider.liveNodes();\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList);\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNodesList.get(0),\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = stateProvider.liveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n\n      Set<String> collectionNames = getCollectionNames(collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = stateProvider.liveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n      if (theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if (s != null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = stateProvider.liveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n\n      Set<String> collectionNames = getCollectionNames(collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = stateProvider.liveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n      if (theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if (s != null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"67a9fd6a5da455e5d6959c1b0fc6f0dc4b15f9b7","date":1494469733,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request instanceof V2Request) {\n      Set<String> liveNodes = stateProvider.liveNodes();\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNodesList.get(0),\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = stateProvider.liveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n\n      Set<String> collectionNames = getCollectionNames(collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = stateProvider.liveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n      if (theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if (s != null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request instanceof V2Request) {\n      Set<String> liveNodes = stateProvider.liveNodes();\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList);\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNodesList.get(0),\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = stateProvider.liveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n\n      Set<String> collectionNames = getCollectionNames(collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = stateProvider.liveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n      if (theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if (s != null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b31ebc7a867ddea79d438a8fca876a94e644d11a","date":1494496172,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request instanceof V2Request) {\n      Set<String> liveNodes = stateProvider.liveNodes();\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNodesList.get(0),\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = stateProvider.liveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n\n      Set<String> collectionNames = getCollectionNames(collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = stateProvider.liveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n      if (theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if (s != null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = stateProvider.liveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n\n      Set<String> collectionNames = getCollectionNames(collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = stateProvider.liveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n      if (theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if (s != null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request instanceof V2Request) {\n      Set<String> liveNodes = stateProvider.liveNodes();\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNodesList.get(0),\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = stateProvider.liveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n\n      Set<String> collectionNames = getCollectionNames(collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = stateProvider.liveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n      if (theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if (s != null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = stateProvider.liveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n\n      Set<String> collectionNames = getCollectionNames(collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = stateProvider.liveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n      if (theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if (s != null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85212dad4ed576c7f7e6c165ee19e597b7b4efc8","date":1507997740,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request instanceof V2Request) {\n      Set<String> liveNodes = stateProvider.getLiveNodes();\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNodesList.get(0),\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = stateProvider.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n\n      Set<String> collectionNames = getCollectionNames(collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = stateProvider.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n      if (theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if (s != null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request instanceof V2Request) {\n      Set<String> liveNodes = stateProvider.liveNodes();\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNodesList.get(0),\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = stateProvider.liveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n\n      Set<String> collectionNames = getCollectionNames(collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = stateProvider.liveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n      if (theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if (s != null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b824daa61db3f30b91a22213d6c04e1fa2e2b06","date":1508385744,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,List[String]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#sendRequest(SolrRequest,String).mjava","sourceNew":"  protected NamedList<Object> sendRequest(SolrRequest request, List<String> inputCollections)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n\n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        String collection = inputCollections.isEmpty() ? null : inputCollections.get(0); // getting first mimics HttpSolrCall\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) { // TODO fix getParams to never return null!\n      reqParams = new ModifiableSolrParams();\n    }\n\n    final Set<String> liveNodes = stateProvider.getLiveNodes();\n\n    final List<String> theUrlList = new ArrayList<>(); // we populate this as follows...\n\n    if (request instanceof V2Request) {\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNodesList.get(0),\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n\n    } else { // Typical...\n      Set<String> collectionNames = resolveAliases(inputCollections);\n      if (collectionNames.isEmpty()) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"No collection param specified on request and no default collection has been set: \" + inputCollections);\n      }\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      //   at every shard when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection specified, add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      String shardKeys = reqParams.get(ShardParams._ROUTE_);\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n\n      // Gather URLs, grouped by leader or replica\n      // TODO: allow filtering by group, role, etc\n      Set<String> seenNodes = new HashSet<>();\n      List<String> replicas = new ArrayList<>();\n      String joinedInputCollections = StrUtils.join(inputCollections, ',');\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(node) // Must be a live node to continue\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) // Must be an ACTIVE replica to continue\n            continue;\n          if (seenNodes.add(node)) { // if we haven't yet collected a URL to this node...\n            String url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), joinedInputCollections);\n            if (sendToLeaders && coreNodeProps.isLeader()) {\n              theUrlList.add(url); // put leaders here eagerly (if sendToLeader mode)\n            } else {\n              replicas.add(url); // replicas here\n            }\n          }\n        }\n      }\n\n      // Shuffle the leaders, if any    (none if !sendToLeaders)\n      Collections.shuffle(theUrlList, rand);\n\n      // Shuffle the replicas, if any, and append to our list\n      Collections.shuffle(replicas, rand);\n      theUrlList.addAll(replicas);\n\n      if (theUrlList.isEmpty()) {\n        collectionStateCache.keySet().removeAll(collectionNames);\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","sourceOld":"  protected NamedList<Object> sendRequest(SolrRequest request, String collection)\n      throws SolrServerException, IOException {\n    connect();\n\n    boolean sendToLeaders = false;\n    List<String> replicas = null;\n    \n    if (request instanceof IsUpdateRequest) {\n      if (request instanceof UpdateRequest) {\n        NamedList<Object> response = directUpdate((AbstractUpdateRequest) request, collection);\n        if (response != null) {\n          return response;\n        }\n      }\n      sendToLeaders = true;\n      replicas = new ArrayList<>();\n    }\n    \n    SolrParams reqParams = request.getParams();\n    if (reqParams == null) {\n      reqParams = new ModifiableSolrParams();\n    }\n    List<String> theUrlList = new ArrayList<>();\n    if (request instanceof V2Request) {\n      Set<String> liveNodes = stateProvider.getLiveNodes();\n      if (!liveNodes.isEmpty()) {\n        List<String> liveNodesList = new ArrayList<>(liveNodes);\n        Collections.shuffle(liveNodesList, rand);\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNodesList.get(0),\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else if (ADMIN_PATHS.contains(request.getPath())) {\n      Set<String> liveNodes = stateProvider.getLiveNodes();\n      for (String liveNode : liveNodes) {\n        theUrlList.add(ZkStateReader.getBaseUrlForNodeName(liveNode,\n            (String) stateProvider.getClusterProperty(ZkStateReader.URL_SCHEME,\"http\")));\n      }\n    } else {\n      \n      if (collection == null) {\n        throw new SolrServerException(\n            \"No collection param specified on request and no default collection has been set.\");\n      }\n\n      Set<String> collectionNames = getCollectionNames(collection);\n      if (collectionNames.size() == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST,\n            \"Could not find collection: \" + collection);\n      }\n\n      String shardKeys =  reqParams.get(ShardParams._ROUTE_);\n\n      // TODO: not a big deal because of the caching, but we could avoid looking\n      // at every shard\n      // when getting leaders if we tweaked some things\n      \n      // Retrieve slices from the cloud state and, for each collection\n      // specified,\n      // add it to the Map of slices.\n      Map<String,Slice> slices = new HashMap<>();\n      for (String collectionName : collectionNames) {\n        DocCollection col = getDocCollection(collectionName, null);\n        Collection<Slice> routeSlices = col.getRouter().getSearchSlices(shardKeys, reqParams , col);\n        ClientUtils.addSlices(slices, collectionName, routeSlices, true);\n      }\n      Set<String> liveNodes = stateProvider.getLiveNodes();\n\n      List<String> leaderUrlList = null;\n      List<String> urlList = null;\n      List<String> replicasList = null;\n      \n      // build a map of unique nodes\n      // TODO: allow filtering by group, role, etc\n      Map<String,ZkNodeProps> nodes = new HashMap<>();\n      List<String> urlList2 = new ArrayList<>();\n      for (Slice slice : slices.values()) {\n        for (ZkNodeProps nodeProps : slice.getReplicasMap().values()) {\n          ZkCoreNodeProps coreNodeProps = new ZkCoreNodeProps(nodeProps);\n          String node = coreNodeProps.getNodeName();\n          if (!liveNodes.contains(coreNodeProps.getNodeName())\n              || Replica.State.getState(coreNodeProps.getState()) != Replica.State.ACTIVE) continue;\n          if (nodes.put(node, nodeProps) == null) {\n            if (!sendToLeaders || coreNodeProps.isLeader()) {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              urlList2.add(url);\n            } else {\n              String url;\n              if (reqParams.get(UpdateParams.COLLECTION) == null) {\n                url = ZkCoreNodeProps.getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), collection);\n              } else {\n                url = coreNodeProps.getCoreUrl();\n              }\n              replicas.add(url);\n            }\n          }\n        }\n      }\n      \n      if (sendToLeaders) {\n        leaderUrlList = urlList2;\n        replicasList = replicas;\n      } else {\n        urlList = urlList2;\n      }\n      \n      if (sendToLeaders) {\n        theUrlList = new ArrayList<>(leaderUrlList.size());\n        theUrlList.addAll(leaderUrlList);\n      } else {\n        theUrlList = new ArrayList<>(urlList.size());\n        theUrlList.addAll(urlList);\n      }\n\n      Collections.shuffle(theUrlList, rand);\n      if (sendToLeaders) {\n        ArrayList<String> theReplicas = new ArrayList<>(\n            replicasList.size());\n        theReplicas.addAll(replicasList);\n        Collections.shuffle(theReplicas, rand);\n        theUrlList.addAll(theReplicas);\n      }\n      \n      if (theUrlList.isEmpty()) {\n        for (String s : collectionNames) {\n          if (s != null) collectionStateCache.remove(s);\n        }\n        throw new SolrException(SolrException.ErrorCode.INVALID_STATE,\n            \"Could not find a healthy node to handle the request.\");\n      }\n    }\n\n    LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\n    LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n    return rsp.getResponse();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6bdcb86c29922edae9a14852e636303bc52df094":["275019a81d0883a1db4560391b072d1fbe272ec4"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["3eaeb36333664e8cb92108ef03f68a7b90beb759"],"6b824daa61db3f30b91a22213d6c04e1fa2e2b06":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"b31ebc7a867ddea79d438a8fca876a94e644d11a":["a64b273d51a6540272668680ece9f8b686ff0004","67a9fd6a5da455e5d6959c1b0fc6f0dc4b15f9b7"],"a64b273d51a6540272668680ece9f8b686ff0004":["3eaeb36333664e8cb92108ef03f68a7b90beb759"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["67a9fd6a5da455e5d6959c1b0fc6f0dc4b15f9b7"],"3eaeb36333664e8cb92108ef03f68a7b90beb759":["e6c86133b70c1a2f86eca01da72b4357774d2b5c"],"767d389403b701039ee599ec2ac8a838f45d8cb7":["a64b273d51a6540272668680ece9f8b686ff0004"],"7ca08c071cb75a8796c36ae6a1c90d7473c2a6df":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["7ca08c071cb75a8796c36ae6a1c90d7473c2a6df"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","67a9fd6a5da455e5d6959c1b0fc6f0dc4b15f9b7"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7ca08c071cb75a8796c36ae6a1c90d7473c2a6df"],"727bb765ff2542275f6d31f67be18d7104bae148":["e6c86133b70c1a2f86eca01da72b4357774d2b5c","3eaeb36333664e8cb92108ef03f68a7b90beb759"],"e78c35bca3e32dfc7a695136fa2b5de1ae135c22":["6bdcb86c29922edae9a14852e636303bc52df094"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e6c86133b70c1a2f86eca01da72b4357774d2b5c":["e78c35bca3e32dfc7a695136fa2b5de1ae135c22"],"275019a81d0883a1db4560391b072d1fbe272ec4":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"67a9fd6a5da455e5d6959c1b0fc6f0dc4b15f9b7":["767d389403b701039ee599ec2ac8a838f45d8cb7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6b824daa61db3f30b91a22213d6c04e1fa2e2b06"]},"commit2Childs":{"6bdcb86c29922edae9a14852e636303bc52df094":["e78c35bca3e32dfc7a695136fa2b5de1ae135c22"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"6b824daa61db3f30b91a22213d6c04e1fa2e2b06":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b31ebc7a867ddea79d438a8fca876a94e644d11a":[],"a64b273d51a6540272668680ece9f8b686ff0004":["b31ebc7a867ddea79d438a8fca876a94e644d11a","767d389403b701039ee599ec2ac8a838f45d8cb7"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["6b824daa61db3f30b91a22213d6c04e1fa2e2b06"],"3eaeb36333664e8cb92108ef03f68a7b90beb759":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","a64b273d51a6540272668680ece9f8b686ff0004","727bb765ff2542275f6d31f67be18d7104bae148"],"767d389403b701039ee599ec2ac8a838f45d8cb7":["67a9fd6a5da455e5d6959c1b0fc6f0dc4b15f9b7"],"7ca08c071cb75a8796c36ae6a1c90d7473c2a6df":["a219f1dcad1700e84807666bdbd2b573e8de7021","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["275019a81d0883a1db4560391b072d1fbe272ec4"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"727bb765ff2542275f6d31f67be18d7104bae148":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7ca08c071cb75a8796c36ae6a1c90d7473c2a6df","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"e78c35bca3e32dfc7a695136fa2b5de1ae135c22":["e6c86133b70c1a2f86eca01da72b4357774d2b5c"],"e6c86133b70c1a2f86eca01da72b4357774d2b5c":["3eaeb36333664e8cb92108ef03f68a7b90beb759","727bb765ff2542275f6d31f67be18d7104bae148"],"275019a81d0883a1db4560391b072d1fbe272ec4":["6bdcb86c29922edae9a14852e636303bc52df094"],"67a9fd6a5da455e5d6959c1b0fc6f0dc4b15f9b7":["b31ebc7a867ddea79d438a8fca876a94e644d11a","85212dad4ed576c7f7e6c165ee19e597b7b4efc8","e9017cf144952056066919f1ebc7897ff9bd71b1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b31ebc7a867ddea79d438a8fca876a94e644d11a","e9017cf144952056066919f1ebc7897ff9bd71b1","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","727bb765ff2542275f6d31f67be18d7104bae148","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}