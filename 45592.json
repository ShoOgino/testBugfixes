{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isInSet(double,double,double,GeoPoint,boolean,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane).mjava","commits":[{"id":"039615f2ceafe5881c61222281f45a0631b90174","date":1524725949,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isInSet(double,double,double,GeoPoint,boolean,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane).mjava","pathOld":"/dev/null","sourceNew":"  /** Given a test point, whether it is in set, and the associated planes, figure out if another point\n    * is in set or not.\n    */\n  private boolean isInSet(final double x, final double y, final double z,\n    final GeoPoint testPoint,\n    final boolean testPointInSet,\n    final Plane testPointFixedXPlane, final Plane testPointFixedXAbovePlane, final Plane testPointFixedXBelowPlane,\n    final Plane testPointFixedYPlane, final Plane testPointFixedYAbovePlane, final Plane testPointFixedYBelowPlane,\n    final Plane testPointFixedZPlane, final Plane testPointFixedZAbovePlane, final Plane testPointFixedZBelowPlane) {\n\n    //System.out.println(\"\\nIswithin called for [\"+x+\",\"+y+\",\"+z+\"]\");\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedYPlane.evaluateIsZero(x, y, z) || testPointFixedXPlane.evaluateIsZero(x, y, z) || testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      throw new IllegalArgumentException(\"Can't compute isWithin for specified point\");\n    } else {\n\n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);\n      if (fixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYAbovePlane = null;\n      }\n      \n      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);\n      if (fixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYBelowPlane = null;\n      }\n      \n      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);\n      if (fixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXAbovePlane = null;\n      }\n      \n      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\n      if (fixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXBelowPlane = null;\n      }\n      \n      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);\n      if (fixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZAbovePlane = null;\n      }\n      \n      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);\n      if (fixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZBelowPlane = null;\n      }\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Plane secondLegAbovePlane = null;\n      Plane secondLegBelowPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : XIntersectionsY) {\n            // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n            // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.y;\n              secondLegValue = x;\n              firstLegPlane = testPointFixedYPlane;\n              firstLegAbovePlane = testPointFixedYAbovePlane;\n              firstLegBelowPlane = testPointFixedYBelowPlane;\n              secondLegPlane = travelPlaneFixedX;\n              secondLegAbovePlane = fixedXAbovePlane;\n              secondLegBelowPlane = fixedXBelowPlane;\n              firstLegTree = yTree;\n              secondLegTree = xTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : XIntersectionsZ) {\n            // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.z;\n              secondLegValue = x;\n              firstLegPlane = testPointFixedZPlane;\n              firstLegAbovePlane = testPointFixedZAbovePlane;\n              firstLegBelowPlane = testPointFixedZBelowPlane;\n              secondLegPlane = travelPlaneFixedX;\n              secondLegAbovePlane = fixedXAbovePlane;\n              secondLegBelowPlane = fixedXBelowPlane;\n              firstLegTree = zTree;\n              secondLegTree = xTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : YIntersectionsX) {\n            // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.x;\n              secondLegValue = y;\n              firstLegPlane = testPointFixedXPlane;\n              firstLegAbovePlane = testPointFixedXAbovePlane;\n              firstLegBelowPlane = testPointFixedXBelowPlane;\n              secondLegPlane = travelPlaneFixedY;\n              secondLegAbovePlane = fixedYAbovePlane;\n              secondLegBelowPlane = fixedYBelowPlane;\n              firstLegTree = xTree;\n              secondLegTree = yTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : YIntersectionsZ) {\n            // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.z;\n              secondLegValue = y;\n              firstLegPlane = testPointFixedZPlane;\n              firstLegAbovePlane = testPointFixedZAbovePlane;\n              firstLegBelowPlane = testPointFixedZBelowPlane;\n              secondLegPlane = travelPlaneFixedY;\n              secondLegAbovePlane = fixedYAbovePlane;\n              secondLegBelowPlane = fixedYBelowPlane;\n              firstLegTree = zTree;\n              secondLegTree = yTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : ZIntersectionsX) {\n            // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.x;\n              secondLegValue = z;\n              firstLegPlane = testPointFixedXPlane;\n              firstLegAbovePlane = testPointFixedXAbovePlane;\n              firstLegBelowPlane = testPointFixedXBelowPlane;\n              secondLegPlane = travelPlaneFixedZ;\n              secondLegAbovePlane = fixedZAbovePlane;\n              secondLegBelowPlane = fixedZBelowPlane;\n              firstLegTree = xTree;\n              secondLegTree = zTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : ZIntersectionsY) {\n            // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.y;\n              secondLegValue = z;\n              firstLegPlane = testPointFixedYPlane;\n              firstLegAbovePlane = testPointFixedYAbovePlane;\n              firstLegBelowPlane = testPointFixedYBelowPlane;\n              secondLegPlane = travelPlaneFixedZ;\n              secondLegAbovePlane = fixedZAbovePlane;\n              secondLegBelowPlane = fixedZBelowPlane;\n              firstLegTree = yTree;\n              secondLegTree = zTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n\n      // First, we'll determine if the intersection point is in set or not\n      final CountingEdgeIterator testPointEdgeIterator = createLinearCrossingEdgeIterator(testPoint,\n        firstLegPlane, firstLegAbovePlane, firstLegBelowPlane,\n        intersectionPoint.x, intersectionPoint.y, intersectionPoint.z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!firstLegTree.traverse(testPointEdgeIterator, firstLegValue)) {\n        // Endpoint is on edge\n        return true;\n      }\n      final boolean intersectionPointInSet = ((testPointEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n\n      // Now do the final leg\n      final CountingEdgeIterator travelEdgeIterator = createLinearCrossingEdgeIterator(intersectionPoint,\n        secondLegPlane, secondLegAbovePlane, secondLegBelowPlane,\n        x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!secondLegTree.traverse(travelEdgeIterator, secondLegValue)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((travelEdgeIterator.getCrossingCount() & 1) == 0)?intersectionPointInSet:!intersectionPointInSet;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["6b04a6a507e06fd3523a15fac87b8311583936fa","3cd25c083a7199445f2db6f32d322eeac1afc99e","d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040","date":1524832766,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isInSet(double,double,double,GeoPoint,boolean,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isInSet(double,double,double,GeoPoint,boolean,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane).mjava","sourceNew":"  /** Given a test point, whether it is in set, and the associated planes, figure out if another point\n    * is in set or not.\n    */\n  private boolean isInSet(final double x, final double y, final double z,\n    final GeoPoint testPoint,\n    final boolean testPointInSet,\n    final Plane testPointFixedXPlane, final Plane testPointFixedXAbovePlane, final Plane testPointFixedXBelowPlane,\n    final Plane testPointFixedYPlane, final Plane testPointFixedYAbovePlane, final Plane testPointFixedYBelowPlane,\n    final Plane testPointFixedZPlane, final Plane testPointFixedZAbovePlane, final Plane testPointFixedZBelowPlane) {\n\n    //System.out.println(\"\\nIsInSet called for [\"+x+\",\"+y+\",\"+z+\"], testPoint=\"+testPoint+\"; is in set? \"+testPointInSet);\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      //System.out.println(\" Using XZ plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      //System.out.println(\" Using YZ plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      //System.out.println(\" Using XY plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      //System.out.println(\" Using two planes\");\n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);\n      if (fixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYAbovePlane = null;\n      }\n      \n      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);\n      if (fixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYBelowPlane = null;\n      }\n      \n      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);\n      if (fixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXAbovePlane = null;\n      }\n      \n      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\n      if (fixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXBelowPlane = null;\n      }\n      \n      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);\n      if (fixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZAbovePlane = null;\n      }\n      \n      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);\n      if (fixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZBelowPlane = null;\n      }\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Plane secondLegAbovePlane = null;\n      Plane secondLegBelowPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : XIntersectionsY) {\n            // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n            // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking YZ then XZ\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.y;\n              secondLegValue = x;\n              firstLegPlane = testPointFixedYPlane;\n              firstLegAbovePlane = testPointFixedYAbovePlane;\n              firstLegBelowPlane = testPointFixedYBelowPlane;\n              secondLegPlane = travelPlaneFixedX;\n              secondLegAbovePlane = fixedXAbovePlane;\n              secondLegBelowPlane = fixedXBelowPlane;\n              firstLegTree = yTree;\n              secondLegTree = xTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : XIntersectionsZ) {\n            // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking YZ then XY\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.z;\n              secondLegValue = x;\n              firstLegPlane = testPointFixedZPlane;\n              firstLegAbovePlane = testPointFixedZAbovePlane;\n              firstLegBelowPlane = testPointFixedZBelowPlane;\n              secondLegPlane = travelPlaneFixedX;\n              secondLegAbovePlane = fixedXAbovePlane;\n              secondLegBelowPlane = fixedXBelowPlane;\n              firstLegTree = zTree;\n              secondLegTree = xTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : YIntersectionsX) {\n            // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking XZ then YZ\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.x;\n              secondLegValue = y;\n              firstLegPlane = testPointFixedXPlane;\n              firstLegAbovePlane = testPointFixedXAbovePlane;\n              firstLegBelowPlane = testPointFixedXBelowPlane;\n              secondLegPlane = travelPlaneFixedY;\n              secondLegAbovePlane = fixedYAbovePlane;\n              secondLegBelowPlane = fixedYBelowPlane;\n              firstLegTree = xTree;\n              secondLegTree = yTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : YIntersectionsZ) {\n            // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking XZ then XY\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.z;\n              secondLegValue = y;\n              firstLegPlane = testPointFixedZPlane;\n              firstLegAbovePlane = testPointFixedZAbovePlane;\n              firstLegBelowPlane = testPointFixedZBelowPlane;\n              secondLegPlane = travelPlaneFixedY;\n              secondLegAbovePlane = fixedYAbovePlane;\n              secondLegBelowPlane = fixedYBelowPlane;\n              firstLegTree = zTree;\n              secondLegTree = yTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : ZIntersectionsX) {\n            // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking XY then YZ\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.x;\n              secondLegValue = z;\n              firstLegPlane = testPointFixedXPlane;\n              firstLegAbovePlane = testPointFixedXAbovePlane;\n              firstLegBelowPlane = testPointFixedXBelowPlane;\n              secondLegPlane = travelPlaneFixedZ;\n              secondLegAbovePlane = fixedZAbovePlane;\n              secondLegBelowPlane = fixedZBelowPlane;\n              firstLegTree = xTree;\n              secondLegTree = zTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : ZIntersectionsY) {\n            // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking XY then XZ\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.y;\n              secondLegValue = z;\n              firstLegPlane = testPointFixedYPlane;\n              firstLegAbovePlane = testPointFixedYAbovePlane;\n              firstLegBelowPlane = testPointFixedYBelowPlane;\n              secondLegPlane = travelPlaneFixedZ;\n              secondLegAbovePlane = fixedZAbovePlane;\n              secondLegBelowPlane = fixedZBelowPlane;\n              firstLegTree = yTree;\n              secondLegTree = zTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n\n      // First, we'll determine if the intersection point is in set or not\n      //System.out.println(\" Finding whether \"+intersectionPoint+\" is in-set, based on travel from \"+testPoint+\" along \"+firstLegPlane+\" (value=\"+firstLegValue+\")\");\n      final boolean intersectionPointInSet;\n      final CountingEdgeIterator testPointEdgeIterator = createLinearCrossingEdgeIterator(testPoint,\n        firstLegPlane, firstLegAbovePlane, firstLegBelowPlane,\n        intersectionPoint.x, intersectionPoint.y, intersectionPoint.z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!firstLegTree.traverse(testPointEdgeIterator, firstLegValue)) {\n        // Endpoint is on edge\n        //System.out.println(\"  Landed on edge -- in-set\");\n        intersectionPointInSet = true;\n      } else {\n        intersectionPointInSet = ((testPointEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n      }\n      \n      //System.out.println(\"  Intersection point in-set? \"+intersectionPointInSet);\n\n      // Now do the final leg\n      //System.out.println(\" Finding whether [\"+x+\",\"+y+\",\"+z+\"] is in-set, based on travel from \"+intersectionPoint+\" along \"+secondLegPlane+\" (value=\"+secondLegValue+\")\");\n      final boolean rval;\n      final CountingEdgeIterator travelEdgeIterator = createLinearCrossingEdgeIterator(intersectionPoint,\n        secondLegPlane, secondLegAbovePlane, secondLegBelowPlane,\n        x, y, z);\n      // Traverse our way from the test point to the check point.\n      if (!secondLegTree.traverse(travelEdgeIterator, secondLegValue)) {\n        // Endpoint is on edge\n        //System.out.println(\"  Landed on edge -- in-set\");\n        rval = true;\n      } else {\n        rval = ((travelEdgeIterator.getCrossingCount() & 1) == 0)?intersectionPointInSet:!intersectionPointInSet;\n      }\n      \n      //System.out.println(\" Check point in set? \"+rval);\n      return rval;\n    }\n  }\n\n","sourceOld":"  /** Given a test point, whether it is in set, and the associated planes, figure out if another point\n    * is in set or not.\n    */\n  private boolean isInSet(final double x, final double y, final double z,\n    final GeoPoint testPoint,\n    final boolean testPointInSet,\n    final Plane testPointFixedXPlane, final Plane testPointFixedXAbovePlane, final Plane testPointFixedXBelowPlane,\n    final Plane testPointFixedYPlane, final Plane testPointFixedYAbovePlane, final Plane testPointFixedYBelowPlane,\n    final Plane testPointFixedZPlane, final Plane testPointFixedZAbovePlane, final Plane testPointFixedZBelowPlane) {\n\n    //System.out.println(\"\\nIswithin called for [\"+x+\",\"+y+\",\"+z+\"]\");\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedYPlane.evaluateIsZero(x, y, z) || testPointFixedXPlane.evaluateIsZero(x, y, z) || testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      throw new IllegalArgumentException(\"Can't compute isWithin for specified point\");\n    } else {\n\n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);\n      if (fixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYAbovePlane = null;\n      }\n      \n      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);\n      if (fixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYBelowPlane = null;\n      }\n      \n      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);\n      if (fixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXAbovePlane = null;\n      }\n      \n      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\n      if (fixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXBelowPlane = null;\n      }\n      \n      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);\n      if (fixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZAbovePlane = null;\n      }\n      \n      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);\n      if (fixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZBelowPlane = null;\n      }\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Plane secondLegAbovePlane = null;\n      Plane secondLegBelowPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : XIntersectionsY) {\n            // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n            // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.y;\n              secondLegValue = x;\n              firstLegPlane = testPointFixedYPlane;\n              firstLegAbovePlane = testPointFixedYAbovePlane;\n              firstLegBelowPlane = testPointFixedYBelowPlane;\n              secondLegPlane = travelPlaneFixedX;\n              secondLegAbovePlane = fixedXAbovePlane;\n              secondLegBelowPlane = fixedXBelowPlane;\n              firstLegTree = yTree;\n              secondLegTree = xTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : XIntersectionsZ) {\n            // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.z;\n              secondLegValue = x;\n              firstLegPlane = testPointFixedZPlane;\n              firstLegAbovePlane = testPointFixedZAbovePlane;\n              firstLegBelowPlane = testPointFixedZBelowPlane;\n              secondLegPlane = travelPlaneFixedX;\n              secondLegAbovePlane = fixedXAbovePlane;\n              secondLegBelowPlane = fixedXBelowPlane;\n              firstLegTree = zTree;\n              secondLegTree = xTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : YIntersectionsX) {\n            // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.x;\n              secondLegValue = y;\n              firstLegPlane = testPointFixedXPlane;\n              firstLegAbovePlane = testPointFixedXAbovePlane;\n              firstLegBelowPlane = testPointFixedXBelowPlane;\n              secondLegPlane = travelPlaneFixedY;\n              secondLegAbovePlane = fixedYAbovePlane;\n              secondLegBelowPlane = fixedYBelowPlane;\n              firstLegTree = xTree;\n              secondLegTree = yTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : YIntersectionsZ) {\n            // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.z;\n              secondLegValue = y;\n              firstLegPlane = testPointFixedZPlane;\n              firstLegAbovePlane = testPointFixedZAbovePlane;\n              firstLegBelowPlane = testPointFixedZBelowPlane;\n              secondLegPlane = travelPlaneFixedY;\n              secondLegAbovePlane = fixedYAbovePlane;\n              secondLegBelowPlane = fixedYBelowPlane;\n              firstLegTree = zTree;\n              secondLegTree = yTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : ZIntersectionsX) {\n            // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.x;\n              secondLegValue = z;\n              firstLegPlane = testPointFixedXPlane;\n              firstLegAbovePlane = testPointFixedXAbovePlane;\n              firstLegBelowPlane = testPointFixedXBelowPlane;\n              secondLegPlane = travelPlaneFixedZ;\n              secondLegAbovePlane = fixedZAbovePlane;\n              secondLegBelowPlane = fixedZBelowPlane;\n              firstLegTree = xTree;\n              secondLegTree = zTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : ZIntersectionsY) {\n            // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n            if (newDistance < bestDistance) {\n              bestDistance = newDistance;\n              firstLegValue = testPoint.y;\n              secondLegValue = z;\n              firstLegPlane = testPointFixedYPlane;\n              firstLegAbovePlane = testPointFixedYAbovePlane;\n              firstLegBelowPlane = testPointFixedYBelowPlane;\n              secondLegPlane = travelPlaneFixedZ;\n              secondLegAbovePlane = fixedZAbovePlane;\n              secondLegBelowPlane = fixedZBelowPlane;\n              firstLegTree = yTree;\n              secondLegTree = zTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n\n      // First, we'll determine if the intersection point is in set or not\n      final CountingEdgeIterator testPointEdgeIterator = createLinearCrossingEdgeIterator(testPoint,\n        firstLegPlane, firstLegAbovePlane, firstLegBelowPlane,\n        intersectionPoint.x, intersectionPoint.y, intersectionPoint.z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!firstLegTree.traverse(testPointEdgeIterator, firstLegValue)) {\n        // Endpoint is on edge\n        return true;\n      }\n      final boolean intersectionPointInSet = ((testPointEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n\n      // Now do the final leg\n      final CountingEdgeIterator travelEdgeIterator = createLinearCrossingEdgeIterator(intersectionPoint,\n        secondLegPlane, secondLegAbovePlane, secondLegBelowPlane,\n        x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!secondLegTree.traverse(travelEdgeIterator, secondLegValue)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((travelEdgeIterator.getCrossingCount() & 1) == 0)?intersectionPointInSet:!intersectionPointInSet;\n    }\n  }\n\n","bugFix":["039615f2ceafe5881c61222281f45a0631b90174"],"bugIntro":["6b04a6a507e06fd3523a15fac87b8311583936fa"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e456381ade0a256838cbf558702284e345c8d3d6","date":1524920804,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isInSet(double,double,double,GeoPoint,boolean,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isInSet(double,double,double,GeoPoint,boolean,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane).mjava","sourceNew":"  /** Given a test point, whether it is in set, and the associated planes, figure out if another point\n    * is in set or not.\n    */\n  private boolean isInSet(final double x, final double y, final double z,\n    final GeoPoint testPoint,\n    final boolean testPointInSet,\n    final Plane testPointFixedXPlane, final Plane testPointFixedXAbovePlane, final Plane testPointFixedXBelowPlane,\n    final Plane testPointFixedYPlane, final Plane testPointFixedYAbovePlane, final Plane testPointFixedYBelowPlane,\n    final Plane testPointFixedZPlane, final Plane testPointFixedZAbovePlane, final Plane testPointFixedZBelowPlane) {\n\n    //System.out.println(\"\\nIsInSet called for [\"+x+\",\"+y+\",\"+z+\"], testPoint=\"+testPoint+\"; is in set? \"+testPointInSet);\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      //System.out.println(\" Using XZ plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      yTree.traverse(crossingEdgeIterator, testPoint.y);\n      return crossingEdgeIterator.isOnEdge() || (((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n    } else if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      //System.out.println(\" Using YZ plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      xTree.traverse(crossingEdgeIterator, testPoint.x);\n      return crossingEdgeIterator.isOnEdge() || (((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n    } else if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      //System.out.println(\" Using XY plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      zTree.traverse(crossingEdgeIterator, testPoint.z);\n      return crossingEdgeIterator.isOnEdge() || (((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n    } else {\n      //System.out.println(\" Using two planes\");\n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);\n      if (fixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYAbovePlane = null;\n      }\n      \n      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);\n      if (fixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYBelowPlane = null;\n      }\n      \n      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);\n      if (fixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXAbovePlane = null;\n      }\n      \n      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\n      if (fixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXBelowPlane = null;\n      }\n      \n      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);\n      if (fixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZAbovePlane = null;\n      }\n      \n      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);\n      if (fixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZBelowPlane = null;\n      }\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Plane secondLegAbovePlane = null;\n      Plane secondLegBelowPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : XIntersectionsY) {\n            // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n            // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking YZ then XZ\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.y;\n              secondLegValue = x;\n              firstLegPlane = testPointFixedYPlane;\n              firstLegAbovePlane = testPointFixedYAbovePlane;\n              firstLegBelowPlane = testPointFixedYBelowPlane;\n              secondLegPlane = travelPlaneFixedX;\n              secondLegAbovePlane = fixedXAbovePlane;\n              secondLegBelowPlane = fixedXBelowPlane;\n              firstLegTree = yTree;\n              secondLegTree = xTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : XIntersectionsZ) {\n            // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking YZ then XY\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.z;\n              secondLegValue = x;\n              firstLegPlane = testPointFixedZPlane;\n              firstLegAbovePlane = testPointFixedZAbovePlane;\n              firstLegBelowPlane = testPointFixedZBelowPlane;\n              secondLegPlane = travelPlaneFixedX;\n              secondLegAbovePlane = fixedXAbovePlane;\n              secondLegBelowPlane = fixedXBelowPlane;\n              firstLegTree = zTree;\n              secondLegTree = xTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : YIntersectionsX) {\n            // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking XZ then YZ\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.x;\n              secondLegValue = y;\n              firstLegPlane = testPointFixedXPlane;\n              firstLegAbovePlane = testPointFixedXAbovePlane;\n              firstLegBelowPlane = testPointFixedXBelowPlane;\n              secondLegPlane = travelPlaneFixedY;\n              secondLegAbovePlane = fixedYAbovePlane;\n              secondLegBelowPlane = fixedYBelowPlane;\n              firstLegTree = xTree;\n              secondLegTree = yTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : YIntersectionsZ) {\n            // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking XZ then XY\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.z;\n              secondLegValue = y;\n              firstLegPlane = testPointFixedZPlane;\n              firstLegAbovePlane = testPointFixedZAbovePlane;\n              firstLegBelowPlane = testPointFixedZBelowPlane;\n              secondLegPlane = travelPlaneFixedY;\n              secondLegAbovePlane = fixedYAbovePlane;\n              secondLegBelowPlane = fixedYBelowPlane;\n              firstLegTree = zTree;\n              secondLegTree = yTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : ZIntersectionsX) {\n            // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking XY then YZ\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.x;\n              secondLegValue = z;\n              firstLegPlane = testPointFixedXPlane;\n              firstLegAbovePlane = testPointFixedXAbovePlane;\n              firstLegBelowPlane = testPointFixedXBelowPlane;\n              secondLegPlane = travelPlaneFixedZ;\n              secondLegAbovePlane = fixedZAbovePlane;\n              secondLegBelowPlane = fixedZBelowPlane;\n              firstLegTree = xTree;\n              secondLegTree = zTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : ZIntersectionsY) {\n            // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking XY then XZ\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.y;\n              secondLegValue = z;\n              firstLegPlane = testPointFixedYPlane;\n              firstLegAbovePlane = testPointFixedYAbovePlane;\n              firstLegBelowPlane = testPointFixedYBelowPlane;\n              secondLegPlane = travelPlaneFixedZ;\n              secondLegAbovePlane = fixedZAbovePlane;\n              secondLegBelowPlane = fixedZBelowPlane;\n              firstLegTree = yTree;\n              secondLegTree = zTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n\n      // First, try with two individual legs.  If that doesn't work, try the DualCrossingIterator.\n      try {\n        // First, we'll determine if the intersection point is in set or not\n        //System.out.println(\" Finding whether \"+intersectionPoint+\" is in-set, based on travel from \"+testPoint+\" along \"+firstLegPlane+\" (value=\"+firstLegValue+\")\");\n        final CountingEdgeIterator testPointEdgeIterator = createLinearCrossingEdgeIterator(testPoint,\n          firstLegPlane, firstLegAbovePlane, firstLegBelowPlane,\n          intersectionPoint.x, intersectionPoint.y, intersectionPoint.z);\n        // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n        firstLegTree.traverse(testPointEdgeIterator, firstLegValue);\n        final boolean intersectionPointOnEdge = testPointEdgeIterator.isOnEdge();\n        // If the intersection point is on the edge, we cannot use this combination of legs, since it's not logically possible to compute in-set or out-of-set\n        // with such a starting point.\n        if (intersectionPointOnEdge) {\n          throw new IllegalArgumentException(\"Intersection point landed on an edge -- illegal path\");\n        }\n        final boolean intersectionPointInSet = intersectionPointOnEdge || (((testPointEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n        \n        //System.out.println(\"  Intersection point in-set? \"+intersectionPointInSet+\" On edge? \"+intersectionPointOnEdge);\n\n        // Now do the final leg\n        //System.out.println(\" Finding whether [\"+x+\",\"+y+\",\"+z+\"] is in-set, based on travel from \"+intersectionPoint+\" along \"+secondLegPlane+\" (value=\"+secondLegValue+\")\");\n        final CountingEdgeIterator travelEdgeIterator = createLinearCrossingEdgeIterator(intersectionPoint,\n          secondLegPlane, secondLegAbovePlane, secondLegBelowPlane,\n          x, y, z);\n        // Traverse our way from the test point to the check point.\n        secondLegTree.traverse(travelEdgeIterator, secondLegValue);\n        final boolean rval = travelEdgeIterator.isOnEdge() || (((travelEdgeIterator.getCrossingCount() & 1) == 0)?intersectionPointInSet:!intersectionPointInSet);\n        \n        //System.out.println(\" Check point in set? \"+rval);\n        return rval;\n      } catch (IllegalArgumentException e) {\n        // Intersection point apparently was on edge, so try another strategy\n        final CountingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(testPoint,\n          firstLegPlane, firstLegAbovePlane, firstLegBelowPlane,\n          secondLegPlane, secondLegAbovePlane, secondLegBelowPlane,\n          x, y, z, intersectionPoint);\n        firstLegTree.traverse(edgeIterator, firstLegValue);\n        if (edgeIterator.isOnEdge()) {\n          return true;\n        }\n        secondLegTree.traverse(edgeIterator, secondLegValue);\n        return edgeIterator.isOnEdge() || (((edgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n      }\n    }\n  }\n\n","sourceOld":"  /** Given a test point, whether it is in set, and the associated planes, figure out if another point\n    * is in set or not.\n    */\n  private boolean isInSet(final double x, final double y, final double z,\n    final GeoPoint testPoint,\n    final boolean testPointInSet,\n    final Plane testPointFixedXPlane, final Plane testPointFixedXAbovePlane, final Plane testPointFixedXBelowPlane,\n    final Plane testPointFixedYPlane, final Plane testPointFixedYAbovePlane, final Plane testPointFixedYBelowPlane,\n    final Plane testPointFixedZPlane, final Plane testPointFixedZAbovePlane, final Plane testPointFixedZBelowPlane) {\n\n    //System.out.println(\"\\nIsInSet called for [\"+x+\",\"+y+\",\"+z+\"], testPoint=\"+testPoint+\"; is in set? \"+testPointInSet);\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      //System.out.println(\" Using XZ plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      //System.out.println(\" Using YZ plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      //System.out.println(\" Using XY plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {\n        // Endpoint is on edge\n        return true;\n      }\n      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n    } else {\n      //System.out.println(\" Using two planes\");\n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);\n      if (fixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYAbovePlane = null;\n      }\n      \n      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);\n      if (fixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYBelowPlane = null;\n      }\n      \n      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);\n      if (fixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXAbovePlane = null;\n      }\n      \n      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\n      if (fixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXBelowPlane = null;\n      }\n      \n      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);\n      if (fixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZAbovePlane = null;\n      }\n      \n      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);\n      if (fixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZBelowPlane = null;\n      }\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Plane secondLegAbovePlane = null;\n      Plane secondLegBelowPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : XIntersectionsY) {\n            // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n            // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking YZ then XZ\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.y;\n              secondLegValue = x;\n              firstLegPlane = testPointFixedYPlane;\n              firstLegAbovePlane = testPointFixedYAbovePlane;\n              firstLegBelowPlane = testPointFixedYBelowPlane;\n              secondLegPlane = travelPlaneFixedX;\n              secondLegAbovePlane = fixedXAbovePlane;\n              secondLegBelowPlane = fixedXBelowPlane;\n              firstLegTree = yTree;\n              secondLegTree = xTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : XIntersectionsZ) {\n            // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking YZ then XY\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.z;\n              secondLegValue = x;\n              firstLegPlane = testPointFixedZPlane;\n              firstLegAbovePlane = testPointFixedZAbovePlane;\n              firstLegBelowPlane = testPointFixedZBelowPlane;\n              secondLegPlane = travelPlaneFixedX;\n              secondLegAbovePlane = fixedXAbovePlane;\n              secondLegBelowPlane = fixedXBelowPlane;\n              firstLegTree = zTree;\n              secondLegTree = xTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : YIntersectionsX) {\n            // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking XZ then YZ\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.x;\n              secondLegValue = y;\n              firstLegPlane = testPointFixedXPlane;\n              firstLegAbovePlane = testPointFixedXAbovePlane;\n              firstLegBelowPlane = testPointFixedXBelowPlane;\n              secondLegPlane = travelPlaneFixedY;\n              secondLegAbovePlane = fixedYAbovePlane;\n              secondLegBelowPlane = fixedYBelowPlane;\n              firstLegTree = xTree;\n              secondLegTree = yTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : YIntersectionsZ) {\n            // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking XZ then XY\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.z;\n              secondLegValue = y;\n              firstLegPlane = testPointFixedZPlane;\n              firstLegAbovePlane = testPointFixedZAbovePlane;\n              firstLegBelowPlane = testPointFixedZBelowPlane;\n              secondLegPlane = travelPlaneFixedY;\n              secondLegAbovePlane = fixedYAbovePlane;\n              secondLegBelowPlane = fixedYBelowPlane;\n              firstLegTree = zTree;\n              secondLegTree = yTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : ZIntersectionsX) {\n            // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking XY then YZ\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.x;\n              secondLegValue = z;\n              firstLegPlane = testPointFixedXPlane;\n              firstLegAbovePlane = testPointFixedXAbovePlane;\n              firstLegBelowPlane = testPointFixedXBelowPlane;\n              secondLegPlane = travelPlaneFixedZ;\n              secondLegAbovePlane = fixedZAbovePlane;\n              secondLegBelowPlane = fixedZBelowPlane;\n              firstLegTree = xTree;\n              secondLegTree = zTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : ZIntersectionsY) {\n            // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking XY then XZ\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.y;\n              secondLegValue = z;\n              firstLegPlane = testPointFixedYPlane;\n              firstLegAbovePlane = testPointFixedYAbovePlane;\n              firstLegBelowPlane = testPointFixedYBelowPlane;\n              secondLegPlane = travelPlaneFixedZ;\n              secondLegAbovePlane = fixedZAbovePlane;\n              secondLegBelowPlane = fixedZBelowPlane;\n              firstLegTree = yTree;\n              secondLegTree = zTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n\n      // First, we'll determine if the intersection point is in set or not\n      //System.out.println(\" Finding whether \"+intersectionPoint+\" is in-set, based on travel from \"+testPoint+\" along \"+firstLegPlane+\" (value=\"+firstLegValue+\")\");\n      final boolean intersectionPointInSet;\n      final CountingEdgeIterator testPointEdgeIterator = createLinearCrossingEdgeIterator(testPoint,\n        firstLegPlane, firstLegAbovePlane, firstLegBelowPlane,\n        intersectionPoint.x, intersectionPoint.y, intersectionPoint.z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      if (!firstLegTree.traverse(testPointEdgeIterator, firstLegValue)) {\n        // Endpoint is on edge\n        //System.out.println(\"  Landed on edge -- in-set\");\n        intersectionPointInSet = true;\n      } else {\n        intersectionPointInSet = ((testPointEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;\n      }\n      \n      //System.out.println(\"  Intersection point in-set? \"+intersectionPointInSet);\n\n      // Now do the final leg\n      //System.out.println(\" Finding whether [\"+x+\",\"+y+\",\"+z+\"] is in-set, based on travel from \"+intersectionPoint+\" along \"+secondLegPlane+\" (value=\"+secondLegValue+\")\");\n      final boolean rval;\n      final CountingEdgeIterator travelEdgeIterator = createLinearCrossingEdgeIterator(intersectionPoint,\n        secondLegPlane, secondLegAbovePlane, secondLegBelowPlane,\n        x, y, z);\n      // Traverse our way from the test point to the check point.\n      if (!secondLegTree.traverse(travelEdgeIterator, secondLegValue)) {\n        // Endpoint is on edge\n        //System.out.println(\"  Landed on edge -- in-set\");\n        rval = true;\n      } else {\n        rval = ((travelEdgeIterator.getCrossingCount() & 1) == 0)?intersectionPointInSet:!intersectionPointInSet;\n      }\n      \n      //System.out.println(\" Check point in set? \"+rval);\n      return rval;\n    }\n  }\n\n","bugFix":null,"bugIntro":["6b04a6a507e06fd3523a15fac87b8311583936fa"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b04a6a507e06fd3523a15fac87b8311583936fa","date":1525083151,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isInSet(double,double,double,GeoPoint,boolean,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isInSet(double,double,double,GeoPoint,boolean,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane).mjava","sourceNew":"  /** Given a test point, whether it is in set, and the associated planes, figure out if another point\n    * is in set or not.\n    */\n  private boolean isInSet(final double x, final double y, final double z,\n    final GeoPoint testPoint,\n    final boolean testPointInSet,\n    final Plane testPointFixedXPlane, final Plane testPointFixedXAbovePlane, final Plane testPointFixedXBelowPlane,\n    final Plane testPointFixedYPlane, final Plane testPointFixedYAbovePlane, final Plane testPointFixedYBelowPlane,\n    final Plane testPointFixedZPlane, final Plane testPointFixedZAbovePlane, final Plane testPointFixedZBelowPlane) {\n\n    //System.out.println(\"\\nIsInSet called for [\"+x+\",\"+y+\",\"+z+\"], testPoint=\"+testPoint+\"; is in set? \"+testPointInSet);\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      //System.out.println(\" Using XZ plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      yTree.traverse(crossingEdgeIterator, testPoint.y);\n      return crossingEdgeIterator.isOnEdge() || (((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n    } else if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      //System.out.println(\" Using YZ plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      xTree.traverse(crossingEdgeIterator, testPoint.x);\n      return crossingEdgeIterator.isOnEdge() || (((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n    } else if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      //System.out.println(\" Using XY plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      zTree.traverse(crossingEdgeIterator, testPoint.z);\n      return crossingEdgeIterator.isOnEdge() || (((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n    } else {\n      //System.out.println(\" Using two planes\");\n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);\n      if (fixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYAbovePlane = null;\n      }\n      \n      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);\n      if (fixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYBelowPlane = null;\n      }\n      \n      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);\n      if (fixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXAbovePlane = null;\n      }\n      \n      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\n      if (fixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXBelowPlane = null;\n      }\n      \n      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);\n      if (fixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZAbovePlane = null;\n      }\n      \n      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);\n      if (fixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZBelowPlane = null;\n      }\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n\n      final List<TraversalStrategy> traversalStrategies = new ArrayList<>(12);\n      \n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : XIntersectionsY) {\n            // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n            // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.y, x,\n              testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane,\n              travelPlaneFixedX, fixedXAbovePlane, fixedXBelowPlane,\n              yTree, xTree, p));\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : XIntersectionsZ) {\n            // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.z, x,\n              testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane,\n              travelPlaneFixedX, fixedXAbovePlane, fixedXBelowPlane,\n              zTree, xTree, p));\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : YIntersectionsX) {\n            // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.x, y,\n              testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane,\n              travelPlaneFixedY, fixedYAbovePlane, fixedYBelowPlane,\n              xTree, yTree, p));\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : YIntersectionsZ) {\n            // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.z, y,\n              testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane,\n              travelPlaneFixedY, fixedYAbovePlane, fixedYBelowPlane,\n              zTree, yTree, p));\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : ZIntersectionsX) {\n            // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.x, z,\n              testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane,\n              travelPlaneFixedZ, fixedZAbovePlane, fixedZBelowPlane,\n              xTree, zTree, p));\n          }\n        }\n      }\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : ZIntersectionsY) {\n            // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.y, z,\n              testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane,\n              travelPlaneFixedZ, fixedZAbovePlane, fixedZBelowPlane,\n              yTree, zTree, p));\n          }\n        }\n      }\n\n      Collections.sort(traversalStrategies);\n      \n      if (traversalStrategies.size() == 0) {\n        throw new IllegalArgumentException(\"No dual-plane travel strategies were found\");\n      }\n\n      // Loop through travel strategies, in order, until we find one that works.\n      for (final TraversalStrategy ts : traversalStrategies) {\n        try {\n          return ts.apply(testPoint, testPointInSet, x, y, z);\n        } catch (IllegalArgumentException e) {\n          // Continue\n        }\n      }\n      \n      throw new IllegalArgumentException(\"Exhausted all traversal strategies\");\n    }\n  }\n\n","sourceOld":"  /** Given a test point, whether it is in set, and the associated planes, figure out if another point\n    * is in set or not.\n    */\n  private boolean isInSet(final double x, final double y, final double z,\n    final GeoPoint testPoint,\n    final boolean testPointInSet,\n    final Plane testPointFixedXPlane, final Plane testPointFixedXAbovePlane, final Plane testPointFixedXBelowPlane,\n    final Plane testPointFixedYPlane, final Plane testPointFixedYAbovePlane, final Plane testPointFixedYBelowPlane,\n    final Plane testPointFixedZPlane, final Plane testPointFixedZAbovePlane, final Plane testPointFixedZBelowPlane) {\n\n    //System.out.println(\"\\nIsInSet called for [\"+x+\",\"+y+\",\"+z+\"], testPoint=\"+testPoint+\"; is in set? \"+testPointInSet);\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      //System.out.println(\" Using XZ plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      yTree.traverse(crossingEdgeIterator, testPoint.y);\n      return crossingEdgeIterator.isOnEdge() || (((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n    } else if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      //System.out.println(\" Using YZ plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      xTree.traverse(crossingEdgeIterator, testPoint.x);\n      return crossingEdgeIterator.isOnEdge() || (((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n    } else if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      //System.out.println(\" Using XY plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      zTree.traverse(crossingEdgeIterator, testPoint.z);\n      return crossingEdgeIterator.isOnEdge() || (((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n    } else {\n      //System.out.println(\" Using two planes\");\n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);\n      if (fixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYAbovePlane = null;\n      }\n      \n      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);\n      if (fixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYBelowPlane = null;\n      }\n      \n      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);\n      if (fixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXAbovePlane = null;\n      }\n      \n      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\n      if (fixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXBelowPlane = null;\n      }\n      \n      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);\n      if (fixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZAbovePlane = null;\n      }\n      \n      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);\n      if (fixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZBelowPlane = null;\n      }\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n\n      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.\n      double bestDistance = Double.POSITIVE_INFINITY;\n      double firstLegValue = 0.0;\n      double secondLegValue = 0.0;\n      Plane firstLegPlane = null;\n      Plane firstLegAbovePlane = null;\n      Plane firstLegBelowPlane = null;\n      Plane secondLegPlane = null;\n      Plane secondLegAbovePlane = null;\n      Plane secondLegBelowPlane = null;\n      Tree firstLegTree = null;\n      Tree secondLegTree = null;\n      GeoPoint intersectionPoint = null;\n\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : XIntersectionsY) {\n            // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n            // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking YZ then XZ\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.y;\n              secondLegValue = x;\n              firstLegPlane = testPointFixedYPlane;\n              firstLegAbovePlane = testPointFixedYAbovePlane;\n              firstLegBelowPlane = testPointFixedYBelowPlane;\n              secondLegPlane = travelPlaneFixedX;\n              secondLegAbovePlane = fixedXAbovePlane;\n              secondLegBelowPlane = fixedXBelowPlane;\n              firstLegTree = yTree;\n              secondLegTree = xTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : XIntersectionsZ) {\n            // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking YZ then XY\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.z;\n              secondLegValue = x;\n              firstLegPlane = testPointFixedZPlane;\n              firstLegAbovePlane = testPointFixedZAbovePlane;\n              firstLegBelowPlane = testPointFixedZBelowPlane;\n              secondLegPlane = travelPlaneFixedX;\n              secondLegAbovePlane = fixedXAbovePlane;\n              secondLegBelowPlane = fixedXBelowPlane;\n              firstLegTree = zTree;\n              secondLegTree = xTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : YIntersectionsX) {\n            // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking XZ then YZ\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.x;\n              secondLegValue = y;\n              firstLegPlane = testPointFixedXPlane;\n              firstLegAbovePlane = testPointFixedXAbovePlane;\n              firstLegBelowPlane = testPointFixedXBelowPlane;\n              secondLegPlane = travelPlaneFixedY;\n              secondLegAbovePlane = fixedYAbovePlane;\n              secondLegBelowPlane = fixedYBelowPlane;\n              firstLegTree = xTree;\n              secondLegTree = yTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : YIntersectionsZ) {\n            // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking XZ then XY\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.z;\n              secondLegValue = y;\n              firstLegPlane = testPointFixedZPlane;\n              firstLegAbovePlane = testPointFixedZAbovePlane;\n              firstLegBelowPlane = testPointFixedZBelowPlane;\n              secondLegPlane = travelPlaneFixedY;\n              secondLegAbovePlane = fixedYAbovePlane;\n              secondLegBelowPlane = fixedYBelowPlane;\n              firstLegTree = zTree;\n              secondLegTree = yTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : ZIntersectionsX) {\n            // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking XY then YZ\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.x;\n              secondLegValue = z;\n              firstLegPlane = testPointFixedXPlane;\n              firstLegAbovePlane = testPointFixedXAbovePlane;\n              firstLegBelowPlane = testPointFixedXBelowPlane;\n              secondLegPlane = travelPlaneFixedZ;\n              secondLegAbovePlane = fixedZAbovePlane;\n              secondLegBelowPlane = fixedZBelowPlane;\n              firstLegTree = xTree;\n              secondLegTree = zTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : ZIntersectionsY) {\n            // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n            if (newDistance < bestDistance) {\n              //System.out.println(\" Picking XY then XZ\");\n              bestDistance = newDistance;\n              firstLegValue = testPoint.y;\n              secondLegValue = z;\n              firstLegPlane = testPointFixedYPlane;\n              firstLegAbovePlane = testPointFixedYAbovePlane;\n              firstLegBelowPlane = testPointFixedYBelowPlane;\n              secondLegPlane = travelPlaneFixedZ;\n              secondLegAbovePlane = fixedZAbovePlane;\n              secondLegBelowPlane = fixedZBelowPlane;\n              firstLegTree = yTree;\n              secondLegTree = zTree;\n              intersectionPoint = p;\n            }\n          }\n        }\n      }\n\n      assert bestDistance > 0.0 : \"Best distance should not be zero unless on single plane\";\n      assert bestDistance < Double.POSITIVE_INFINITY : \"Couldn't find an intersection point of any kind\";\n\n      // First, try with two individual legs.  If that doesn't work, try the DualCrossingIterator.\n      try {\n        // First, we'll determine if the intersection point is in set or not\n        //System.out.println(\" Finding whether \"+intersectionPoint+\" is in-set, based on travel from \"+testPoint+\" along \"+firstLegPlane+\" (value=\"+firstLegValue+\")\");\n        final CountingEdgeIterator testPointEdgeIterator = createLinearCrossingEdgeIterator(testPoint,\n          firstLegPlane, firstLegAbovePlane, firstLegBelowPlane,\n          intersectionPoint.x, intersectionPoint.y, intersectionPoint.z);\n        // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n        firstLegTree.traverse(testPointEdgeIterator, firstLegValue);\n        final boolean intersectionPointOnEdge = testPointEdgeIterator.isOnEdge();\n        // If the intersection point is on the edge, we cannot use this combination of legs, since it's not logically possible to compute in-set or out-of-set\n        // with such a starting point.\n        if (intersectionPointOnEdge) {\n          throw new IllegalArgumentException(\"Intersection point landed on an edge -- illegal path\");\n        }\n        final boolean intersectionPointInSet = intersectionPointOnEdge || (((testPointEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n        \n        //System.out.println(\"  Intersection point in-set? \"+intersectionPointInSet+\" On edge? \"+intersectionPointOnEdge);\n\n        // Now do the final leg\n        //System.out.println(\" Finding whether [\"+x+\",\"+y+\",\"+z+\"] is in-set, based on travel from \"+intersectionPoint+\" along \"+secondLegPlane+\" (value=\"+secondLegValue+\")\");\n        final CountingEdgeIterator travelEdgeIterator = createLinearCrossingEdgeIterator(intersectionPoint,\n          secondLegPlane, secondLegAbovePlane, secondLegBelowPlane,\n          x, y, z);\n        // Traverse our way from the test point to the check point.\n        secondLegTree.traverse(travelEdgeIterator, secondLegValue);\n        final boolean rval = travelEdgeIterator.isOnEdge() || (((travelEdgeIterator.getCrossingCount() & 1) == 0)?intersectionPointInSet:!intersectionPointInSet);\n        \n        //System.out.println(\" Check point in set? \"+rval);\n        return rval;\n      } catch (IllegalArgumentException e) {\n        // Intersection point apparently was on edge, so try another strategy\n        final CountingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(testPoint,\n          firstLegPlane, firstLegAbovePlane, firstLegBelowPlane,\n          secondLegPlane, secondLegAbovePlane, secondLegBelowPlane,\n          x, y, z, intersectionPoint);\n        firstLegTree.traverse(edgeIterator, firstLegValue);\n        if (edgeIterator.isOnEdge()) {\n          return true;\n        }\n        secondLegTree.traverse(edgeIterator, secondLegValue);\n        return edgeIterator.isOnEdge() || (((edgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n      }\n    }\n  }\n\n","bugFix":["d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040","e456381ade0a256838cbf558702284e345c8d3d6","039615f2ceafe5881c61222281f45a0631b90174"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3cd25c083a7199445f2db6f32d322eeac1afc99e","date":1527642183,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isInSet(double,double,double,GeoPoint,boolean,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isInSet(double,double,double,GeoPoint,boolean,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane).mjava","sourceNew":"  /** Given a test point, whether it is in set, and the associated planes, figure out if another point\n    * is in set or not.\n    */\n  private boolean isInSet(final double x, final double y, final double z,\n    final GeoPoint testPoint,\n    final boolean testPointInSet,\n    final Plane testPointFixedXPlane, final Plane testPointFixedXAbovePlane, final Plane testPointFixedXBelowPlane,\n    final Plane testPointFixedYPlane, final Plane testPointFixedYAbovePlane, final Plane testPointFixedYBelowPlane,\n    final Plane testPointFixedZPlane, final Plane testPointFixedZAbovePlane, final Plane testPointFixedZBelowPlane) {\n\n    //System.out.println(\"\\nIsInSet called for [\"+x+\",\"+y+\",\"+z+\"], testPoint=\"+testPoint+\"; is in set? \"+testPointInSet);\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      //System.out.println(\" Using XZ plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      yTree.traverse(crossingEdgeIterator, testPoint.y);\n      return crossingEdgeIterator.isOnEdge() || (((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n    } else if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      //System.out.println(\" Using YZ plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      xTree.traverse(crossingEdgeIterator, testPoint.x);\n      return crossingEdgeIterator.isOnEdge() || (((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n    } else if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      //System.out.println(\" Using XY plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      zTree.traverse(crossingEdgeIterator, testPoint.z);\n      return crossingEdgeIterator.isOnEdge() || (((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n    } else {\n      //System.out.println(\" Using two planes\");\n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);\n      if (-fixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() + fixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYAbovePlane = null;\n      }\n      \n      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);\n      if (-fixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() + fixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYBelowPlane = null;\n      }\n      \n      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);\n      if (-fixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() + fixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXAbovePlane = null;\n      }\n      \n      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\n      if (-fixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() + fixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXBelowPlane = null;\n      }\n      \n      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);\n      if (-fixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() + fixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZAbovePlane = null;\n      }\n      \n      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);\n      if (-fixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() + fixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZBelowPlane = null;\n      }\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n\n      final List<TraversalStrategy> traversalStrategies = new ArrayList<>(12);\n      \n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : XIntersectionsY) {\n            // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n            // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.y, x,\n              testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane,\n              travelPlaneFixedX, fixedXAbovePlane, fixedXBelowPlane,\n              yTree, xTree, p));\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : XIntersectionsZ) {\n            // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.z, x,\n              testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane,\n              travelPlaneFixedX, fixedXAbovePlane, fixedXBelowPlane,\n              zTree, xTree, p));\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : YIntersectionsX) {\n            // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.x, y,\n              testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane,\n              travelPlaneFixedY, fixedYAbovePlane, fixedYBelowPlane,\n              xTree, yTree, p));\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : YIntersectionsZ) {\n            // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.z, y,\n              testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane,\n              travelPlaneFixedY, fixedYAbovePlane, fixedYBelowPlane,\n              zTree, yTree, p));\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : ZIntersectionsX) {\n            // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.x, z,\n              testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane,\n              travelPlaneFixedZ, fixedZAbovePlane, fixedZBelowPlane,\n              xTree, zTree, p));\n          }\n        }\n      }\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : ZIntersectionsY) {\n            // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.y, z,\n              testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane,\n              travelPlaneFixedZ, fixedZAbovePlane, fixedZBelowPlane,\n              yTree, zTree, p));\n          }\n        }\n      }\n\n      Collections.sort(traversalStrategies);\n      \n      if (traversalStrategies.size() == 0) {\n        throw new IllegalArgumentException(\"No dual-plane travel strategies were found\");\n      }\n\n      // Loop through travel strategies, in order, until we find one that works.\n      for (final TraversalStrategy ts : traversalStrategies) {\n        try {\n          return ts.apply(testPoint, testPointInSet, x, y, z);\n        } catch (IllegalArgumentException e) {\n          // Continue\n        }\n      }\n      \n      throw new IllegalArgumentException(\"Exhausted all traversal strategies\");\n    }\n  }\n\n","sourceOld":"  /** Given a test point, whether it is in set, and the associated planes, figure out if another point\n    * is in set or not.\n    */\n  private boolean isInSet(final double x, final double y, final double z,\n    final GeoPoint testPoint,\n    final boolean testPointInSet,\n    final Plane testPointFixedXPlane, final Plane testPointFixedXAbovePlane, final Plane testPointFixedXBelowPlane,\n    final Plane testPointFixedYPlane, final Plane testPointFixedYAbovePlane, final Plane testPointFixedYBelowPlane,\n    final Plane testPointFixedZPlane, final Plane testPointFixedZAbovePlane, final Plane testPointFixedZBelowPlane) {\n\n    //System.out.println(\"\\nIsInSet called for [\"+x+\",\"+y+\",\"+z+\"], testPoint=\"+testPoint+\"; is in set? \"+testPointInSet);\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      //System.out.println(\" Using XZ plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      yTree.traverse(crossingEdgeIterator, testPoint.y);\n      return crossingEdgeIterator.isOnEdge() || (((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n    } else if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      //System.out.println(\" Using YZ plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      xTree.traverse(crossingEdgeIterator, testPoint.x);\n      return crossingEdgeIterator.isOnEdge() || (((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n    } else if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      //System.out.println(\" Using XY plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      zTree.traverse(crossingEdgeIterator, testPoint.z);\n      return crossingEdgeIterator.isOnEdge() || (((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n    } else {\n      //System.out.println(\" Using two planes\");\n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);\n      if (fixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYAbovePlane = null;\n      }\n      \n      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);\n      if (fixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYBelowPlane = null;\n      }\n      \n      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);\n      if (fixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXAbovePlane = null;\n      }\n      \n      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\n      if (fixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXBelowPlane = null;\n      }\n      \n      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);\n      if (fixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZAbovePlane = null;\n      }\n      \n      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);\n      if (fixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZBelowPlane = null;\n      }\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n\n      final List<TraversalStrategy> traversalStrategies = new ArrayList<>(12);\n      \n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : XIntersectionsY) {\n            // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n            // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.y, x,\n              testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane,\n              travelPlaneFixedX, fixedXAbovePlane, fixedXBelowPlane,\n              yTree, xTree, p));\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : XIntersectionsZ) {\n            // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.z, x,\n              testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane,\n              travelPlaneFixedX, fixedXAbovePlane, fixedXBelowPlane,\n              zTree, xTree, p));\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : YIntersectionsX) {\n            // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.x, y,\n              testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane,\n              travelPlaneFixedY, fixedYAbovePlane, fixedYBelowPlane,\n              xTree, yTree, p));\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : YIntersectionsZ) {\n            // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.z, y,\n              testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane,\n              travelPlaneFixedY, fixedYAbovePlane, fixedYBelowPlane,\n              zTree, yTree, p));\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : ZIntersectionsX) {\n            // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.x, z,\n              testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane,\n              travelPlaneFixedZ, fixedZAbovePlane, fixedZBelowPlane,\n              xTree, zTree, p));\n          }\n        }\n      }\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : ZIntersectionsY) {\n            // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.y, z,\n              testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane,\n              travelPlaneFixedZ, fixedZAbovePlane, fixedZBelowPlane,\n              yTree, zTree, p));\n          }\n        }\n      }\n\n      Collections.sort(traversalStrategies);\n      \n      if (traversalStrategies.size() == 0) {\n        throw new IllegalArgumentException(\"No dual-plane travel strategies were found\");\n      }\n\n      // Loop through travel strategies, in order, until we find one that works.\n      for (final TraversalStrategy ts : traversalStrategies) {\n        try {\n          return ts.apply(testPoint, testPointInSet, x, y, z);\n        } catch (IllegalArgumentException e) {\n          // Continue\n        }\n      }\n      \n      throw new IllegalArgumentException(\"Exhausted all traversal strategies\");\n    }\n  }\n\n","bugFix":["039615f2ceafe5881c61222281f45a0631b90174"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a","date":1583186777,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isInSet(double,double,double,GeoPoint,boolean,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon#isInSet(double,double,double,GeoPoint,boolean,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane,Plane).mjava","sourceNew":"  /** Given a test point, whether it is in set, and the associated planes, figure out if another point\n    * is in set or not.\n    */\n  private boolean isInSet(final double x, final double y, final double z,\n    final GeoPoint testPoint,\n    final boolean testPointInSet,\n    final Plane testPointFixedXPlane, final Plane testPointFixedXAbovePlane, final Plane testPointFixedXBelowPlane,\n    final Plane testPointFixedYPlane, final Plane testPointFixedYAbovePlane, final Plane testPointFixedYBelowPlane,\n    final Plane testPointFixedZPlane, final Plane testPointFixedZAbovePlane, final Plane testPointFixedZBelowPlane) {\n\n    //System.out.println(\"\\nIsInSet called for [\"+x+\",\"+y+\",\"+z+\"], testPoint=\"+testPoint+\"; is in set? \"+testPointInSet);\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      //System.out.println(\" Using XZ plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      yTree.traverse(crossingEdgeIterator, testPoint.y);\n      return crossingEdgeIterator.isOnEdge() || (((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n    } else if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      //System.out.println(\" Using YZ plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      xTree.traverse(crossingEdgeIterator, testPoint.x);\n      return crossingEdgeIterator.isOnEdge() || (((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n    } else if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      //System.out.println(\" Using XY plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      zTree.traverse(crossingEdgeIterator, testPoint.z);\n      return crossingEdgeIterator.isOnEdge() || (((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n    } else {\n      //System.out.println(\" Using two planes\");\n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);\n      if (-fixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() + fixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYAbovePlane = null;\n      }\n      \n      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);\n      if (-fixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() + fixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYBelowPlane = null;\n      }\n      \n      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);\n      if (-fixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() + fixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXAbovePlane = null;\n      }\n      \n      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\n      if (-fixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() + fixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXBelowPlane = null;\n      }\n      \n      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);\n      if (-fixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() + fixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZAbovePlane = null;\n      }\n      \n      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);\n      if (-fixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() + fixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZBelowPlane = null;\n      }\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n\n      final List<TraversalStrategy> traversalStrategies = new ArrayList<>(12);\n      \n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseXYScalingSquared + testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseXYScalingSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseXYScalingSquared + testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseXYScalingSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : XIntersectionsY) {\n            // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n            // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.y, x,\n              testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane,\n              travelPlaneFixedX, fixedXAbovePlane, fixedXBelowPlane,\n              yTree, xTree, p));\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseXYScalingSquared + testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseZScalingSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseXYScalingSquared + testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseZScalingSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : XIntersectionsZ) {\n            // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.z, x,\n              testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane,\n              travelPlaneFixedX, fixedXAbovePlane, fixedXBelowPlane,\n              zTree, xTree, p));\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseXYScalingSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseXYScalingSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseXYScalingSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseXYScalingSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : YIntersectionsX) {\n            // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.x, y,\n              testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane,\n              travelPlaneFixedY, fixedYAbovePlane, fixedYBelowPlane,\n              xTree, yTree, p));\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseZScalingSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseXYScalingSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseZScalingSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseXYScalingSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : YIntersectionsZ) {\n            // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.z, y,\n              testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane,\n              travelPlaneFixedY, fixedYAbovePlane, fixedYBelowPlane,\n              zTree, yTree, p));\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseXYScalingSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseZScalingSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseXYScalingSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseZScalingSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : ZIntersectionsX) {\n            // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.x, z,\n              testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane,\n              travelPlaneFixedZ, fixedZAbovePlane, fixedZBelowPlane,\n              xTree, zTree, p));\n          }\n        }\n      }\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseXYScalingSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseZScalingSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseXYScalingSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseZScalingSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : ZIntersectionsY) {\n            // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.y, z,\n              testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane,\n              travelPlaneFixedZ, fixedZAbovePlane, fixedZBelowPlane,\n              yTree, zTree, p));\n          }\n        }\n      }\n\n      Collections.sort(traversalStrategies);\n      \n      if (traversalStrategies.size() == 0) {\n        throw new IllegalArgumentException(\"No dual-plane travel strategies were found\");\n      }\n\n      // Loop through travel strategies, in order, until we find one that works.\n      for (final TraversalStrategy ts : traversalStrategies) {\n        try {\n          return ts.apply(testPoint, testPointInSet, x, y, z);\n        } catch (IllegalArgumentException e) {\n          // Continue\n        }\n      }\n      \n      throw new IllegalArgumentException(\"Exhausted all traversal strategies\");\n    }\n  }\n\n","sourceOld":"  /** Given a test point, whether it is in set, and the associated planes, figure out if another point\n    * is in set or not.\n    */\n  private boolean isInSet(final double x, final double y, final double z,\n    final GeoPoint testPoint,\n    final boolean testPointInSet,\n    final Plane testPointFixedXPlane, final Plane testPointFixedXAbovePlane, final Plane testPointFixedXBelowPlane,\n    final Plane testPointFixedYPlane, final Plane testPointFixedYAbovePlane, final Plane testPointFixedYBelowPlane,\n    final Plane testPointFixedZPlane, final Plane testPointFixedZAbovePlane, final Plane testPointFixedZBelowPlane) {\n\n    //System.out.println(\"\\nIsInSet called for [\"+x+\",\"+y+\",\"+z+\"], testPoint=\"+testPoint+\"; is in set? \"+testPointInSet);\n    // If we're right on top of the point, we know the answer.\n    if (testPoint.isNumericallyIdentical(x, y, z)) {\n      return testPointInSet;\n    }\n    \n    // If we're right on top of any of the test planes, we navigate solely on that plane.\n    if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {\n      // Use the XZ plane exclusively.\n      //System.out.println(\" Using XZ plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.\n      yTree.traverse(crossingEdgeIterator, testPoint.y);\n      return crossingEdgeIterator.isOnEdge() || (((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n    } else if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {\n      // Use the YZ plane exclusively.\n      //System.out.println(\" Using YZ plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.\n      xTree.traverse(crossingEdgeIterator, testPoint.x);\n      return crossingEdgeIterator.isOnEdge() || (((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n    } else if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {\n      //System.out.println(\" Using XY plane alone\");\n      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);\n      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.\n      zTree.traverse(crossingEdgeIterator, testPoint.z);\n      return crossingEdgeIterator.isOnEdge() || (((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);\n    } else {\n      //System.out.println(\" Using two planes\");\n      // This is the expensive part!!\n      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.\n      \n      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.\n      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);\n      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);\n      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);\n\n      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);\n      if (-fixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() + fixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYAbovePlane = null;\n      }\n      \n      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);\n      if (-fixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() + fixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedYBelowPlane = null;\n      }\n      \n      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);\n      if (-fixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() + fixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXAbovePlane = null;\n      }\n      \n      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\n      if (-fixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() + fixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedXBelowPlane = null;\n      }\n      \n      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);\n      if (-fixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() + fixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZAbovePlane = null;\n      }\n      \n      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);\n      if (-fixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() + fixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {\n          fixedZBelowPlane = null;\n      }\n\n      // Find the intersection points for each one of these and the complementary test point planes.\n\n      final List<TraversalStrategy> traversalStrategies = new ArrayList<>(12);\n      \n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : XIntersectionsY) {\n            // Travel would be in YZ plane (fixed x) then in XZ (fixed y)\n            // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.y, x,\n              testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane,\n              travelPlaneFixedX, fixedXAbovePlane, fixedXBelowPlane,\n              yTree, xTree, p));\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {\n        //check if planes intersects  inside world\n        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : XIntersectionsZ) {\n            // Travel would be in YZ plane (fixed x) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.z, x,\n              testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane,\n              travelPlaneFixedX, fixedXAbovePlane, fixedXBelowPlane,\n              zTree, xTree, p));\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : YIntersectionsX) {\n            // Travel would be in XZ plane (fixed y) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.x, y,\n              testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane,\n              travelPlaneFixedY, fixedYAbovePlane, fixedYBelowPlane,\n              xTree, yTree, p));\n          }\n        }\n      }\n      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);\n          for (final GeoPoint p : YIntersectionsZ) {\n            // Travel would be in XZ plane (fixed y) then in XY (fixed z)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.y - p.y;\n            final double cpDelta1 = x - p.x;\n            final double cpDelta2 = z - p.z;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);\n            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.z, y,\n              testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane,\n              travelPlaneFixedY, fixedYAbovePlane, fixedYBelowPlane,\n              zTree, yTree, p));\n          }\n        }\n      }\n      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);\n          for (final GeoPoint p : ZIntersectionsX) {\n            // Travel would be in XY plane (fixed z) then in YZ (fixed x)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.y - p.y;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.x, z,\n              testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane,\n              travelPlaneFixedZ, fixedZAbovePlane, fixedZBelowPlane,\n              xTree, zTree, p));\n          }\n        }\n      }\n      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {\n        //check if planes intersects inside world\n        final double checkAbove = 4.0 * (testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);\n        final double checkBelow = 4.0 * (testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);\n        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {\n          //System.out.println(\"  Looking for intersections between travel and test point planes...\");\n          final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);\n          for (final GeoPoint p : ZIntersectionsY) {\n            // Travel would be in XY plane (fixed z) then in XZ (fixed y)\n            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);\n            final double tpDelta1 = testPoint.x - p.x;\n            final double tpDelta2 = testPoint.z - p.z;\n            final double cpDelta1 = y - p.y;\n            final double cpDelta2 = x - p.x;\n            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;\n            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);\n            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);\n            traversalStrategies.add(new TraversalStrategy(newDistance, testPoint.y, z,\n              testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane,\n              travelPlaneFixedZ, fixedZAbovePlane, fixedZBelowPlane,\n              yTree, zTree, p));\n          }\n        }\n      }\n\n      Collections.sort(traversalStrategies);\n      \n      if (traversalStrategies.size() == 0) {\n        throw new IllegalArgumentException(\"No dual-plane travel strategies were found\");\n      }\n\n      // Loop through travel strategies, in order, until we find one that works.\n      for (final TraversalStrategy ts : traversalStrategies) {\n        try {\n          return ts.apply(testPoint, testPointInSet, x, y, z);\n        } catch (IllegalArgumentException e) {\n          // Continue\n        }\n      }\n      \n      throw new IllegalArgumentException(\"Exhausted all traversal strategies\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6b04a6a507e06fd3523a15fac87b8311583936fa":["e456381ade0a256838cbf558702284e345c8d3d6"],"3cd25c083a7199445f2db6f32d322eeac1afc99e":["6b04a6a507e06fd3523a15fac87b8311583936fa"],"e456381ade0a256838cbf558702284e345c8d3d6":["d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040":["039615f2ceafe5881c61222281f45a0631b90174"],"039615f2ceafe5881c61222281f45a0631b90174":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["3cd25c083a7199445f2db6f32d322eeac1afc99e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c33ed6824db1d3c54aaf0208e68c3df3fd43d93a"]},"commit2Childs":{"6b04a6a507e06fd3523a15fac87b8311583936fa":["3cd25c083a7199445f2db6f32d322eeac1afc99e"],"3cd25c083a7199445f2db6f32d322eeac1afc99e":["c33ed6824db1d3c54aaf0208e68c3df3fd43d93a"],"e456381ade0a256838cbf558702284e345c8d3d6":["6b04a6a507e06fd3523a15fac87b8311583936fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["039615f2ceafe5881c61222281f45a0631b90174"],"d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040":["e456381ade0a256838cbf558702284e345c8d3d6"],"039615f2ceafe5881c61222281f45a0631b90174":["d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040"],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}