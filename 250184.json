{"path":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","commits":[{"id":"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200","date":1358521790,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiSimpleDocValues#simpleBinaryValues(IndexReader,String).mjava","sourceNew":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    boolean anyReal = false;\n\n    for(AtomicReaderContext ctx : leaves) {\n      BinaryDocValues values = ctx.reader().getBinaryDocValues(field);\n\n      if (values != null) {\n        anyReal = true;\n      }\n    }\n\n    if (!anyReal) {\n      return null;\n    } else {\n\n      return new BinaryDocValues() {\n        @Override\n        public void get(int docID, BytesRef result) {\n          int subIndex = ReaderUtil.subIndex(docID, leaves);\n          BinaryDocValues values;\n          try {\n            values = leaves.get(subIndex).reader().getBinaryDocValues(field);\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n          if (values != null) {\n            values.get(docID - leaves.get(subIndex).docBase, result);\n          } else {\n            result.length = 0;\n            result.bytes = BinaryDocValues.MISSING;\n          }\n        }\n      };\n    }\n  }\n\n","sourceOld":"  public static BinaryDocValues simpleBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    boolean anyReal = false;\n\n    for(AtomicReaderContext ctx : leaves) {\n      BinaryDocValues values = ctx.reader().getBinaryDocValues(field);\n\n      if (values != null) {\n        anyReal = true;\n      }\n    }\n\n    if (!anyReal) {\n      return null;\n    } else {\n\n      return new BinaryDocValues() {\n        @Override\n        public void get(int docID, BytesRef result) {\n          int subIndex = ReaderUtil.subIndex(docID, leaves);\n          BinaryDocValues values;\n          try {\n            values = leaves.get(subIndex).reader().getBinaryDocValues(field);\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n          if (values != null) {\n            values.get(docID - leaves.get(subIndex).docBase, result);\n          } else {\n            result.length = 0;\n            result.bytes = BinaryDocValues.MISSING;\n          }\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd5cc84228660a66f2acf468586412e75cde579a","date":1359061988,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","sourceNew":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    boolean anyReal = false;\n\n    for(AtomicReaderContext ctx : leaves) {\n      BinaryDocValues values = ctx.reader().getBinaryDocValues(field);\n\n      if (values != null) {\n        anyReal = true;\n      }\n    }\n\n    if (!anyReal) {\n      return null;\n    } else {\n\n      return new BinaryDocValues() {\n        @Override\n        public void get(int docID, BytesRef result) {\n          int subIndex = ReaderUtil.subIndex(docID, leaves);\n          BinaryDocValues values;\n          try {\n            values = leaves.get(subIndex).reader().getBinaryDocValues(field);\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n          if (values != null) {\n            values.get(docID - leaves.get(subIndex).docBase, result);\n          } else {\n            result.length = 0;\n            result.offset = 0;\n            result.bytes = BinaryDocValues.MISSING;\n          }\n        }\n      };\n    }\n  }\n\n","sourceOld":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    boolean anyReal = false;\n\n    for(AtomicReaderContext ctx : leaves) {\n      BinaryDocValues values = ctx.reader().getBinaryDocValues(field);\n\n      if (values != null) {\n        anyReal = true;\n      }\n    }\n\n    if (!anyReal) {\n      return null;\n    } else {\n\n      return new BinaryDocValues() {\n        @Override\n        public void get(int docID, BytesRef result) {\n          int subIndex = ReaderUtil.subIndex(docID, leaves);\n          BinaryDocValues values;\n          try {\n            values = leaves.get(subIndex).reader().getBinaryDocValues(field);\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n          if (values != null) {\n            values.get(docID - leaves.get(subIndex).docBase, result);\n          } else {\n            result.length = 0;\n            result.bytes = BinaryDocValues.MISSING;\n          }\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4772ea9604873dc0b22ea724398008998afc8e41","date":1359133954,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","sourceNew":"  /** returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly) */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    boolean anyReal = false;\n\n    for(AtomicReaderContext ctx : leaves) {\n      BinaryDocValues values = ctx.reader().getBinaryDocValues(field);\n\n      if (values != null) {\n        anyReal = true;\n      }\n    }\n\n    if (!anyReal) {\n      return null;\n    } else {\n\n      return new BinaryDocValues() {\n        @Override\n        public void get(int docID, BytesRef result) {\n          int subIndex = ReaderUtil.subIndex(docID, leaves);\n          BinaryDocValues values;\n          try {\n            values = leaves.get(subIndex).reader().getBinaryDocValues(field);\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n          if (values != null) {\n            values.get(docID - leaves.get(subIndex).docBase, result);\n          } else {\n            result.length = 0;\n            result.offset = 0;\n            result.bytes = BinaryDocValues.MISSING;\n          }\n        }\n      };\n    }\n  }\n\n","sourceOld":"  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    boolean anyReal = false;\n\n    for(AtomicReaderContext ctx : leaves) {\n      BinaryDocValues values = ctx.reader().getBinaryDocValues(field);\n\n      if (values != null) {\n        anyReal = true;\n      }\n    }\n\n    if (!anyReal) {\n      return null;\n    } else {\n\n      return new BinaryDocValues() {\n        @Override\n        public void get(int docID, BytesRef result) {\n          int subIndex = ReaderUtil.subIndex(docID, leaves);\n          BinaryDocValues values;\n          try {\n            values = leaves.get(subIndex).reader().getBinaryDocValues(field);\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n          if (values != null) {\n            values.get(docID - leaves.get(subIndex).docBase, result);\n          } else {\n            result.length = 0;\n            result.offset = 0;\n            result.bytes = BinaryDocValues.MISSING;\n          }\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"026059dab6db2d84d0e57c4774484b93a540ee6c","date":1359995853,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","sourceNew":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly)\n   * <p>\n   * This is a slow way to access binary values. Instead, access them per-segment\n   * with {@link AtomicReader#getBinaryDocValues(String)}\n   * </p>  \n   */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = BinaryDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public void get(int docID, BytesRef result) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          values[subIndex].get(docID - starts[subIndex], result);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly) */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    if (leaves.size() == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    boolean anyReal = false;\n\n    for(AtomicReaderContext ctx : leaves) {\n      BinaryDocValues values = ctx.reader().getBinaryDocValues(field);\n\n      if (values != null) {\n        anyReal = true;\n      }\n    }\n\n    if (!anyReal) {\n      return null;\n    } else {\n\n      return new BinaryDocValues() {\n        @Override\n        public void get(int docID, BytesRef result) {\n          int subIndex = ReaderUtil.subIndex(docID, leaves);\n          BinaryDocValues values;\n          try {\n            values = leaves.get(subIndex).reader().getBinaryDocValues(field);\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n          if (values != null) {\n            values.get(docID - leaves.get(subIndex).docBase, result);\n          } else {\n            result.length = 0;\n            result.offset = 0;\n            result.bytes = BinaryDocValues.MISSING;\n          }\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":["8429ddf2214f2bf8abcbb5484fefef6aaf5c417e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly)\n   * <p>\n   * This is a slow way to access binary values. Instead, access them per-segment\n   * with {@link AtomicReader#getBinaryDocValues(String)}\n   * </p>  \n   */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = BinaryDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public void get(int docID, BytesRef result) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          values[subIndex].get(docID - starts[subIndex], result);\n        }\n      };\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8429ddf2214f2bf8abcbb5484fefef6aaf5c417e","date":1397206443,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","sourceNew":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly)\n   * <p>\n   * This is a slow way to access binary values. Instead, access them per-segment\n   * with {@link AtomicReader#getBinaryDocValues(String)}\n   * </p>  \n   */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = DocValues.EMPTY_BINARY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public void get(int docID, BytesRef result) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          values[subIndex].get(docID - starts[subIndex], result);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly)\n   * <p>\n   * This is a slow way to access binary values. Instead, access them per-segment\n   * with {@link AtomicReader#getBinaryDocValues(String)}\n   * </p>  \n   */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = BinaryDocValues.EMPTY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public void get(int docID, BytesRef result) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          values[subIndex].get(docID - starts[subIndex], result);\n        }\n      };\n    }\n  }\n\n","bugFix":["026059dab6db2d84d0e57c4774484b93a540ee6c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf","date":1401983689,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","sourceNew":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly)\n   * <p>\n   * This is a slow way to access binary values. Instead, access them per-segment\n   * with {@link AtomicReader#getBinaryDocValues(String)}\n   * </p>  \n   */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = DocValues.emptyBinary();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public BytesRef get(int docID) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          return values[subIndex].get(docID - starts[subIndex]);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly)\n   * <p>\n   * This is a slow way to access binary values. Instead, access them per-segment\n   * with {@link AtomicReader#getBinaryDocValues(String)}\n   * </p>  \n   */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = DocValues.EMPTY_BINARY;\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public void get(int docID, BytesRef result) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          values[subIndex].get(docID - starts[subIndex], result);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","sourceNew":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly)\n   * <p>\n   * This is a slow way to access binary values. Instead, access them per-segment\n   * with {@link LeafReader#getBinaryDocValues(String)}\n   * </p>  \n   */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = DocValues.emptyBinary();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public BytesRef get(int docID) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          return values[subIndex].get(docID - starts[subIndex]);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly)\n   * <p>\n   * This is a slow way to access binary values. Instead, access them per-segment\n   * with {@link AtomicReader#getBinaryDocValues(String)}\n   * </p>  \n   */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<AtomicReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      AtomicReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = DocValues.emptyBinary();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public BytesRef get(int docID) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          return values[subIndex].get(docID - starts[subIndex]);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22aab7a3b640b0dba26cc5e9416bc7af93614b46","date":1462575761,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","sourceNew":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly)\n   * <p>\n   * This is a slow way to access binary values. Instead, access them per-segment\n   * with {@link LeafReader#getBinaryDocValues(String)}\n   * </p>  \n   */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      if (context.reader().getIndexSort() != null) {\n        throw new IllegalArgumentException(\"cannot handle index sort: reader=\" + context.reader());\n      }\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = DocValues.emptyBinary();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public BytesRef get(int docID) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          return values[subIndex].get(docID - starts[subIndex]);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly)\n   * <p>\n   * This is a slow way to access binary values. Instead, access them per-segment\n   * with {@link LeafReader#getBinaryDocValues(String)}\n   * </p>  \n   */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = DocValues.emptyBinary();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public BytesRef get(int docID) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          return values[subIndex].get(docID - starts[subIndex]);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"815972da4a13279b8e975d2e32ca450649d6c295","date":1462635959,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","sourceNew":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly)\n   * <p>\n   * This is a slow way to access binary values. Instead, access them per-segment\n   * with {@link LeafReader#getBinaryDocValues(String)}\n   * </p>  \n   */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = DocValues.emptyBinary();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public BytesRef get(int docID) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          return values[subIndex].get(docID - starts[subIndex]);\n        }\n      };\n    }\n  }\n\n","sourceOld":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly)\n   * <p>\n   * This is a slow way to access binary values. Instead, access them per-segment\n   * with {@link LeafReader#getBinaryDocValues(String)}\n   * </p>  \n   */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      if (context.reader().getIndexSort() != null) {\n        throw new IllegalArgumentException(\"cannot handle index sort: reader=\" + context.reader());\n      }\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = DocValues.emptyBinary();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public BytesRef get(int docID) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          return values[subIndex].get(docID - starts[subIndex]);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","sourceNew":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly) */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public BytesRef binaryValue() {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        // TODO\n        return 0;\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly)\n   * <p>\n   * This is a slow way to access binary values. Instead, access them per-segment\n   * with {@link LeafReader#getBinaryDocValues(String)}\n   * </p>  \n   */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = DocValues.emptyBinary();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public BytesRef get(int docID) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          return values[subIndex].get(docID - starts[subIndex]);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":["f7558b5077dd4abd457be151475f13b541f4f13e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","sourceNew":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly) */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public BytesRef binaryValue() {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        // TODO\n        return 0;\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly)\n   * <p>\n   * This is a slow way to access binary values. Instead, access them per-segment\n   * with {@link LeafReader#getBinaryDocValues(String)}\n   * </p>  \n   */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = DocValues.emptyBinary();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public BytesRef get(int docID) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          return values[subIndex].get(docID - starts[subIndex]);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7558b5077dd4abd457be151475f13b541f4f13e","date":1475830751,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","sourceNew":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly) */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public BytesRef binaryValue() throws IOException {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        // TODO\n        return 0;\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly) */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public BytesRef binaryValue() {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        // TODO\n        return 0;\n      }\n    };\n  }\n\n","bugFix":["6652c74b2358a0b13223817a6a793bf1c9d0749d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","sourceNew":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly) */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public BytesRef binaryValue() throws IOException {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        // TODO\n        return 0;\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly)\n   * <p>\n   * This is a slow way to access binary values. Instead, access them per-segment\n   * with {@link LeafReader#getBinaryDocValues(String)}\n   * </p>  \n   */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    \n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n    \n    boolean anyReal = false;\n    final BinaryDocValues[] values = new BinaryDocValues[size];\n    final int[] starts = new int[size+1];\n    for (int i = 0; i < size; i++) {\n      LeafReaderContext context = leaves.get(i);\n      BinaryDocValues v = context.reader().getBinaryDocValues(field);\n      if (v == null) {\n        v = DocValues.emptyBinary();\n      } else {\n        anyReal = true;\n      }\n      values[i] = v;\n      starts[i] = context.docBase;\n    }\n    starts[size] = r.maxDoc();\n    \n    if (!anyReal) {\n      return null;\n    } else {\n      return new BinaryDocValues() {\n        @Override\n        public BytesRef get(int docID) {\n          int subIndex = ReaderUtil.subIndex(docID, starts);\n          return values[subIndex].get(docID - starts[subIndex]);\n        }\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11134e449dabe11d6d0ff6a564d84b82cbe93722","date":1477299083,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","sourceNew":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly) */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public BytesRef binaryValue() throws IOException {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        // TODO\n        return 0;\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly) */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public BytesRef binaryValue() throws IOException {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        // TODO\n        return 0;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["14b133bc4d7193efff507eb88f86fcc07c4e8b50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2714c85633b642b29871cf5ff8d17d3ba7bfd76","date":1477307753,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","sourceNew":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly) */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public BytesRef binaryValue() throws IOException {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        // TODO\n        return 0;\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly) */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public BytesRef binaryValue() throws IOException {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        // TODO\n        return 0;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","sourceNew":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly) */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public BytesRef binaryValue() throws IOException {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        // TODO\n        return 0;\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly) */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public BytesRef binaryValue() throws IOException {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        // TODO\n        return 0;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"14b133bc4d7193efff507eb88f86fcc07c4e8b50","date":1477907694,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","sourceNew":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly) */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID < docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public BytesRef binaryValue() throws IOException {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        // TODO\n        return 0;\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly) */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public BytesRef binaryValue() throws IOException {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        // TODO\n        return 0;\n      }\n    };\n  }\n\n","bugFix":["11134e449dabe11d6d0ff6a564d84b82cbe93722"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"320888923ec13b91f53082558f01f4c9960dd226","date":1477926871,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues#getBinaryValues(IndexReader,String).mjava","sourceNew":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly) */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID < docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public BytesRef binaryValue() throws IOException {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        // TODO\n        return 0;\n      }\n    };\n  }\n\n","sourceOld":"  /** Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly) */\n  public static BinaryDocValues getBinaryValues(final IndexReader r, final String field) throws IOException {\n    final List<LeafReaderContext> leaves = r.leaves();\n    final int size = leaves.size();\n    if (size == 0) {\n      return null;\n    } else if (size == 1) {\n      return leaves.get(0).reader().getBinaryDocValues(field);\n    }\n\n    boolean anyReal = false;\n    for(LeafReaderContext leaf : leaves) {\n      FieldInfo fieldInfo = leaf.reader().getFieldInfos().fieldInfo(field);\n      if (fieldInfo != null) {\n        DocValuesType dvType = fieldInfo.getDocValuesType();\n        if (dvType == DocValuesType.BINARY) {\n          anyReal = true;\n          break;\n        }\n      }\n    }\n\n    if (anyReal == false) {\n      return null;\n    }\n\n    return new BinaryDocValues() {\n      private int nextLeaf;\n      private BinaryDocValues currentValues;\n      private LeafReaderContext currentLeaf;\n      private int docID = -1;\n\n      @Override\n      public int nextDoc() throws IOException {\n        while (true) {\n          while (currentValues == null) {\n            if (nextLeaf == leaves.size()) {\n              docID = NO_MORE_DOCS;\n              return docID;\n            }\n            currentLeaf = leaves.get(nextLeaf);\n            currentValues = currentLeaf.reader().getBinaryDocValues(field);\n            nextLeaf++;\n          }\n\n          int newDocID = currentValues.nextDoc();\n\n          if (newDocID == NO_MORE_DOCS) {\n            currentValues = null;\n            continue;\n          } else {\n            docID = currentLeaf.docBase + newDocID;\n            return docID;\n          }\n        }\n      }\n        \n      @Override\n      public int docID() {\n        return docID;\n      }\n\n      @Override\n      public int advance(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            currentValues = null;\n            docID = NO_MORE_DOCS;\n            return docID;\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n          if (currentValues == null) {\n            return nextDoc();\n          }\n        }\n        int newDocID = currentValues.advance(targetDocID - currentLeaf.docBase);\n        if (newDocID == NO_MORE_DOCS) {\n          currentValues = null;\n          return nextDoc();\n        } else {\n          docID = currentLeaf.docBase + newDocID;\n          return docID;\n        }\n      }\n\n      @Override\n      public boolean advanceExact(int targetDocID) throws IOException {\n        if (targetDocID <= docID) {\n          throw new IllegalArgumentException(\"can only advance beyond current document: on docID=\" + docID + \" but targetDocID=\" + targetDocID);\n        }\n        int readerIndex = ReaderUtil.subIndex(targetDocID, leaves);\n        if (readerIndex >= nextLeaf) {\n          if (readerIndex == leaves.size()) {\n            throw new IllegalArgumentException(\"Out of range: \" + targetDocID);\n          }\n          currentLeaf = leaves.get(readerIndex);\n          currentValues = currentLeaf.reader().getBinaryDocValues(field);\n          nextLeaf = readerIndex+1;\n        }\n        docID = targetDocID;\n        if (currentValues == null) {\n          return false;\n        }\n        return currentValues.advanceExact(targetDocID - currentLeaf.docBase);\n      }\n\n      @Override\n      public BytesRef binaryValue() throws IOException {\n        return currentValues.binaryValue();\n      }\n\n      @Override\n      public long cost() {\n        // TODO\n        return 0;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"dd5cc84228660a66f2acf468586412e75cde579a":["b8acf0807ca5f38beda8e0f7d5ab46ff39f81200"],"f7558b5077dd4abd457be151475f13b541f4f13e":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"026059dab6db2d84d0e57c4774484b93a540ee6c":["4772ea9604873dc0b22ea724398008998afc8e41"],"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf":["8429ddf2214f2bf8abcbb5484fefef6aaf5c417e"],"320888923ec13b91f53082558f01f4c9960dd226":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","14b133bc4d7193efff507eb88f86fcc07c4e8b50"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["c9fb5f46e264daf5ba3860defe623a89d202dd87","f7558b5077dd4abd457be151475f13b541f4f13e"],"8429ddf2214f2bf8abcbb5484fefef6aaf5c417e":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"22aab7a3b640b0dba26cc5e9416bc7af93614b46":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","026059dab6db2d84d0e57c4774484b93a540ee6c"],"11134e449dabe11d6d0ff6a564d84b82cbe93722":["f7558b5077dd4abd457be151475f13b541f4f13e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["c9fb5f46e264daf5ba3860defe623a89d202dd87","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d2714c85633b642b29871cf5ff8d17d3ba7bfd76"],"14b133bc4d7193efff507eb88f86fcc07c4e8b50":["d2714c85633b642b29871cf5ff8d17d3ba7bfd76"],"815972da4a13279b8e975d2e32ca450649d6c295":["22aab7a3b640b0dba26cc5e9416bc7af93614b46"],"d2714c85633b642b29871cf5ff8d17d3ba7bfd76":["f7558b5077dd4abd457be151475f13b541f4f13e","11134e449dabe11d6d0ff6a564d84b82cbe93722"],"4772ea9604873dc0b22ea724398008998afc8e41":["dd5cc84228660a66f2acf468586412e75cde579a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["14b133bc4d7193efff507eb88f86fcc07c4e8b50"]},"commit2Childs":{"dd5cc84228660a66f2acf468586412e75cde579a":["4772ea9604873dc0b22ea724398008998afc8e41"],"f7558b5077dd4abd457be151475f13b541f4f13e":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","11134e449dabe11d6d0ff6a564d84b82cbe93722","d2714c85633b642b29871cf5ff8d17d3ba7bfd76"],"026059dab6db2d84d0e57c4774484b93a540ee6c":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"320888923ec13b91f53082558f01f4c9960dd226":[],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","22aab7a3b640b0dba26cc5e9416bc7af93614b46","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"8429ddf2214f2bf8abcbb5484fefef6aaf5c417e":["53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf"],"22aab7a3b640b0dba26cc5e9416bc7af93614b46":["815972da4a13279b8e975d2e32ca450649d6c295"],"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":["dd5cc84228660a66f2acf468586412e75cde579a"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["8429ddf2214f2bf8abcbb5484fefef6aaf5c417e"],"11134e449dabe11d6d0ff6a564d84b82cbe93722":["d2714c85633b642b29871cf5ff8d17d3ba7bfd76"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["f7558b5077dd4abd457be151475f13b541f4f13e"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["320888923ec13b91f53082558f01f4c9960dd226"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b8acf0807ca5f38beda8e0f7d5ab46ff39f81200","d4d69c535930b5cce125cff868d40f6373dc27d4"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"14b133bc4d7193efff507eb88f86fcc07c4e8b50":["320888923ec13b91f53082558f01f4c9960dd226","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"815972da4a13279b8e975d2e32ca450649d6c295":[],"d2714c85633b642b29871cf5ff8d17d3ba7bfd76":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","14b133bc4d7193efff507eb88f86fcc07c4e8b50"],"4772ea9604873dc0b22ea724398008998afc8e41":["026059dab6db2d84d0e57c4774484b93a540ee6c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["320888923ec13b91f53082558f01f4c9960dd226","815972da4a13279b8e975d2e32ca450649d6c295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}