{"path":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#fileIsIdentical(String,FileMetaData).mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#fileIsIdentical(String,FileMetaData).mjava","pathOld":"/dev/null","sourceNew":"  /** Carefully determine if the file on the primary, identified by its {@code String fileName} along with the {@link FileMetaData}\n   * \"summarizing\" its contents, is precisely the same file that we have locally.  If the file does not exist locally, or if its its header\n   * (inclues the segment id), length, footer (including checksum) differ, then this returns false, else true. */\n  private boolean fileIsIdentical(String fileName, FileMetaData srcMetaData) throws IOException {\n\n    if (deleter.isPending(fileName)) {\n      // This was a file we had wanted to delete yet a virus checker prevented us, and now we need to overwrite it.\n      // Such files are in an unknown state, and even if their header and footer and length all\n      // match, since they may not have been fsync'd by the previous node instance on this directory,\n      // they could in theory have corruption internally.  So we always force ourselves to copy them here:\n      if (Node.VERBOSE_FILES) {\n        message(\"file \" + fileName + \": will copy [we had wanted to delete this file on init, but failed]\");\n      }\n      return false;\n    }\n\n    FileMetaData destMetaData = readLocalFileMetaData(fileName);\n    if (destMetaData == null) {\n      // Something went wrong in reading the file (it's corrupt, truncated, does not exist, etc.):\n      return false;\n    }\n\n    if (Arrays.equals(destMetaData.header, srcMetaData.header) == false ||\n        Arrays.equals(destMetaData.footer, srcMetaData.footer) == false) {\n      // Segment name was reused!  This is rare but possible and otherwise devastating:\n      if (Node.VERBOSE_FILES) {\n        message(\"file \" + fileName + \": will copy [header/footer is different]\");\n      }\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b72a3c8c250ce67d9dd59e06316f982cd77bdb3c","date":1454874368,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#fileIsIdentical(String,FileMetaData).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#fileIsIdentical(String,FileMetaData).mjava","sourceNew":"  /** Carefully determine if the file on the primary, identified by its {@code String fileName} along with the {@link FileMetaData}\n   * \"summarizing\" its contents, is precisely the same file that we have locally.  If the file does not exist locally, or if its its header\n   * (inclues the segment id), length, footer (including checksum) differ, then this returns false, else true. */\n  private boolean fileIsIdentical(String fileName, FileMetaData srcMetaData) throws IOException {\n\n    FileMetaData destMetaData = readLocalFileMetaData(fileName);\n    if (destMetaData == null) {\n      // Something went wrong in reading the file (it's corrupt, truncated, does not exist, etc.):\n      return false;\n    }\n\n    if (Arrays.equals(destMetaData.header, srcMetaData.header) == false ||\n        Arrays.equals(destMetaData.footer, srcMetaData.footer) == false) {\n      // Segment name was reused!  This is rare but possible and otherwise devastating:\n      if (Node.VERBOSE_FILES) {\n        message(\"file \" + fileName + \": will copy [header/footer is different]\");\n      }\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n","sourceOld":"  /** Carefully determine if the file on the primary, identified by its {@code String fileName} along with the {@link FileMetaData}\n   * \"summarizing\" its contents, is precisely the same file that we have locally.  If the file does not exist locally, or if its its header\n   * (inclues the segment id), length, footer (including checksum) differ, then this returns false, else true. */\n  private boolean fileIsIdentical(String fileName, FileMetaData srcMetaData) throws IOException {\n\n    if (deleter.isPending(fileName)) {\n      // This was a file we had wanted to delete yet a virus checker prevented us, and now we need to overwrite it.\n      // Such files are in an unknown state, and even if their header and footer and length all\n      // match, since they may not have been fsync'd by the previous node instance on this directory,\n      // they could in theory have corruption internally.  So we always force ourselves to copy them here:\n      if (Node.VERBOSE_FILES) {\n        message(\"file \" + fileName + \": will copy [we had wanted to delete this file on init, but failed]\");\n      }\n      return false;\n    }\n\n    FileMetaData destMetaData = readLocalFileMetaData(fileName);\n    if (destMetaData == null) {\n      // Something went wrong in reading the file (it's corrupt, truncated, does not exist, etc.):\n      return false;\n    }\n\n    if (Arrays.equals(destMetaData.header, srcMetaData.header) == false ||\n        Arrays.equals(destMetaData.footer, srcMetaData.footer) == false) {\n      // Segment name was reused!  This is rare but possible and otherwise devastating:\n      if (Node.VERBOSE_FILES) {\n        message(\"file \" + fileName + \": will copy [header/footer is different]\");\n      }\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#fileIsIdentical(String,FileMetaData).mjava","pathOld":"/dev/null","sourceNew":"  /** Carefully determine if the file on the primary, identified by its {@code String fileName} along with the {@link FileMetaData}\n   * \"summarizing\" its contents, is precisely the same file that we have locally.  If the file does not exist locally, or if its its header\n   * (inclues the segment id), length, footer (including checksum) differ, then this returns false, else true. */\n  private boolean fileIsIdentical(String fileName, FileMetaData srcMetaData) throws IOException {\n\n    FileMetaData destMetaData = readLocalFileMetaData(fileName);\n    if (destMetaData == null) {\n      // Something went wrong in reading the file (it's corrupt, truncated, does not exist, etc.):\n      return false;\n    }\n\n    if (Arrays.equals(destMetaData.header, srcMetaData.header) == false ||\n        Arrays.equals(destMetaData.footer, srcMetaData.footer) == false) {\n      // Segment name was reused!  This is rare but possible and otherwise devastating:\n      if (Node.VERBOSE_FILES) {\n        message(\"file \" + fileName + \": will copy [header/footer is different]\");\n      }\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a","date":1550036130,"type":3,"author":"Bruno P. Kinoshita","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#fileIsIdentical(String,FileMetaData).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#fileIsIdentical(String,FileMetaData).mjava","sourceNew":"  /** Carefully determine if the file on the primary, identified by its {@code String fileName} along with the {@link FileMetaData}\n   * \"summarizing\" its contents, is precisely the same file that we have locally.  If the file does not exist locally, or if its header\n   * (includes the segment id), length, footer (including checksum) differ, then this returns false, else true. */\n  private boolean fileIsIdentical(String fileName, FileMetaData srcMetaData) throws IOException {\n\n    FileMetaData destMetaData = readLocalFileMetaData(fileName);\n    if (destMetaData == null) {\n      // Something went wrong in reading the file (it's corrupt, truncated, does not exist, etc.):\n      return false;\n    }\n\n    if (Arrays.equals(destMetaData.header, srcMetaData.header) == false ||\n        Arrays.equals(destMetaData.footer, srcMetaData.footer) == false) {\n      // Segment name was reused!  This is rare but possible and otherwise devastating:\n      if (Node.VERBOSE_FILES) {\n        message(\"file \" + fileName + \": will copy [header/footer is different]\");\n      }\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n","sourceOld":"  /** Carefully determine if the file on the primary, identified by its {@code String fileName} along with the {@link FileMetaData}\n   * \"summarizing\" its contents, is precisely the same file that we have locally.  If the file does not exist locally, or if its its header\n   * (inclues the segment id), length, footer (including checksum) differ, then this returns false, else true. */\n  private boolean fileIsIdentical(String fileName, FileMetaData srcMetaData) throws IOException {\n\n    FileMetaData destMetaData = readLocalFileMetaData(fileName);\n    if (destMetaData == null) {\n      // Something went wrong in reading the file (it's corrupt, truncated, does not exist, etc.):\n      return false;\n    }\n\n    if (Arrays.equals(destMetaData.header, srcMetaData.header) == false ||\n        Arrays.equals(destMetaData.footer, srcMetaData.footer) == false) {\n      // Segment name was reused!  This is rare but possible and otherwise devastating:\n      if (Node.VERBOSE_FILES) {\n        message(\"file \" + fileName + \": will copy [header/footer is different]\");\n      }\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a":["68496c2200e559fb7802f7575427b7a482659afb"],"b72a3c8c250ce67d9dd59e06316f982cd77bdb3c":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b72a3c8c250ce67d9dd59e06316f982cd77bdb3c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b72a3c8c250ce67d9dd59e06316f982cd77bdb3c":["68496c2200e559fb7802f7575427b7a482659afb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"68496c2200e559fb7802f7575427b7a482659afb":["d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["b72a3c8c250ce67d9dd59e06316f982cd77bdb3c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}