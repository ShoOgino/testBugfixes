{"path":"lucene/core/src/java/org/apache/lucene/index/FieldUpdatesBuffer#add(String,int,int,boolean).mjava","commits":[{"id":"28211671436f185419b3f7e53ccfc3911441ab65","date":1544026960,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldUpdatesBuffer#add(String,int,int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  void add(String field, int docUpTo, int ord, boolean hasValue) {\n    if (fields[0].equals(field) == false || fields.length != 1 ) {\n      if (fields.length <= ord) {\n        String[] array = ArrayUtil.grow(fields, ord+1);\n        if (fields.length == 1) {\n          Arrays.fill(array, 1, ord, fields[0]);\n        }\n        bytesUsed.addAndGet((array.length - fields.length) * RamUsageEstimator.NUM_BYTES_OBJECT_REF);\n        fields = array;\n      }\n      if (field != fields[0]) { // that's an easy win of not accounting if there is an outlier\n        bytesUsed.addAndGet(sizeOfString(field));\n      }\n      fields[ord] = field;\n    }\n\n    if (docsUpTo[0] != docUpTo || docsUpTo.length != 1) {\n      if (docsUpTo.length <= ord) {\n        int[] array = ArrayUtil.grow(docsUpTo, ord+1);\n        if (docsUpTo.length == 1) {\n          Arrays.fill(array, 1, ord, docsUpTo[0]);\n        }\n        bytesUsed.addAndGet((array.length-docsUpTo.length) * Integer.BYTES);\n        docsUpTo = array;\n      }\n      docsUpTo[ord] = docUpTo;\n    }\n\n    if (hasValue == false || hasValues != null) {\n      if (hasValues == null) {\n        hasValues = new FixedBitSet(ord+1);\n        hasValues.set(0, ord);\n        bytesUsed.addAndGet(hasValues.ramBytesUsed());\n      } else if (hasValues.length() <= ord) {\n        FixedBitSet fixedBitSet = FixedBitSet.ensureCapacity(hasValues, ArrayUtil.oversize(ord + 1, 1));\n        bytesUsed.addAndGet(fixedBitSet.ramBytesUsed()-hasValues.ramBytesUsed());\n        hasValues = fixedBitSet;\n      }\n      if (hasValue) {\n        hasValues.set(ord);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb0b91dbd7ffa9329d88b6cf6d606e542fed61d8","date":1582222690,"type":3,"author":"Nhat Nguyen","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldUpdatesBuffer#add(String,int,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldUpdatesBuffer#add(String,int,int,boolean).mjava","sourceNew":"  void add(String field, int docUpTo, int ord, boolean hasValue) {\n    assert finished == false : \"buffer was finished already\";\n    if (fields[0].equals(field) == false || fields.length != 1 ) {\n      if (fields.length <= ord) {\n        String[] array = ArrayUtil.grow(fields, ord+1);\n        if (fields.length == 1) {\n          Arrays.fill(array, 1, ord, fields[0]);\n        }\n        bytesUsed.addAndGet((array.length - fields.length) * RamUsageEstimator.NUM_BYTES_OBJECT_REF);\n        fields = array;\n      }\n      if (field != fields[0]) { // that's an easy win of not accounting if there is an outlier\n        bytesUsed.addAndGet(sizeOfString(field));\n      }\n      fields[ord] = field;\n    }\n\n    if (docsUpTo[0] != docUpTo || docsUpTo.length != 1) {\n      if (docsUpTo.length <= ord) {\n        int[] array = ArrayUtil.grow(docsUpTo, ord+1);\n        if (docsUpTo.length == 1) {\n          Arrays.fill(array, 1, ord, docsUpTo[0]);\n        }\n        bytesUsed.addAndGet((array.length-docsUpTo.length) * Integer.BYTES);\n        docsUpTo = array;\n      }\n      docsUpTo[ord] = docUpTo;\n    }\n\n    if (hasValue == false || hasValues != null) {\n      if (hasValues == null) {\n        hasValues = new FixedBitSet(ord+1);\n        hasValues.set(0, ord);\n        bytesUsed.addAndGet(hasValues.ramBytesUsed());\n      } else if (hasValues.length() <= ord) {\n        FixedBitSet fixedBitSet = FixedBitSet.ensureCapacity(hasValues, ArrayUtil.oversize(ord + 1, 1));\n        bytesUsed.addAndGet(fixedBitSet.ramBytesUsed()-hasValues.ramBytesUsed());\n        hasValues = fixedBitSet;\n      }\n      if (hasValue) {\n        hasValues.set(ord);\n      }\n    }\n  }\n\n","sourceOld":"  void add(String field, int docUpTo, int ord, boolean hasValue) {\n    if (fields[0].equals(field) == false || fields.length != 1 ) {\n      if (fields.length <= ord) {\n        String[] array = ArrayUtil.grow(fields, ord+1);\n        if (fields.length == 1) {\n          Arrays.fill(array, 1, ord, fields[0]);\n        }\n        bytesUsed.addAndGet((array.length - fields.length) * RamUsageEstimator.NUM_BYTES_OBJECT_REF);\n        fields = array;\n      }\n      if (field != fields[0]) { // that's an easy win of not accounting if there is an outlier\n        bytesUsed.addAndGet(sizeOfString(field));\n      }\n      fields[ord] = field;\n    }\n\n    if (docsUpTo[0] != docUpTo || docsUpTo.length != 1) {\n      if (docsUpTo.length <= ord) {\n        int[] array = ArrayUtil.grow(docsUpTo, ord+1);\n        if (docsUpTo.length == 1) {\n          Arrays.fill(array, 1, ord, docsUpTo[0]);\n        }\n        bytesUsed.addAndGet((array.length-docsUpTo.length) * Integer.BYTES);\n        docsUpTo = array;\n      }\n      docsUpTo[ord] = docUpTo;\n    }\n\n    if (hasValue == false || hasValues != null) {\n      if (hasValues == null) {\n        hasValues = new FixedBitSet(ord+1);\n        hasValues.set(0, ord);\n        bytesUsed.addAndGet(hasValues.ramBytesUsed());\n      } else if (hasValues.length() <= ord) {\n        FixedBitSet fixedBitSet = FixedBitSet.ensureCapacity(hasValues, ArrayUtil.oversize(ord + 1, 1));\n        bytesUsed.addAndGet(fixedBitSet.ramBytesUsed()-hasValues.ramBytesUsed());\n        hasValues = fixedBitSet;\n      }\n      if (hasValue) {\n        hasValues.set(ord);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fb0b91dbd7ffa9329d88b6cf6d606e542fed61d8":["28211671436f185419b3f7e53ccfc3911441ab65"],"28211671436f185419b3f7e53ccfc3911441ab65":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fb0b91dbd7ffa9329d88b6cf6d606e542fed61d8"]},"commit2Childs":{"fb0b91dbd7ffa9329d88b6cf6d606e542fed61d8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"28211671436f185419b3f7e53ccfc3911441ab65":["fb0b91dbd7ffa9329d88b6cf6d606e542fed61d8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["28211671436f185419b3f7e53ccfc3911441ab65"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}