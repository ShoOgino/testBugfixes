{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","commits":[{"id":"6ce825e9276493231308229152c48f755ce1a0a5","date":1348871483,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void build(TermFreqIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = new EscapingTokenStreamToAutomaton();\n\n    // analyzed sequence + 0(byte) + weight(int) + surface + analyzedLength(short) \n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n      while ((surfaceForm = iterator.next()) != null) {\n\n        // Analyze surface form:\n        TokenStream ts = indexAnalyzer.tokenStream(\"\", new StringReader(surfaceForm.utf8ToString()));\n\n        // Create corresponding automaton: labels are bytes\n        // from each analyzed token, with byte 0 used as\n        // separator between tokens:\n        Automaton automaton = ts2a.toAutomaton(ts);\n        ts.end();\n        ts.close();\n\n        replaceSep(automaton);\n\n        assert SpecialOperations.isFinite(automaton);\n\n        // Get all paths from the automaton (there can be\n        // more than one path, eg if the analyzer created a\n        // graph using SynFilter or WDF):\n\n        // TODO: we could walk & add simultaneously, so we\n        // don't have to alloc [possibly biggish]\n        // intermediate HashSet in RAM:\n        Set<IntsRef> paths = SpecialOperations.getFiniteStrings(automaton, maxGraphExpansions);\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          short analyzedLength = (short) scratch.length;\n          // compute the required length:\n          // analyzed sequence + 12 (separator) + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 2 + 4 + surfaceForm.length + 2;\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n          output.writeByte((byte)0); // separator: not used, just for sort order\n          output.writeByte((byte)0); // separator: not used, just for sort order\n\n          // NOTE: important that writeInt is big-endian,\n          // because this means we sort secondarily by\n          // cost ascending (= weight descending) so that\n          // when we discard too many surface forms for a\n          // single analyzed form we are discarding the\n          // least weight ones:\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          output.writeShort(analyzedLength);\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort().sort(tempInput, tempSorted);\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(true), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previous = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        input.setPosition(input.length()-2);\n        short analyzedLength = input.readShort();\n\n        analyzed.bytes = scratch.bytes;\n        analyzed.offset = scratch.offset;\n        analyzed.length = analyzedLength;\n        \n        input.setPosition(analyzedLength + 2); // analyzed sequence + separator\n        long cost = input.readInt();\n   \n        surface.bytes = scratch.bytes;\n        surface.offset = input.getPosition();\n        surface.length = input.length() - input.getPosition() - 2;\n\n        if (previous == null) {\n          previous = new BytesRef();\n          previous.copyBytes(analyzed);\n        } else if (analyzed.equals(previous)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n        } else {\n          dedup = 0;\n          previous.copyBytes(analyzed);\n        }\n\n        analyzed.grow(analyzed.length+2);\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.length] = 0;\n        analyzed.bytes[analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["cbc3688252d4a8045d69a164236b2cf87b721f17","ba791bce8103c79e38f957e9c5a53a75871bd918","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f903593885012bb5d79809c44cb6dfcebb4a2c66","date":1349971647,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","sourceNew":"  @Override\n  public void build(TermFreqIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n    // analyzed sequence + 0(byte) + weight(int) + surface + analyzedLength(short) \n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n      while ((surfaceForm = iterator.next()) != null) {\n\n        // Analyze surface form:\n        TokenStream ts = indexAnalyzer.tokenStream(\"\", new StringReader(surfaceForm.utf8ToString()));\n\n        // Create corresponding automaton: labels are bytes\n        // from each analyzed token, with byte 0 used as\n        // separator between tokens:\n        Automaton automaton = ts2a.toAutomaton(ts);\n        ts.end();\n        ts.close();\n\n        replaceSep(automaton);\n\n        assert SpecialOperations.isFinite(automaton);\n\n        // Get all paths from the automaton (there can be\n        // more than one path, eg if the analyzer created a\n        // graph using SynFilter or WDF):\n\n        // TODO: we could walk & add simultaneously, so we\n        // don't have to alloc [possibly biggish]\n        // intermediate HashSet in RAM:\n        Set<IntsRef> paths = SpecialOperations.getFiniteStrings(automaton, maxGraphExpansions);\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          short analyzedLength = (short) scratch.length;\n          // compute the required length:\n          // analyzed sequence + 12 (separator) + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 2 + 4 + surfaceForm.length + 2;\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n          output.writeByte((byte)0); // separator: not used, just for sort order\n          output.writeByte((byte)0); // separator: not used, just for sort order\n\n          // NOTE: important that writeInt is big-endian,\n          // because this means we sort secondarily by\n          // cost ascending (= weight descending) so that\n          // when we discard too many surface forms for a\n          // single analyzed form we are discarding the\n          // least weight ones:\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          output.writeShort(analyzedLength);\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort().sort(tempInput, tempSorted);\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(true), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previous = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        input.setPosition(input.length()-2);\n        short analyzedLength = input.readShort();\n\n        analyzed.bytes = scratch.bytes;\n        analyzed.offset = scratch.offset;\n        analyzed.length = analyzedLength;\n        \n        input.setPosition(analyzedLength + 2); // analyzed sequence + separator\n        long cost = input.readInt();\n   \n        surface.bytes = scratch.bytes;\n        surface.offset = input.getPosition();\n        surface.length = input.length() - input.getPosition() - 2;\n\n        if (previous == null) {\n          previous = new BytesRef();\n          previous.copyBytes(analyzed);\n        } else if (analyzed.equals(previous)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n        } else {\n          dedup = 0;\n          previous.copyBytes(analyzed);\n        }\n\n        analyzed.grow(analyzed.length+2);\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.length] = 0;\n        analyzed.bytes[analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(TermFreqIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = new EscapingTokenStreamToAutomaton();\n\n    // analyzed sequence + 0(byte) + weight(int) + surface + analyzedLength(short) \n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n      while ((surfaceForm = iterator.next()) != null) {\n\n        // Analyze surface form:\n        TokenStream ts = indexAnalyzer.tokenStream(\"\", new StringReader(surfaceForm.utf8ToString()));\n\n        // Create corresponding automaton: labels are bytes\n        // from each analyzed token, with byte 0 used as\n        // separator between tokens:\n        Automaton automaton = ts2a.toAutomaton(ts);\n        ts.end();\n        ts.close();\n\n        replaceSep(automaton);\n\n        assert SpecialOperations.isFinite(automaton);\n\n        // Get all paths from the automaton (there can be\n        // more than one path, eg if the analyzer created a\n        // graph using SynFilter or WDF):\n\n        // TODO: we could walk & add simultaneously, so we\n        // don't have to alloc [possibly biggish]\n        // intermediate HashSet in RAM:\n        Set<IntsRef> paths = SpecialOperations.getFiniteStrings(automaton, maxGraphExpansions);\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          short analyzedLength = (short) scratch.length;\n          // compute the required length:\n          // analyzed sequence + 12 (separator) + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 2 + 4 + surfaceForm.length + 2;\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n          output.writeByte((byte)0); // separator: not used, just for sort order\n          output.writeByte((byte)0); // separator: not used, just for sort order\n\n          // NOTE: important that writeInt is big-endian,\n          // because this means we sort secondarily by\n          // cost ascending (= weight descending) so that\n          // when we discard too many surface forms for a\n          // single analyzed form we are discarding the\n          // least weight ones:\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          output.writeShort(analyzedLength);\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort().sort(tempInput, tempSorted);\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(true), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previous = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        input.setPosition(input.length()-2);\n        short analyzedLength = input.readShort();\n\n        analyzed.bytes = scratch.bytes;\n        analyzed.offset = scratch.offset;\n        analyzed.length = analyzedLength;\n        \n        input.setPosition(analyzedLength + 2); // analyzed sequence + separator\n        long cost = input.readInt();\n   \n        surface.bytes = scratch.bytes;\n        surface.offset = input.getPosition();\n        surface.length = input.length() - input.getPosition() - 2;\n\n        if (previous == null) {\n          previous = new BytesRef();\n          previous.copyBytes(analyzed);\n        } else if (analyzed.equals(previous)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n        } else {\n          dedup = 0;\n          previous.copyBytes(analyzed);\n        }\n\n        analyzed.grow(analyzed.length+2);\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.length] = 0;\n        analyzed.bytes[analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc41b743423981e7ec17a024ce7e107096e472fe","date":1349975327,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","sourceNew":"  @Override\n  public void build(TermFreqIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    // analyzed sequence + 0(byte) + weight(int) + surface + analyzedLength(short) \n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          short analyzedLength = (short) scratch.length;\n          // compute the required length:\n          // analyzed sequence + 12 (separator) + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 2 + 4 + surfaceForm.length + 2;\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n          output.writeByte((byte)0); // separator: not used, just for sort order\n          output.writeByte((byte)0); // separator: not used, just for sort order\n\n          // NOTE: important that writeInt is big-endian,\n          // because this means we sort secondarily by\n          // cost ascending (= weight descending) so that\n          // when we discard too many surface forms for a\n          // single analyzed form we are discarding the\n          // least weight ones:\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          output.writeShort(analyzedLength);\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort().sort(tempInput, tempSorted);\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(true), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previous = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        input.setPosition(input.length()-2);\n        short analyzedLength = input.readShort();\n\n        analyzed.bytes = scratch.bytes;\n        analyzed.offset = scratch.offset;\n        analyzed.length = analyzedLength;\n        \n        input.setPosition(analyzedLength + 2); // analyzed sequence + separator\n        long cost = input.readInt();\n   \n        surface.bytes = scratch.bytes;\n        surface.offset = input.getPosition();\n        surface.length = input.length() - input.getPosition() - 2;\n\n        if (previous == null) {\n          previous = new BytesRef();\n          previous.copyBytes(analyzed);\n        } else if (analyzed.equals(previous)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n        } else {\n          dedup = 0;\n          previous.copyBytes(analyzed);\n        }\n\n        analyzed.grow(analyzed.length+2);\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.length] = 0;\n        analyzed.bytes[analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(TermFreqIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n    // analyzed sequence + 0(byte) + weight(int) + surface + analyzedLength(short) \n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n      while ((surfaceForm = iterator.next()) != null) {\n\n        // Analyze surface form:\n        TokenStream ts = indexAnalyzer.tokenStream(\"\", new StringReader(surfaceForm.utf8ToString()));\n\n        // Create corresponding automaton: labels are bytes\n        // from each analyzed token, with byte 0 used as\n        // separator between tokens:\n        Automaton automaton = ts2a.toAutomaton(ts);\n        ts.end();\n        ts.close();\n\n        replaceSep(automaton);\n\n        assert SpecialOperations.isFinite(automaton);\n\n        // Get all paths from the automaton (there can be\n        // more than one path, eg if the analyzer created a\n        // graph using SynFilter or WDF):\n\n        // TODO: we could walk & add simultaneously, so we\n        // don't have to alloc [possibly biggish]\n        // intermediate HashSet in RAM:\n        Set<IntsRef> paths = SpecialOperations.getFiniteStrings(automaton, maxGraphExpansions);\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          short analyzedLength = (short) scratch.length;\n          // compute the required length:\n          // analyzed sequence + 12 (separator) + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 2 + 4 + surfaceForm.length + 2;\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n          output.writeByte((byte)0); // separator: not used, just for sort order\n          output.writeByte((byte)0); // separator: not used, just for sort order\n\n          // NOTE: important that writeInt is big-endian,\n          // because this means we sort secondarily by\n          // cost ascending (= weight descending) so that\n          // when we discard too many surface forms for a\n          // single analyzed form we are discarding the\n          // least weight ones:\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          output.writeShort(analyzedLength);\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort().sort(tempInput, tempSorted);\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(true), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previous = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        input.setPosition(input.length()-2);\n        short analyzedLength = input.readShort();\n\n        analyzed.bytes = scratch.bytes;\n        analyzed.offset = scratch.offset;\n        analyzed.length = analyzedLength;\n        \n        input.setPosition(analyzedLength + 2); // analyzed sequence + separator\n        long cost = input.readInt();\n   \n        surface.bytes = scratch.bytes;\n        surface.offset = input.getPosition();\n        surface.length = input.length() - input.getPosition() - 2;\n\n        if (previous == null) {\n          previous = new BytesRef();\n          previous.copyBytes(analyzed);\n        } else if (analyzed.equals(previous)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n        } else {\n          dedup = 0;\n          previous.copyBytes(analyzed);\n        }\n\n        analyzed.grow(analyzed.length+2);\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.length] = 0;\n        analyzed.bytes[analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"414aae1db83a83d247caa9514e383e4ca3d43da5","date":1350824365,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","sourceNew":"  @Override\n  public void build(TermFreqIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n    // analyzed sequence + 0(byte) + weight(int) + surface + analyzedLength(short) \n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n      while ((surfaceForm = iterator.next()) != null) {\n\n        // Analyze surface form:\n        TokenStream ts = indexAnalyzer.tokenStream(\"\", new StringReader(surfaceForm.utf8ToString()));\n\n        // Create corresponding automaton: labels are bytes\n        // from each analyzed token, with byte 0 used as\n        // separator between tokens:\n        Automaton automaton = ts2a.toAutomaton(ts);\n        ts.end();\n        ts.close();\n\n        replaceSep(automaton);\n\n        assert SpecialOperations.isFinite(automaton);\n\n        // Get all paths from the automaton (there can be\n        // more than one path, eg if the analyzer created a\n        // graph using SynFilter or WDF):\n\n        // TODO: we could walk & add simultaneously, so we\n        // don't have to alloc [possibly biggish]\n        // intermediate HashSet in RAM:\n        Set<IntsRef> paths = SpecialOperations.getFiniteStrings(automaton, maxGraphExpansions);\n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          short analyzedLength = (short) scratch.length;\n          // compute the required length:\n          // analyzed sequence + 12 (separator) + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 2 + 4 + surfaceForm.length + 2;\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n          output.writeByte((byte)0); // separator: not used, just for sort order\n          output.writeByte((byte)0); // separator: not used, just for sort order\n\n          // NOTE: important that writeInt is big-endian,\n          // because this means we sort secondarily by\n          // cost ascending (= weight descending) so that\n          // when we discard too many surface forms for a\n          // single analyzed form we are discarding the\n          // least weight ones:\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          output.writeShort(analyzedLength);\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort().sort(tempInput, tempSorted);\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(true), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previous = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        input.setPosition(input.length()-2);\n        short analyzedLength = input.readShort();\n\n        analyzed.bytes = scratch.bytes;\n        analyzed.offset = scratch.offset;\n        analyzed.length = analyzedLength;\n        \n        input.setPosition(analyzedLength + 2); // analyzed sequence + separator\n        long cost = input.readInt();\n   \n        surface.bytes = scratch.bytes;\n        surface.offset = input.getPosition();\n        surface.length = input.length() - input.getPosition() - 2;\n\n        if (previous == null) {\n          previous = new BytesRef();\n          previous.copyBytes(analyzed);\n        } else if (analyzed.equals(previous)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n        } else {\n          dedup = 0;\n          previous.copyBytes(analyzed);\n        }\n\n        analyzed.grow(analyzed.length+2);\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.length] = 0;\n        analyzed.bytes[analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(TermFreqIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n    // analyzed sequence + 0(byte) + weight(int) + surface + analyzedLength(short) \n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n      while ((surfaceForm = iterator.next()) != null) {\n\n        // Analyze surface form:\n        TokenStream ts = indexAnalyzer.tokenStream(\"\", new StringReader(surfaceForm.utf8ToString()));\n\n        // Create corresponding automaton: labels are bytes\n        // from each analyzed token, with byte 0 used as\n        // separator between tokens:\n        Automaton automaton = ts2a.toAutomaton(ts);\n        ts.end();\n        ts.close();\n\n        replaceSep(automaton);\n\n        assert SpecialOperations.isFinite(automaton);\n\n        // Get all paths from the automaton (there can be\n        // more than one path, eg if the analyzer created a\n        // graph using SynFilter or WDF):\n\n        // TODO: we could walk & add simultaneously, so we\n        // don't have to alloc [possibly biggish]\n        // intermediate HashSet in RAM:\n        Set<IntsRef> paths = SpecialOperations.getFiniteStrings(automaton, maxGraphExpansions);\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          short analyzedLength = (short) scratch.length;\n          // compute the required length:\n          // analyzed sequence + 12 (separator) + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 2 + 4 + surfaceForm.length + 2;\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n          output.writeByte((byte)0); // separator: not used, just for sort order\n          output.writeByte((byte)0); // separator: not used, just for sort order\n\n          // NOTE: important that writeInt is big-endian,\n          // because this means we sort secondarily by\n          // cost ascending (= weight descending) so that\n          // when we discard too many surface forms for a\n          // single analyzed form we are discarding the\n          // least weight ones:\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          output.writeShort(analyzedLength);\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort().sort(tempInput, tempSorted);\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(true), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previous = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        input.setPosition(input.length()-2);\n        short analyzedLength = input.readShort();\n\n        analyzed.bytes = scratch.bytes;\n        analyzed.offset = scratch.offset;\n        analyzed.length = analyzedLength;\n        \n        input.setPosition(analyzedLength + 2); // analyzed sequence + separator\n        long cost = input.readInt();\n   \n        surface.bytes = scratch.bytes;\n        surface.offset = input.getPosition();\n        surface.length = input.length() - input.getPosition() - 2;\n\n        if (previous == null) {\n          previous = new BytesRef();\n          previous.copyBytes(analyzed);\n        } else if (analyzed.equals(previous)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n        } else {\n          dedup = 0;\n          previous.copyBytes(analyzed);\n        }\n\n        analyzed.grow(analyzed.length+2);\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.length] = 0;\n        analyzed.bytes[analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"62e52115b56781006682fd92c6938efaf174304d","date":1351014780,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","sourceNew":"  @Override\n  public void build(TermFreqIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    // analyzed sequence + 0(byte) + weight(int) + surface + analyzedLength(short) \n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          short analyzedLength = (short) scratch.length;\n          // compute the required length:\n          // analyzed sequence + 12 (separator) + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 2 + 4 + surfaceForm.length + 2;\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n          output.writeByte((byte)0); // separator: not used, just for sort order\n          output.writeByte((byte)0); // separator: not used, just for sort order\n\n          // NOTE: important that writeInt is big-endian,\n          // because this means we sort secondarily by\n          // cost ascending (= weight descending) so that\n          // when we discard too many surface forms for a\n          // single analyzed form we are discarding the\n          // least weight ones:\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          output.writeShort(analyzedLength);\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort().sort(tempInput, tempSorted);\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(true), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previous = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        input.setPosition(input.length()-2);\n        short analyzedLength = input.readShort();\n\n        analyzed.bytes = scratch.bytes;\n        analyzed.offset = scratch.offset;\n        analyzed.length = analyzedLength;\n        \n        input.setPosition(analyzedLength + 2); // analyzed sequence + separator\n        long cost = input.readInt();\n   \n        surface.bytes = scratch.bytes;\n        surface.offset = input.getPosition();\n        surface.length = input.length() - input.getPosition() - 2;\n\n        if (previous == null) {\n          previous = new BytesRef();\n          previous.copyBytes(analyzed);\n        } else if (analyzed.equals(previous)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n        } else {\n          dedup = 0;\n          previous.copyBytes(analyzed);\n        }\n\n        analyzed.grow(analyzed.length+2);\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.length] = 0;\n        analyzed.bytes[analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(TermFreqIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    // analyzed sequence + 0(byte) + weight(int) + surface + analyzedLength(short) \n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          short analyzedLength = (short) scratch.length;\n          // compute the required length:\n          // analyzed sequence + 12 (separator) + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 2 + 4 + surfaceForm.length + 2;\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n          output.writeByte((byte)0); // separator: not used, just for sort order\n          output.writeByte((byte)0); // separator: not used, just for sort order\n\n          // NOTE: important that writeInt is big-endian,\n          // because this means we sort secondarily by\n          // cost ascending (= weight descending) so that\n          // when we discard too many surface forms for a\n          // single analyzed form we are discarding the\n          // least weight ones:\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          output.writeShort(analyzedLength);\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort().sort(tempInput, tempSorted);\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(true), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previous = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        input.setPosition(input.length()-2);\n        short analyzedLength = input.readShort();\n\n        analyzed.bytes = scratch.bytes;\n        analyzed.offset = scratch.offset;\n        analyzed.length = analyzedLength;\n        \n        input.setPosition(analyzedLength + 2); // analyzed sequence + separator\n        long cost = input.readInt();\n   \n        surface.bytes = scratch.bytes;\n        surface.offset = input.getPosition();\n        surface.length = input.length() - input.getPosition() - 2;\n\n        if (previous == null) {\n          previous = new BytesRef();\n          previous.copyBytes(analyzed);\n        } else if (analyzed.equals(previous)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n        } else {\n          dedup = 0;\n          previous.copyBytes(analyzed);\n        }\n\n        analyzed.grow(analyzed.length+2);\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.length] = 0;\n        analyzed.bytes[analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","date":1351615637,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","sourceNew":"  @Override\n  public void build(TermFreqIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    // analyzed sequence + 0(byte) + weight(int) + surface + analyzedLength(short) \n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          short analyzedLength = (short) scratch.length;\n          // compute the required length:\n          // analyzed sequence + 12 (separator) + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 2 + 4 + surfaceForm.length + 2;\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n          output.writeByte((byte)0); // separator: not used, just for sort order\n          output.writeByte((byte)0); // separator: not used, just for sort order\n\n          // NOTE: important that writeInt is big-endian,\n          // because this means we sort secondarily by\n          // cost ascending (= weight descending) so that\n          // when we discard too many surface forms for a\n          // single analyzed form we are discarding the\n          // least weight ones:\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          output.writeShort(analyzedLength);\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort().sort(tempInput, tempSorted);\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(true), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previous = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        input.setPosition(input.length()-2);\n        short analyzedLength = input.readShort();\n\n        analyzed.bytes = scratch.bytes;\n        analyzed.offset = scratch.offset;\n        analyzed.length = analyzedLength;\n        \n        input.setPosition(analyzedLength + 2); // analyzed sequence + separator\n        long cost = input.readInt();\n   \n        surface.bytes = scratch.bytes;\n        surface.offset = input.getPosition();\n        surface.length = input.length() - input.getPosition() - 2;\n\n        if (previous == null) {\n          previous = new BytesRef();\n          previous.copyBytes(analyzed);\n        } else if (analyzed.equals(previous)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n        } else {\n          dedup = 0;\n          previous.copyBytes(analyzed);\n        }\n\n        analyzed.grow(analyzed.length+2);\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.length] = 0;\n        analyzed.bytes[analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(TermFreqIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n    // analyzed sequence + 0(byte) + weight(int) + surface + analyzedLength(short) \n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n      while ((surfaceForm = iterator.next()) != null) {\n\n        // Analyze surface form:\n        TokenStream ts = indexAnalyzer.tokenStream(\"\", new StringReader(surfaceForm.utf8ToString()));\n\n        // Create corresponding automaton: labels are bytes\n        // from each analyzed token, with byte 0 used as\n        // separator between tokens:\n        Automaton automaton = ts2a.toAutomaton(ts);\n        ts.end();\n        ts.close();\n\n        replaceSep(automaton);\n\n        assert SpecialOperations.isFinite(automaton);\n\n        // Get all paths from the automaton (there can be\n        // more than one path, eg if the analyzer created a\n        // graph using SynFilter or WDF):\n\n        // TODO: we could walk & add simultaneously, so we\n        // don't have to alloc [possibly biggish]\n        // intermediate HashSet in RAM:\n        Set<IntsRef> paths = SpecialOperations.getFiniteStrings(automaton, maxGraphExpansions);\n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          short analyzedLength = (short) scratch.length;\n          // compute the required length:\n          // analyzed sequence + 12 (separator) + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 2 + 4 + surfaceForm.length + 2;\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n          output.writeByte((byte)0); // separator: not used, just for sort order\n          output.writeByte((byte)0); // separator: not used, just for sort order\n\n          // NOTE: important that writeInt is big-endian,\n          // because this means we sort secondarily by\n          // cost ascending (= weight descending) so that\n          // when we discard too many surface forms for a\n          // single analyzed form we are discarding the\n          // least weight ones:\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          output.writeShort(analyzedLength);\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort().sort(tempInput, tempSorted);\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(true), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previous = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        input.setPosition(input.length()-2);\n        short analyzedLength = input.readShort();\n\n        analyzed.bytes = scratch.bytes;\n        analyzed.offset = scratch.offset;\n        analyzed.length = analyzedLength;\n        \n        input.setPosition(analyzedLength + 2); // analyzed sequence + separator\n        long cost = input.readInt();\n   \n        surface.bytes = scratch.bytes;\n        surface.offset = input.getPosition();\n        surface.length = input.length() - input.getPosition() - 2;\n\n        if (previous == null) {\n          previous = new BytesRef();\n          previous.copyBytes(analyzed);\n        } else if (analyzed.equals(previous)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n        } else {\n          dedup = 0;\n          previous.copyBytes(analyzed);\n        }\n\n        analyzed.grow(analyzed.length+2);\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.length] = 0;\n        analyzed.bytes[analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c784b25e28b81ddedff2b97738c8286773f00f15","date":1352150231,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","sourceNew":"  @Override\n  public void build(TermFreqIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    // analyzed sequence + 0(byte) + weight(int) + surface + analyzedLength(short) \n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort(sortComparator).sort(tempInput, tempSorted);\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(true), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        surface.offset = input.getPosition();\n        surface.length = scratch.length - surface.offset;\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(TermFreqIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    // analyzed sequence + 0(byte) + weight(int) + surface + analyzedLength(short) \n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          short analyzedLength = (short) scratch.length;\n          // compute the required length:\n          // analyzed sequence + 12 (separator) + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 2 + 4 + surfaceForm.length + 2;\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n          output.writeByte((byte)0); // separator: not used, just for sort order\n          output.writeByte((byte)0); // separator: not used, just for sort order\n\n          // NOTE: important that writeInt is big-endian,\n          // because this means we sort secondarily by\n          // cost ascending (= weight descending) so that\n          // when we discard too many surface forms for a\n          // single analyzed form we are discarding the\n          // least weight ones:\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          output.writeShort(analyzedLength);\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort().sort(tempInput, tempSorted);\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(true), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previous = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        input.setPosition(input.length()-2);\n        short analyzedLength = input.readShort();\n\n        analyzed.bytes = scratch.bytes;\n        analyzed.offset = scratch.offset;\n        analyzed.length = analyzedLength;\n        \n        input.setPosition(analyzedLength + 2); // analyzed sequence + separator\n        long cost = input.readInt();\n   \n        surface.bytes = scratch.bytes;\n        surface.offset = input.getPosition();\n        surface.length = input.length() - input.getPosition() - 2;\n\n        if (previous == null) {\n          previous = new BytesRef();\n          previous.copyBytes(analyzed);\n        } else if (analyzed.equals(previous)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n        } else {\n          dedup = 0;\n          previous.copyBytes(analyzed);\n        }\n\n        analyzed.grow(analyzed.length+2);\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.length] = 0;\n        analyzed.bytes[analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0c1a09d2dfe98662e5268acb84685b971e16daf1","date":1352152464,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","sourceNew":"  @Override\n  public void build(TermFreqIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    // analyzed sequence + 0(byte) + weight(int) + surface + analyzedLength(short) \n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort(sortComparator).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(true), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        surface.offset = input.getPosition();\n        surface.length = scratch.length - surface.offset;\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(TermFreqIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    // analyzed sequence + 0(byte) + weight(int) + surface + analyzedLength(short) \n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort(sortComparator).sort(tempInput, tempSorted);\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(true), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        surface.offset = input.getPosition();\n        surface.length = scratch.length - surface.offset;\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":["cbc3688252d4a8045d69a164236b2cf87b721f17"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5a48377c9931ddb38c784846217ff68d7dcd0b44","date":1363202036,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","sourceNew":"  @Override\n  public void build(TermFreqIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    TermFreqPayloadIterator payloads;\n    if (iterator instanceof TermFreqPayloadIterator) {\n      payloads = (TermFreqPayloadIterator) iterator;\n    } else {\n      payloads = null;\n    }\n    hasPayloads = payloads != null;\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = payloads.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort(new AnalyzingComparator(payloads != null)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(true), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(TermFreqIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n    \n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    // analyzed sequence + 0(byte) + weight(int) + surface + analyzedLength(short) \n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort(sortComparator).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(true), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        surface.offset = input.getPosition();\n        surface.length = scratch.length - surface.offset;\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b1e6a1c51433ebaa34dc0b76d7ab1876072be39","date":1370266419,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","sourceNew":"  @Override\n  public void build(TermFreqIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    TermFreqPayloadIterator payloads;\n    if (iterator instanceof TermFreqPayloadIterator) {\n      payloads = (TermFreqPayloadIterator) iterator;\n    } else {\n      payloads = null;\n    }\n    hasPayloads = payloads != null;\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = payloads.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort(new AnalyzingComparator(payloads != null)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(TermFreqIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    TermFreqPayloadIterator payloads;\n    if (iterator instanceof TermFreqPayloadIterator) {\n      payloads = (TermFreqPayloadIterator) iterator;\n    } else {\n      payloads = null;\n    }\n    hasPayloads = payloads != null;\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = payloads.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort(new AnalyzingComparator(payloads != null)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(true), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ada2f7352a7f964fe49bccd13227c4ec38563d39","date":1381659982,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqPayloadIterator).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#build(TermFreqIterator).mjava","sourceNew":"  @Override\n  public void build(TermFreqPayloadIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    hasPayloads = iterator.hasPayloads();\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = iterator.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void build(TermFreqIterator iterator) throws IOException {\n    String prefix = getClass().getSimpleName();\n    File directory = Sort.defaultTempDir();\n    File tempInput = File.createTempFile(prefix, \".input\", directory);\n    File tempSorted = File.createTempFile(prefix, \".sorted\", directory);\n\n    TermFreqPayloadIterator payloads;\n    if (iterator instanceof TermFreqPayloadIterator) {\n      payloads = (TermFreqPayloadIterator) iterator;\n    } else {\n      payloads = null;\n    }\n    hasPayloads = payloads != null;\n\n    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);\n    Sort.ByteSequencesReader reader = null;\n    BytesRef scratch = new BytesRef();\n\n    TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();\n\n    boolean success = false;\n    byte buffer[] = new byte[8];\n    try {\n      ByteArrayDataOutput output = new ByteArrayDataOutput(buffer);\n      BytesRef surfaceForm;\n\n      while ((surfaceForm = iterator.next()) != null) {\n        Set<IntsRef> paths = toFiniteStrings(surfaceForm, ts2a);\n        \n        maxAnalyzedPathsForOneInput = Math.max(maxAnalyzedPathsForOneInput, paths.size());\n\n        for (IntsRef path : paths) {\n\n          Util.toBytesRef(path, scratch);\n          \n          // length of the analyzed text (FST input)\n          if (scratch.length > Short.MAX_VALUE-2) {\n            throw new IllegalArgumentException(\"cannot handle analyzed forms > \" + (Short.MAX_VALUE-2) + \" in length (got \" + scratch.length + \")\");\n          }\n          short analyzedLength = (short) scratch.length;\n\n          // compute the required length:\n          // analyzed sequence + weight (4) + surface + analyzedLength (short)\n          int requiredLength = analyzedLength + 4 + surfaceForm.length + 2;\n\n          BytesRef payload;\n\n          if (hasPayloads) {\n            if (surfaceForm.length > (Short.MAX_VALUE-2)) {\n              throw new IllegalArgumentException(\"cannot handle surface form > \" + (Short.MAX_VALUE-2) + \" in length (got \" + surfaceForm.length + \")\");\n            }\n            payload = payloads.payload();\n            // payload + surfaceLength (short)\n            requiredLength += payload.length + 2;\n          } else {\n            payload = null;\n          }\n          \n          buffer = ArrayUtil.grow(buffer, requiredLength);\n          \n          output.reset(buffer);\n\n          output.writeShort(analyzedLength);\n\n          output.writeBytes(scratch.bytes, scratch.offset, scratch.length);\n\n          output.writeInt(encodeWeight(iterator.weight()));\n\n          if (hasPayloads) {\n            for(int i=0;i<surfaceForm.length;i++) {\n              if (surfaceForm.bytes[i] == PAYLOAD_SEP) {\n                throw new IllegalArgumentException(\"surface form cannot contain unit separator character U+001F; this character is reserved\");\n              }\n            }\n            output.writeShort((short) surfaceForm.length);\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n            output.writeBytes(payload.bytes, payload.offset, payload.length);\n          } else {\n            output.writeBytes(surfaceForm.bytes, surfaceForm.offset, surfaceForm.length);\n          }\n\n          assert output.getPosition() == requiredLength: output.getPosition() + \" vs \" + requiredLength;\n\n          writer.write(buffer, 0, output.getPosition());\n        }\n      }\n      writer.close();\n\n      // Sort all input/output pairs (required by FST.Builder):\n      new Sort(new AnalyzingComparator(payloads != null)).sort(tempInput, tempSorted);\n\n      // Free disk space:\n      tempInput.delete();\n\n      reader = new Sort.ByteSequencesReader(tempSorted);\n     \n      PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());\n      Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);\n\n      // Build FST:\n      BytesRef previousAnalyzed = null;\n      BytesRef analyzed = new BytesRef();\n      BytesRef surface = new BytesRef();\n      IntsRef scratchInts = new IntsRef();\n      ByteArrayDataInput input = new ByteArrayDataInput();\n\n      // Used to remove duplicate surface forms (but we\n      // still index the hightest-weight one).  We clear\n      // this when we see a new analyzed form, so it cannot\n      // grow unbounded (at most 256 entries):\n      Set<BytesRef> seenSurfaceForms = new HashSet<BytesRef>();\n\n      int dedup = 0;\n      while (reader.read(scratch)) {\n        input.reset(scratch.bytes, scratch.offset, scratch.length);\n        short analyzedLength = input.readShort();\n        analyzed.grow(analyzedLength+2);\n        input.readBytes(analyzed.bytes, 0, analyzedLength);\n        analyzed.length = analyzedLength;\n\n        long cost = input.readInt();\n\n        surface.bytes = scratch.bytes;\n        if (hasPayloads) {\n          surface.length = input.readShort();\n          surface.offset = input.getPosition();\n        } else {\n          surface.offset = input.getPosition();\n          surface.length = scratch.length - surface.offset;\n        }\n        \n        if (previousAnalyzed == null) {\n          previousAnalyzed = new BytesRef();\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else if (analyzed.equals(previousAnalyzed)) {\n          dedup++;\n          if (dedup >= maxSurfaceFormsPerAnalyzedForm) {\n            // More than maxSurfaceFormsPerAnalyzedForm\n            // dups: skip the rest:\n            continue;\n          }\n          if (seenSurfaceForms.contains(surface)) {\n            continue;\n          }\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        } else {\n          dedup = 0;\n          previousAnalyzed.copyBytes(analyzed);\n          seenSurfaceForms.clear();\n          seenSurfaceForms.add(BytesRef.deepCopyOf(surface));\n        }\n\n        // TODO: I think we can avoid the extra 2 bytes when\n        // there is no dup (dedup==0), but we'd have to fix\n        // the exactFirst logic ... which would be sort of\n        // hairy because we'd need to special case the two\n        // (dup/not dup)...\n\n        // NOTE: must be byte 0 so we sort before whatever\n        // is next\n        analyzed.bytes[analyzed.offset+analyzed.length] = 0;\n        analyzed.bytes[analyzed.offset+analyzed.length+1] = (byte) dedup;\n        analyzed.length += 2;\n\n        Util.toIntsRef(analyzed, scratchInts);\n        //System.out.println(\"ADD: \" + scratchInts + \" -> \" + cost + \": \" + surface.utf8ToString());\n        if (!hasPayloads) {\n          builder.add(scratchInts, outputs.newPair(cost, BytesRef.deepCopyOf(surface)));\n        } else {\n          int payloadOffset = input.getPosition() + surface.length;\n          int payloadLength = scratch.length - payloadOffset;\n          BytesRef br = new BytesRef(surface.length + 1 + payloadLength);\n          System.arraycopy(surface.bytes, surface.offset, br.bytes, 0, surface.length);\n          br.bytes[surface.length] = PAYLOAD_SEP;\n          System.arraycopy(scratch.bytes, payloadOffset, br.bytes, surface.length+1, payloadLength);\n          br.length = br.bytes.length;\n          builder.add(scratchInts, outputs.newPair(cost, br));\n        }\n      }\n      fst = builder.finish();\n\n      //Util.dotToFile(fst, \"/tmp/suggest.dot\");\n      \n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(reader, writer);\n      } else {\n        IOUtils.closeWhileHandlingException(reader, writer);\n      }\n      \n      tempInput.delete();\n      tempSorted.delete();\n    }\n  }\n\n","bugFix":null,"bugIntro":["ba791bce8103c79e38f957e9c5a53a75871bd918"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"0c1a09d2dfe98662e5268acb84685b971e16daf1":["c784b25e28b81ddedff2b97738c8286773f00f15"],"414aae1db83a83d247caa9514e383e4ca3d43da5":["f903593885012bb5d79809c44cb6dfcebb4a2c66"],"6b1e6a1c51433ebaa34dc0b76d7ab1876072be39":["5a48377c9931ddb38c784846217ff68d7dcd0b44"],"c784b25e28b81ddedff2b97738c8286773f00f15":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b"],"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b":["414aae1db83a83d247caa9514e383e4ca3d43da5","62e52115b56781006682fd92c6938efaf174304d"],"62e52115b56781006682fd92c6938efaf174304d":["cc41b743423981e7ec17a024ce7e107096e472fe","414aae1db83a83d247caa9514e383e4ca3d43da5"],"cc41b743423981e7ec17a024ce7e107096e472fe":["f903593885012bb5d79809c44cb6dfcebb4a2c66"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5a48377c9931ddb38c784846217ff68d7dcd0b44":["0c1a09d2dfe98662e5268acb84685b971e16daf1"],"6ce825e9276493231308229152c48f755ce1a0a5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f903593885012bb5d79809c44cb6dfcebb4a2c66":["6ce825e9276493231308229152c48f755ce1a0a5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ada2f7352a7f964fe49bccd13227c4ec38563d39"],"ada2f7352a7f964fe49bccd13227c4ec38563d39":["6b1e6a1c51433ebaa34dc0b76d7ab1876072be39"]},"commit2Childs":{"0c1a09d2dfe98662e5268acb84685b971e16daf1":["5a48377c9931ddb38c784846217ff68d7dcd0b44"],"414aae1db83a83d247caa9514e383e4ca3d43da5":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","62e52115b56781006682fd92c6938efaf174304d"],"c784b25e28b81ddedff2b97738c8286773f00f15":["0c1a09d2dfe98662e5268acb84685b971e16daf1"],"6b1e6a1c51433ebaa34dc0b76d7ab1876072be39":["ada2f7352a7f964fe49bccd13227c4ec38563d39"],"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b":["c784b25e28b81ddedff2b97738c8286773f00f15"],"62e52115b56781006682fd92c6938efaf174304d":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b"],"cc41b743423981e7ec17a024ce7e107096e472fe":["62e52115b56781006682fd92c6938efaf174304d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6ce825e9276493231308229152c48f755ce1a0a5"],"5a48377c9931ddb38c784846217ff68d7dcd0b44":["6b1e6a1c51433ebaa34dc0b76d7ab1876072be39"],"6ce825e9276493231308229152c48f755ce1a0a5":["f903593885012bb5d79809c44cb6dfcebb4a2c66"],"f903593885012bb5d79809c44cb6dfcebb4a2c66":["414aae1db83a83d247caa9514e383e4ca3d43da5","cc41b743423981e7ec17a024ce7e107096e472fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"ada2f7352a7f964fe49bccd13227c4ec38563d39":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}