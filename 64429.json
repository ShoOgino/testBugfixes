{"path":"lucene/queryparser/src/java/org/apache/lucene/queryparser/simple/SimpleQueryParser#consumePhrase(State).mjava","commits":[{"id":"fdc91c6aee685b616507b9e44fcc69315b8a9e6c","date":1384275771,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/simple/SimpleQueryParser#consumePhrase(State).mjava","pathOld":"/dev/null","sourceNew":"  private void consumePhrase(State state) {\n    assert (flags & PHRASE_OPERATOR) != 0;\n    int start = ++state.index;\n    int copied = 0;\n    boolean escaped = false;\n\n    while (state.index < state.length) {\n      if (!escaped) {\n        if (state.data[state.index] == '\\\\' && (flags & ESCAPE_OPERATOR) != 0) {\n          // an escape character has been found so\n          // whatever character is next will become\n          // part of the phrase unless the escape\n          // character is the last one in the data\n          escaped = true;\n          ++state.index;\n\n          continue;\n        } else if (state.data[state.index] == '\"') {\n          // this should be the end of the phrase\n          // all characters found will used for\n          // creating the phrase query\n          break;\n        }\n      }\n\n      escaped = false;\n      state.buffer[copied++] = state.data[state.index++];\n    }\n\n    if (state.index == state.length) {\n      // a closing double quote was never found so the opening\n      // double quote is considered extraneous and will be ignored\n      state.index = start;\n    } else if (state.index == start) {\n      // a closing double quote was found immediately after the opening\n      // double quote so the current operation is reset since it would\n      // have been applied to this phrase\n      state.currentOperation = null;\n\n      ++state.index;\n    } else {\n      // a complete phrase has been found and is parsed through\n      // through the analyzer from the given field\n      String phrase = new String(state.buffer, 0, copied);\n      Query branch = newPhraseQuery(phrase);\n      buildQueryTree(state, branch);\n\n      ++state.index;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bae2070aa7aaff000145c4978276eb085e2ff279","date":1391309822,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/simple/SimpleQueryParser#consumePhrase(State).mjava","pathOld":"lucene/queryparser/src/java/org/apache/lucene/queryparser/simple/SimpleQueryParser#consumePhrase(State).mjava","sourceNew":"  private void consumePhrase(State state) {\n    assert (flags & PHRASE_OPERATOR) != 0;\n    int start = ++state.index;\n    int copied = 0;\n    boolean escaped = false;\n    boolean hasSlop = false;\n\n    while (state.index < state.length) {\n      if (!escaped) {\n        if (state.data[state.index] == '\\\\' && (flags & ESCAPE_OPERATOR) != 0) {\n          // an escape character has been found so\n          // whatever character is next will become\n          // part of the phrase unless the escape\n          // character is the last one in the data\n          escaped = true;\n          ++state.index;\n\n          continue;\n        } else if (state.data[state.index] == '\"') {\n          // if there are still characters after the closing \", check for a\n          // tilde\n          if (state.length > (state.index + 1) &&\n              state.data[state.index+1] == '~' &&\n              (flags & NEAR_OPERATOR) != 0) {\n            state.index++;\n            // check for characters after the tilde\n            if (state.length > (state.index + 1)) {\n              hasSlop = true;\n            }\n            break;\n          } else {\n            // this should be the end of the phrase\n            // all characters found will used for\n            // creating the phrase query\n            break;\n          }\n        }\n      }\n\n      escaped = false;\n      state.buffer[copied++] = state.data[state.index++];\n    }\n\n    if (state.index == state.length) {\n      // a closing double quote was never found so the opening\n      // double quote is considered extraneous and will be ignored\n      state.index = start;\n    } else if (state.index == start) {\n      // a closing double quote was found immediately after the opening\n      // double quote so the current operation is reset since it would\n      // have been applied to this phrase\n      state.currentOperation = null;\n\n      ++state.index;\n    } else {\n      // a complete phrase has been found and is parsed through\n      // through the analyzer from the given field\n      String phrase = new String(state.buffer, 0, copied);\n      Query branch;\n      if (hasSlop) {\n        branch = newPhraseQuery(phrase, parseFuzziness(state));\n      } else {\n        branch = newPhraseQuery(phrase, 0);\n      }\n      buildQueryTree(state, branch);\n\n      ++state.index;\n    }\n  }\n\n","sourceOld":"  private void consumePhrase(State state) {\n    assert (flags & PHRASE_OPERATOR) != 0;\n    int start = ++state.index;\n    int copied = 0;\n    boolean escaped = false;\n\n    while (state.index < state.length) {\n      if (!escaped) {\n        if (state.data[state.index] == '\\\\' && (flags & ESCAPE_OPERATOR) != 0) {\n          // an escape character has been found so\n          // whatever character is next will become\n          // part of the phrase unless the escape\n          // character is the last one in the data\n          escaped = true;\n          ++state.index;\n\n          continue;\n        } else if (state.data[state.index] == '\"') {\n          // this should be the end of the phrase\n          // all characters found will used for\n          // creating the phrase query\n          break;\n        }\n      }\n\n      escaped = false;\n      state.buffer[copied++] = state.data[state.index++];\n    }\n\n    if (state.index == state.length) {\n      // a closing double quote was never found so the opening\n      // double quote is considered extraneous and will be ignored\n      state.index = start;\n    } else if (state.index == start) {\n      // a closing double quote was found immediately after the opening\n      // double quote so the current operation is reset since it would\n      // have been applied to this phrase\n      state.currentOperation = null;\n\n      ++state.index;\n    } else {\n      // a complete phrase has been found and is parsed through\n      // through the analyzer from the given field\n      String phrase = new String(state.buffer, 0, copied);\n      Query branch = newPhraseQuery(phrase);\n      buildQueryTree(state, branch);\n\n      ++state.index;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bae2070aa7aaff000145c4978276eb085e2ff279":["fdc91c6aee685b616507b9e44fcc69315b8a9e6c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fdc91c6aee685b616507b9e44fcc69315b8a9e6c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bae2070aa7aaff000145c4978276eb085e2ff279"]},"commit2Childs":{"bae2070aa7aaff000145c4978276eb085e2ff279":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fdc91c6aee685b616507b9e44fcc69315b8a9e6c"],"fdc91c6aee685b616507b9e44fcc69315b8a9e6c":["bae2070aa7aaff000145c4978276eb085e2ff279"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}