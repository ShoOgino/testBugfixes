{"path":"solr/core/src/test/org/apache/solr/client/solrj/impl/ConnectionReuseTest#testConnectionReuse().mjava","commits":[{"id":"15fb22f207e0cbf913dbc9857b6a4fe30390a625","date":1475989569,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/client/solrj/impl/ConnectionReuseTest#testConnectionReuse().mjava","pathOld":"solr/core/src/test/org/apache/solr/client/solrj/ConnectionReuseTest#testConnectionReuse().mjava","sourceNew":"  @Test\n  public void testConnectionReuse() throws Exception {\n\n    URL url = cluster.getJettySolrRunners().get(0).getBaseUrl();\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try (SolrClient client = buildClient(httpClient, url)) {\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        boolean done = false;\n        for (int i = 0; i < cnt2; i++) {\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, HttpSolrClient.cacheKey);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    }\n    finally {\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testConnectionReuse() throws Exception {\n\n    URL url = cluster.getJettySolrRunners().get(0).getBaseUrl();\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try (SolrClient client = buildClient(httpClient, url)) {\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        boolean done = false;\n        for (int i = 0; i < cnt2; i++) {\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, null);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    }\n    finally {\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/client/solrj/impl/ConnectionReuseTest#testConnectionReuse().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testConnectionReuse() throws Exception {\n\n    URL url = cluster.getJettySolrRunners().get(0).getBaseUrl();\n    PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n\n    CloseableHttpClient httpClient = HttpClientUtil.createClient(null, cm);\n    try (SolrClient client = buildClient(httpClient, url)) {\n\n      HttpHost target = new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\");\n      HttpRoute route = new HttpRoute(target);\n\n      ConnectionRequest mConn = getClientConnectionRequest(httpClient, route, cm);\n\n      HttpClientConnection conn1 = getConn(mConn);\n      headerRequest(target, route, conn1, cm);\n\n      cm.releaseConnection(conn1, null, -1, TimeUnit.MILLISECONDS);\n\n      int queueBreaks = 0;\n      int cnt1 = atLeast(3);\n      int cnt2 = atLeast(30);\n      for (int j = 0; j < cnt1; j++) {\n        boolean done = false;\n        for (int i = 0; i < cnt2; i++) {\n          AddUpdateCommand c = new AddUpdateCommand(null);\n          c.solrDoc = sdoc(\"id\", id.incrementAndGet());\n          try {\n            client.add(c.solrDoc);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n          if (!done && i > 0 && i < cnt2 - 1 && client instanceof ConcurrentUpdateSolrClient\n              && random().nextInt(10) > 8) {\n            queueBreaks++;\n            done = true;\n            Thread.sleep(350); // wait past streaming client poll time of 250ms\n          }\n        }\n        if (client instanceof ConcurrentUpdateSolrClient) {\n          ((ConcurrentUpdateSolrClient) client).blockUntilFinished();\n        }\n      }\n\n      route = new HttpRoute(new HttpHost(url.getHost(), url.getPort(), isSSLMode() ? \"https\" : \"http\"));\n\n      mConn = cm.requestConnection(route, HttpSolrClient.cacheKey);\n\n      HttpClientConnection conn2 = getConn(mConn);\n\n      HttpConnectionMetrics metrics = conn2.getMetrics();\n      headerRequest(target, route, conn2, cm);\n\n      cm.releaseConnection(conn2, null, -1, TimeUnit.MILLISECONDS);\n\n      assertNotNull(\"No connection metrics found - is the connection getting aborted? server closing the connection? \"\n          + client.getClass().getSimpleName(), metrics);\n\n      // we try and make sure the connection we get has handled all of the requests in this test\n      if (client instanceof ConcurrentUpdateSolrClient) {\n        // we can't fully control queue polling breaking up requests - allow a bit of leeway\n        int exp = cnt1 + queueBreaks + 2;\n        assertTrue(\n            \"We expected all communication via streaming client to use one connection! expected=\" + exp + \" got=\"\n                + metrics.getRequestCount(),\n            Math.max(exp, metrics.getRequestCount()) - Math.min(exp, metrics.getRequestCount()) < 3);\n      } else {\n        assertTrue(\"We expected all communication to use one connection! \" + client.getClass().getSimpleName() + \" \"\n            + metrics.getRequestCount(),\n            cnt1 * cnt2 + 2 <= metrics.getRequestCount());\n      }\n\n    }\n    finally {\n      HttpClientUtil.close(httpClient);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"15fb22f207e0cbf913dbc9857b6a4fe30390a625":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","15fb22f207e0cbf913dbc9857b6a4fe30390a625"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["15fb22f207e0cbf913dbc9857b6a4fe30390a625"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["15fb22f207e0cbf913dbc9857b6a4fe30390a625","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"15fb22f207e0cbf913dbc9857b6a4fe30390a625":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}