{"path":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\r\n    // do this outside of the callable for thread safety reasons\r\n    final List<String> urls = getURLs(shard);\r\n\r\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\r\n      public ShardResponse call() throws Exception {\r\n\r\n        ShardResponse srsp = new ShardResponse();\r\n        srsp.setShardRequest(sreq);\r\n        srsp.setShard(shard);\r\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\r\n        srsp.setSolrResponse(ssr);\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        try {\r\n          params.remove(CommonParams.WT); // use default (currently javabin)\r\n          params.remove(CommonParams.VERSION);\r\n\r\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\r\n          // use generic request to avoid extra processing of queries\r\n          QueryRequest req = new QueryRequest(params);\r\n          req.setMethod(SolrRequest.METHOD.POST);\r\n\r\n          // no need to set the response parser as binary is the default\r\n          // req.setResponseParser(new BinaryResponseParser());\r\n\r\n          // if there are no shards available for a slice, urls.size()==0\r\n          if (urls.size()==0) {\r\n            // TODO: what's the right error code here? We should use the same thing when\r\n            // all of the servers for a shard are down.\r\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\r\n          }\r\n\r\n          if (urls.size() <= 1) {\r\n            String url = urls.get(0);\r\n            srsp.setShardAddress(url);\r\n            SolrServer server = new CommonsHttpSolrServer(url, httpShardHandlerFactory.client);\r\n            ssr.nl = server.request(req);\r\n          } else {\r\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\r\n            ssr.nl = rsp.getResponse();\r\n            srsp.setShardAddress(rsp.getServer());\r\n          }\r\n        } catch (Throwable th) {\r\n          srsp.setException(th);\r\n          if (th instanceof SolrException) {\r\n            srsp.setResponseCode(((SolrException)th).code());\r\n          } else {\r\n            srsp.setResponseCode(-1);\r\n          }\r\n        }\r\n\r\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\r\n\r\n        return srsp;\r\n      }\r\n    };\r\n\r\n    pending.add( completionService.submit(task) );\r\n  }\r\n\n","sourceOld":"  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\r\n    // do this outside of the callable for thread safety reasons\r\n    final List<String> urls = getURLs(shard);\r\n\r\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\r\n      public ShardResponse call() throws Exception {\r\n\r\n        ShardResponse srsp = new ShardResponse();\r\n        srsp.setShardRequest(sreq);\r\n        srsp.setShard(shard);\r\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\r\n        srsp.setSolrResponse(ssr);\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        try {\r\n          params.remove(CommonParams.WT); // use default (currently javabin)\r\n          params.remove(CommonParams.VERSION);\r\n\r\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\r\n          // use generic request to avoid extra processing of queries\r\n          QueryRequest req = new QueryRequest(params);\r\n          req.setMethod(SolrRequest.METHOD.POST);\r\n\r\n          // no need to set the response parser as binary is the default\r\n          // req.setResponseParser(new BinaryResponseParser());\r\n\r\n          // if there are no shards available for a slice, urls.size()==0\r\n          if (urls.size()==0) {\r\n            // TODO: what's the right error code here? We should use the same thing when\r\n            // all of the servers for a shard are down.\r\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\r\n          }\r\n\r\n          if (urls.size() <= 1) {\r\n            String url = urls.get(0);\r\n            srsp.setShardAddress(url);\r\n            SolrServer server = new CommonsHttpSolrServer(url, httpShardHandlerFactory.client);\r\n            ssr.nl = server.request(req);\r\n          } else {\r\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\r\n            ssr.nl = rsp.getResponse();\r\n            srsp.setShardAddress(rsp.getServer());\r\n          }\r\n        } catch (Throwable th) {\r\n          srsp.setException(th);\r\n          if (th instanceof SolrException) {\r\n            srsp.setResponseCode(((SolrException)th).code());\r\n          } else {\r\n            srsp.setResponseCode(-1);\r\n          }\r\n        }\r\n\r\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\r\n\r\n        return srsp;\r\n      }\r\n    };\r\n\r\n    pending.add( completionService.submit(task) );\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\r\n    // do this outside of the callable for thread safety reasons\r\n    final List<String> urls = getURLs(shard);\r\n\r\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\r\n      public ShardResponse call() throws Exception {\r\n\r\n        ShardResponse srsp = new ShardResponse();\r\n        srsp.setShardRequest(sreq);\r\n        srsp.setShard(shard);\r\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\r\n        srsp.setSolrResponse(ssr);\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        try {\r\n          params.remove(CommonParams.WT); // use default (currently javabin)\r\n          params.remove(CommonParams.VERSION);\r\n\r\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\r\n          // use generic request to avoid extra processing of queries\r\n          QueryRequest req = new QueryRequest(params);\r\n          req.setMethod(SolrRequest.METHOD.POST);\r\n\r\n          // no need to set the response parser as binary is the default\r\n          // req.setResponseParser(new BinaryResponseParser());\r\n\r\n          // if there are no shards available for a slice, urls.size()==0\r\n          if (urls.size()==0) {\r\n            // TODO: what's the right error code here? We should use the same thing when\r\n            // all of the servers for a shard are down.\r\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\r\n          }\r\n\r\n          if (urls.size() <= 1) {\r\n            String url = urls.get(0);\r\n            srsp.setShardAddress(url);\r\n            SolrServer server = new CommonsHttpSolrServer(url, httpShardHandlerFactory.client);\r\n            ssr.nl = server.request(req);\r\n          } else {\r\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\r\n            ssr.nl = rsp.getResponse();\r\n            srsp.setShardAddress(rsp.getServer());\r\n          }\r\n        } catch (Throwable th) {\r\n          srsp.setException(th);\r\n          if (th instanceof SolrException) {\r\n            srsp.setResponseCode(((SolrException)th).code());\r\n          } else {\r\n            srsp.setResponseCode(-1);\r\n          }\r\n        }\r\n\r\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\r\n\r\n        return srsp;\r\n      }\r\n    };\r\n\r\n    pending.add( completionService.submit(task) );\r\n  }\r\n\n","sourceOld":"  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\r\n    // do this outside of the callable for thread safety reasons\r\n    final List<String> urls = getURLs(shard);\r\n\r\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\r\n      public ShardResponse call() throws Exception {\r\n\r\n        ShardResponse srsp = new ShardResponse();\r\n        srsp.setShardRequest(sreq);\r\n        srsp.setShard(shard);\r\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\r\n        srsp.setSolrResponse(ssr);\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        try {\r\n          params.remove(CommonParams.WT); // use default (currently javabin)\r\n          params.remove(CommonParams.VERSION);\r\n\r\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\r\n          // use generic request to avoid extra processing of queries\r\n          QueryRequest req = new QueryRequest(params);\r\n          req.setMethod(SolrRequest.METHOD.POST);\r\n\r\n          // no need to set the response parser as binary is the default\r\n          // req.setResponseParser(new BinaryResponseParser());\r\n\r\n          // if there are no shards available for a slice, urls.size()==0\r\n          if (urls.size()==0) {\r\n            // TODO: what's the right error code here? We should use the same thing when\r\n            // all of the servers for a shard are down.\r\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\r\n          }\r\n\r\n          if (urls.size() <= 1) {\r\n            String url = urls.get(0);\r\n            srsp.setShardAddress(url);\r\n            SolrServer server = new CommonsHttpSolrServer(url, httpShardHandlerFactory.client);\r\n            ssr.nl = server.request(req);\r\n          } else {\r\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\r\n            ssr.nl = rsp.getResponse();\r\n            srsp.setShardAddress(rsp.getServer());\r\n          }\r\n        } catch (Throwable th) {\r\n          srsp.setException(th);\r\n          if (th instanceof SolrException) {\r\n            srsp.setResponseCode(((SolrException)th).code());\r\n          } else {\r\n            srsp.setResponseCode(-1);\r\n          }\r\n        }\r\n\r\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\r\n\r\n        return srsp;\r\n      }\r\n    };\r\n\r\n    pending.add( completionService.submit(task) );\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\r\n    // do this outside of the callable for thread safety reasons\r\n    final List<String> urls = getURLs(shard);\r\n\r\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\r\n      public ShardResponse call() throws Exception {\r\n\r\n        ShardResponse srsp = new ShardResponse();\r\n        srsp.setShardRequest(sreq);\r\n        srsp.setShard(shard);\r\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\r\n        srsp.setSolrResponse(ssr);\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        try {\r\n          params.remove(CommonParams.WT); // use default (currently javabin)\r\n          params.remove(CommonParams.VERSION);\r\n\r\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\r\n          // use generic request to avoid extra processing of queries\r\n          QueryRequest req = new QueryRequest(params);\r\n          req.setMethod(SolrRequest.METHOD.POST);\r\n\r\n          // no need to set the response parser as binary is the default\r\n          // req.setResponseParser(new BinaryResponseParser());\r\n\r\n          // if there are no shards available for a slice, urls.size()==0\r\n          if (urls.size()==0) {\r\n            // TODO: what's the right error code here? We should use the same thing when\r\n            // all of the servers for a shard are down.\r\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\r\n          }\r\n\r\n          if (urls.size() <= 1) {\r\n            String url = urls.get(0);\r\n            srsp.setShardAddress(url);\r\n            SolrServer server = new CommonsHttpSolrServer(url, httpShardHandlerFactory.client);\r\n            ssr.nl = server.request(req);\r\n          } else {\r\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\r\n            ssr.nl = rsp.getResponse();\r\n            srsp.setShardAddress(rsp.getServer());\r\n          }\r\n        } catch (Throwable th) {\r\n          srsp.setException(th);\r\n          if (th instanceof SolrException) {\r\n            srsp.setResponseCode(((SolrException)th).code());\r\n          } else {\r\n            srsp.setResponseCode(-1);\r\n          }\r\n        }\r\n\r\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\r\n\r\n        return srsp;\r\n      }\r\n    };\r\n\r\n    pending.add( completionService.submit(task) );\r\n  }\r\n\n","sourceOld":"  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\r\n    // do this outside of the callable for thread safety reasons\r\n    final List<String> urls = getURLs(shard);\r\n\r\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\r\n      public ShardResponse call() throws Exception {\r\n\r\n        ShardResponse srsp = new ShardResponse();\r\n        srsp.setShardRequest(sreq);\r\n        srsp.setShard(shard);\r\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\r\n        srsp.setSolrResponse(ssr);\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        try {\r\n          params.remove(CommonParams.WT); // use default (currently javabin)\r\n          params.remove(CommonParams.VERSION);\r\n\r\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\r\n          // use generic request to avoid extra processing of queries\r\n          QueryRequest req = new QueryRequest(params);\r\n          req.setMethod(SolrRequest.METHOD.POST);\r\n\r\n          // no need to set the response parser as binary is the default\r\n          // req.setResponseParser(new BinaryResponseParser());\r\n\r\n          // if there are no shards available for a slice, urls.size()==0\r\n          if (urls.size()==0) {\r\n            // TODO: what's the right error code here? We should use the same thing when\r\n            // all of the servers for a shard are down.\r\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\r\n          }\r\n\r\n          if (urls.size() <= 1) {\r\n            String url = urls.get(0);\r\n            srsp.setShardAddress(url);\r\n            SolrServer server = new CommonsHttpSolrServer(url, httpShardHandlerFactory.client);\r\n            ssr.nl = server.request(req);\r\n          } else {\r\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\r\n            ssr.nl = rsp.getResponse();\r\n            srsp.setShardAddress(rsp.getServer());\r\n          }\r\n        } catch (Throwable th) {\r\n          srsp.setException(th);\r\n          if (th instanceof SolrException) {\r\n            srsp.setResponseCode(((SolrException)th).code());\r\n          } else {\r\n            srsp.setResponseCode(-1);\r\n          }\r\n        }\r\n\r\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\r\n\r\n        return srsp;\r\n      }\r\n    };\r\n\r\n    pending.add( completionService.submit(task) );\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b834dd353486678973f4157b3ba402ac3a7ca88","date":1329782329,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\r\n    // do this outside of the callable for thread safety reasons\r\n    final List<String> urls = getURLs(shard);\r\n\r\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\r\n      public ShardResponse call() throws Exception {\r\n\r\n        ShardResponse srsp = new ShardResponse();\r\n        srsp.setShardRequest(sreq);\r\n        srsp.setShard(shard);\r\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\r\n        srsp.setSolrResponse(ssr);\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        try {\r\n          params.remove(CommonParams.WT); // use default (currently javabin)\r\n          params.remove(CommonParams.VERSION);\r\n\r\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\r\n          // use generic request to avoid extra processing of queries\r\n          QueryRequest req = new QueryRequest(params);\r\n          req.setMethod(SolrRequest.METHOD.POST);\r\n\r\n          // no need to set the response parser as binary is the default\r\n          // req.setResponseParser(new BinaryResponseParser());\r\n\r\n          // if there are no shards available for a slice, urls.size()==0\r\n          if (urls.size()==0) {\r\n            // TODO: what's the right error code here? We should use the same thing when\r\n            // all of the servers for a shard are down.\r\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\r\n          }\r\n\r\n          if (urls.size() <= 1) {\r\n            String url = urls.get(0);\r\n            srsp.setShardAddress(url);\r\n            SolrServer server = new CommonsHttpSolrServer(url, httpClient == null ? httpShardHandlerFactory.client : httpClient);\r\n            ssr.nl = server.request(req);\r\n          } else {\r\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\r\n            ssr.nl = rsp.getResponse();\r\n            srsp.setShardAddress(rsp.getServer());\r\n          }\r\n        } catch (Throwable th) {\r\n          srsp.setException(th);\r\n          if (th instanceof SolrException) {\r\n            srsp.setResponseCode(((SolrException)th).code());\r\n          } else {\r\n            srsp.setResponseCode(-1);\r\n          }\r\n        }\r\n\r\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\r\n\r\n        return srsp;\r\n      }\r\n    };\r\n\r\n    pending.add( completionService.submit(task) );\r\n  }\r\n\n","sourceOld":"  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\r\n    // do this outside of the callable for thread safety reasons\r\n    final List<String> urls = getURLs(shard);\r\n\r\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\r\n      public ShardResponse call() throws Exception {\r\n\r\n        ShardResponse srsp = new ShardResponse();\r\n        srsp.setShardRequest(sreq);\r\n        srsp.setShard(shard);\r\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\r\n        srsp.setSolrResponse(ssr);\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        try {\r\n          params.remove(CommonParams.WT); // use default (currently javabin)\r\n          params.remove(CommonParams.VERSION);\r\n\r\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\r\n          // use generic request to avoid extra processing of queries\r\n          QueryRequest req = new QueryRequest(params);\r\n          req.setMethod(SolrRequest.METHOD.POST);\r\n\r\n          // no need to set the response parser as binary is the default\r\n          // req.setResponseParser(new BinaryResponseParser());\r\n\r\n          // if there are no shards available for a slice, urls.size()==0\r\n          if (urls.size()==0) {\r\n            // TODO: what's the right error code here? We should use the same thing when\r\n            // all of the servers for a shard are down.\r\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\r\n          }\r\n\r\n          if (urls.size() <= 1) {\r\n            String url = urls.get(0);\r\n            srsp.setShardAddress(url);\r\n            SolrServer server = new CommonsHttpSolrServer(url, httpShardHandlerFactory.client);\r\n            ssr.nl = server.request(req);\r\n          } else {\r\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\r\n            ssr.nl = rsp.getResponse();\r\n            srsp.setShardAddress(rsp.getServer());\r\n          }\r\n        } catch (Throwable th) {\r\n          srsp.setException(th);\r\n          if (th instanceof SolrException) {\r\n            srsp.setResponseCode(((SolrException)th).code());\r\n          } else {\r\n            srsp.setResponseCode(-1);\r\n          }\r\n        }\r\n\r\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\r\n\r\n        return srsp;\r\n      }\r\n    };\r\n\r\n    pending.add( completionService.submit(task) );\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d66363068e87a246ce08fee4a42f30f126b92723","date":1329988051,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\r\n    // do this outside of the callable for thread safety reasons\r\n    final List<String> urls = getURLs(shard);\r\n\r\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\r\n      public ShardResponse call() throws Exception {\r\n\r\n        ShardResponse srsp = new ShardResponse();\r\n        srsp.setShardRequest(sreq);\r\n        srsp.setShard(shard);\r\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\r\n        srsp.setSolrResponse(ssr);\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        try {\r\n          params.remove(CommonParams.WT); // use default (currently javabin)\r\n          params.remove(CommonParams.VERSION);\r\n\r\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\r\n          // use generic request to avoid extra processing of queries\r\n          QueryRequest req = new QueryRequest(params);\r\n          req.setMethod(SolrRequest.METHOD.POST);\r\n\r\n          // no need to set the response parser as binary is the default\r\n          // req.setResponseParser(new BinaryResponseParser());\r\n\r\n          // if there are no shards available for a slice, urls.size()==0\r\n          if (urls.size()==0) {\r\n            // TODO: what's the right error code here? We should use the same thing when\r\n            // all of the servers for a shard are down.\r\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\r\n          }\r\n\r\n          if (urls.size() <= 1) {\r\n            String url = urls.get(0);\r\n            srsp.setShardAddress(url);\r\n            SolrServer server = new CommonsHttpSolrServer(url, httpClient == null ? httpShardHandlerFactory.client : httpClient);\r\n            ssr.nl = server.request(req);\r\n          } else {\r\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\r\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Throwable th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\r\n          } else {\r\n            srsp.setResponseCode(-1);\r\n          }\r\n        }\r\n\r\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\r\n\r\n        return srsp;\r\n      }\r\n    };\r\n\r\n    pending.add( completionService.submit(task) );\r\n  }\r\n\n","sourceOld":"  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\r\n    // do this outside of the callable for thread safety reasons\r\n    final List<String> urls = getURLs(shard);\r\n\r\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\r\n      public ShardResponse call() throws Exception {\r\n\r\n        ShardResponse srsp = new ShardResponse();\r\n        srsp.setShardRequest(sreq);\r\n        srsp.setShard(shard);\r\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\r\n        srsp.setSolrResponse(ssr);\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        try {\r\n          params.remove(CommonParams.WT); // use default (currently javabin)\r\n          params.remove(CommonParams.VERSION);\r\n\r\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\r\n          // use generic request to avoid extra processing of queries\r\n          QueryRequest req = new QueryRequest(params);\r\n          req.setMethod(SolrRequest.METHOD.POST);\r\n\r\n          // no need to set the response parser as binary is the default\r\n          // req.setResponseParser(new BinaryResponseParser());\r\n\r\n          // if there are no shards available for a slice, urls.size()==0\r\n          if (urls.size()==0) {\r\n            // TODO: what's the right error code here? We should use the same thing when\r\n            // all of the servers for a shard are down.\r\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\r\n          }\r\n\r\n          if (urls.size() <= 1) {\r\n            String url = urls.get(0);\r\n            srsp.setShardAddress(url);\r\n            SolrServer server = new CommonsHttpSolrServer(url, httpClient == null ? httpShardHandlerFactory.client : httpClient);\r\n            ssr.nl = server.request(req);\r\n          } else {\r\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\r\n            ssr.nl = rsp.getResponse();\r\n            srsp.setShardAddress(rsp.getServer());\r\n          }\r\n        } catch (Throwable th) {\r\n          srsp.setException(th);\r\n          if (th instanceof SolrException) {\r\n            srsp.setResponseCode(((SolrException)th).code());\r\n          } else {\r\n            srsp.setResponseCode(-1);\r\n          }\r\n        }\r\n\r\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\r\n\r\n        return srsp;\r\n      }\r\n    };\r\n\r\n    pending.add( completionService.submit(task) );\r\n  }\r\n\n","bugFix":null,"bugIntro":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\r\n    // do this outside of the callable for thread safety reasons\r\n    final List<String> urls = getURLs(shard);\r\n\r\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\r\n      public ShardResponse call() throws Exception {\r\n\r\n        ShardResponse srsp = new ShardResponse();\r\n        srsp.setShardRequest(sreq);\r\n        srsp.setShard(shard);\r\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\r\n        srsp.setSolrResponse(ssr);\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        try {\r\n          params.remove(CommonParams.WT); // use default (currently javabin)\r\n          params.remove(CommonParams.VERSION);\r\n\r\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\r\n          // use generic request to avoid extra processing of queries\r\n          QueryRequest req = new QueryRequest(params);\r\n          req.setMethod(SolrRequest.METHOD.POST);\r\n\r\n          // no need to set the response parser as binary is the default\r\n          // req.setResponseParser(new BinaryResponseParser());\r\n\r\n          // if there are no shards available for a slice, urls.size()==0\r\n          if (urls.size()==0) {\r\n            // TODO: what's the right error code here? We should use the same thing when\r\n            // all of the servers for a shard are down.\r\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\r\n          }\r\n\r\n          if (urls.size() <= 1) {\r\n            String url = urls.get(0);\r\n            srsp.setShardAddress(url);\r\n            SolrServer server = new CommonsHttpSolrServer(url, httpClient == null ? httpShardHandlerFactory.client : httpClient);\r\n            ssr.nl = server.request(req);\r\n          } else {\r\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\r\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Throwable th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\r\n          } else {\r\n            srsp.setResponseCode(-1);\r\n          }\r\n        }\r\n\r\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\r\n\r\n        return srsp;\r\n      }\r\n    };\r\n\r\n    pending.add( completionService.submit(task) );\r\n  }\r\n\n","sourceOld":"  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\r\n    // do this outside of the callable for thread safety reasons\r\n    final List<String> urls = getURLs(shard);\r\n\r\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\r\n      public ShardResponse call() throws Exception {\r\n\r\n        ShardResponse srsp = new ShardResponse();\r\n        srsp.setShardRequest(sreq);\r\n        srsp.setShard(shard);\r\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\r\n        srsp.setSolrResponse(ssr);\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        try {\r\n          params.remove(CommonParams.WT); // use default (currently javabin)\r\n          params.remove(CommonParams.VERSION);\r\n\r\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\r\n          // use generic request to avoid extra processing of queries\r\n          QueryRequest req = new QueryRequest(params);\r\n          req.setMethod(SolrRequest.METHOD.POST);\r\n\r\n          // no need to set the response parser as binary is the default\r\n          // req.setResponseParser(new BinaryResponseParser());\r\n\r\n          // if there are no shards available for a slice, urls.size()==0\r\n          if (urls.size()==0) {\r\n            // TODO: what's the right error code here? We should use the same thing when\r\n            // all of the servers for a shard are down.\r\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\r\n          }\r\n\r\n          if (urls.size() <= 1) {\r\n            String url = urls.get(0);\r\n            srsp.setShardAddress(url);\r\n            SolrServer server = new CommonsHttpSolrServer(url, httpShardHandlerFactory.client);\r\n            ssr.nl = server.request(req);\r\n          } else {\r\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\r\n            ssr.nl = rsp.getResponse();\r\n            srsp.setShardAddress(rsp.getServer());\r\n          }\r\n        } catch (Throwable th) {\r\n          srsp.setException(th);\r\n          if (th instanceof SolrException) {\r\n            srsp.setResponseCode(((SolrException)th).code());\r\n          } else {\r\n            srsp.setResponseCode(-1);\r\n          }\r\n        }\r\n\r\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\r\n\r\n        return srsp;\r\n      }\r\n    };\r\n\r\n    pending.add( completionService.submit(task) );\r\n  }\r\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d76dfc2581b6998f72c0e749c6200e9c2432c36f","date":1332788228,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.currentTimeMillis();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrServer server = new CommonsHttpSolrServer(url, httpClient == null ? httpShardHandlerFactory.client : httpClient);\n            ssr.nl = server.request(req);\n          } else {\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Throwable th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","sourceOld":"  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\r\n    // do this outside of the callable for thread safety reasons\r\n    final List<String> urls = getURLs(shard);\r\n\r\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\r\n      public ShardResponse call() throws Exception {\r\n\r\n        ShardResponse srsp = new ShardResponse();\r\n        srsp.setShardRequest(sreq);\r\n        srsp.setShard(shard);\r\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\r\n        srsp.setSolrResponse(ssr);\r\n        long startTime = System.currentTimeMillis();\r\n\r\n        try {\r\n          params.remove(CommonParams.WT); // use default (currently javabin)\r\n          params.remove(CommonParams.VERSION);\r\n\r\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\r\n          // use generic request to avoid extra processing of queries\r\n          QueryRequest req = new QueryRequest(params);\r\n          req.setMethod(SolrRequest.METHOD.POST);\r\n\r\n          // no need to set the response parser as binary is the default\r\n          // req.setResponseParser(new BinaryResponseParser());\r\n\r\n          // if there are no shards available for a slice, urls.size()==0\r\n          if (urls.size()==0) {\r\n            // TODO: what's the right error code here? We should use the same thing when\r\n            // all of the servers for a shard are down.\r\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\r\n          }\r\n\r\n          if (urls.size() <= 1) {\r\n            String url = urls.get(0);\r\n            srsp.setShardAddress(url);\r\n            SolrServer server = new CommonsHttpSolrServer(url, httpClient == null ? httpShardHandlerFactory.client : httpClient);\r\n            ssr.nl = server.request(req);\r\n          } else {\r\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\r\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Throwable th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\r\n          } else {\r\n            srsp.setResponseCode(-1);\r\n          }\r\n        }\r\n\r\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\r\n\r\n        return srsp;\r\n      }\r\n    };\r\n\r\n    pending.add( completionService.submit(task) );\r\n  }\r\n\n","bugFix":null,"bugIntro":["51b92ffe30c50bb08699200b62c40420378ac3df","51b92ffe30c50bb08699200b62c40420378ac3df"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7321b77a7bc3edfebd637ef273e9dfaa9969eba6","date":1333023097,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.currentTimeMillis();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrServer server = new HttpSolrServer(url, httpClient == null ? httpShardHandlerFactory.client : httpClient);\n            ssr.nl = server.request(req);\n          } else {\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Throwable th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","sourceOld":"  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.currentTimeMillis();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrServer server = new CommonsHttpSolrServer(url, httpClient == null ? httpShardHandlerFactory.client : httpClient);\n            ssr.nl = server.request(req);\n          } else {\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Throwable th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eb99886ff640d94edb43e0d36112a2b7023379ba","date":1338292884,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.currentTimeMillis();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrServer server = new HttpSolrServer(url, httpClient);\n            ssr.nl = server.request(req);\n          } else {\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Throwable th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","sourceOld":"  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.currentTimeMillis();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrServer server = new HttpSolrServer(url, httpClient == null ? httpShardHandlerFactory.client : httpClient);\n            ssr.nl = server.request(req);\n          } else {\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Throwable th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.currentTimeMillis();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrServer server = new HttpSolrServer(url, httpClient);\n            ssr.nl = server.request(req);\n          } else {\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Throwable th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","sourceOld":"  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.currentTimeMillis();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrServer server = new HttpSolrServer(url, httpClient);\n            ssr.nl = server.request(req);\n          } else {\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Throwable th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.currentTimeMillis();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrServer server = new HttpSolrServer(url, httpClient);\n            ssr.nl = server.request(req);\n          } else {\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Throwable th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","sourceOld":"  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.currentTimeMillis();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrServer server = new HttpSolrServer(url, httpClient);\n            ssr.nl = server.request(req);\n          } else {\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Throwable th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe999fc2d95d6fea71f960bf9556858387ba21f5","date":1363294860,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.currentTimeMillis();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrServer server = new HttpSolrServer(url, httpClient);\n            ssr.nl = server.request(req);\n          } else {\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Throwable th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.currentTimeMillis();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrServer server = new HttpSolrServer(url, httpClient);\n            ssr.nl = server.request(req);\n          } else {\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Throwable th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"241163c8f5d129a8327eb3950d20bb4f065b8a14","date":1363612901,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.currentTimeMillis();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrServer server = new HttpSolrServer(url, httpClient);\n            ssr.nl = server.request(req);\n          } else {\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Throwable th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.currentTimeMillis();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrServer server = new HttpSolrServer(url, httpClient);\n            ssr.nl = server.request(req);\n          } else {\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.loadbalancer.request(new LBHttpSolrServer.Req(req, urls));\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Throwable th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2d750082a4223c20902ef11ff6a9831d55738ea4","date":1382309916,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.currentTimeMillis();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrServer server = new HttpSolrServer(url, httpClient);\n            try {\n              ssr.nl = server.request(req);\n            } finally {\n              server.shutdown();\n            }\n          } else {\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Throwable th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.currentTimeMillis();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrServer server = new HttpSolrServer(url, httpClient);\n            ssr.nl = server.request(req);\n          } else {\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Throwable th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.currentTimeMillis();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrServer server = new HttpSolrServer(url, httpClient);\n            try {\n              ssr.nl = server.request(req);\n            } finally {\n              server.shutdown();\n            }\n          } else {\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.currentTimeMillis();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrServer server = new HttpSolrServer(url, httpClient);\n            try {\n              ssr.nl = server.request(req);\n            } finally {\n              server.shutdown();\n            }\n          } else {\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Throwable th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","bugFix":["d66363068e87a246ce08fee4a42f30f126b92723"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fd5bc858b8426d40bbe90b94120ead37c77d7954","date":1393812525,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrServer server = new HttpSolrServer(url, httpClient);\n            try {\n              ssr.nl = server.request(req);\n            } finally {\n              server.shutdown();\n            }\n          } else {\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.currentTimeMillis();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrServer server = new HttpSolrServer(url, httpClient);\n            try {\n              ssr.nl = server.request(req);\n            } finally {\n              server.shutdown();\n            }\n          } else {\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = System.currentTimeMillis() - startTime;\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrClient client = new HttpSolrClient(url, httpClient);\n            try {\n              ssr.nl = client.request(req);\n            } finally {\n              client.shutdown();\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrServer server = new HttpSolrServer(url, httpClient);\n            try {\n              ssr.nl = server.request(req);\n            } finally {\n              server.shutdown();\n            }\n          } else {\n            LBHttpSolrServer.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc3b13b430571c2e169f98fe38e1e7666f88522d","date":1422446157,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n              ssr.nl = client.request(req);\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            SolrClient client = new HttpSolrClient(url, httpClient);\n            try {\n              ssr.nl = client.request(req);\n            } finally {\n              client.shutdown();\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"51b92ffe30c50bb08699200b62c40420378ac3df","date":1423881454,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(sreq, shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n              ssr.nl = client.request(req);\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n              ssr.nl = client.request(req);\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","bugFix":["d76dfc2581b6998f72c0e749c6200e9c2432c36f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bc766d645fa848f86c381c7f6acf2c881c99399","date":1425549246,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(sreq, shard);\n    if (Strings.isNullOrEmpty(shard))\n      System.out.println(\"Empty shard!\");\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n              ssr.nl = client.request(req);\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(sreq, shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n              ssr.nl = client.request(req);\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(sreq, shard);\n    if (Strings.isNullOrEmpty(shard))\n      System.out.println(\"Empty shard!\");\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n              ssr.nl = client.request(req);\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(sreq, shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n              ssr.nl = client.request(req);\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"00c74d0f104801c1a740ef3c4a899dba5cf0111d","date":1427848663,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(sreq, shard);\n    if (Strings.isNullOrEmpty(shard))\n      System.out.println(\"Empty shard!\");\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          QueryRequest req = makeQueryRequest(sreq, params, shard);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n              ssr.nl = client.request(req);\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return transfomResponse(sreq, srsp, shard);\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(sreq, shard);\n    if (Strings.isNullOrEmpty(shard))\n      System.out.println(\"Empty shard!\");\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n              ssr.nl = client.request(req);\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fab172655716b96f7e42376116235017a922de3a","date":1427850611,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(sreq, shard);\n    if (Strings.isNullOrEmpty(shard))\n      System.out.println(\"Empty shard!\");\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          QueryRequest req = makeQueryRequest(sreq, params, shard);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n              ssr.nl = client.request(req);\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return transfomResponse(sreq, srsp, shard);\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(sreq, shard);\n    if (Strings.isNullOrEmpty(shard))\n      System.out.println(\"Empty shard!\");\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          // SolrRequest req = new QueryRequest(SolrRequest.METHOD.POST, \"/select\");\n          // use generic request to avoid extra processing of queries\n          QueryRequest req = new QueryRequest(params);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n              ssr.nl = client.request(req);\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return srsp;\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9e592c966d0093ed8a86ed2f58e94967d159ab01","date":1428930334,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(sreq, shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          QueryRequest req = makeQueryRequest(sreq, params, shard);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n              ssr.nl = client.request(req);\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return transfomResponse(sreq, srsp, shard);\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(sreq, shard);\n    if (Strings.isNullOrEmpty(shard))\n      System.out.println(\"Empty shard!\");\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          QueryRequest req = makeQueryRequest(sreq, params, shard);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n              ssr.nl = client.request(req);\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return transfomResponse(sreq, srsp, shard);\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a96b173f2f573ac82bc8279dfdd3cbe2b948f95","date":1429031018,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(sreq, shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          QueryRequest req = makeQueryRequest(sreq, params, shard);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n              ssr.nl = client.request(req);\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return transfomResponse(sreq, srsp, shard);\n      }\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(sreq, shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          QueryRequest req = makeQueryRequest(sreq, params, shard);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n              ssr.nl = client.request(req);\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return transfomResponse(sreq, srsp, shard);\n      }\n    };\n\n    pending.add( completionService.submit(task) );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23e55c29de60130e8a1226800b66c5f6d7e16e8a","date":1447950053,"type":5,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params, String preferredHostAddress) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard, preferredHostAddress);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          QueryRequest req = makeQueryRequest(sreq, params, shard);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n              ssr.nl = client.request(req);\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return transfomResponse(sreq, srsp, shard);\n      }\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(sreq, shard);\n\n    Callable<ShardResponse> task = new Callable<ShardResponse>() {\n      @Override\n      public ShardResponse call() throws Exception {\n\n        ShardResponse srsp = new ShardResponse();\n        if (sreq.nodeName != null) {\n          srsp.setNodeName(sreq.nodeName);\n        }\n        srsp.setShardRequest(sreq);\n        srsp.setShard(shard);\n        SimpleSolrResponse ssr = new SimpleSolrResponse();\n        srsp.setSolrResponse(ssr);\n        long startTime = System.nanoTime();\n\n        try {\n          params.remove(CommonParams.WT); // use default (currently javabin)\n          params.remove(CommonParams.VERSION);\n\n          QueryRequest req = makeQueryRequest(sreq, params, shard);\n          req.setMethod(SolrRequest.METHOD.POST);\n\n          // no need to set the response parser as binary is the default\n          // req.setResponseParser(new BinaryResponseParser());\n\n          // if there are no shards available for a slice, urls.size()==0\n          if (urls.size()==0) {\n            // TODO: what's the right error code here? We should use the same thing when\n            // all of the servers for a shard are down.\n            throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n          }\n\n          if (urls.size() <= 1) {\n            String url = urls.get(0);\n            srsp.setShardAddress(url);\n            try (SolrClient client = new HttpSolrClient(url, httpClient)) {\n              ssr.nl = client.request(req);\n            }\n          } else {\n            LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n            ssr.nl = rsp.getResponse();\n            srsp.setShardAddress(rsp.getServer());\n          }\n        }\n        catch( ConnectException cex ) {\n          srsp.setException(cex); //????\n        } catch (Exception th) {\n          srsp.setException(th);\n          if (th instanceof SolrException) {\n            srsp.setResponseCode(((SolrException)th).code());\n          } else {\n            srsp.setResponseCode(-1);\n          }\n        }\n\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n        return transfomResponse(sreq, srsp, shard);\n      }\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"304ef848381e39ff6cf3e7af6127733a6f4db389","date":1482353305,"type":1,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams,String).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        req.setMethod(SolrRequest.METHOD.POST);\n\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          try (SolrClient client = new Builder(url).withHttpClient(httpClient).build()) {\n            ssr.nl = client.request(req);\n          }\n        } else {\n          LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params, String preferredHostAddress) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard, preferredHostAddress);\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        req.setMethod(SolrRequest.METHOD.POST);\n\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          try (SolrClient client = new Builder(url).withHttpClient(httpClient).build()) {\n            ssr.nl = client.request(req);\n          }\n        } else {\n          LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        req.setMethod(SolrRequest.METHOD.POST);\n\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          try (SolrClient client = new Builder(url).withHttpClient(httpClient).build()) {\n            ssr.nl = client.request(req);\n          }\n        } else {\n          LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4bb519c79b76e52145e37b6681a7012525ed5f4b","date":1544694716,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        req.setMethod(SolrRequest.METHOD.POST);\n        SolrRequestInfo requestInfo = SolrRequestInfo.getRequestInfo();\n        if (requestInfo != null) req.setUserPrincipal(requestInfo.getReq().getUserPrincipal());\n\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          try (SolrClient client = new Builder(url).withHttpClient(httpClient).build()) {\n            ssr.nl = client.request(req);\n          }\n        } else {\n          LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        req.setMethod(SolrRequest.METHOD.POST);\n\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          try (SolrClient client = new Builder(url).withHttpClient(httpClient).build()) {\n            ssr.nl = client.request(req);\n          }\n        } else {\n          LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1a77e5e21cbd575a8240b0e3926164f15295f4e8","date":1544979500,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        req.setMethod(SolrRequest.METHOD.POST);\n        SolrRequestInfo requestInfo = SolrRequestInfo.getRequestInfo();\n        if (requestInfo != null) req.setUserPrincipal(requestInfo.getReq().getUserPrincipal());\n\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          ssr.nl = request(url, req);\n        } else {\n          LBSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        req.setMethod(SolrRequest.METHOD.POST);\n        SolrRequestInfo requestInfo = SolrRequestInfo.getRequestInfo();\n        if (requestInfo != null) req.setUserPrincipal(requestInfo.getReq().getUserPrincipal());\n\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          try (SolrClient client = new Builder(url).withHttpClient(httpClient).build()) {\n            ssr.nl = client.request(req);\n          }\n        } else {\n          LBHttpSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5794254fa05b066ccd00251bd2c010660e3bad4","date":1548565331,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        req.setMethod(SolrRequest.METHOD.POST);\n        SolrRequestInfo requestInfo = SolrRequestInfo.getRequestInfo();\n        if (requestInfo != null) req.setUserPrincipal(requestInfo.getReq().getUserPrincipal());\n\n        if (sreq.purpose == PURPOSE_GET_FIELDS) {\n          req.setResponseParser(READ_STR_AS_CHARSEQ_PARSER);\n        }\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          ssr.nl = request(url, req);\n        } else {\n          LBSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        req.setMethod(SolrRequest.METHOD.POST);\n        SolrRequestInfo requestInfo = SolrRequestInfo.getRequestInfo();\n        if (requestInfo != null) req.setUserPrincipal(requestInfo.getReq().getUserPrincipal());\n\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          ssr.nl = request(url, req);\n        } else {\n          LBSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cbaf96cfda5422c42955ce34344f0e01839894ea","date":1559675051,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n    final Tracer tracer = GlobalTracer.getTracer();\n    final Span span = tracer != null? tracer.activeSpan() : null;\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        if (tracer != null && span != null) {\n          tracer.inject(span.context(), Format.Builtin.HTTP_HEADERS, new SolrRequestCarrier(req));\n        }\n        req.setMethod(SolrRequest.METHOD.POST);\n        SolrRequestInfo requestInfo = SolrRequestInfo.getRequestInfo();\n        if (requestInfo != null) req.setUserPrincipal(requestInfo.getReq().getUserPrincipal());\n\n        if (sreq.purpose == PURPOSE_GET_FIELDS) {\n          req.setResponseParser(READ_STR_AS_CHARSEQ_PARSER);\n        }\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          ssr.nl = request(url, req);\n        } else {\n          LBSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        req.setMethod(SolrRequest.METHOD.POST);\n        SolrRequestInfo requestInfo = SolrRequestInfo.getRequestInfo();\n        if (requestInfo != null) req.setUserPrincipal(requestInfo.getReq().getUserPrincipal());\n\n        if (sreq.purpose == PURPOSE_GET_FIELDS) {\n          req.setResponseParser(READ_STR_AS_CHARSEQ_PARSER);\n        }\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          ssr.nl = request(url, req);\n        } else {\n          LBSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3665b66adafb1514bba04cd1d5c477fcaa93d592","date":1576153597,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n    final Tracer tracer = GlobalTracer.getTracer();\n    final Span span = tracer != null? tracer.activeSpan() : null;\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        if (tracer != null && span != null) {\n          tracer.inject(span.context(), Format.Builtin.HTTP_HEADERS, new SolrRequestCarrier(req));\n        }\n        req.setMethod(SolrRequest.METHOD.POST);\n        SolrRequestInfo requestInfo = SolrRequestInfo.getRequestInfo();\n        if (requestInfo != null) req.setUserPrincipal(requestInfo.getReq().getUserPrincipal());\n\n        // no need to set the response parser as binary is the defaultJab\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          ssr.nl = request(url, req);\n        } else {\n          LBSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n    final Tracer tracer = GlobalTracer.getTracer();\n    final Span span = tracer != null? tracer.activeSpan() : null;\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        if (tracer != null && span != null) {\n          tracer.inject(span.context(), Format.Builtin.HTTP_HEADERS, new SolrRequestCarrier(req));\n        }\n        req.setMethod(SolrRequest.METHOD.POST);\n        SolrRequestInfo requestInfo = SolrRequestInfo.getRequestInfo();\n        if (requestInfo != null) req.setUserPrincipal(requestInfo.getReq().getUserPrincipal());\n\n        if (sreq.purpose == PURPOSE_GET_FIELDS) {\n          req.setResponseParser(READ_STR_AS_CHARSEQ_PARSER);\n        }\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          ssr.nl = request(url, req);\n        } else {\n          LBSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df724d84dab24a0cc54bec95a8680867adc7f171","date":1576156608,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n    final Tracer tracer = GlobalTracer.getTracer();\n    final Span span = tracer != null? tracer.activeSpan() : null;\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        if (tracer != null && span != null) {\n          tracer.inject(span.context(), Format.Builtin.HTTP_HEADERS, new SolrRequestCarrier(req));\n        }\n        req.setMethod(SolrRequest.METHOD.POST);\n        SolrRequestInfo requestInfo = SolrRequestInfo.getRequestInfo();\n        if (requestInfo != null) req.setUserPrincipal(requestInfo.getReq().getUserPrincipal());\n\n        // no need to set the response parser as binary is the defaultJab\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          ssr.nl = request(url, req);\n        } else {\n          LBSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n    final Tracer tracer = GlobalTracer.getTracer();\n    final Span span = tracer != null? tracer.activeSpan() : null;\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        if (tracer != null && span != null) {\n          tracer.inject(span.context(), Format.Builtin.HTTP_HEADERS, new SolrRequestCarrier(req));\n        }\n        req.setMethod(SolrRequest.METHOD.POST);\n        SolrRequestInfo requestInfo = SolrRequestInfo.getRequestInfo();\n        if (requestInfo != null) req.setUserPrincipal(requestInfo.getReq().getUserPrincipal());\n\n        if (sreq.purpose == PURPOSE_GET_FIELDS) {\n          req.setResponseParser(READ_STR_AS_CHARSEQ_PARSER);\n        }\n        // no need to set the response parser as binary is the default\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          ssr.nl = request(url, req);\n        } else {\n          LBSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc28b46d62a8b91c8e90f9345612c4050eab98d4","date":1581344825,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n    final Tracer tracer = GlobalTracer.getTracer();\n    final Span span = tracer != null ? tracer.activeSpan() : null;\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        if (tracer != null && span != null) {\n          tracer.inject(span.context(), Format.Builtin.HTTP_HEADERS, new SolrRequestCarrier(req));\n        }\n        req.setMethod(SolrRequest.METHOD.POST);\n        SolrRequestInfo requestInfo = SolrRequestInfo.getRequestInfo();\n        if (requestInfo != null) req.setUserPrincipal(requestInfo.getReq().getUserPrincipal());\n\n        // no need to set the response parser as binary is the defaultJab\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size() == 0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          ssr.nl = request(url, req);\n        } else {\n          LBSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      } catch (ConnectException cex) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException) th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null) {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty()) {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add(completionService.submit(task));\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n    final Tracer tracer = GlobalTracer.getTracer();\n    final Span span = tracer != null? tracer.activeSpan() : null;\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        if (tracer != null && span != null) {\n          tracer.inject(span.context(), Format.Builtin.HTTP_HEADERS, new SolrRequestCarrier(req));\n        }\n        req.setMethod(SolrRequest.METHOD.POST);\n        SolrRequestInfo requestInfo = SolrRequestInfo.getRequestInfo();\n        if (requestInfo != null) req.setUserPrincipal(requestInfo.getReq().getUserPrincipal());\n\n        // no need to set the response parser as binary is the defaultJab\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size()==0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          ssr.nl = request(url, req);\n        } else {\n          LBSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      }\n      catch( ConnectException cex ) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException)th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null)  {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty())  {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add( completionService.submit(task) );\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6df9c9814bf0485db9001f5d37a2528bfc5f1970","date":1591077658,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    ShardRequestor shardRequestor = new ShardRequestor(sreq, shard, params, this);\n    try {\n      shardRequestor.init();\n      pending.add(completionService.submit(shardRequestor));\n    } finally {\n      shardRequestor.end();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n    final Tracer tracer = GlobalTracer.getTracer();\n    final Span span = tracer != null ? tracer.activeSpan() : null;\n\n    Callable<ShardResponse> task = () -> {\n\n      ShardResponse srsp = new ShardResponse();\n      if (sreq.nodeName != null) {\n        srsp.setNodeName(sreq.nodeName);\n      }\n      srsp.setShardRequest(sreq);\n      srsp.setShard(shard);\n      SimpleSolrResponse ssr = new SimpleSolrResponse();\n      srsp.setSolrResponse(ssr);\n      long startTime = System.nanoTime();\n\n      try {\n        params.remove(CommonParams.WT); // use default (currently javabin)\n        params.remove(CommonParams.VERSION);\n\n        QueryRequest req = makeQueryRequest(sreq, params, shard);\n        if (tracer != null && span != null) {\n          tracer.inject(span.context(), Format.Builtin.HTTP_HEADERS, new SolrRequestCarrier(req));\n        }\n        req.setMethod(SolrRequest.METHOD.POST);\n        SolrRequestInfo requestInfo = SolrRequestInfo.getRequestInfo();\n        if (requestInfo != null) req.setUserPrincipal(requestInfo.getReq().getUserPrincipal());\n\n        // no need to set the response parser as binary is the defaultJab\n        // req.setResponseParser(new BinaryResponseParser());\n\n        // if there are no shards available for a slice, urls.size()==0\n        if (urls.size() == 0) {\n          // TODO: what's the right error code here? We should use the same thing when\n          // all of the servers for a shard are down.\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n        }\n\n        if (urls.size() <= 1) {\n          String url = urls.get(0);\n          srsp.setShardAddress(url);\n          ssr.nl = request(url, req);\n        } else {\n          LBSolrClient.Rsp rsp = httpShardHandlerFactory.makeLoadBalancedRequest(req, urls);\n          ssr.nl = rsp.getResponse();\n          srsp.setShardAddress(rsp.getServer());\n        }\n      } catch (ConnectException cex) {\n        srsp.setException(cex); //????\n      } catch (Exception th) {\n        srsp.setException(th);\n        if (th instanceof SolrException) {\n          srsp.setResponseCode(((SolrException) th).code());\n        } else {\n          srsp.setResponseCode(-1);\n        }\n      }\n\n      ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n\n      return transfomResponse(sreq, srsp, shard);\n    };\n\n    try {\n      if (shard != null) {\n        MDC.put(\"ShardRequest.shards\", shard);\n      }\n      if (urls != null && !urls.isEmpty()) {\n        MDC.put(\"ShardRequest.urlList\", urls.toString());\n      }\n      pending.add(completionService.submit(task));\n    } finally {\n      MDC.remove(\"ShardRequest.shards\");\n      MDC.remove(\"ShardRequest.urlList\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1964c059f45ae1de1877f9f0fe3ca327ea4218e8","date":1594088246,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#submit(ShardRequest,String,ModifiableSolrParams).mjava","sourceNew":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    // do this outside of the callable for thread safety reasons\n    final List<String> urls = getURLs(shard);\n    final Tracer tracer = GlobalTracer.getTracer();\n    final Span span = tracer != null ? tracer.activeSpan() : null;\n\n    params.remove(CommonParams.WT); // use default (currently javabin)\n    params.remove(CommonParams.VERSION);\n    QueryRequest req = makeQueryRequest(sreq, params, shard);\n    req.setMethod(SolrRequest.METHOD.POST);\n\n    LBSolrClient.Req lbReq = httpShardHandlerFactory.newLBHttpSolrClientReq(req, urls);\n\n    ShardResponse srsp = new ShardResponse();\n    if (sreq.nodeName != null) {\n      srsp.setNodeName(sreq.nodeName);\n    }\n    srsp.setShardRequest(sreq);\n    srsp.setShard(shard);\n    SimpleSolrResponse ssr = new SimpleSolrResponse();\n    srsp.setSolrResponse(ssr);\n\n    pending.incrementAndGet();\n    // if there are no shards available for a slice, urls.size()==0\n    if (urls.size() == 0) {\n      // TODO: what's the right error code here? We should use the same thing when\n      // all of the servers for a shard are down.\n      SolrException exception = new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n      srsp.setException(exception);\n      srsp.setResponseCode(exception.code());\n      responses.add(srsp);\n      return;\n    }\n\n    // all variables that set inside this listener must be at least volatile\n    responseCancellableMap.put(srsp, this.lbClient.asyncReq(lbReq, new AsyncListener<>() {\n      volatile long startTime = System.nanoTime();\n\n      @Override\n      public void onStart() {\n        if (tracer != null && span != null) {\n          tracer.inject(span.context(), Format.Builtin.HTTP_HEADERS, new SolrRequestCarrier(req));\n        }\n        SolrRequestInfo requestInfo = SolrRequestInfo.getRequestInfo();\n        if (requestInfo != null) req.setUserPrincipal(requestInfo.getReq().getUserPrincipal());\n      }\n\n      @Override\n      public void onSuccess(LBSolrClient.Rsp rsp) {\n        ssr.nl = rsp.getResponse();\n        srsp.setShardAddress(rsp.getServer());\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n        responses.add(srsp);\n      }\n\n      public void onFailure(Throwable throwable) {\n        ssr.elapsedTime = TimeUnit.MILLISECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);\n        srsp.setException(throwable);\n        if (throwable instanceof SolrException) {\n          srsp.setResponseCode(((SolrException) throwable).code());\n        }\n        responses.add(srsp);\n      }\n    }));\n  }\n\n","sourceOld":"  @Override\n  public void submit(final ShardRequest sreq, final String shard, final ModifiableSolrParams params) {\n    ShardRequestor shardRequestor = new ShardRequestor(sreq, shard, params, this);\n    try {\n      shardRequestor.init();\n      pending.add(completionService.submit(shardRequestor));\n    } finally {\n      shardRequestor.end();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["eb99886ff640d94edb43e0d36112a2b7023379ba","7530de27b87b961b51f01bd1299b7004d46e8823"],"4bb519c79b76e52145e37b6681a7012525ed5f4b":["304ef848381e39ff6cf3e7af6127733a6f4db389"],"1964c059f45ae1de1877f9f0fe3ca327ea4218e8":["6df9c9814bf0485db9001f5d37a2528bfc5f1970"],"6a96b173f2f573ac82bc8279dfdd3cbe2b948f95":["9e592c966d0093ed8a86ed2f58e94967d159ab01"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["c26f00b574427b55127e869b935845554afde1fa","d66363068e87a246ce08fee4a42f30f126b92723"],"6b834dd353486678973f4157b3ba402ac3a7ca88":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"9bc766d645fa848f86c381c7f6acf2c881c99399":["51b92ffe30c50bb08699200b62c40420378ac3df"],"6df9c9814bf0485db9001f5d37a2528bfc5f1970":["cc28b46d62a8b91c8e90f9345612c4050eab98d4"],"bafca15d8e408346a67f4282ad1143b88023893b":["fd5bc858b8426d40bbe90b94120ead37c77d7954"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"df724d84dab24a0cc54bec95a8680867adc7f171":["cbaf96cfda5422c42955ce34344f0e01839894ea","3665b66adafb1514bba04cd1d5c477fcaa93d592"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["51b92ffe30c50bb08699200b62c40420378ac3df","9bc766d645fa848f86c381c7f6acf2c881c99399"],"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["4bb519c79b76e52145e37b6681a7012525ed5f4b"],"9e592c966d0093ed8a86ed2f58e94967d159ab01":["00c74d0f104801c1a740ef3c4a899dba5cf0111d"],"b5794254fa05b066ccd00251bd2c010660e3bad4":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cc28b46d62a8b91c8e90f9345612c4050eab98d4":["3665b66adafb1514bba04cd1d5c477fcaa93d592"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["bafca15d8e408346a67f4282ad1143b88023893b"],"00c74d0f104801c1a740ef3c4a899dba5cf0111d":["9bc766d645fa848f86c381c7f6acf2c881c99399"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["2d750082a4223c20902ef11ff6a9831d55738ea4"],"fab172655716b96f7e42376116235017a922de3a":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","00c74d0f104801c1a740ef3c4a899dba5cf0111d"],"d66363068e87a246ce08fee4a42f30f126b92723":["6b834dd353486678973f4157b3ba402ac3a7ca88"],"51b92ffe30c50bb08699200b62c40420378ac3df":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"3665b66adafb1514bba04cd1d5c477fcaa93d592":["cbaf96cfda5422c42955ce34344f0e01839894ea"],"d76dfc2581b6998f72c0e749c6200e9c2432c36f":["d66363068e87a246ce08fee4a42f30f126b92723"],"7321b77a7bc3edfebd637ef273e9dfaa9969eba6":["d76dfc2581b6998f72c0e749c6200e9c2432c36f"],"304ef848381e39ff6cf3e7af6127733a6f4db389":["23e55c29de60130e8a1226800b66c5f6d7e16e8a"],"eb99886ff640d94edb43e0d36112a2b7023379ba":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["23e55c29de60130e8a1226800b66c5f6d7e16e8a","304ef848381e39ff6cf3e7af6127733a6f4db389"],"fe999fc2d95d6fea71f960bf9556858387ba21f5":["7530de27b87b961b51f01bd1299b7004d46e8823"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cbaf96cfda5422c42955ce34344f0e01839894ea":["b5794254fa05b066ccd00251bd2c010660e3bad4"],"2d750082a4223c20902ef11ff6a9831d55738ea4":["241163c8f5d129a8327eb3950d20bb4f065b8a14"],"241163c8f5d129a8327eb3950d20bb4f065b8a14":["fe999fc2d95d6fea71f960bf9556858387ba21f5"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"23e55c29de60130e8a1226800b66c5f6d7e16e8a":["6a96b173f2f573ac82bc8279dfdd3cbe2b948f95"],"7530de27b87b961b51f01bd1299b7004d46e8823":["eb99886ff640d94edb43e0d36112a2b7023379ba"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1964c059f45ae1de1877f9f0fe3ca327ea4218e8"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"4bb519c79b76e52145e37b6681a7012525ed5f4b":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"1964c059f45ae1de1877f9f0fe3ca327ea4218e8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6a96b173f2f573ac82bc8279dfdd3cbe2b948f95":["23e55c29de60130e8a1226800b66c5f6d7e16e8a"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"6b834dd353486678973f4157b3ba402ac3a7ca88":["d66363068e87a246ce08fee4a42f30f126b92723"],"c26f00b574427b55127e869b935845554afde1fa":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","6b834dd353486678973f4157b3ba402ac3a7ca88"],"9bc766d645fa848f86c381c7f6acf2c881c99399":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","00c74d0f104801c1a740ef3c4a899dba5cf0111d"],"6df9c9814bf0485db9001f5d37a2528bfc5f1970":["1964c059f45ae1de1877f9f0fe3ca327ea4218e8"],"bafca15d8e408346a67f4282ad1143b88023893b":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["bafca15d8e408346a67f4282ad1143b88023893b"],"df724d84dab24a0cc54bec95a8680867adc7f171":[],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["fab172655716b96f7e42376116235017a922de3a"],"9e592c966d0093ed8a86ed2f58e94967d159ab01":["6a96b173f2f573ac82bc8279dfdd3cbe2b948f95"],"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["b5794254fa05b066ccd00251bd2c010660e3bad4"],"b5794254fa05b066ccd00251bd2c010660e3bad4":["cbaf96cfda5422c42955ce34344f0e01839894ea"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"cc28b46d62a8b91c8e90f9345612c4050eab98d4":["6df9c9814bf0485db9001f5d37a2528bfc5f1970"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["51b92ffe30c50bb08699200b62c40420378ac3df"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["fd5bc858b8426d40bbe90b94120ead37c77d7954"],"00c74d0f104801c1a740ef3c4a899dba5cf0111d":["9e592c966d0093ed8a86ed2f58e94967d159ab01","fab172655716b96f7e42376116235017a922de3a"],"fab172655716b96f7e42376116235017a922de3a":[],"d66363068e87a246ce08fee4a42f30f126b92723":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","d76dfc2581b6998f72c0e749c6200e9c2432c36f"],"51b92ffe30c50bb08699200b62c40420378ac3df":["9bc766d645fa848f86c381c7f6acf2c881c99399","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"3665b66adafb1514bba04cd1d5c477fcaa93d592":["df724d84dab24a0cc54bec95a8680867adc7f171","cc28b46d62a8b91c8e90f9345612c4050eab98d4"],"d76dfc2581b6998f72c0e749c6200e9c2432c36f":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"7321b77a7bc3edfebd637ef273e9dfaa9969eba6":["eb99886ff640d94edb43e0d36112a2b7023379ba"],"304ef848381e39ff6cf3e7af6127733a6f4db389":["4bb519c79b76e52145e37b6681a7012525ed5f4b","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"eb99886ff640d94edb43e0d36112a2b7023379ba":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[],"fe999fc2d95d6fea71f960bf9556858387ba21f5":["241163c8f5d129a8327eb3950d20bb4f065b8a14"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"cbaf96cfda5422c42955ce34344f0e01839894ea":["df724d84dab24a0cc54bec95a8680867adc7f171","3665b66adafb1514bba04cd1d5c477fcaa93d592"],"2d750082a4223c20902ef11ff6a9831d55738ea4":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"241163c8f5d129a8327eb3950d20bb4f065b8a14":["2d750082a4223c20902ef11ff6a9831d55738ea4"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","fe999fc2d95d6fea71f960bf9556858387ba21f5"],"23e55c29de60130e8a1226800b66c5f6d7e16e8a":["304ef848381e39ff6cf3e7af6127733a6f4db389","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","df724d84dab24a0cc54bec95a8680867adc7f171","fab172655716b96f7e42376116235017a922de3a","f03e4bed5023ec3ef93a771b8888cae991cf448d","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}