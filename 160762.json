{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottingTesterAction#process(AutoScaling.TriggerEvent).mjava","commits":[{"id":"009caa80830ac6369c42e5f6515405d686eabfee","date":1494487120,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottingTesterAction#process(AutoScaling.TriggerEvent).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void process(AutoScaling.TriggerEvent event) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        if (lastActionExecutedAt.get() != 0)  {\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" nano time = \" + System.nanoTime());\n          if (System.nanoTime() - lastActionExecutedAt.get() < TimeUnit.NANOSECONDS.convert(ScheduledTriggers.DEFAULT_MIN_MS_BETWEEN_ACTIONS - DELTA_MS, TimeUnit.MILLISECONDS)) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource().getName());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource().getName());\n          lastActionExecutedAt.set(System.nanoTime());\n          triggerFiredLatch.countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource().getName());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        if (locked) {\n          lock.unlock();\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"464244264804e3f981bf1fb4b732516d8d62dbc2","date":1495736161,"type":5,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottingTesterAction#process(AutoScaling.TriggerEvent).mjava","sourceNew":"    @Override\n    public void process(TriggerEvent event) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        if (lastActionExecutedAt.get() != 0)  {\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" time = \" + timeSource.getTime());\n          if (TimeUnit.MILLISECONDS.convert(timeSource.getTime() - lastActionExecutedAt.get(), TimeUnit.NANOSECONDS) < ScheduledTriggers.DEFAULT_MIN_MS_BETWEEN_ACTIONS - DELTA_MS) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource());\n          lastActionExecutedAt.set(timeSource.getTime());\n          getTriggerFiredLatch().countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        if (locked) {\n          lock.unlock();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void process(AutoScaling.TriggerEvent event) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        if (lastActionExecutedAt.get() != 0)  {\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" nano time = \" + System.nanoTime());\n          if (System.nanoTime() - lastActionExecutedAt.get() < TimeUnit.NANOSECONDS.convert(ScheduledTriggers.DEFAULT_MIN_MS_BETWEEN_ACTIONS - DELTA_MS, TimeUnit.MILLISECONDS)) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource().getName());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource().getName());\n          lastActionExecutedAt.set(System.nanoTime());\n          triggerFiredLatch.countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource().getName());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        if (locked) {\n          lock.unlock();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c","65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5531f16a602ef350b6c9adfb08ebaa13a60fe3db","date":1495756318,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottlingTesterAction#process(TriggerEvent).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest.ThrottingTesterAction#process(AutoScaling.TriggerEvent).mjava","sourceNew":"    @Override\n    public void process(TriggerEvent event) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        if (lastActionExecutedAt.get() != 0)  {\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" time = \" + timeSource.getTime());\n          if (TimeUnit.MILLISECONDS.convert(timeSource.getTime() - lastActionExecutedAt.get(), TimeUnit.NANOSECONDS) < ScheduledTriggers.DEFAULT_MIN_MS_BETWEEN_ACTIONS - DELTA_MS) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource());\n          lastActionExecutedAt.set(timeSource.getTime());\n          getTriggerFiredLatch().countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        if (locked) {\n          lock.unlock();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void process(AutoScaling.TriggerEvent event) {\n      boolean locked = lock.tryLock();\n      if (!locked)  {\n        log.info(\"We should never have a tryLock fail because actions are never supposed to be executed concurrently\");\n        return;\n      }\n      try {\n        if (lastActionExecutedAt.get() != 0)  {\n          log.info(\"last action at \" + lastActionExecutedAt.get() + \" nano time = \" + System.nanoTime());\n          if (System.nanoTime() - lastActionExecutedAt.get() < TimeUnit.NANOSECONDS.convert(ScheduledTriggers.DEFAULT_MIN_MS_BETWEEN_ACTIONS - DELTA_MS, TimeUnit.MILLISECONDS)) {\n            log.info(\"action executed again before minimum wait time from {}\", event.getSource().getName());\n            fail(\"TriggerListener was fired before the throttling period\");\n          }\n        }\n        if (onlyOnce.compareAndSet(false, true)) {\n          log.info(\"action executed from {}\", event.getSource().getName());\n          lastActionExecutedAt.set(System.nanoTime());\n          triggerFiredLatch.countDown();\n        } else  {\n          log.info(\"action executed more than once from {}\", event.getSource().getName());\n          fail(\"Trigger should not have fired more than once!\");\n        }\n      } finally {\n        if (locked) {\n          lock.unlock();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"5531f16a602ef350b6c9adfb08ebaa13a60fe3db":["009caa80830ac6369c42e5f6515405d686eabfee","464244264804e3f981bf1fb4b732516d8d62dbc2"],"009caa80830ac6369c42e5f6515405d686eabfee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"464244264804e3f981bf1fb4b732516d8d62dbc2":["009caa80830ac6369c42e5f6515405d686eabfee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"5531f16a602ef350b6c9adfb08ebaa13a60fe3db":[],"009caa80830ac6369c42e5f6515405d686eabfee":["5531f16a602ef350b6c9adfb08ebaa13a60fe3db","464244264804e3f981bf1fb4b732516d8d62dbc2"],"464244264804e3f981bf1fb4b732516d8d62dbc2":["5531f16a602ef350b6c9adfb08ebaa13a60fe3db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["009caa80830ac6369c42e5f6515405d686eabfee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5531f16a602ef350b6c9adfb08ebaa13a60fe3db","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}