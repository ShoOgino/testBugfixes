{"path":"lucene/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","commits":[{"id":"8be6e1e4fbbc94d90b78f175c03ff389b6949373","date":1306674752,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":1,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    //System.out.println(\"\\nFST ADD: input=\" + input + \" output=\" + fst.outputs.outputToString(output));\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      //System.out.println(\"  incr \" + pos1);\n      frontier[pos1].inputCount++;\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    compilePrevTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      //System.out.println(\"  incr tail \" + idx);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e6e919043fa85ee891123768dd655a98edbbf63c","date":1322225413,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copy(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3be20ca1091c0b7cdb2308b9023606a5e451cec","date":1327877325,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"817882884229bace7dc5d1b75f6b0e4aa1e47122","date":1327879145,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b6fdfce35d0adb18836cf8711abe487a934df33","date":1327946200,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["8be6e1e4fbbc94d90b78f175c03ff389b6949373"],"8be6e1e4fbbc94d90b78f175c03ff389b6949373":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b3be20ca1091c0b7cdb2308b9023606a5e451cec":["e6e919043fa85ee891123768dd655a98edbbf63c"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":["e6e919043fa85ee891123768dd655a98edbbf63c","b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8be6e1e4fbbc94d90b78f175c03ff389b6949373"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5b6fdfce35d0adb18836cf8711abe487a934df33":["e6e919043fa85ee891123768dd655a98edbbf63c","b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"e6e919043fa85ee891123768dd655a98edbbf63c":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8be6e1e4fbbc94d90b78f175c03ff389b6949373"]},"commit2Childs":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["e6e919043fa85ee891123768dd655a98edbbf63c"],"8be6e1e4fbbc94d90b78f175c03ff389b6949373":["60ba444201d2570214b6fcf1d15600dc1a01f548","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"b3be20ca1091c0b7cdb2308b9023606a5e451cec":["817882884229bace7dc5d1b75f6b0e4aa1e47122","3a119bbc8703c10faa329ec201c654b3a35a1e3e","5b6fdfce35d0adb18836cf8711abe487a934df33"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":[],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8be6e1e4fbbc94d90b78f175c03ff389b6949373","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"5b6fdfce35d0adb18836cf8711abe487a934df33":[],"e6e919043fa85ee891123768dd655a98edbbf63c":["b3be20ca1091c0b7cdb2308b9023606a5e451cec","817882884229bace7dc5d1b75f6b0e4aa1e47122","5b6fdfce35d0adb18836cf8711abe487a934df33"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[]},"heads":["817882884229bace7dc5d1b75f6b0e4aa1e47122","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","5b6fdfce35d0adb18836cf8711abe487a934df33","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}