{"path":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","sourceNew":"  void parseParams(String type, String param) throws ParseException, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    base = docs;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) return;\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      base = searcher.getDocSet(qlist);\n    }\n\n  }\n\n","sourceOld":"  void parseParams(String type, String param) throws ParseException, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    base = docs;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) return;\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      base = searcher.getDocSet(qlist);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","sourceNew":"  void parseParams(String type, String param) throws ParseException, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    base = docs;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) return;\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      base = searcher.getDocSet(qlist);\n    }\n\n  }\n\n","sourceOld":"  void parseParams(String type, String param) throws ParseException, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    base = docs;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) return;\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      base = searcher.getDocSet(qlist);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","pathOld":"solr/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","sourceNew":"  void parseParams(String type, String param) throws ParseException, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    base = docs;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) return;\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      base = searcher.getDocSet(qlist);\n    }\n\n  }\n\n","sourceOld":"  void parseParams(String type, String param) throws ParseException, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    base = docs;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) return;\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      base = searcher.getDocSet(qlist);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8af6befbf8d7be9538fb4fb8a9d64a1aff18e772","date":1316691408,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","sourceNew":"  void parseParams(String type, String param) throws ParseException, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    base = docs;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) return;\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.base = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        int maxDoc = searcher.maxDoc();\n        FixedBitSet fixedBitSet = allGroupHeadsCollector.retrieveGroupHeads(maxDoc);\n        long[] bits = fixedBitSet.getBits();\n        this.base = new BitDocSet(new OpenBitSet(bits, bits.length));\n      } else {\n        this.base = base;\n      }\n    }\n\n  }\n\n","sourceOld":"  void parseParams(String type, String param) throws ParseException, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    base = docs;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) return;\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      base = searcher.getDocSet(qlist);\n    }\n\n  }\n\n","bugFix":["9cb179b2fab2183d2f6041e450ff8022c592ecf0"],"bugIntro":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a2ba67a463f52915e77a5fd8714aa7d36faf59c","date":1348538193,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","sourceNew":"  protected void parseParams(String type, String param) throws ParseException, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) return;\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        int maxDoc = searcher.maxDoc();\n        FixedBitSet fixedBitSet = allGroupHeadsCollector.retrieveGroupHeads(maxDoc);\n        long[] bits = fixedBitSet.getBits();\n        this.docs = new BitDocSet(new OpenBitSet(bits, bits.length));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","sourceOld":"  void parseParams(String type, String param) throws ParseException, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    base = docs;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) return;\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.base = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        int maxDoc = searcher.maxDoc();\n        FixedBitSet fixedBitSet = allGroupHeadsCollector.retrieveGroupHeads(maxDoc);\n        long[] bits = fixedBitSet.getBits();\n        this.base = new BitDocSet(new OpenBitSet(bits, bits.length));\n      } else {\n        this.base = base;\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3cdb67100dc016748799a77218aa409478372d79","date":1353699950,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","sourceNew":"  protected void parseParams(String type, String param) throws SyntaxError, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) return;\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        int maxDoc = searcher.maxDoc();\n        FixedBitSet fixedBitSet = allGroupHeadsCollector.retrieveGroupHeads(maxDoc);\n        long[] bits = fixedBitSet.getBits();\n        this.docs = new BitDocSet(new OpenBitSet(bits, bits.length));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","sourceOld":"  protected void parseParams(String type, String param) throws ParseException, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) return;\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        int maxDoc = searcher.maxDoc();\n        FixedBitSet fixedBitSet = allGroupHeadsCollector.retrieveGroupHeads(maxDoc);\n        long[] bits = fixedBitSet.getBits();\n        this.docs = new BitDocSet(new OpenBitSet(bits, bits.length));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","sourceNew":"  protected void parseParams(String type, String param) throws SyntaxError, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) return;\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        int maxDoc = searcher.maxDoc();\n        FixedBitSet fixedBitSet = allGroupHeadsCollector.retrieveGroupHeads(maxDoc);\n        long[] bits = fixedBitSet.getBits();\n        this.docs = new BitDocSet(new OpenBitSet(bits, bits.length));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","sourceOld":"  protected void parseParams(String type, String param) throws ParseException, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) return;\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        int maxDoc = searcher.maxDoc();\n        FixedBitSet fixedBitSet = allGroupHeadsCollector.retrieveGroupHeads(maxDoc);\n        long[] bits = fixedBitSet.getBits();\n        this.docs = new BitDocSet(new OpenBitSet(bits, bits.length));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a60b2c00832877c72a25bdbc0d81b07acf758fc","date":1358853997,"type":3,"author":"Koji Sekiguchi","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","sourceNew":"  protected void parseParams(String type, String param) throws SyntaxError, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) return;\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        grouping.setGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        int maxDoc = searcher.maxDoc();\n        FixedBitSet fixedBitSet = allGroupHeadsCollector.retrieveGroupHeads(maxDoc);\n        long[] bits = fixedBitSet.getBits();\n        this.docs = new BitDocSet(new OpenBitSet(bits, bits.length));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","sourceOld":"  protected void parseParams(String type, String param) throws SyntaxError, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) return;\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        int maxDoc = searcher.maxDoc();\n        FixedBitSet fixedBitSet = allGroupHeadsCollector.retrieveGroupHeads(maxDoc);\n        long[] bits = fixedBitSet.getBits();\n        this.docs = new BitDocSet(new OpenBitSet(bits, bits.length));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b2d5244a676b83c2d551c3746e8181588ba619e1","date":1359031414,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","sourceNew":"  protected void parseParams(String type, String param) throws SyntaxError, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) return;\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        grouping.setGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        int maxDoc = searcher.maxDoc();\n        FixedBitSet fixedBitSet = allGroupHeadsCollector.retrieveGroupHeads(maxDoc);\n        long[] bits = fixedBitSet.getBits();\n        this.docs = new BitDocSet(new OpenBitSet(bits, bits.length));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","sourceOld":"  protected void parseParams(String type, String param) throws SyntaxError, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) return;\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        int maxDoc = searcher.maxDoc();\n        FixedBitSet fixedBitSet = allGroupHeadsCollector.retrieveGroupHeads(maxDoc);\n        long[] bits = fixedBitSet.getBits();\n        this.docs = new BitDocSet(new OpenBitSet(bits, bits.length));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f5684d5cdbe0dc30849f6baef278a1f5efe9d52","date":1366128824,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","sourceNew":"  protected void parseParams(String type, String param) throws SyntaxError, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) {\n      return;\n    }\n    params = SolrParams.wrapDefaults(localParams, orig);\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        grouping.setGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        int maxDoc = searcher.maxDoc();\n        FixedBitSet fixedBitSet = allGroupHeadsCollector.retrieveGroupHeads(maxDoc);\n        long[] bits = fixedBitSet.getBits();\n        this.docs = new BitDocSet(new OpenBitSet(bits, bits.length));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","sourceOld":"  protected void parseParams(String type, String param) throws SyntaxError, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) return;\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        grouping.setGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        int maxDoc = searcher.maxDoc();\n        FixedBitSet fixedBitSet = allGroupHeadsCollector.retrieveGroupHeads(maxDoc);\n        long[] bits = fixedBitSet.getBits();\n        this.docs = new BitDocSet(new OpenBitSet(bits, bits.length));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"309bb934ccf1b9733206e54bd15a143b6a198889","date":1366132561,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","sourceNew":"  protected void parseParams(String type, String param) throws SyntaxError, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) {\n      return;\n    }\n    params = SolrParams.wrapDefaults(localParams, orig);\n    required = new RequiredSolrParams(params);\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        grouping.setGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        int maxDoc = searcher.maxDoc();\n        FixedBitSet fixedBitSet = allGroupHeadsCollector.retrieveGroupHeads(maxDoc);\n        long[] bits = fixedBitSet.getBits();\n        this.docs = new BitDocSet(new OpenBitSet(bits, bits.length));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","sourceOld":"  protected void parseParams(String type, String param) throws SyntaxError, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) {\n      return;\n    }\n    params = SolrParams.wrapDefaults(localParams, orig);\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        grouping.setGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        int maxDoc = searcher.maxDoc();\n        FixedBitSet fixedBitSet = allGroupHeadsCollector.retrieveGroupHeads(maxDoc);\n        long[] bits = fixedBitSet.getBits();\n        this.docs = new BitDocSet(new OpenBitSet(bits, bits.length));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f29c962d2a19abc63339cd093c2c0f234fc763e8","date":1369157614,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","sourceNew":"  protected void parseParams(String type, String param) throws SyntaxError, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) {\n      params = orig;\n      required = new RequiredSolrParams(params);\n      return;\n    }\n    params = SolrParams.wrapDefaults(localParams, orig);\n    required = new RequiredSolrParams(params);\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        grouping.setGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        int maxDoc = searcher.maxDoc();\n        FixedBitSet fixedBitSet = allGroupHeadsCollector.retrieveGroupHeads(maxDoc);\n        long[] bits = fixedBitSet.getBits();\n        this.docs = new BitDocSet(new OpenBitSet(bits, bits.length));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","sourceOld":"  protected void parseParams(String type, String param) throws SyntaxError, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) {\n      return;\n    }\n    params = SolrParams.wrapDefaults(localParams, orig);\n    required = new RequiredSolrParams(params);\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        grouping.setGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        int maxDoc = searcher.maxDoc();\n        FixedBitSet fixedBitSet = allGroupHeadsCollector.retrieveGroupHeads(maxDoc);\n        long[] bits = fixedBitSet.getBits();\n        this.docs = new BitDocSet(new OpenBitSet(bits, bits.length));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a69cf7f1b4cac5d5b1363402b565cd535f13e6a1","date":1392536197,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","sourceNew":"  protected void parseParams(String type, String param) throws SyntaxError, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) {\n      params = orig;\n      required = new RequiredSolrParams(params);\n      return;\n    }\n    params = SolrParams.wrapDefaults(localParams, orig);\n    required = new RequiredSolrParams(params);\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        grouping.setGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        this.docs = new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","sourceOld":"  protected void parseParams(String type, String param) throws SyntaxError, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) {\n      params = orig;\n      required = new RequiredSolrParams(params);\n      return;\n    }\n    params = SolrParams.wrapDefaults(localParams, orig);\n    required = new RequiredSolrParams(params);\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        grouping.setGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        int maxDoc = searcher.maxDoc();\n        FixedBitSet fixedBitSet = allGroupHeadsCollector.retrieveGroupHeads(maxDoc);\n        long[] bits = fixedBitSet.getBits();\n        this.docs = new BitDocSet(new OpenBitSet(bits, bits.length));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","sourceNew":"  protected void parseParams(String type, String param) throws SyntaxError, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) {\n      params = orig;\n      required = new RequiredSolrParams(params);\n      return;\n    }\n    params = SolrParams.wrapDefaults(localParams, orig);\n    required = new RequiredSolrParams(params);\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        grouping.setGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        this.docs = new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","sourceOld":"  protected void parseParams(String type, String param) throws SyntaxError, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) {\n      params = orig;\n      required = new RequiredSolrParams(params);\n      return;\n    }\n    params = SolrParams.wrapDefaults(localParams, orig);\n    required = new RequiredSolrParams(params);\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<Query,Boolean>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<Query>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        grouping.setGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        this.docs = new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc","date":1424799790,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","sourceNew":"  protected void parseParams(String type, String param) throws SyntaxError, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) {\n      params = orig;\n      required = new RequiredSolrParams(params);\n      return;\n    }\n    params = SolrParams.wrapDefaults(localParams, orig);\n    required = new RequiredSolrParams(params);\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        grouping.setGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new FilteredQuery(new MatchAllDocsQuery(), base.getTopFilter()), allGroupHeadsCollector);\n        this.docs = new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","sourceOld":"  protected void parseParams(String type, String param) throws SyntaxError, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) {\n      params = orig;\n      required = new RequiredSolrParams(params);\n      return;\n    }\n    params = SolrParams.wrapDefaults(localParams, orig);\n    required = new RequiredSolrParams(params);\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        grouping.setGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new MatchAllDocsQuery(), base.getTopFilter(), allGroupHeadsCollector);\n        this.docs = new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1db68e96dd908fcd79ef809095822736aa601d08","date":1434630596,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","sourceNew":"  protected void parseParams(String type, String param) throws SyntaxError, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) {\n      params = orig;\n      required = new RequiredSolrParams(params);\n      return;\n    }\n    params = SolrParams.wrapDefaults(localParams, orig);\n    required = new RequiredSolrParams(params);\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        grouping.setGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n        this.docs = new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","sourceOld":"  protected void parseParams(String type, String param) throws SyntaxError, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) {\n      params = orig;\n      required = new RequiredSolrParams(params);\n      return;\n    }\n    params = SolrParams.wrapDefaults(localParams, orig);\n    required = new RequiredSolrParams(params);\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        grouping.setGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(new FilteredQuery(new MatchAllDocsQuery(), base.getTopFilter()), allGroupHeadsCollector);\n        this.docs = new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aa62c79a7afa4d7f22e1f71b883659f3213d7db1","date":1435334422,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","sourceNew":"  protected ParsedParams parseParams(String type, String param) throws SyntaxError, IOException {\n    SolrParams localParams = QueryParsing.getLocalParams(param, req.getParams());\n    DocSet docs = docsOrig;\n    String facetValue = param;\n    String key = param;\n    int threads = -1;\n\n    if (localParams == null) {\n      SolrParams params = global;\n      SolrParams required = new RequiredSolrParams(params);\n      return new ParsedParams(localParams, params, required, facetValue, docs, key, threads);\n    }\n    \n    SolrParams params = SolrParams.wrapDefaults(localParams, global);\n    SolrParams required = new RequiredSolrParams(params);\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return new ParsedParams(localParams, params, required, facetValue, docs, key, threads);\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return new ParsedParams(localParams, params, required, facetValue, docs, key, threads);\n\n      List<Query> qlist = new ArrayList<>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        grouping.setGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          docs = base;\n          return new ParsedParams(localParams, params, required, facetValue, docs, key, threads);\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n        docs = new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n      } else {\n        docs = base;\n      }\n    }\n\n    return new ParsedParams(localParams, params, required, facetValue, docs, key, threads);\n  }\n\n","sourceOld":"  protected void parseParams(String type, String param) throws SyntaxError, IOException {\n    localParams = QueryParsing.getLocalParams(param, req.getParams());\n    docs = docsOrig;\n    facetValue = param;\n    key = param;\n    threads = -1;\n\n    if (localParams == null) {\n      params = orig;\n      required = new RequiredSolrParams(params);\n      return;\n    }\n    params = SolrParams.wrapDefaults(localParams, orig);\n    required = new RequiredSolrParams(params);\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return;\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return;\n\n      List<Query> qlist = new ArrayList<>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        grouping.setGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          this.docs = base;\n          return;\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n        this.docs = new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n      } else {\n        this.docs = base;\n      }\n    }\n\n  }\n\n","bugFix":["309bb934ccf1b9733206e54bd15a143b6a198889","8af6befbf8d7be9538fb4fb8a9d64a1aff18e772","98a8a68e6714cb8742c790308b9f5180d63417d4","3cdb67100dc016748799a77218aa409478372d79","4f5684d5cdbe0dc30849f6baef278a1f5efe9d52","7a2ba67a463f52915e77a5fd8714aa7d36faf59c","9cb179b2fab2183d2f6041e450ff8022c592ecf0","f29c962d2a19abc63339cd093c2c0f234fc763e8","a69cf7f1b4cac5d5b1363402b565cd535f13e6a1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22d0a81a05eba47d5e18976f17d88306b218cc22","date":1436341569,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#parseParams(String,String).mjava","sourceNew":"  protected ParsedParams parseParams(String type, String param) throws SyntaxError, IOException {\n    SolrParams localParams = QueryParsing.getLocalParams(param, req.getParams());\n    DocSet docs = docsOrig;\n    String facetValue = param;\n    String key = param;\n    List<String> tags = Collections.emptyList();\n    int threads = -1;\n\n    if (localParams == null) {\n      SolrParams params = global;\n      SolrParams required = new RequiredSolrParams(params);\n      return new ParsedParams(localParams, params, required, facetValue, docs, key, tags, threads);\n    }\n    \n    SolrParams params = SolrParams.wrapDefaults(localParams, global);\n    SolrParams required = new RequiredSolrParams(params);\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String tagStr = localParams.get(CommonParams.TAG);\n    tags = tagStr == null ? Collections.<String>emptyList() : StrUtils.splitSmart(tagStr,',');\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return new ParsedParams(localParams, params, required, facetValue, docs, key, tags, threads);\n\n    List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n    docs = computeDocSet(docs, excludeTagList);\n    return new ParsedParams(localParams, params, required, facetValue, docs, key, tags, threads);\n  }\n\n","sourceOld":"  protected ParsedParams parseParams(String type, String param) throws SyntaxError, IOException {\n    SolrParams localParams = QueryParsing.getLocalParams(param, req.getParams());\n    DocSet docs = docsOrig;\n    String facetValue = param;\n    String key = param;\n    int threads = -1;\n\n    if (localParams == null) {\n      SolrParams params = global;\n      SolrParams required = new RequiredSolrParams(params);\n      return new ParsedParams(localParams, params, required, facetValue, docs, key, threads);\n    }\n    \n    SolrParams params = SolrParams.wrapDefaults(localParams, global);\n    SolrParams required = new RequiredSolrParams(params);\n\n    // remove local params unless it's a query\n    if (type != FacetParams.FACET_QUERY) { // TODO Cut over to an Enum here\n      facetValue = localParams.get(CommonParams.VALUE);\n    }\n\n    // reset set the default key now that localParams have been removed\n    key = facetValue;\n\n    // allow explicit set of the key\n    key = localParams.get(CommonParams.OUTPUT_KEY, key);\n\n    String threadStr = localParams.get(CommonParams.THREADS);\n    if (threadStr != null) {\n      threads = Integer.parseInt(threadStr);\n    }\n\n    // figure out if we need a new base DocSet\n    String excludeStr = localParams.get(CommonParams.EXCLUDE);\n    if (excludeStr == null) return new ParsedParams(localParams, params, required, facetValue, docs, key, threads);\n\n    Map<?,?> tagMap = (Map<?,?>)req.getContext().get(\"tags\");\n    if (tagMap != null && rb != null) {\n      List<String> excludeTagList = StrUtils.splitSmart(excludeStr,',');\n\n      IdentityHashMap<Query,Boolean> excludeSet = new IdentityHashMap<>();\n      for (String excludeTag : excludeTagList) {\n        Object olst = tagMap.get(excludeTag);\n        // tagMap has entries of List<String,List<QParser>>, but subject to change in the future\n        if (!(olst instanceof Collection)) continue;\n        for (Object o : (Collection<?>)olst) {\n          if (!(o instanceof QParser)) continue;\n          QParser qp = (QParser)o;\n          excludeSet.put(qp.getQuery(), Boolean.TRUE);\n        }\n      }\n      if (excludeSet.size() == 0) return new ParsedParams(localParams, params, required, facetValue, docs, key, threads);\n\n      List<Query> qlist = new ArrayList<>();\n\n      // add the base query\n      if (!excludeSet.containsKey(rb.getQuery())) {\n        qlist.add(rb.getQuery());\n      }\n\n      // add the filters\n      if (rb.getFilters() != null) {\n        for (Query q : rb.getFilters()) {\n          if (!excludeSet.containsKey(q)) {\n            qlist.add(q);\n          }\n        }\n      }\n\n      // get the new base docset for this facet\n      DocSet base = searcher.getDocSet(qlist);\n      if (rb.grouping() && rb.getGroupingSpec().isTruncateGroups()) {\n        Grouping grouping = new Grouping(searcher, null, rb.getQueryCommand(), false, 0, false);\n        grouping.setGroupSort(rb.getGroupingSpec().getSortWithinGroup());\n        if (rb.getGroupingSpec().getFields().length > 0) {\n          grouping.addFieldCommand(rb.getGroupingSpec().getFields()[0], req);\n        } else if (rb.getGroupingSpec().getFunctions().length > 0) {\n          grouping.addFunctionCommand(rb.getGroupingSpec().getFunctions()[0], req);\n        } else {\n          docs = base;\n          return new ParsedParams(localParams, params, required, facetValue, docs, key, threads);\n        }\n        AbstractAllGroupHeadsCollector allGroupHeadsCollector = grouping.getCommands().get(0).createAllGroupCollector();\n        searcher.search(base.getTopFilter(), allGroupHeadsCollector);\n        docs = new BitDocSet(allGroupHeadsCollector.retrieveGroupHeads(searcher.maxDoc()));\n      } else {\n        docs = base;\n      }\n    }\n\n    return new ParsedParams(localParams, params, required, facetValue, docs, key, threads);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["a69cf7f1b4cac5d5b1363402b565cd535f13e6a1"],"f29c962d2a19abc63339cd093c2c0f234fc763e8":["309bb934ccf1b9733206e54bd15a143b6a198889"],"3cdb67100dc016748799a77218aa409478372d79":["7a2ba67a463f52915e77a5fd8714aa7d36faf59c"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"407687e67faf6e1f02a211ca078d8e3eed631027":["7a2ba67a463f52915e77a5fd8714aa7d36faf59c","3cdb67100dc016748799a77218aa409478372d79"],"4f5684d5cdbe0dc30849f6baef278a1f5efe9d52":["8a60b2c00832877c72a25bdbc0d81b07acf758fc"],"309bb934ccf1b9733206e54bd15a143b6a198889":["4f5684d5cdbe0dc30849f6baef278a1f5efe9d52"],"aa62c79a7afa4d7f22e1f71b883659f3213d7db1":["1db68e96dd908fcd79ef809095822736aa601d08"],"8af6befbf8d7be9538fb4fb8a9d64a1aff18e772":["c26f00b574427b55127e869b935845554afde1fa"],"b2d5244a676b83c2d551c3746e8181588ba619e1":["407687e67faf6e1f02a211ca078d8e3eed631027","8a60b2c00832877c72a25bdbc0d81b07acf758fc"],"1db68e96dd908fcd79ef809095822736aa601d08":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"8a60b2c00832877c72a25bdbc0d81b07acf758fc":["3cdb67100dc016748799a77218aa409478372d79"],"a69cf7f1b4cac5d5b1363402b565cd535f13e6a1":["f29c962d2a19abc63339cd093c2c0f234fc763e8"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7a2ba67a463f52915e77a5fd8714aa7d36faf59c":["8af6befbf8d7be9538fb4fb8a9d64a1aff18e772"],"22d0a81a05eba47d5e18976f17d88306b218cc22":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["22d0a81a05eba47d5e18976f17d88306b218cc22"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"f29c962d2a19abc63339cd093c2c0f234fc763e8":["a69cf7f1b4cac5d5b1363402b565cd535f13e6a1"],"3cdb67100dc016748799a77218aa409478372d79":["407687e67faf6e1f02a211ca078d8e3eed631027","8a60b2c00832877c72a25bdbc0d81b07acf758fc"],"c26f00b574427b55127e869b935845554afde1fa":["8af6befbf8d7be9538fb4fb8a9d64a1aff18e772"],"407687e67faf6e1f02a211ca078d8e3eed631027":["b2d5244a676b83c2d551c3746e8181588ba619e1"],"4f5684d5cdbe0dc30849f6baef278a1f5efe9d52":["309bb934ccf1b9733206e54bd15a143b6a198889"],"309bb934ccf1b9733206e54bd15a143b6a198889":["f29c962d2a19abc63339cd093c2c0f234fc763e8"],"aa62c79a7afa4d7f22e1f71b883659f3213d7db1":["22d0a81a05eba47d5e18976f17d88306b218cc22"],"8af6befbf8d7be9538fb4fb8a9d64a1aff18e772":["7a2ba67a463f52915e77a5fd8714aa7d36faf59c"],"b2d5244a676b83c2d551c3746e8181588ba619e1":[],"8a60b2c00832877c72a25bdbc0d81b07acf758fc":["4f5684d5cdbe0dc30849f6baef278a1f5efe9d52","b2d5244a676b83c2d551c3746e8181588ba619e1"],"1db68e96dd908fcd79ef809095822736aa601d08":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"a69cf7f1b4cac5d5b1363402b565cd535f13e6a1":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["1db68e96dd908fcd79ef809095822736aa601d08"],"7a2ba67a463f52915e77a5fd8714aa7d36faf59c":["3cdb67100dc016748799a77218aa409478372d79","407687e67faf6e1f02a211ca078d8e3eed631027"],"22d0a81a05eba47d5e18976f17d88306b218cc22":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b2d5244a676b83c2d551c3746e8181588ba619e1","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}