{"path":"src/java/org/apache/solr/search/QueryUtils#getAbs(Query).mjava","commits":[{"id":"b1940b60224897131cf61bb615e02af1b26558c8","date":1169501002,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/QueryUtils#getAbs(Query).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns the original query if it was already a positive query, otherwise\n   * return the negative of the query (i.e., a positive query).\n   * <p>\n   * Example: both id:10 and id:-10 will return id:10\n   * <p>\n   * The caller can tell the sign of the original by a reference comparison between\n   * the original and returned query.\n   * @param q\n   * @return\n   */\n  static Query getAbs(Query q) {\n    if (!(q instanceof BooleanQuery)) return q;\n    BooleanQuery bq = (BooleanQuery)q;\n\n    BooleanClause[] clauses = bq.getClauses();\n    if (clauses.length==0) return q;\n\n\n    for (BooleanClause clause: clauses) {\n      if (!clause.isProhibited()) return q;\n    }\n\n    if (clauses.length==1) {\n      // if only one clause, dispense with the wrapping BooleanQuery\n      Query negClause = clauses[0].getQuery();\n      // we shouldn't need to worry about adjusting the boosts since the negative\n      // clause would have never been selected in a positive query, and hence would\n      // not contribute to a score.\n      return negClause;\n    } else {\n      BooleanQuery newBq = new BooleanQuery(bq.isCoordDisabled());\n      newBq.setBoost(bq.getBoost());\n      // ignore minNrShouldMatch... it doesn't make sense for a negative query\n\n      // the inverse of -a -b is a OR b\n      for (BooleanClause clause: clauses) {\n        newBq.add(clause.getQuery(), BooleanClause.Occur.SHOULD);\n      }\n      return newBq;\n    }\n\n\n    /*** TODO: use after next lucene update\n    List <BooleanClause> clauses = (List <BooleanClause>)bq.clauses();\n    // A single filtered out stopword currently causes a BooleanQuery with\n    // zero clauses.\n    if (clauses.size()==0) return q;\n\n    for (BooleanClause clause: clauses) {\n      if (!clause.isProhibited()) return q;\n    }\n\n    if (clauses.size()==1) {\n      // if only one clause, dispense with the wrapping BooleanQuery\n      Query negClause = clauses.get(0).getQuery();\n      // we shouldn't need to worry about adjusting the boosts since the negative\n      // clause would have never been selected in a positive query, and hence the\n      // boost is meaningless.\n      return negClause;\n    } else {\n      BooleanQuery newBq = new BooleanQuery(bq.isCoordDisabled());\n      newBq.setBoost(bq.getBoost());\n      // ignore minNrShouldMatch... it doesn't make sense for a negative query\n\n      // the inverse of -a -b is a b\n      for (BooleanClause clause: clauses) {\n        newBq.add(clause.getQuery(), BooleanClause.Occur.SHOULD);\n      }\n      return newBq;\n    }\n    ***/\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"27adc06684d74d32d4d07537a81903ffbf816d27","date":1178648148,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/search/QueryUtils#getAbs(Query).mjava","pathOld":"src/java/org/apache/solr/search/QueryUtils#getAbs(Query).mjava","sourceNew":"  /** Returns the original query if it was already a positive query, otherwise\n   * return the negative of the query (i.e., a positive query).\n   * <p>\n   * Example: both id:10 and id:-10 will return id:10\n   * <p>\n   * The caller can tell the sign of the original by a reference comparison between\n   * the original and returned query.\n   * @param q\n   * @return\n   */\n  static Query getAbs(Query q) {\n    if (!(q instanceof BooleanQuery)) return q;\n    BooleanQuery bq = (BooleanQuery)q;\n\n    List<BooleanClause> clauses = bq.clauses();\n    if (clauses.size()==0) return q;\n\n\n    for (BooleanClause clause : clauses) {\n      if (!clause.isProhibited()) return q;\n    }\n\n    if (clauses.size()==1) {\n      // if only one clause, dispense with the wrapping BooleanQuery\n      Query negClause = clauses.get(0).getQuery();\n      // we shouldn't need to worry about adjusting the boosts since the negative\n      // clause would have never been selected in a positive query, and hence would\n      // not contribute to a score.\n      return negClause;\n    } else {\n      BooleanQuery newBq = new BooleanQuery(bq.isCoordDisabled());\n      newBq.setBoost(bq.getBoost());\n      // ignore minNrShouldMatch... it doesn't make sense for a negative query\n\n      // the inverse of -a -b is a OR b\n      for (BooleanClause clause : clauses) {\n        newBq.add(clause.getQuery(), BooleanClause.Occur.SHOULD);\n      }\n      return newBq;\n    }\n\n\n    /*** TODO: use after next lucene update\n    List <BooleanClause> clauses = (List <BooleanClause>)bq.clauses();\n    // A single filtered out stopword currently causes a BooleanQuery with\n    // zero clauses.\n    if (clauses.size()==0) return q;\n\n    for (BooleanClause clause: clauses) {\n      if (!clause.isProhibited()) return q;\n    }\n\n    if (clauses.size()==1) {\n      // if only one clause, dispense with the wrapping BooleanQuery\n      Query negClause = clauses.get(0).getQuery();\n      // we shouldn't need to worry about adjusting the boosts since the negative\n      // clause would have never been selected in a positive query, and hence the\n      // boost is meaningless.\n      return negClause;\n    } else {\n      BooleanQuery newBq = new BooleanQuery(bq.isCoordDisabled());\n      newBq.setBoost(bq.getBoost());\n      // ignore minNrShouldMatch... it doesn't make sense for a negative query\n\n      // the inverse of -a -b is a b\n      for (BooleanClause clause: clauses) {\n        newBq.add(clause.getQuery(), BooleanClause.Occur.SHOULD);\n      }\n      return newBq;\n    }\n    ***/\n  }\n\n","sourceOld":"  /** Returns the original query if it was already a positive query, otherwise\n   * return the negative of the query (i.e., a positive query).\n   * <p>\n   * Example: both id:10 and id:-10 will return id:10\n   * <p>\n   * The caller can tell the sign of the original by a reference comparison between\n   * the original and returned query.\n   * @param q\n   * @return\n   */\n  static Query getAbs(Query q) {\n    if (!(q instanceof BooleanQuery)) return q;\n    BooleanQuery bq = (BooleanQuery)q;\n\n    BooleanClause[] clauses = bq.getClauses();\n    if (clauses.length==0) return q;\n\n\n    for (BooleanClause clause: clauses) {\n      if (!clause.isProhibited()) return q;\n    }\n\n    if (clauses.length==1) {\n      // if only one clause, dispense with the wrapping BooleanQuery\n      Query negClause = clauses[0].getQuery();\n      // we shouldn't need to worry about adjusting the boosts since the negative\n      // clause would have never been selected in a positive query, and hence would\n      // not contribute to a score.\n      return negClause;\n    } else {\n      BooleanQuery newBq = new BooleanQuery(bq.isCoordDisabled());\n      newBq.setBoost(bq.getBoost());\n      // ignore minNrShouldMatch... it doesn't make sense for a negative query\n\n      // the inverse of -a -b is a OR b\n      for (BooleanClause clause: clauses) {\n        newBq.add(clause.getQuery(), BooleanClause.Occur.SHOULD);\n      }\n      return newBq;\n    }\n\n\n    /*** TODO: use after next lucene update\n    List <BooleanClause> clauses = (List <BooleanClause>)bq.clauses();\n    // A single filtered out stopword currently causes a BooleanQuery with\n    // zero clauses.\n    if (clauses.size()==0) return q;\n\n    for (BooleanClause clause: clauses) {\n      if (!clause.isProhibited()) return q;\n    }\n\n    if (clauses.size()==1) {\n      // if only one clause, dispense with the wrapping BooleanQuery\n      Query negClause = clauses.get(0).getQuery();\n      // we shouldn't need to worry about adjusting the boosts since the negative\n      // clause would have never been selected in a positive query, and hence the\n      // boost is meaningless.\n      return negClause;\n    } else {\n      BooleanQuery newBq = new BooleanQuery(bq.isCoordDisabled());\n      newBq.setBoost(bq.getBoost());\n      // ignore minNrShouldMatch... it doesn't make sense for a negative query\n\n      // the inverse of -a -b is a b\n      for (BooleanClause clause: clauses) {\n        newBq.add(clause.getQuery(), BooleanClause.Occur.SHOULD);\n      }\n      return newBq;\n    }\n    ***/\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6590da0a724a2b5773ac230c11c7011b35badf83","date":1180473095,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/QueryUtils#getAbs(Query).mjava","pathOld":"src/java/org/apache/solr/search/QueryUtils#getAbs(Query).mjava","sourceNew":"  /** Returns the original query if it was already a positive query, otherwise\n   * return the negative of the query (i.e., a positive query).\n   * <p>\n   * Example: both id:10 and id:-10 will return id:10\n   * <p>\n   * The caller can tell the sign of the original by a reference comparison between\n   * the original and returned query.\n   * @param q\n   * @return\n   */\n  static Query getAbs(Query q) {\n    if (!(q instanceof BooleanQuery)) return q;\n    BooleanQuery bq = (BooleanQuery)q;\n\n    List<BooleanClause> clauses = bq.clauses();\n    if (clauses.size()==0) return q;\n\n\n    for (BooleanClause clause : clauses) {\n      if (!clause.isProhibited()) return q;\n    }\n\n    if (clauses.size()==1) {\n      // if only one clause, dispense with the wrapping BooleanQuery\n      Query negClause = clauses.get(0).getQuery();\n      // we shouldn't need to worry about adjusting the boosts since the negative\n      // clause would have never been selected in a positive query, and hence would\n      // not contribute to a score.\n      return negClause;\n    } else {\n      BooleanQuery newBq = new BooleanQuery(bq.isCoordDisabled());\n      newBq.setBoost(bq.getBoost());\n      // ignore minNrShouldMatch... it doesn't make sense for a negative query\n\n      // the inverse of -a -b is a OR b\n      for (BooleanClause clause : clauses) {\n        newBq.add(clause.getQuery(), BooleanClause.Occur.SHOULD);\n      }\n      return newBq;\n    }\n  }\n\n","sourceOld":"  /** Returns the original query if it was already a positive query, otherwise\n   * return the negative of the query (i.e., a positive query).\n   * <p>\n   * Example: both id:10 and id:-10 will return id:10\n   * <p>\n   * The caller can tell the sign of the original by a reference comparison between\n   * the original and returned query.\n   * @param q\n   * @return\n   */\n  static Query getAbs(Query q) {\n    if (!(q instanceof BooleanQuery)) return q;\n    BooleanQuery bq = (BooleanQuery)q;\n\n    List<BooleanClause> clauses = bq.clauses();\n    if (clauses.size()==0) return q;\n\n\n    for (BooleanClause clause : clauses) {\n      if (!clause.isProhibited()) return q;\n    }\n\n    if (clauses.size()==1) {\n      // if only one clause, dispense with the wrapping BooleanQuery\n      Query negClause = clauses.get(0).getQuery();\n      // we shouldn't need to worry about adjusting the boosts since the negative\n      // clause would have never been selected in a positive query, and hence would\n      // not contribute to a score.\n      return negClause;\n    } else {\n      BooleanQuery newBq = new BooleanQuery(bq.isCoordDisabled());\n      newBq.setBoost(bq.getBoost());\n      // ignore minNrShouldMatch... it doesn't make sense for a negative query\n\n      // the inverse of -a -b is a OR b\n      for (BooleanClause clause : clauses) {\n        newBq.add(clause.getQuery(), BooleanClause.Occur.SHOULD);\n      }\n      return newBq;\n    }\n\n\n    /*** TODO: use after next lucene update\n    List <BooleanClause> clauses = (List <BooleanClause>)bq.clauses();\n    // A single filtered out stopword currently causes a BooleanQuery with\n    // zero clauses.\n    if (clauses.size()==0) return q;\n\n    for (BooleanClause clause: clauses) {\n      if (!clause.isProhibited()) return q;\n    }\n\n    if (clauses.size()==1) {\n      // if only one clause, dispense with the wrapping BooleanQuery\n      Query negClause = clauses.get(0).getQuery();\n      // we shouldn't need to worry about adjusting the boosts since the negative\n      // clause would have never been selected in a positive query, and hence the\n      // boost is meaningless.\n      return negClause;\n    } else {\n      BooleanQuery newBq = new BooleanQuery(bq.isCoordDisabled());\n      newBq.setBoost(bq.getBoost());\n      // ignore minNrShouldMatch... it doesn't make sense for a negative query\n\n      // the inverse of -a -b is a b\n      for (BooleanClause clause: clauses) {\n        newBq.add(clause.getQuery(), BooleanClause.Occur.SHOULD);\n      }\n      return newBq;\n    }\n    ***/\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/QueryUtils#getAbs(Query).mjava","pathOld":"src/java/org/apache/solr/search/QueryUtils#getAbs(Query).mjava","sourceNew":"  /** Returns the original query if it was already a positive query, otherwise\n   * return the negative of the query (i.e., a positive query).\n   * <p>\n   * Example: both id:10 and id:-10 will return id:10\n   * <p>\n   * The caller can tell the sign of the original by a reference comparison between\n   * the original and returned query.\n   * @param q\n   * @return\n   */\n  static Query getAbs(Query q) {\n    if (!(q instanceof BooleanQuery)) return q;\n    BooleanQuery bq = (BooleanQuery)q;\n\n    List<BooleanClause> clauses = bq.clauses();\n    if (clauses.size()==0) return q;\n\n\n    for (BooleanClause clause : clauses) {\n      if (!clause.isProhibited()) return q;\n    }\n\n    if (clauses.size()==1) {\n      // if only one clause, dispense with the wrapping BooleanQuery\n      Query negClause = clauses.get(0).getQuery();\n      // we shouldn't need to worry about adjusting the boosts since the negative\n      // clause would have never been selected in a positive query, and hence would\n      // not contribute to a score.\n      return negClause;\n    } else {\n      BooleanQuery newBq = new BooleanQuery(bq.isCoordDisabled());\n      newBq.setBoost(bq.getBoost());\n      // ignore minNrShouldMatch... it doesn't make sense for a negative query\n\n      // the inverse of -a -b is a OR b\n      for (BooleanClause clause : clauses) {\n        newBq.add(clause.getQuery(), BooleanClause.Occur.SHOULD);\n      }\n      return newBq;\n    }\n  }\n\n","sourceOld":"  /** Returns the original query if it was already a positive query, otherwise\n   * return the negative of the query (i.e., a positive query).\n   * <p>\n   * Example: both id:10 and id:-10 will return id:10\n   * <p>\n   * The caller can tell the sign of the original by a reference comparison between\n   * the original and returned query.\n   * @param q\n   * @return\n   */\n  static Query getAbs(Query q) {\n    if (!(q instanceof BooleanQuery)) return q;\n    BooleanQuery bq = (BooleanQuery)q;\n\n    List<BooleanClause> clauses = bq.clauses();\n    if (clauses.size()==0) return q;\n\n\n    for (BooleanClause clause : clauses) {\n      if (!clause.isProhibited()) return q;\n    }\n\n    if (clauses.size()==1) {\n      // if only one clause, dispense with the wrapping BooleanQuery\n      Query negClause = clauses.get(0).getQuery();\n      // we shouldn't need to worry about adjusting the boosts since the negative\n      // clause would have never been selected in a positive query, and hence would\n      // not contribute to a score.\n      return negClause;\n    } else {\n      BooleanQuery newBq = new BooleanQuery(bq.isCoordDisabled());\n      newBq.setBoost(bq.getBoost());\n      // ignore minNrShouldMatch... it doesn't make sense for a negative query\n\n      // the inverse of -a -b is a OR b\n      for (BooleanClause clause : clauses) {\n        newBq.add(clause.getQuery(), BooleanClause.Occur.SHOULD);\n      }\n      return newBq;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6590da0a724a2b5773ac230c11c7011b35badf83":["27adc06684d74d32d4d07537a81903ffbf816d27"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b1940b60224897131cf61bb615e02af1b26558c8":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["6590da0a724a2b5773ac230c11c7011b35badf83"],"27adc06684d74d32d4d07537a81903ffbf816d27":["b1940b60224897131cf61bb615e02af1b26558c8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"6590da0a724a2b5773ac230c11c7011b35badf83":["ad94625fb8d088209f46650c8097196fec67f00c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b1940b60224897131cf61bb615e02af1b26558c8":["27adc06684d74d32d4d07537a81903ffbf816d27"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["b1940b60224897131cf61bb615e02af1b26558c8"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"27adc06684d74d32d4d07537a81903ffbf816d27":["6590da0a724a2b5773ac230c11c7011b35badf83"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}