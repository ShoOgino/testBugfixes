{"path":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","commits":[{"id":"326b3b177da8135f97e1832c22fbae8dab7c9400","date":1193062944,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","pathOld":"/dev/null","sourceNew":"  public static void main(String[] args) throws Throwable {\n\n    boolean doFix = false;\n    for(int i=0;i<args.length;i++)\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        break;\n      }\n\n    if (args.length != (doFix ? 2:1)) {\n      System.out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\");\n      System.exit(1);\n    }\n\n    NumberFormat nf = NumberFormat.getInstance();\n    \n    SegmentInfos sis = new SegmentInfos();\n    final String dirName = args[0];\n    System.out.println(\"\\nOpening index @ \" + dirName + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.getDirectory(dirName);\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not open directory \\\"\" + dirName + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    } \n    \n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not read any segments file in directory \\\"\" + dirName + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not open segments file in directory \\\"\" + dirName + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not read segment file version in directory \\\"\" + dirName + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT)\n      sFormat = \"FORMAT [Lucene Pre-2.1]\";\n    if (format == SegmentInfos.FORMAT_LOCKLESS)\n      sFormat = \"FORMAT_LOCKLESS [Lucene 2.1]\";\n    else if (format == SegmentInfos.FORMAT_SINGLE_NORM_FILE)\n      sFormat = \"FORMAT_SINGLE_NORM_FILE [Lucene 2.2]\";\n    else if (format == SegmentInfos.FORMAT_SHARED_DOC_STORE)\n      sFormat = \"FORMAT_SHARED_DOC_STORE [Lucene 2.3]\";\n    else if (format < SegmentInfos.FORMAT_SHARED_DOC_STORE) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool]\";\n      skip = true;\n    } else {\n      sFormat = format + \" [Lucene 1.3 or prior]\";\n    }\n\n    System.out.println(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat);\n\n    if (skip) {\n      System.out.println(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      System.exit(1);\n    }\n\n    SegmentInfos newSIS = (SegmentInfos) sis.clone();\n    newSIS.clear();\n    boolean changed = false;\n    int totLoseDocCount = 0;\n    int numBadSegments = 0;\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      System.out.println(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      int toLoseDocCount = info.docCount;\n\n      try {\n        System.out.println(\"    compound=\" + info.getUseCompoundFile());\n        System.out.println(\"    numFiles=\" + info.files().size());\n        System.out.println(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          System.out.println(\"    docStoreOffset=\" + docStoreOffset);\n          System.out.println(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          System.out.println(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n        }\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null)\n          System.out.println(\"    no deletions\");\n        else\n          System.out.println(\"    has deletions [delFileName=\" + delFileName + \"]\");\n        System.out.print(\"    test: open reader.........\");\n        SegmentReader reader = SegmentReader.get(info);\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions())\n          System.out.println(\"OK [\" + (info.docCount - numDocs) + \" deleted docs]\");\n        else\n          System.out.println(\"OK\");\n\n        System.out.print(\"    test: fields, norms.......\");\n        Collection fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        Iterator it = fieldNames.iterator();\n        while(it.hasNext()) {\n          final String fieldName = (String) it.next();\n          byte[] b = reader.norms(fieldName);\n          if (b.length != info.docCount)\n            throw new RuntimeException(\"norms for field \\\"\" + fieldName + \"\\\" is length \" + b.length + \" != maxDoc \" + info.docCount);\n\n        }\n        System.out.println(\"OK [\" + fieldNames.size() + \" fields]\");\n\n        System.out.print(\"    test: terms, freq, prox...\");\n        final TermEnum termEnum = reader.terms();\n        final TermPositions termPositions = reader.termPositions();\n        long termCount = 0;\n        long totFreq = 0;\n        long totPos = 0;\n        while(termEnum.next()) {\n          termCount++;\n          final Term term = termEnum.term();\n          final int docFreq = termEnum.docFreq();\n          termPositions.seek(term);\n          int lastDoc = -1;\n          int freq0 = 0;\n          totFreq += docFreq;\n          while(termPositions.next()) {\n            freq0++;\n            final int doc = termPositions.doc();\n            final int freq = termPositions.freq();\n            if (doc <= lastDoc)\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" < lastDoc \" + lastDoc);\n            lastDoc = doc;\n            if (freq <= 0)\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            \n            int lastPos = -1;\n            totPos += freq;\n            for(int j=0;j<freq;j++) {\n              final int pos = termPositions.nextPosition();\n              if (pos < 0)\n                throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n              if (pos <= lastPos)\n                throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n            }\n          }\n          if (freq0 != docFreq)\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != num docs seen \" + freq0);\n        }\n\n        System.out.println(\"OK [\" + termCount + \" terms; \" + totFreq + \" terms/docs pairs; \" + totPos + \" tokens]\");\n\n        System.out.print(\"    test: stored fields.......\");\n        int docCount = 0;\n        long totFields = 0;\n        for(int j=0;j<info.docCount;j++)\n          if (!reader.isDeleted(j)) {\n            docCount++;\n            Document doc = reader.document(j);\n            totFields += doc.getFields().size();\n          }\n\n        if (docCount != reader.numDocs())\n          throw new RuntimeException(\"docCount=\" + docCount + \" but saw \" + docCount + \" undeleted docs\");\n\n        System.out.println(\"OK [\" + totFields + \" total field count; avg \" + nf.format((((float) totFields)/docCount)) + \" fields per doc]\");\n\n        System.out.print(\"    test: term vectors........\");\n        int totVectors = 0;\n        for(int j=0;j<info.docCount;j++)\n          if (!reader.isDeleted(j)) {\n            TermFreqVector[] tfv = reader.getTermFreqVectors(j);\n            if (tfv != null)\n              totVectors += tfv.length;\n          }\n\n        System.out.println(\"OK [\" + totVectors + \" total vector count; avg \" + nf.format((((float) totVectors)/docCount)) + \" term/freq vector fields per doc]\");\n        System.out.println(\"\");\n\n      } catch (Throwable t) {\n        System.out.println(\"FAILED\");\n        String comment;\n        if (doFix)\n          comment = \"will remove reference to this segment (-fix is specified)\";\n        else\n          comment = \"would remove reference to this segment (-fix was not specified)\";\n        System.out.println(\"    WARNING: \" + comment + \"; full exception:\");\n        t.printStackTrace(System.out);\n        System.out.println(\"\");\n        totLoseDocCount += toLoseDocCount;\n        numBadSegments++;\n        changed = true;\n        continue;\n      }\n\n      // Keeper\n      newSIS.add(info.clone());\n    }\n\n    if (!changed) {\n      System.out.println(\"No problems were detected with this index.\\n\");\n      System.exit(0);\n    } else {\n      System.out.println(\"WARNING: \" + numBadSegments + \" broken segments detected\");\n      if (doFix)\n        System.out.println(\"WARNING: \" + totLoseDocCount + \" documents will be lost\");\n      else\n        System.out.println(\"WARNING: \" + totLoseDocCount + \" documents would be lost if -fix were specified\");\n      System.out.println(\"\");\n    }\n\n    if (doFix) {\n      System.out.println(\"NOTE: will write new segments file in 5 seconds; this will remove \" + totLoseDocCount + \" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!\");\n      for(int i=0;i<5;i++) {\n        Thread.sleep(1000);\n        System.out.println(\"  \" + (5-i) + \"...\");\n      }\n      System.out.print(\"Writing...\");\n      try {\n        newSIS.write(dir);\n      } catch (Throwable t) {\n        System.out.println(\"FAILED; exiting\");\n        t.printStackTrace(System.out);\n        System.exit(1);\n      }\n      System.out.println(\"OK\");\n      System.out.println(\"Wrote new segments file \\\"\" + newSIS.getCurrentSegmentFileName() + \"\\\"\");\n    } else {\n      System.out.println(\"NOTE: would write new segments file [-fix was not specified]\");\n    }\n    System.out.println(\"\");\n\n    System.exit(0);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7391c1f4ab1a6817de8a262f5c1b3de3cf190785","5b38e3f2849cb8d8626cd5368aa64de4fed9edde","f7523916a1350712e1ae710affd4e88ccd7c431d","8eaedf240fab95c428d5f496a274256d2053ad37"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"996842e9b73111f695c542be757f2b3cd541b60a","date":1194733990,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","pathOld":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Throwable {\n\n    boolean doFix = false;\n    for(int i=0;i<args.length;i++)\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        break;\n      }\n\n    if (args.length != (doFix ? 2:1)) {\n      System.out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\");\n      System.exit(1);\n    }\n\n    NumberFormat nf = NumberFormat.getInstance();\n    \n    SegmentInfos sis = new SegmentInfos();\n    final String dirName = args[0];\n    System.out.println(\"\\nOpening index @ \" + dirName + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.getDirectory(dirName);\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not open directory \\\"\" + dirName + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    } \n    \n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not read any segments file in directory \\\"\" + dirName + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not open segments file in directory \\\"\" + dirName + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not read segment file version in directory \\\"\" + dirName + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT)\n      sFormat = \"FORMAT [Lucene Pre-2.1]\";\n    if (format == SegmentInfos.FORMAT_LOCKLESS)\n      sFormat = \"FORMAT_LOCKLESS [Lucene 2.1]\";\n    else if (format == SegmentInfos.FORMAT_SINGLE_NORM_FILE)\n      sFormat = \"FORMAT_SINGLE_NORM_FILE [Lucene 2.2]\";\n    else if (format == SegmentInfos.FORMAT_SHARED_DOC_STORE)\n      sFormat = \"FORMAT_SHARED_DOC_STORE [Lucene 2.3]\";\n    else if (format < SegmentInfos.FORMAT_SHARED_DOC_STORE) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool]\";\n      skip = true;\n    } else {\n      sFormat = format + \" [Lucene 1.3 or prior]\";\n    }\n\n    System.out.println(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat);\n\n    if (skip) {\n      System.out.println(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      System.exit(1);\n    }\n\n    SegmentInfos newSIS = (SegmentInfos) sis.clone();\n    newSIS.clear();\n    boolean changed = false;\n    int totLoseDocCount = 0;\n    int numBadSegments = 0;\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      System.out.println(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        System.out.println(\"    compound=\" + info.getUseCompoundFile());\n        System.out.println(\"    numFiles=\" + info.files().size());\n        System.out.println(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          System.out.println(\"    docStoreOffset=\" + docStoreOffset);\n          System.out.println(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          System.out.println(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n        }\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null)\n          System.out.println(\"    no deletions\");\n        else\n          System.out.println(\"    has deletions [delFileName=\" + delFileName + \"]\");\n        System.out.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(info);\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions())\n          System.out.println(\"OK [\" + (info.docCount - numDocs) + \" deleted docs]\");\n        else\n          System.out.println(\"OK\");\n\n        System.out.print(\"    test: fields, norms.......\");\n        Collection fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        Iterator it = fieldNames.iterator();\n        while(it.hasNext()) {\n          final String fieldName = (String) it.next();\n          byte[] b = reader.norms(fieldName);\n          if (b.length != info.docCount)\n            throw new RuntimeException(\"norms for field \\\"\" + fieldName + \"\\\" is length \" + b.length + \" != maxDoc \" + info.docCount);\n\n        }\n        System.out.println(\"OK [\" + fieldNames.size() + \" fields]\");\n\n        System.out.print(\"    test: terms, freq, prox...\");\n        final TermEnum termEnum = reader.terms();\n        final TermPositions termPositions = reader.termPositions();\n        long termCount = 0;\n        long totFreq = 0;\n        long totPos = 0;\n        while(termEnum.next()) {\n          termCount++;\n          final Term term = termEnum.term();\n          final int docFreq = termEnum.docFreq();\n          termPositions.seek(term);\n          int lastDoc = -1;\n          int freq0 = 0;\n          totFreq += docFreq;\n          while(termPositions.next()) {\n            freq0++;\n            final int doc = termPositions.doc();\n            final int freq = termPositions.freq();\n            if (doc <= lastDoc)\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" < lastDoc \" + lastDoc);\n            lastDoc = doc;\n            if (freq <= 0)\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            \n            int lastPos = -1;\n            totPos += freq;\n            for(int j=0;j<freq;j++) {\n              final int pos = termPositions.nextPosition();\n              if (pos < 0)\n                throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n              if (pos <= lastPos)\n                throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n            }\n          }\n          if (freq0 != docFreq)\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != num docs seen \" + freq0);\n        }\n\n        System.out.println(\"OK [\" + termCount + \" terms; \" + totFreq + \" terms/docs pairs; \" + totPos + \" tokens]\");\n\n        System.out.print(\"    test: stored fields.......\");\n        int docCount = 0;\n        long totFields = 0;\n        for(int j=0;j<info.docCount;j++)\n          if (!reader.isDeleted(j)) {\n            docCount++;\n            Document doc = reader.document(j);\n            totFields += doc.getFields().size();\n          }\n\n        if (docCount != reader.numDocs())\n          throw new RuntimeException(\"docCount=\" + docCount + \" but saw \" + docCount + \" undeleted docs\");\n\n        System.out.println(\"OK [\" + totFields + \" total field count; avg \" + nf.format((((float) totFields)/docCount)) + \" fields per doc]\");\n\n        System.out.print(\"    test: term vectors........\");\n        int totVectors = 0;\n        for(int j=0;j<info.docCount;j++)\n          if (!reader.isDeleted(j)) {\n            TermFreqVector[] tfv = reader.getTermFreqVectors(j);\n            if (tfv != null)\n              totVectors += tfv.length;\n          }\n\n        System.out.println(\"OK [\" + totVectors + \" total vector count; avg \" + nf.format((((float) totVectors)/docCount)) + \" term/freq vector fields per doc]\");\n        System.out.println(\"\");\n\n      } catch (Throwable t) {\n        System.out.println(\"FAILED\");\n        String comment;\n        if (doFix)\n          comment = \"will remove reference to this segment (-fix is specified)\";\n        else\n          comment = \"would remove reference to this segment (-fix was not specified)\";\n        System.out.println(\"    WARNING: \" + comment + \"; full exception:\");\n        t.printStackTrace(System.out);\n        System.out.println(\"\");\n        totLoseDocCount += toLoseDocCount;\n        numBadSegments++;\n        changed = true;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      newSIS.add(info.clone());\n    }\n\n    if (!changed) {\n      System.out.println(\"No problems were detected with this index.\\n\");\n      System.exit(0);\n    } else {\n      System.out.println(\"WARNING: \" + numBadSegments + \" broken segments detected\");\n      if (doFix)\n        System.out.println(\"WARNING: \" + totLoseDocCount + \" documents will be lost\");\n      else\n        System.out.println(\"WARNING: \" + totLoseDocCount + \" documents would be lost if -fix were specified\");\n      System.out.println(\"\");\n    }\n\n    if (doFix) {\n      System.out.println(\"NOTE: will write new segments file in 5 seconds; this will remove \" + totLoseDocCount + \" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!\");\n      for(int i=0;i<5;i++) {\n        Thread.sleep(1000);\n        System.out.println(\"  \" + (5-i) + \"...\");\n      }\n      System.out.print(\"Writing...\");\n      try {\n        newSIS.write(dir);\n      } catch (Throwable t) {\n        System.out.println(\"FAILED; exiting\");\n        t.printStackTrace(System.out);\n        System.exit(1);\n      }\n      System.out.println(\"OK\");\n      System.out.println(\"Wrote new segments file \\\"\" + newSIS.getCurrentSegmentFileName() + \"\\\"\");\n    } else {\n      System.out.println(\"NOTE: would write new segments file [-fix was not specified]\");\n    }\n    System.out.println(\"\");\n\n    System.exit(0);\n  }\n\n","sourceOld":"  public static void main(String[] args) throws Throwable {\n\n    boolean doFix = false;\n    for(int i=0;i<args.length;i++)\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        break;\n      }\n\n    if (args.length != (doFix ? 2:1)) {\n      System.out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\");\n      System.exit(1);\n    }\n\n    NumberFormat nf = NumberFormat.getInstance();\n    \n    SegmentInfos sis = new SegmentInfos();\n    final String dirName = args[0];\n    System.out.println(\"\\nOpening index @ \" + dirName + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.getDirectory(dirName);\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not open directory \\\"\" + dirName + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    } \n    \n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not read any segments file in directory \\\"\" + dirName + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not open segments file in directory \\\"\" + dirName + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not read segment file version in directory \\\"\" + dirName + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT)\n      sFormat = \"FORMAT [Lucene Pre-2.1]\";\n    if (format == SegmentInfos.FORMAT_LOCKLESS)\n      sFormat = \"FORMAT_LOCKLESS [Lucene 2.1]\";\n    else if (format == SegmentInfos.FORMAT_SINGLE_NORM_FILE)\n      sFormat = \"FORMAT_SINGLE_NORM_FILE [Lucene 2.2]\";\n    else if (format == SegmentInfos.FORMAT_SHARED_DOC_STORE)\n      sFormat = \"FORMAT_SHARED_DOC_STORE [Lucene 2.3]\";\n    else if (format < SegmentInfos.FORMAT_SHARED_DOC_STORE) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool]\";\n      skip = true;\n    } else {\n      sFormat = format + \" [Lucene 1.3 or prior]\";\n    }\n\n    System.out.println(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat);\n\n    if (skip) {\n      System.out.println(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      System.exit(1);\n    }\n\n    SegmentInfos newSIS = (SegmentInfos) sis.clone();\n    newSIS.clear();\n    boolean changed = false;\n    int totLoseDocCount = 0;\n    int numBadSegments = 0;\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      System.out.println(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      int toLoseDocCount = info.docCount;\n\n      try {\n        System.out.println(\"    compound=\" + info.getUseCompoundFile());\n        System.out.println(\"    numFiles=\" + info.files().size());\n        System.out.println(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          System.out.println(\"    docStoreOffset=\" + docStoreOffset);\n          System.out.println(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          System.out.println(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n        }\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null)\n          System.out.println(\"    no deletions\");\n        else\n          System.out.println(\"    has deletions [delFileName=\" + delFileName + \"]\");\n        System.out.print(\"    test: open reader.........\");\n        SegmentReader reader = SegmentReader.get(info);\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions())\n          System.out.println(\"OK [\" + (info.docCount - numDocs) + \" deleted docs]\");\n        else\n          System.out.println(\"OK\");\n\n        System.out.print(\"    test: fields, norms.......\");\n        Collection fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        Iterator it = fieldNames.iterator();\n        while(it.hasNext()) {\n          final String fieldName = (String) it.next();\n          byte[] b = reader.norms(fieldName);\n          if (b.length != info.docCount)\n            throw new RuntimeException(\"norms for field \\\"\" + fieldName + \"\\\" is length \" + b.length + \" != maxDoc \" + info.docCount);\n\n        }\n        System.out.println(\"OK [\" + fieldNames.size() + \" fields]\");\n\n        System.out.print(\"    test: terms, freq, prox...\");\n        final TermEnum termEnum = reader.terms();\n        final TermPositions termPositions = reader.termPositions();\n        long termCount = 0;\n        long totFreq = 0;\n        long totPos = 0;\n        while(termEnum.next()) {\n          termCount++;\n          final Term term = termEnum.term();\n          final int docFreq = termEnum.docFreq();\n          termPositions.seek(term);\n          int lastDoc = -1;\n          int freq0 = 0;\n          totFreq += docFreq;\n          while(termPositions.next()) {\n            freq0++;\n            final int doc = termPositions.doc();\n            final int freq = termPositions.freq();\n            if (doc <= lastDoc)\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" < lastDoc \" + lastDoc);\n            lastDoc = doc;\n            if (freq <= 0)\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            \n            int lastPos = -1;\n            totPos += freq;\n            for(int j=0;j<freq;j++) {\n              final int pos = termPositions.nextPosition();\n              if (pos < 0)\n                throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n              if (pos <= lastPos)\n                throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n            }\n          }\n          if (freq0 != docFreq)\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != num docs seen \" + freq0);\n        }\n\n        System.out.println(\"OK [\" + termCount + \" terms; \" + totFreq + \" terms/docs pairs; \" + totPos + \" tokens]\");\n\n        System.out.print(\"    test: stored fields.......\");\n        int docCount = 0;\n        long totFields = 0;\n        for(int j=0;j<info.docCount;j++)\n          if (!reader.isDeleted(j)) {\n            docCount++;\n            Document doc = reader.document(j);\n            totFields += doc.getFields().size();\n          }\n\n        if (docCount != reader.numDocs())\n          throw new RuntimeException(\"docCount=\" + docCount + \" but saw \" + docCount + \" undeleted docs\");\n\n        System.out.println(\"OK [\" + totFields + \" total field count; avg \" + nf.format((((float) totFields)/docCount)) + \" fields per doc]\");\n\n        System.out.print(\"    test: term vectors........\");\n        int totVectors = 0;\n        for(int j=0;j<info.docCount;j++)\n          if (!reader.isDeleted(j)) {\n            TermFreqVector[] tfv = reader.getTermFreqVectors(j);\n            if (tfv != null)\n              totVectors += tfv.length;\n          }\n\n        System.out.println(\"OK [\" + totVectors + \" total vector count; avg \" + nf.format((((float) totVectors)/docCount)) + \" term/freq vector fields per doc]\");\n        System.out.println(\"\");\n\n      } catch (Throwable t) {\n        System.out.println(\"FAILED\");\n        String comment;\n        if (doFix)\n          comment = \"will remove reference to this segment (-fix is specified)\";\n        else\n          comment = \"would remove reference to this segment (-fix was not specified)\";\n        System.out.println(\"    WARNING: \" + comment + \"; full exception:\");\n        t.printStackTrace(System.out);\n        System.out.println(\"\");\n        totLoseDocCount += toLoseDocCount;\n        numBadSegments++;\n        changed = true;\n        continue;\n      }\n\n      // Keeper\n      newSIS.add(info.clone());\n    }\n\n    if (!changed) {\n      System.out.println(\"No problems were detected with this index.\\n\");\n      System.exit(0);\n    } else {\n      System.out.println(\"WARNING: \" + numBadSegments + \" broken segments detected\");\n      if (doFix)\n        System.out.println(\"WARNING: \" + totLoseDocCount + \" documents will be lost\");\n      else\n        System.out.println(\"WARNING: \" + totLoseDocCount + \" documents would be lost if -fix were specified\");\n      System.out.println(\"\");\n    }\n\n    if (doFix) {\n      System.out.println(\"NOTE: will write new segments file in 5 seconds; this will remove \" + totLoseDocCount + \" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!\");\n      for(int i=0;i<5;i++) {\n        Thread.sleep(1000);\n        System.out.println(\"  \" + (5-i) + \"...\");\n      }\n      System.out.print(\"Writing...\");\n      try {\n        newSIS.write(dir);\n      } catch (Throwable t) {\n        System.out.println(\"FAILED; exiting\");\n        t.printStackTrace(System.out);\n        System.exit(1);\n      }\n      System.out.println(\"OK\");\n      System.out.println(\"Wrote new segments file \\\"\" + newSIS.getCurrentSegmentFileName() + \"\\\"\");\n    } else {\n      System.out.println(\"NOTE: would write new segments file [-fix was not specified]\");\n    }\n    System.out.println(\"\");\n\n    System.exit(0);\n  }\n\n","bugFix":null,"bugIntro":["5b38e3f2849cb8d8626cd5368aa64de4fed9edde"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5b38e3f2849cb8d8626cd5368aa64de4fed9edde","date":1196183330,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","pathOld":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Throwable {\n\n    boolean doFix = false;\n    for(int i=0;i<args.length;i++)\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        break;\n      }\n\n    if (args.length != (doFix ? 2:1)) {\n      out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\" +\n                         \"\\n\" +\n                         \"This tool exits with exit code 1 if the index cannot be opened or has has any\\n\" +\n                         \"corruption, else 0.\\n\");\n      System.exit(1);\n    }\n\n    final String dirName = args[0];\n    out.println(\"\\nOpening index @ \" + dirName + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.getDirectory(dirName);\n    } catch (Throwable t) {\n      out.println(\"ERROR: could not open directory \\\"\" + dirName + \"\\\"; exiting\");\n      t.printStackTrace(out);\n      System.exit(1);\n    }\n\n    boolean isClean = check(dir, doFix);\n\n    final int exitCode;\n    if (isClean)\n      exitCode = 0;\n    else\n      exitCode = 1;\n    System.exit(exitCode);\n  }    \n\n","sourceOld":"  public static void main(String[] args) throws Throwable {\n\n    boolean doFix = false;\n    for(int i=0;i<args.length;i++)\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        break;\n      }\n\n    if (args.length != (doFix ? 2:1)) {\n      System.out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\");\n      System.exit(1);\n    }\n\n    NumberFormat nf = NumberFormat.getInstance();\n    \n    SegmentInfos sis = new SegmentInfos();\n    final String dirName = args[0];\n    System.out.println(\"\\nOpening index @ \" + dirName + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.getDirectory(dirName);\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not open directory \\\"\" + dirName + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    } \n    \n    try {\n      sis.read(dir);\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not read any segments file in directory \\\"\" + dirName + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not open segments file in directory \\\"\" + dirName + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not read segment file version in directory \\\"\" + dirName + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT)\n      sFormat = \"FORMAT [Lucene Pre-2.1]\";\n    if (format == SegmentInfos.FORMAT_LOCKLESS)\n      sFormat = \"FORMAT_LOCKLESS [Lucene 2.1]\";\n    else if (format == SegmentInfos.FORMAT_SINGLE_NORM_FILE)\n      sFormat = \"FORMAT_SINGLE_NORM_FILE [Lucene 2.2]\";\n    else if (format == SegmentInfos.FORMAT_SHARED_DOC_STORE)\n      sFormat = \"FORMAT_SHARED_DOC_STORE [Lucene 2.3]\";\n    else if (format < SegmentInfos.FORMAT_SHARED_DOC_STORE) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool]\";\n      skip = true;\n    } else {\n      sFormat = format + \" [Lucene 1.3 or prior]\";\n    }\n\n    System.out.println(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat);\n\n    if (skip) {\n      System.out.println(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      System.exit(1);\n    }\n\n    SegmentInfos newSIS = (SegmentInfos) sis.clone();\n    newSIS.clear();\n    boolean changed = false;\n    int totLoseDocCount = 0;\n    int numBadSegments = 0;\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      System.out.println(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        System.out.println(\"    compound=\" + info.getUseCompoundFile());\n        System.out.println(\"    numFiles=\" + info.files().size());\n        System.out.println(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          System.out.println(\"    docStoreOffset=\" + docStoreOffset);\n          System.out.println(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          System.out.println(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n        }\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null)\n          System.out.println(\"    no deletions\");\n        else\n          System.out.println(\"    has deletions [delFileName=\" + delFileName + \"]\");\n        System.out.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(info);\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions())\n          System.out.println(\"OK [\" + (info.docCount - numDocs) + \" deleted docs]\");\n        else\n          System.out.println(\"OK\");\n\n        System.out.print(\"    test: fields, norms.......\");\n        Collection fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        Iterator it = fieldNames.iterator();\n        while(it.hasNext()) {\n          final String fieldName = (String) it.next();\n          byte[] b = reader.norms(fieldName);\n          if (b.length != info.docCount)\n            throw new RuntimeException(\"norms for field \\\"\" + fieldName + \"\\\" is length \" + b.length + \" != maxDoc \" + info.docCount);\n\n        }\n        System.out.println(\"OK [\" + fieldNames.size() + \" fields]\");\n\n        System.out.print(\"    test: terms, freq, prox...\");\n        final TermEnum termEnum = reader.terms();\n        final TermPositions termPositions = reader.termPositions();\n        long termCount = 0;\n        long totFreq = 0;\n        long totPos = 0;\n        while(termEnum.next()) {\n          termCount++;\n          final Term term = termEnum.term();\n          final int docFreq = termEnum.docFreq();\n          termPositions.seek(term);\n          int lastDoc = -1;\n          int freq0 = 0;\n          totFreq += docFreq;\n          while(termPositions.next()) {\n            freq0++;\n            final int doc = termPositions.doc();\n            final int freq = termPositions.freq();\n            if (doc <= lastDoc)\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \" < lastDoc \" + lastDoc);\n            lastDoc = doc;\n            if (freq <= 0)\n              throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": freq \" + freq + \" is out of bounds\");\n            \n            int lastPos = -1;\n            totPos += freq;\n            for(int j=0;j<freq;j++) {\n              final int pos = termPositions.nextPosition();\n              if (pos < 0)\n                throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" is out of bounds\");\n              if (pos <= lastPos)\n                throw new RuntimeException(\"term \" + term + \": doc \" + doc + \": pos \" + pos + \" < lastPos \" + lastPos);\n            }\n          }\n          if (freq0 != docFreq)\n            throw new RuntimeException(\"term \" + term + \" docFreq=\" + docFreq + \" != num docs seen \" + freq0);\n        }\n\n        System.out.println(\"OK [\" + termCount + \" terms; \" + totFreq + \" terms/docs pairs; \" + totPos + \" tokens]\");\n\n        System.out.print(\"    test: stored fields.......\");\n        int docCount = 0;\n        long totFields = 0;\n        for(int j=0;j<info.docCount;j++)\n          if (!reader.isDeleted(j)) {\n            docCount++;\n            Document doc = reader.document(j);\n            totFields += doc.getFields().size();\n          }\n\n        if (docCount != reader.numDocs())\n          throw new RuntimeException(\"docCount=\" + docCount + \" but saw \" + docCount + \" undeleted docs\");\n\n        System.out.println(\"OK [\" + totFields + \" total field count; avg \" + nf.format((((float) totFields)/docCount)) + \" fields per doc]\");\n\n        System.out.print(\"    test: term vectors........\");\n        int totVectors = 0;\n        for(int j=0;j<info.docCount;j++)\n          if (!reader.isDeleted(j)) {\n            TermFreqVector[] tfv = reader.getTermFreqVectors(j);\n            if (tfv != null)\n              totVectors += tfv.length;\n          }\n\n        System.out.println(\"OK [\" + totVectors + \" total vector count; avg \" + nf.format((((float) totVectors)/docCount)) + \" term/freq vector fields per doc]\");\n        System.out.println(\"\");\n\n      } catch (Throwable t) {\n        System.out.println(\"FAILED\");\n        String comment;\n        if (doFix)\n          comment = \"will remove reference to this segment (-fix is specified)\";\n        else\n          comment = \"would remove reference to this segment (-fix was not specified)\";\n        System.out.println(\"    WARNING: \" + comment + \"; full exception:\");\n        t.printStackTrace(System.out);\n        System.out.println(\"\");\n        totLoseDocCount += toLoseDocCount;\n        numBadSegments++;\n        changed = true;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      newSIS.add(info.clone());\n    }\n\n    if (!changed) {\n      System.out.println(\"No problems were detected with this index.\\n\");\n      System.exit(0);\n    } else {\n      System.out.println(\"WARNING: \" + numBadSegments + \" broken segments detected\");\n      if (doFix)\n        System.out.println(\"WARNING: \" + totLoseDocCount + \" documents will be lost\");\n      else\n        System.out.println(\"WARNING: \" + totLoseDocCount + \" documents would be lost if -fix were specified\");\n      System.out.println(\"\");\n    }\n\n    if (doFix) {\n      System.out.println(\"NOTE: will write new segments file in 5 seconds; this will remove \" + totLoseDocCount + \" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!\");\n      for(int i=0;i<5;i++) {\n        Thread.sleep(1000);\n        System.out.println(\"  \" + (5-i) + \"...\");\n      }\n      System.out.print(\"Writing...\");\n      try {\n        newSIS.write(dir);\n      } catch (Throwable t) {\n        System.out.println(\"FAILED; exiting\");\n        t.printStackTrace(System.out);\n        System.exit(1);\n      }\n      System.out.println(\"OK\");\n      System.out.println(\"Wrote new segments file \\\"\" + newSIS.getCurrentSegmentFileName() + \"\\\"\");\n    } else {\n      System.out.println(\"NOTE: would write new segments file [-fix was not specified]\");\n    }\n    System.out.println(\"\");\n\n    System.exit(0);\n  }\n\n","bugFix":["326b3b177da8135f97e1832c22fbae8dab7c9400","996842e9b73111f695c542be757f2b3cd541b60a"],"bugIntro":["7391c1f4ab1a6817de8a262f5c1b3de3cf190785","f7523916a1350712e1ae710affd4e88ccd7c431d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a64db7380e46c730a4ff0f00ebd7b29219312c14","date":1201253781,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","pathOld":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Throwable {\n\n    boolean doFix = false;\n    List onlySegments = new ArrayList();\n    String indexPath = null;\n    int i = 0;\n    while(i < args.length) {\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        i++;\n      } else if (args[i].equals(\"-segment\")) {\n        if (i == args.length-1) {\n          out.println(\"ERROR: missing name for -segment option\");\n          System.exit(1);\n        }\n        onlySegments.add(args[i+1]);\n        i += 2;\n      } else {\n        if (indexPath != null) {\n          out.println(\"ERROR: unexpected extra argument '\" + args[i] + \"'\");\n          System.exit(1);\n        }\n        indexPath = args[i];\n        i++;\n      }\n    }\n\n    if (indexPath == null) {\n      out.println(\"\\nERROR: index path not specified\");\n      out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"  -segment X: only check the specified segments.  This can be specified multiple\\n\" + \n                         \"              times, to check more than one segment, eg '-segment _2 -segment _a'.\\n\" +\n                         \"              You can't use this with the -fix option\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\" +\n                         \"\\n\" +\n                         \"This tool exits with exit code 1 if the index cannot be opened or has has any\\n\" +\n                         \"corruption, else 0.\\n\");\n      System.exit(1);\n    }\n\n    if (onlySegments.size() == 0)\n      onlySegments = null;\n    else if (doFix) {\n      out.println(\"ERROR: cannot specify both -fix and -segment\");\n      System.exit(1);\n    }\n\n    out.println(\"\\nOpening index @ \" + indexPath + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.getDirectory(indexPath);\n    } catch (Throwable t) {\n      out.println(\"ERROR: could not open directory \\\"\" + indexPath + \"\\\"; exiting\");\n      t.printStackTrace(out);\n      System.exit(1);\n    }\n\n    boolean isClean = check(dir, doFix, onlySegments);\n\n    final int exitCode;\n    if (isClean)\n      exitCode = 0;\n    else\n      exitCode = 1;\n    System.exit(exitCode);\n  }    \n\n","sourceOld":"  public static void main(String[] args) throws Throwable {\n\n    boolean doFix = false;\n    for(int i=0;i<args.length;i++)\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        break;\n      }\n\n    if (args.length != (doFix ? 2:1)) {\n      out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\" +\n                         \"\\n\" +\n                         \"This tool exits with exit code 1 if the index cannot be opened or has has any\\n\" +\n                         \"corruption, else 0.\\n\");\n      System.exit(1);\n    }\n\n    final String dirName = args[0];\n    out.println(\"\\nOpening index @ \" + dirName + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.getDirectory(dirName);\n    } catch (Throwable t) {\n      out.println(\"ERROR: could not open directory \\\"\" + dirName + \"\\\"; exiting\");\n      t.printStackTrace(out);\n      System.exit(1);\n    }\n\n    boolean isClean = check(dir, doFix);\n\n    final int exitCode;\n    if (isClean)\n      exitCode = 0;\n    else\n      exitCode = 1;\n    System.exit(exitCode);\n  }    \n\n","bugFix":null,"bugIntro":["f7523916a1350712e1ae710affd4e88ccd7c431d","8eaedf240fab95c428d5f496a274256d2053ad37"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9cb1313e01866149ff8dde7e80345a5476de305e","date":1208975167,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","pathOld":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Throwable {\n\n    boolean doFix = false;\n    List onlySegments = new ArrayList();\n    String indexPath = null;\n    int i = 0;\n    while(i < args.length) {\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        i++;\n      } else if (args[i].equals(\"-segment\")) {\n        if (i == args.length-1) {\n          out.println(\"ERROR: missing name for -segment option\");\n          System.exit(1);\n        }\n        onlySegments.add(args[i+1]);\n        i += 2;\n      } else {\n        if (indexPath != null) {\n          out.println(\"ERROR: unexpected extra argument '\" + args[i] + \"'\");\n          System.exit(1);\n        }\n        indexPath = args[i];\n        i++;\n      }\n    }\n\n    if (indexPath == null) {\n      out.println(\"\\nERROR: index path not specified\");\n      out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"  -segment X: only check the specified segments.  This can be specified multiple\\n\" + \n                         \"              times, to check more than one segment, eg '-segment _2 -segment _a'.\\n\" +\n                         \"              You can't use this with the -fix option\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\" +\n                         \"\\n\" +\n                         \"This tool exits with exit code 1 if the index cannot be opened or has has any\\n\" +\n                         \"corruption, else 0.\\n\");\n      System.exit(1);\n    }\n\n    if (onlySegments.size() == 0)\n      onlySegments = null;\n    else if (doFix) {\n      out.println(\"ERROR: cannot specify both -fix and -segment\");\n      System.exit(1);\n    }\n\n    assert testAsserts();\n    if (!assertsOn)\n      out.println(\"\\nNOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene', so assertions are enabled\");\n\n    out.println(\"\\nOpening index @ \" + indexPath + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.getDirectory(indexPath);\n    } catch (Throwable t) {\n      out.println(\"ERROR: could not open directory \\\"\" + indexPath + \"\\\"; exiting\");\n      t.printStackTrace(out);\n      System.exit(1);\n    }\n\n    boolean isClean = check(dir, doFix, onlySegments);\n\n    final int exitCode;\n    if (isClean)\n      exitCode = 0;\n    else\n      exitCode = 1;\n    System.exit(exitCode);\n  }    \n\n","sourceOld":"  public static void main(String[] args) throws Throwable {\n\n    boolean doFix = false;\n    List onlySegments = new ArrayList();\n    String indexPath = null;\n    int i = 0;\n    while(i < args.length) {\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        i++;\n      } else if (args[i].equals(\"-segment\")) {\n        if (i == args.length-1) {\n          out.println(\"ERROR: missing name for -segment option\");\n          System.exit(1);\n        }\n        onlySegments.add(args[i+1]);\n        i += 2;\n      } else {\n        if (indexPath != null) {\n          out.println(\"ERROR: unexpected extra argument '\" + args[i] + \"'\");\n          System.exit(1);\n        }\n        indexPath = args[i];\n        i++;\n      }\n    }\n\n    if (indexPath == null) {\n      out.println(\"\\nERROR: index path not specified\");\n      out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"  -segment X: only check the specified segments.  This can be specified multiple\\n\" + \n                         \"              times, to check more than one segment, eg '-segment _2 -segment _a'.\\n\" +\n                         \"              You can't use this with the -fix option\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\" +\n                         \"\\n\" +\n                         \"This tool exits with exit code 1 if the index cannot be opened or has has any\\n\" +\n                         \"corruption, else 0.\\n\");\n      System.exit(1);\n    }\n\n    if (onlySegments.size() == 0)\n      onlySegments = null;\n    else if (doFix) {\n      out.println(\"ERROR: cannot specify both -fix and -segment\");\n      System.exit(1);\n    }\n\n    out.println(\"\\nOpening index @ \" + indexPath + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.getDirectory(indexPath);\n    } catch (Throwable t) {\n      out.println(\"ERROR: could not open directory \\\"\" + indexPath + \"\\\"; exiting\");\n      t.printStackTrace(out);\n      System.exit(1);\n    }\n\n    boolean isClean = check(dir, doFix, onlySegments);\n\n    final int exitCode;\n    if (isClean)\n      exitCode = 0;\n    else\n      exitCode = 1;\n    System.exit(exitCode);\n  }    \n\n","bugFix":null,"bugIntro":["7391c1f4ab1a6817de8a262f5c1b3de3cf190785"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cba44a7c8f0e3eb449bcdbd53960b7705c0bf902","date":1220978058,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","pathOld":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Throwable {\n\n    boolean doFix = false;\n    List onlySegments = new ArrayList();\n    String indexPath = null;\n    int i = 0;\n    while(i < args.length) {\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        i++;\n      } else if (args[i].equals(\"-segment\")) {\n        if (i == args.length-1) {\n          msg(\"ERROR: missing name for -segment option\");\n          System.exit(1);\n        }\n        onlySegments.add(args[i+1]);\n        i += 2;\n      } else {\n        if (indexPath != null) {\n          msg(\"ERROR: unexpected extra argument '\" + args[i] + \"'\");\n          System.exit(1);\n        }\n        indexPath = args[i];\n        i++;\n      }\n    }\n\n    if (indexPath == null) {\n      msg(\"\\nERROR: index path not specified\");\n      msg(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"  -segment X: only check the specified segments.  This can be specified multiple\\n\" + \n                         \"              times, to check more than one segment, eg '-segment _2 -segment _a'.\\n\" +\n                         \"              You can't use this with the -fix option\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\" +\n                         \"\\n\" +\n                         \"This tool exits with exit code 1 if the index cannot be opened or has has any\\n\" +\n                         \"corruption, else 0.\\n\");\n      System.exit(1);\n    }\n\n    if (onlySegments.size() == 0)\n      onlySegments = null;\n    else if (doFix) {\n      msg(\"ERROR: cannot specify both -fix and -segment\");\n      System.exit(1);\n    }\n\n    assert testAsserts();\n    if (!assertsOn)\n      msg(\"\\nNOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene', so assertions are enabled\");\n\n    msg(\"\\nOpening index @ \" + indexPath + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.getDirectory(indexPath);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open directory \\\"\" + indexPath + \"\\\"; exiting\");\n      t.printStackTrace(out);\n      System.exit(1);\n    }\n\n    CheckIndexStatus result = check(dir, doFix, onlySegments);\n\n    if (!result.clean) {\n      if (!doFix){\n        msg(\"WARNING: would write new segments file, and \" + result.totLoseDocCount + \" documents would be lost, if -fix were specified\\n\");\n      } else {\n        msg(\"WARNING: \" + result.totLoseDocCount + \" documents will be lost\\n\");\n        msg(\"NOTE: will write new segments file in 5 seconds; this will remove \" + result.totLoseDocCount + \" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!\");\n        for(int s=0;s<5;s++) {\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n            s--;\n            continue;\n          }\n          msg(\"  \" + (5-i) + \"...\");\n        }\n        msg(\"Writing...\");\n        CheckIndex.fix(result);\n      }\n      msg(\"OK\");\n      msg(\"Wrote new segments file \\\"\" + result.newSegments.getCurrentSegmentFileName() + \"\\\"\");\n    }\n    msg(\"\");\n\n    final int exitCode;\n    if (result != null && result.clean == true)\n      exitCode = 0;\n    else\n      exitCode = 1;\n    System.exit(exitCode);\n  }\n\n","sourceOld":"  public static void main(String[] args) throws Throwable {\n\n    boolean doFix = false;\n    List onlySegments = new ArrayList();\n    String indexPath = null;\n    int i = 0;\n    while(i < args.length) {\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        i++;\n      } else if (args[i].equals(\"-segment\")) {\n        if (i == args.length-1) {\n          out.println(\"ERROR: missing name for -segment option\");\n          System.exit(1);\n        }\n        onlySegments.add(args[i+1]);\n        i += 2;\n      } else {\n        if (indexPath != null) {\n          out.println(\"ERROR: unexpected extra argument '\" + args[i] + \"'\");\n          System.exit(1);\n        }\n        indexPath = args[i];\n        i++;\n      }\n    }\n\n    if (indexPath == null) {\n      out.println(\"\\nERROR: index path not specified\");\n      out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"  -segment X: only check the specified segments.  This can be specified multiple\\n\" + \n                         \"              times, to check more than one segment, eg '-segment _2 -segment _a'.\\n\" +\n                         \"              You can't use this with the -fix option\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\" +\n                         \"\\n\" +\n                         \"This tool exits with exit code 1 if the index cannot be opened or has has any\\n\" +\n                         \"corruption, else 0.\\n\");\n      System.exit(1);\n    }\n\n    if (onlySegments.size() == 0)\n      onlySegments = null;\n    else if (doFix) {\n      out.println(\"ERROR: cannot specify both -fix and -segment\");\n      System.exit(1);\n    }\n\n    assert testAsserts();\n    if (!assertsOn)\n      out.println(\"\\nNOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene', so assertions are enabled\");\n\n    out.println(\"\\nOpening index @ \" + indexPath + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.getDirectory(indexPath);\n    } catch (Throwable t) {\n      out.println(\"ERROR: could not open directory \\\"\" + indexPath + \"\\\"; exiting\");\n      t.printStackTrace(out);\n      System.exit(1);\n    }\n\n    boolean isClean = check(dir, doFix, onlySegments);\n\n    final int exitCode;\n    if (isClean)\n      exitCode = 0;\n    else\n      exitCode = 1;\n    System.exit(exitCode);\n  }    \n\n","bugFix":null,"bugIntro":["7391c1f4ab1a6817de8a262f5c1b3de3cf190785","f7523916a1350712e1ae710affd4e88ccd7c431d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7391c1f4ab1a6817de8a262f5c1b3de3cf190785","date":1222335791,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","pathOld":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","sourceNew":"  /** Command-line interface to check and fix an index.\n\n    <p>\n    Run it like this:\n    <pre>\n    java -ea:org.apache.lucene... org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\n    </pre>\n    <ul>\n    <li><code>-fix</code>: actually write a new segments_N file, removing any problematic segments\n\n    <li><code>-segment X</code>: only check the specified\n    segment(s).  This can be specified multiple times,\n    to check more than one segment, eg <code>-segment _2\n    -segment _a</code>.  You can't use this with the -fix\n    option.\n    </ul>\n\n    <p><b>WARNING</b>: <code>-fix</code> should only be used on an emergency basis as it will cause\n                       documents (perhaps many) to be permanently removed from the index.  Always make\n                       a backup copy of your index before running this!  Do not run this tool on an index\n                       that is actively being written to.  You have been warned!\n\n    <p>                Run without -fix, this tool will open the index, report version information\n                       and report any exceptions it hits and what action it would take if -fix were\n                       specified.  With -fix, this tool will remove any segments that have issues and\n                       write a new segments_N file.  This means all documents contained in the affected\n                       segments will be removed.\n\n    <p>\n                       This tool exits with exit code 1 if the index cannot be opened or has any\n                       corruption, else 0.\n   */\n  public static void main(String[] args) throws IOException {\n\n    boolean doFix = false;\n    List onlySegments = new ArrayList();\n    String indexPath = null;\n    int i = 0;\n    while(i < args.length) {\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        i++;\n      } else if (args[i].equals(\"-segment\")) {\n        if (i == args.length-1) {\n          System.out.println(\"ERROR: missing name for -segment option\");\n          System.exit(1);\n        }\n        onlySegments.add(args[i+1]);\n        i += 2;\n      } else {\n        if (indexPath != null) {\n          System.out.println(\"ERROR: unexpected extra argument '\" + args[i] + \"'\");\n          System.exit(1);\n        }\n        indexPath = args[i];\n        i++;\n      }\n    }\n\n    if (indexPath == null) {\n      System.out.println(\"\\nERROR: index path not specified\");\n      System.out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"  -segment X: only check the specified segments.  This can be specified multiple\\n\" + \n                         \"              times, to check more than one segment, eg '-segment _2 -segment _a'.\\n\" +\n                         \"              You can't use this with the -fix option\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\" +\n                         \"\\n\" +\n                         \"This tool exits with exit code 1 if the index cannot be opened or has any\\n\" +\n                         \"corruption, else 0.\\n\");\n      System.exit(1);\n    }\n\n    if (!assertsOn())\n      System.out.println(\"\\nNOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene...', so assertions are enabled\");\n\n    if (onlySegments.size() == 0)\n      onlySegments = null;\n    else if (doFix) {\n      System.out.println(\"ERROR: cannot specify both -fix and -segment\");\n      System.exit(1);\n    }\n\n    System.out.println(\"\\nOpening index @ \" + indexPath + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.getDirectory(indexPath);\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not open directory \\\"\" + indexPath + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n\n    CheckIndex checker = new CheckIndex(dir);\n    checker.setInfoStream(System.out);\n\n    Status result = checker.checkIndex(onlySegments);\n\n    if (!result.clean) {\n      if (!doFix) {\n        System.out.println(\"WARNING: would write new segments file, and \" + result.totLoseDocCount + \" documents would be lost, if -fix were specified\\n\");\n      } else {\n        System.out.println(\"WARNING: \" + result.totLoseDocCount + \" documents will be lost\\n\");\n        System.out.println(\"NOTE: will write new segments file in 5 seconds; this will remove \" + result.totLoseDocCount + \" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!\");\n        for(int s=0;s<5;s++) {\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n            s--;\n            continue;\n          }\n          System.out.println(\"  \" + (5-s) + \"...\");\n        }\n        System.out.println(\"Writing...\");\n        checker.fixIndex(result);\n        System.out.println(\"OK\");\n        System.out.println(\"Wrote new segments file \\\"\" + result.newSegments.getCurrentSegmentFileName() + \"\\\"\");\n      }\n    }\n    System.out.println(\"\");\n\n    final int exitCode;\n    if (result != null && result.clean == true)\n      exitCode = 0;\n    else\n      exitCode = 1;\n    System.exit(exitCode);\n  }\n\n","sourceOld":"  public static void main(String[] args) throws Throwable {\n\n    boolean doFix = false;\n    List onlySegments = new ArrayList();\n    String indexPath = null;\n    int i = 0;\n    while(i < args.length) {\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        i++;\n      } else if (args[i].equals(\"-segment\")) {\n        if (i == args.length-1) {\n          msg(\"ERROR: missing name for -segment option\");\n          System.exit(1);\n        }\n        onlySegments.add(args[i+1]);\n        i += 2;\n      } else {\n        if (indexPath != null) {\n          msg(\"ERROR: unexpected extra argument '\" + args[i] + \"'\");\n          System.exit(1);\n        }\n        indexPath = args[i];\n        i++;\n      }\n    }\n\n    if (indexPath == null) {\n      msg(\"\\nERROR: index path not specified\");\n      msg(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"  -segment X: only check the specified segments.  This can be specified multiple\\n\" + \n                         \"              times, to check more than one segment, eg '-segment _2 -segment _a'.\\n\" +\n                         \"              You can't use this with the -fix option\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\" +\n                         \"\\n\" +\n                         \"This tool exits with exit code 1 if the index cannot be opened or has has any\\n\" +\n                         \"corruption, else 0.\\n\");\n      System.exit(1);\n    }\n\n    if (onlySegments.size() == 0)\n      onlySegments = null;\n    else if (doFix) {\n      msg(\"ERROR: cannot specify both -fix and -segment\");\n      System.exit(1);\n    }\n\n    assert testAsserts();\n    if (!assertsOn)\n      msg(\"\\nNOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene', so assertions are enabled\");\n\n    msg(\"\\nOpening index @ \" + indexPath + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.getDirectory(indexPath);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open directory \\\"\" + indexPath + \"\\\"; exiting\");\n      t.printStackTrace(out);\n      System.exit(1);\n    }\n\n    CheckIndexStatus result = check(dir, doFix, onlySegments);\n\n    if (!result.clean) {\n      if (!doFix){\n        msg(\"WARNING: would write new segments file, and \" + result.totLoseDocCount + \" documents would be lost, if -fix were specified\\n\");\n      } else {\n        msg(\"WARNING: \" + result.totLoseDocCount + \" documents will be lost\\n\");\n        msg(\"NOTE: will write new segments file in 5 seconds; this will remove \" + result.totLoseDocCount + \" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!\");\n        for(int s=0;s<5;s++) {\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n            s--;\n            continue;\n          }\n          msg(\"  \" + (5-i) + \"...\");\n        }\n        msg(\"Writing...\");\n        CheckIndex.fix(result);\n      }\n      msg(\"OK\");\n      msg(\"Wrote new segments file \\\"\" + result.newSegments.getCurrentSegmentFileName() + \"\\\"\");\n    }\n    msg(\"\");\n\n    final int exitCode;\n    if (result != null && result.clean == true)\n      exitCode = 0;\n    else\n      exitCode = 1;\n    System.exit(exitCode);\n  }\n\n","bugFix":["5b38e3f2849cb8d8626cd5368aa64de4fed9edde","326b3b177da8135f97e1832c22fbae8dab7c9400","cba44a7c8f0e3eb449bcdbd53960b7705c0bf902","9cb1313e01866149ff8dde7e80345a5476de305e"],"bugIntro":["f7523916a1350712e1ae710affd4e88ccd7c431d","8eaedf240fab95c428d5f496a274256d2053ad37"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba7fd1181f778e9954547e8e6a47587ebf08e3fb","date":1238267455,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","pathOld":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","sourceNew":"  /** Command-line interface to check and fix an index.\n\n    <p>\n    Run it like this:\n    <pre>\n    java -ea:org.apache.lucene... org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\n    </pre>\n    <ul>\n    <li><code>-fix</code>: actually write a new segments_N file, removing any problematic segments\n\n    <li><code>-segment X</code>: only check the specified\n    segment(s).  This can be specified multiple times,\n    to check more than one segment, eg <code>-segment _2\n    -segment _a</code>.  You can't use this with the -fix\n    option.\n    </ul>\n\n    <p><b>WARNING</b>: <code>-fix</code> should only be used on an emergency basis as it will cause\n                       documents (perhaps many) to be permanently removed from the index.  Always make\n                       a backup copy of your index before running this!  Do not run this tool on an index\n                       that is actively being written to.  You have been warned!\n\n    <p>                Run without -fix, this tool will open the index, report version information\n                       and report any exceptions it hits and what action it would take if -fix were\n                       specified.  With -fix, this tool will remove any segments that have issues and\n                       write a new segments_N file.  This means all documents contained in the affected\n                       segments will be removed.\n\n    <p>\n                       This tool exits with exit code 1 if the index cannot be opened or has any\n                       corruption, else 0.\n   */\n  public static void main(String[] args) throws IOException, InterruptedException {\n\n    boolean doFix = false;\n    List onlySegments = new ArrayList();\n    String indexPath = null;\n    int i = 0;\n    while(i < args.length) {\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        i++;\n      } else if (args[i].equals(\"-segment\")) {\n        if (i == args.length-1) {\n          System.out.println(\"ERROR: missing name for -segment option\");\n          System.exit(1);\n        }\n        onlySegments.add(args[i+1]);\n        i += 2;\n      } else {\n        if (indexPath != null) {\n          System.out.println(\"ERROR: unexpected extra argument '\" + args[i] + \"'\");\n          System.exit(1);\n        }\n        indexPath = args[i];\n        i++;\n      }\n    }\n\n    if (indexPath == null) {\n      System.out.println(\"\\nERROR: index path not specified\");\n      System.out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"  -segment X: only check the specified segments.  This can be specified multiple\\n\" + \n                         \"              times, to check more than one segment, eg '-segment _2 -segment _a'.\\n\" +\n                         \"              You can't use this with the -fix option\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\" +\n                         \"\\n\" +\n                         \"This tool exits with exit code 1 if the index cannot be opened or has any\\n\" +\n                         \"corruption, else 0.\\n\");\n      System.exit(1);\n    }\n\n    if (!assertsOn())\n      System.out.println(\"\\nNOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene...', so assertions are enabled\");\n\n    if (onlySegments.size() == 0)\n      onlySegments = null;\n    else if (doFix) {\n      System.out.println(\"ERROR: cannot specify both -fix and -segment\");\n      System.exit(1);\n    }\n\n    System.out.println(\"\\nOpening index @ \" + indexPath + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.getDirectory(indexPath);\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not open directory \\\"\" + indexPath + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n\n    CheckIndex checker = new CheckIndex(dir);\n    checker.setInfoStream(System.out);\n\n    Status result = checker.checkIndex(onlySegments);\n\n    if (!result.clean) {\n      if (!doFix) {\n        System.out.println(\"WARNING: would write new segments file, and \" + result.totLoseDocCount + \" documents would be lost, if -fix were specified\\n\");\n      } else {\n        System.out.println(\"WARNING: \" + result.totLoseDocCount + \" documents will be lost\\n\");\n        System.out.println(\"NOTE: will write new segments file in 5 seconds; this will remove \" + result.totLoseDocCount + \" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!\");\n        for(int s=0;s<5;s++) {\n          Thread.sleep(1000);\n          System.out.println(\"  \" + (5-s) + \"...\");\n        }\n        System.out.println(\"Writing...\");\n        checker.fixIndex(result);\n        System.out.println(\"OK\");\n        System.out.println(\"Wrote new segments file \\\"\" + result.newSegments.getCurrentSegmentFileName() + \"\\\"\");\n      }\n    }\n    System.out.println(\"\");\n\n    final int exitCode;\n    if (result != null && result.clean == true)\n      exitCode = 0;\n    else\n      exitCode = 1;\n    System.exit(exitCode);\n  }\n\n","sourceOld":"  /** Command-line interface to check and fix an index.\n\n    <p>\n    Run it like this:\n    <pre>\n    java -ea:org.apache.lucene... org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\n    </pre>\n    <ul>\n    <li><code>-fix</code>: actually write a new segments_N file, removing any problematic segments\n\n    <li><code>-segment X</code>: only check the specified\n    segment(s).  This can be specified multiple times,\n    to check more than one segment, eg <code>-segment _2\n    -segment _a</code>.  You can't use this with the -fix\n    option.\n    </ul>\n\n    <p><b>WARNING</b>: <code>-fix</code> should only be used on an emergency basis as it will cause\n                       documents (perhaps many) to be permanently removed from the index.  Always make\n                       a backup copy of your index before running this!  Do not run this tool on an index\n                       that is actively being written to.  You have been warned!\n\n    <p>                Run without -fix, this tool will open the index, report version information\n                       and report any exceptions it hits and what action it would take if -fix were\n                       specified.  With -fix, this tool will remove any segments that have issues and\n                       write a new segments_N file.  This means all documents contained in the affected\n                       segments will be removed.\n\n    <p>\n                       This tool exits with exit code 1 if the index cannot be opened or has any\n                       corruption, else 0.\n   */\n  public static void main(String[] args) throws IOException {\n\n    boolean doFix = false;\n    List onlySegments = new ArrayList();\n    String indexPath = null;\n    int i = 0;\n    while(i < args.length) {\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        i++;\n      } else if (args[i].equals(\"-segment\")) {\n        if (i == args.length-1) {\n          System.out.println(\"ERROR: missing name for -segment option\");\n          System.exit(1);\n        }\n        onlySegments.add(args[i+1]);\n        i += 2;\n      } else {\n        if (indexPath != null) {\n          System.out.println(\"ERROR: unexpected extra argument '\" + args[i] + \"'\");\n          System.exit(1);\n        }\n        indexPath = args[i];\n        i++;\n      }\n    }\n\n    if (indexPath == null) {\n      System.out.println(\"\\nERROR: index path not specified\");\n      System.out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"  -segment X: only check the specified segments.  This can be specified multiple\\n\" + \n                         \"              times, to check more than one segment, eg '-segment _2 -segment _a'.\\n\" +\n                         \"              You can't use this with the -fix option\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\" +\n                         \"\\n\" +\n                         \"This tool exits with exit code 1 if the index cannot be opened or has any\\n\" +\n                         \"corruption, else 0.\\n\");\n      System.exit(1);\n    }\n\n    if (!assertsOn())\n      System.out.println(\"\\nNOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene...', so assertions are enabled\");\n\n    if (onlySegments.size() == 0)\n      onlySegments = null;\n    else if (doFix) {\n      System.out.println(\"ERROR: cannot specify both -fix and -segment\");\n      System.exit(1);\n    }\n\n    System.out.println(\"\\nOpening index @ \" + indexPath + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.getDirectory(indexPath);\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not open directory \\\"\" + indexPath + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n\n    CheckIndex checker = new CheckIndex(dir);\n    checker.setInfoStream(System.out);\n\n    Status result = checker.checkIndex(onlySegments);\n\n    if (!result.clean) {\n      if (!doFix) {\n        System.out.println(\"WARNING: would write new segments file, and \" + result.totLoseDocCount + \" documents would be lost, if -fix were specified\\n\");\n      } else {\n        System.out.println(\"WARNING: \" + result.totLoseDocCount + \" documents will be lost\\n\");\n        System.out.println(\"NOTE: will write new segments file in 5 seconds; this will remove \" + result.totLoseDocCount + \" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!\");\n        for(int s=0;s<5;s++) {\n          try {\n            Thread.sleep(1000);\n          } catch (InterruptedException ie) {\n            Thread.currentThread().interrupt();\n            s--;\n            continue;\n          }\n          System.out.println(\"  \" + (5-s) + \"...\");\n        }\n        System.out.println(\"Writing...\");\n        checker.fixIndex(result);\n        System.out.println(\"OK\");\n        System.out.println(\"Wrote new segments file \\\"\" + result.newSegments.getCurrentSegmentFileName() + \"\\\"\");\n      }\n    }\n    System.out.println(\"\");\n\n    final int exitCode;\n    if (result != null && result.clean == true)\n      exitCode = 0;\n    else\n      exitCode = 1;\n    System.exit(exitCode);\n  }\n\n","bugFix":null,"bugIntro":["f7523916a1350712e1ae710affd4e88ccd7c431d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bf757952ed13ac1d3bec8adf69bcfde39031cdb5","date":1243362950,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","pathOld":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","sourceNew":"  /** Command-line interface to check and fix an index.\n\n    <p>\n    Run it like this:\n    <pre>\n    java -ea:org.apache.lucene... org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\n    </pre>\n    <ul>\n    <li><code>-fix</code>: actually write a new segments_N file, removing any problematic segments\n\n    <li><code>-segment X</code>: only check the specified\n    segment(s).  This can be specified multiple times,\n    to check more than one segment, eg <code>-segment _2\n    -segment _a</code>.  You can't use this with the -fix\n    option.\n    </ul>\n\n    <p><b>WARNING</b>: <code>-fix</code> should only be used on an emergency basis as it will cause\n                       documents (perhaps many) to be permanently removed from the index.  Always make\n                       a backup copy of your index before running this!  Do not run this tool on an index\n                       that is actively being written to.  You have been warned!\n\n    <p>                Run without -fix, this tool will open the index, report version information\n                       and report any exceptions it hits and what action it would take if -fix were\n                       specified.  With -fix, this tool will remove any segments that have issues and\n                       write a new segments_N file.  This means all documents contained in the affected\n                       segments will be removed.\n\n    <p>\n                       This tool exits with exit code 1 if the index cannot be opened or has any\n                       corruption, else 0.\n   */\n  public static void main(String[] args) throws IOException, InterruptedException {\n\n    boolean doFix = false;\n    List onlySegments = new ArrayList();\n    String indexPath = null;\n    int i = 0;\n    while(i < args.length) {\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        i++;\n      } else if (args[i].equals(\"-segment\")) {\n        if (i == args.length-1) {\n          System.out.println(\"ERROR: missing name for -segment option\");\n          System.exit(1);\n        }\n        onlySegments.add(args[i+1]);\n        i += 2;\n      } else {\n        if (indexPath != null) {\n          System.out.println(\"ERROR: unexpected extra argument '\" + args[i] + \"'\");\n          System.exit(1);\n        }\n        indexPath = args[i];\n        i++;\n      }\n    }\n\n    if (indexPath == null) {\n      System.out.println(\"\\nERROR: index path not specified\");\n      System.out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"  -segment X: only check the specified segments.  This can be specified multiple\\n\" + \n                         \"              times, to check more than one segment, eg '-segment _2 -segment _a'.\\n\" +\n                         \"              You can't use this with the -fix option\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\" +\n                         \"\\n\" +\n                         \"This tool exits with exit code 1 if the index cannot be opened or has any\\n\" +\n                         \"corruption, else 0.\\n\");\n      System.exit(1);\n    }\n\n    if (!assertsOn())\n      System.out.println(\"\\nNOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene...', so assertions are enabled\");\n\n    if (onlySegments.size() == 0)\n      onlySegments = null;\n    else if (doFix) {\n      System.out.println(\"ERROR: cannot specify both -fix and -segment\");\n      System.exit(1);\n    }\n\n    System.out.println(\"\\nOpening index @ \" + indexPath + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.getDirectory(indexPath);\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not open directory \\\"\" + indexPath + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n\n    CheckIndex checker = new CheckIndex(dir);\n    checker.setInfoStream(System.out);\n\n    Status result = checker.checkIndex(onlySegments);\n    if (result.missingSegments) {\n      System.exit(1);\n    }\n\n    if (!result.clean) {\n      if (!doFix) {\n        System.out.println(\"WARNING: would write new segments file, and \" + result.totLoseDocCount + \" documents would be lost, if -fix were specified\\n\");\n      } else {\n        System.out.println(\"WARNING: \" + result.totLoseDocCount + \" documents will be lost\\n\");\n        System.out.println(\"NOTE: will write new segments file in 5 seconds; this will remove \" + result.totLoseDocCount + \" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!\");\n        for(int s=0;s<5;s++) {\n          Thread.sleep(1000);\n          System.out.println(\"  \" + (5-s) + \"...\");\n        }\n        System.out.println(\"Writing...\");\n        checker.fixIndex(result);\n        System.out.println(\"OK\");\n        System.out.println(\"Wrote new segments file \\\"\" + result.newSegments.getCurrentSegmentFileName() + \"\\\"\");\n      }\n    }\n    System.out.println(\"\");\n\n    final int exitCode;\n    if (result != null && result.clean == true)\n      exitCode = 0;\n    else\n      exitCode = 1;\n    System.exit(exitCode);\n  }\n\n","sourceOld":"  /** Command-line interface to check and fix an index.\n\n    <p>\n    Run it like this:\n    <pre>\n    java -ea:org.apache.lucene... org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\n    </pre>\n    <ul>\n    <li><code>-fix</code>: actually write a new segments_N file, removing any problematic segments\n\n    <li><code>-segment X</code>: only check the specified\n    segment(s).  This can be specified multiple times,\n    to check more than one segment, eg <code>-segment _2\n    -segment _a</code>.  You can't use this with the -fix\n    option.\n    </ul>\n\n    <p><b>WARNING</b>: <code>-fix</code> should only be used on an emergency basis as it will cause\n                       documents (perhaps many) to be permanently removed from the index.  Always make\n                       a backup copy of your index before running this!  Do not run this tool on an index\n                       that is actively being written to.  You have been warned!\n\n    <p>                Run without -fix, this tool will open the index, report version information\n                       and report any exceptions it hits and what action it would take if -fix were\n                       specified.  With -fix, this tool will remove any segments that have issues and\n                       write a new segments_N file.  This means all documents contained in the affected\n                       segments will be removed.\n\n    <p>\n                       This tool exits with exit code 1 if the index cannot be opened or has any\n                       corruption, else 0.\n   */\n  public static void main(String[] args) throws IOException, InterruptedException {\n\n    boolean doFix = false;\n    List onlySegments = new ArrayList();\n    String indexPath = null;\n    int i = 0;\n    while(i < args.length) {\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        i++;\n      } else if (args[i].equals(\"-segment\")) {\n        if (i == args.length-1) {\n          System.out.println(\"ERROR: missing name for -segment option\");\n          System.exit(1);\n        }\n        onlySegments.add(args[i+1]);\n        i += 2;\n      } else {\n        if (indexPath != null) {\n          System.out.println(\"ERROR: unexpected extra argument '\" + args[i] + \"'\");\n          System.exit(1);\n        }\n        indexPath = args[i];\n        i++;\n      }\n    }\n\n    if (indexPath == null) {\n      System.out.println(\"\\nERROR: index path not specified\");\n      System.out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"  -segment X: only check the specified segments.  This can be specified multiple\\n\" + \n                         \"              times, to check more than one segment, eg '-segment _2 -segment _a'.\\n\" +\n                         \"              You can't use this with the -fix option\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\" +\n                         \"\\n\" +\n                         \"This tool exits with exit code 1 if the index cannot be opened or has any\\n\" +\n                         \"corruption, else 0.\\n\");\n      System.exit(1);\n    }\n\n    if (!assertsOn())\n      System.out.println(\"\\nNOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene...', so assertions are enabled\");\n\n    if (onlySegments.size() == 0)\n      onlySegments = null;\n    else if (doFix) {\n      System.out.println(\"ERROR: cannot specify both -fix and -segment\");\n      System.exit(1);\n    }\n\n    System.out.println(\"\\nOpening index @ \" + indexPath + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.getDirectory(indexPath);\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not open directory \\\"\" + indexPath + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n\n    CheckIndex checker = new CheckIndex(dir);\n    checker.setInfoStream(System.out);\n\n    Status result = checker.checkIndex(onlySegments);\n\n    if (!result.clean) {\n      if (!doFix) {\n        System.out.println(\"WARNING: would write new segments file, and \" + result.totLoseDocCount + \" documents would be lost, if -fix were specified\\n\");\n      } else {\n        System.out.println(\"WARNING: \" + result.totLoseDocCount + \" documents will be lost\\n\");\n        System.out.println(\"NOTE: will write new segments file in 5 seconds; this will remove \" + result.totLoseDocCount + \" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!\");\n        for(int s=0;s<5;s++) {\n          Thread.sleep(1000);\n          System.out.println(\"  \" + (5-s) + \"...\");\n        }\n        System.out.println(\"Writing...\");\n        checker.fixIndex(result);\n        System.out.println(\"OK\");\n        System.out.println(\"Wrote new segments file \\\"\" + result.newSegments.getCurrentSegmentFileName() + \"\\\"\");\n      }\n    }\n    System.out.println(\"\");\n\n    final int exitCode;\n    if (result != null && result.clean == true)\n      exitCode = 0;\n    else\n      exitCode = 1;\n    System.exit(exitCode);\n  }\n\n","bugFix":null,"bugIntro":["f7523916a1350712e1ae710affd4e88ccd7c431d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba712167ee848727018d8b77aa0c273839fbe15c","date":1244411561,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","pathOld":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","sourceNew":"  /** Command-line interface to check and fix an index.\n\n    <p>\n    Run it like this:\n    <pre>\n    java -ea:org.apache.lucene... org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\n    </pre>\n    <ul>\n    <li><code>-fix</code>: actually write a new segments_N file, removing any problematic segments\n\n    <li><code>-segment X</code>: only check the specified\n    segment(s).  This can be specified multiple times,\n    to check more than one segment, eg <code>-segment _2\n    -segment _a</code>.  You can't use this with the -fix\n    option.\n    </ul>\n\n    <p><b>WARNING</b>: <code>-fix</code> should only be used on an emergency basis as it will cause\n                       documents (perhaps many) to be permanently removed from the index.  Always make\n                       a backup copy of your index before running this!  Do not run this tool on an index\n                       that is actively being written to.  You have been warned!\n\n    <p>                Run without -fix, this tool will open the index, report version information\n                       and report any exceptions it hits and what action it would take if -fix were\n                       specified.  With -fix, this tool will remove any segments that have issues and\n                       write a new segments_N file.  This means all documents contained in the affected\n                       segments will be removed.\n\n    <p>\n                       This tool exits with exit code 1 if the index cannot be opened or has any\n                       corruption, else 0.\n   */\n  public static void main(String[] args) throws IOException, InterruptedException {\n\n    boolean doFix = false;\n    List onlySegments = new ArrayList();\n    String indexPath = null;\n    int i = 0;\n    while(i < args.length) {\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        i++;\n      } else if (args[i].equals(\"-segment\")) {\n        if (i == args.length-1) {\n          System.out.println(\"ERROR: missing name for -segment option\");\n          System.exit(1);\n        }\n        onlySegments.add(args[i+1]);\n        i += 2;\n      } else {\n        if (indexPath != null) {\n          System.out.println(\"ERROR: unexpected extra argument '\" + args[i] + \"'\");\n          System.exit(1);\n        }\n        indexPath = args[i];\n        i++;\n      }\n    }\n\n    if (indexPath == null) {\n      System.out.println(\"\\nERROR: index path not specified\");\n      System.out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"  -segment X: only check the specified segments.  This can be specified multiple\\n\" + \n                         \"              times, to check more than one segment, eg '-segment _2 -segment _a'.\\n\" +\n                         \"              You can't use this with the -fix option\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\" +\n                         \"\\n\" +\n                         \"This tool exits with exit code 1 if the index cannot be opened or has any\\n\" +\n                         \"corruption, else 0.\\n\");\n      System.exit(1);\n    }\n\n    if (!assertsOn())\n      System.out.println(\"\\nNOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene...', so assertions are enabled\");\n\n    if (onlySegments.size() == 0)\n      onlySegments = null;\n    else if (doFix) {\n      System.out.println(\"ERROR: cannot specify both -fix and -segment\");\n      System.exit(1);\n    }\n\n    System.out.println(\"\\nOpening index @ \" + indexPath + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.open(new File(indexPath));\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not open directory \\\"\" + indexPath + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n\n    CheckIndex checker = new CheckIndex(dir);\n    checker.setInfoStream(System.out);\n\n    Status result = checker.checkIndex(onlySegments);\n    if (result.missingSegments) {\n      System.exit(1);\n    }\n\n    if (!result.clean) {\n      if (!doFix) {\n        System.out.println(\"WARNING: would write new segments file, and \" + result.totLoseDocCount + \" documents would be lost, if -fix were specified\\n\");\n      } else {\n        System.out.println(\"WARNING: \" + result.totLoseDocCount + \" documents will be lost\\n\");\n        System.out.println(\"NOTE: will write new segments file in 5 seconds; this will remove \" + result.totLoseDocCount + \" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!\");\n        for(int s=0;s<5;s++) {\n          Thread.sleep(1000);\n          System.out.println(\"  \" + (5-s) + \"...\");\n        }\n        System.out.println(\"Writing...\");\n        checker.fixIndex(result);\n        System.out.println(\"OK\");\n        System.out.println(\"Wrote new segments file \\\"\" + result.newSegments.getCurrentSegmentFileName() + \"\\\"\");\n      }\n    }\n    System.out.println(\"\");\n\n    final int exitCode;\n    if (result != null && result.clean == true)\n      exitCode = 0;\n    else\n      exitCode = 1;\n    System.exit(exitCode);\n  }\n\n","sourceOld":"  /** Command-line interface to check and fix an index.\n\n    <p>\n    Run it like this:\n    <pre>\n    java -ea:org.apache.lucene... org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\n    </pre>\n    <ul>\n    <li><code>-fix</code>: actually write a new segments_N file, removing any problematic segments\n\n    <li><code>-segment X</code>: only check the specified\n    segment(s).  This can be specified multiple times,\n    to check more than one segment, eg <code>-segment _2\n    -segment _a</code>.  You can't use this with the -fix\n    option.\n    </ul>\n\n    <p><b>WARNING</b>: <code>-fix</code> should only be used on an emergency basis as it will cause\n                       documents (perhaps many) to be permanently removed from the index.  Always make\n                       a backup copy of your index before running this!  Do not run this tool on an index\n                       that is actively being written to.  You have been warned!\n\n    <p>                Run without -fix, this tool will open the index, report version information\n                       and report any exceptions it hits and what action it would take if -fix were\n                       specified.  With -fix, this tool will remove any segments that have issues and\n                       write a new segments_N file.  This means all documents contained in the affected\n                       segments will be removed.\n\n    <p>\n                       This tool exits with exit code 1 if the index cannot be opened or has any\n                       corruption, else 0.\n   */\n  public static void main(String[] args) throws IOException, InterruptedException {\n\n    boolean doFix = false;\n    List onlySegments = new ArrayList();\n    String indexPath = null;\n    int i = 0;\n    while(i < args.length) {\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        i++;\n      } else if (args[i].equals(\"-segment\")) {\n        if (i == args.length-1) {\n          System.out.println(\"ERROR: missing name for -segment option\");\n          System.exit(1);\n        }\n        onlySegments.add(args[i+1]);\n        i += 2;\n      } else {\n        if (indexPath != null) {\n          System.out.println(\"ERROR: unexpected extra argument '\" + args[i] + \"'\");\n          System.exit(1);\n        }\n        indexPath = args[i];\n        i++;\n      }\n    }\n\n    if (indexPath == null) {\n      System.out.println(\"\\nERROR: index path not specified\");\n      System.out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"  -segment X: only check the specified segments.  This can be specified multiple\\n\" + \n                         \"              times, to check more than one segment, eg '-segment _2 -segment _a'.\\n\" +\n                         \"              You can't use this with the -fix option\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\" +\n                         \"\\n\" +\n                         \"This tool exits with exit code 1 if the index cannot be opened or has any\\n\" +\n                         \"corruption, else 0.\\n\");\n      System.exit(1);\n    }\n\n    if (!assertsOn())\n      System.out.println(\"\\nNOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene...', so assertions are enabled\");\n\n    if (onlySegments.size() == 0)\n      onlySegments = null;\n    else if (doFix) {\n      System.out.println(\"ERROR: cannot specify both -fix and -segment\");\n      System.exit(1);\n    }\n\n    System.out.println(\"\\nOpening index @ \" + indexPath + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.getDirectory(indexPath);\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not open directory \\\"\" + indexPath + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n\n    CheckIndex checker = new CheckIndex(dir);\n    checker.setInfoStream(System.out);\n\n    Status result = checker.checkIndex(onlySegments);\n    if (result.missingSegments) {\n      System.exit(1);\n    }\n\n    if (!result.clean) {\n      if (!doFix) {\n        System.out.println(\"WARNING: would write new segments file, and \" + result.totLoseDocCount + \" documents would be lost, if -fix were specified\\n\");\n      } else {\n        System.out.println(\"WARNING: \" + result.totLoseDocCount + \" documents will be lost\\n\");\n        System.out.println(\"NOTE: will write new segments file in 5 seconds; this will remove \" + result.totLoseDocCount + \" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!\");\n        for(int s=0;s<5;s++) {\n          Thread.sleep(1000);\n          System.out.println(\"  \" + (5-s) + \"...\");\n        }\n        System.out.println(\"Writing...\");\n        checker.fixIndex(result);\n        System.out.println(\"OK\");\n        System.out.println(\"Wrote new segments file \\\"\" + result.newSegments.getCurrentSegmentFileName() + \"\\\"\");\n      }\n    }\n    System.out.println(\"\");\n\n    final int exitCode;\n    if (result != null && result.clean == true)\n      exitCode = 0;\n    else\n      exitCode = 1;\n    System.exit(exitCode);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f011f01db72fa6f556a9a0843944ecee2de4aaa8","date":1255806907,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","pathOld":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","sourceNew":"  /** Command-line interface to check and fix an index.\n\n    <p>\n    Run it like this:\n    <pre>\n    java -ea:org.apache.lucene... org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\n    </pre>\n    <ul>\n    <li><code>-fix</code>: actually write a new segments_N file, removing any problematic segments\n\n    <li><code>-segment X</code>: only check the specified\n    segment(s).  This can be specified multiple times,\n    to check more than one segment, eg <code>-segment _2\n    -segment _a</code>.  You can't use this with the -fix\n    option.\n    </ul>\n\n    <p><b>WARNING</b>: <code>-fix</code> should only be used on an emergency basis as it will cause\n                       documents (perhaps many) to be permanently removed from the index.  Always make\n                       a backup copy of your index before running this!  Do not run this tool on an index\n                       that is actively being written to.  You have been warned!\n\n    <p>                Run without -fix, this tool will open the index, report version information\n                       and report any exceptions it hits and what action it would take if -fix were\n                       specified.  With -fix, this tool will remove any segments that have issues and\n                       write a new segments_N file.  This means all documents contained in the affected\n                       segments will be removed.\n\n    <p>\n                       This tool exits with exit code 1 if the index cannot be opened or has any\n                       corruption, else 0.\n   */\n  public static void main(String[] args) throws IOException, InterruptedException {\n\n    boolean doFix = false;\n    List<String> onlySegments = new ArrayList<String>();\n    String indexPath = null;\n    int i = 0;\n    while(i < args.length) {\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        i++;\n      } else if (args[i].equals(\"-segment\")) {\n        if (i == args.length-1) {\n          System.out.println(\"ERROR: missing name for -segment option\");\n          System.exit(1);\n        }\n        onlySegments.add(args[i+1]);\n        i += 2;\n      } else {\n        if (indexPath != null) {\n          System.out.println(\"ERROR: unexpected extra argument '\" + args[i] + \"'\");\n          System.exit(1);\n        }\n        indexPath = args[i];\n        i++;\n      }\n    }\n\n    if (indexPath == null) {\n      System.out.println(\"\\nERROR: index path not specified\");\n      System.out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"  -segment X: only check the specified segments.  This can be specified multiple\\n\" + \n                         \"              times, to check more than one segment, eg '-segment _2 -segment _a'.\\n\" +\n                         \"              You can't use this with the -fix option\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\" +\n                         \"\\n\" +\n                         \"This tool exits with exit code 1 if the index cannot be opened or has any\\n\" +\n                         \"corruption, else 0.\\n\");\n      System.exit(1);\n    }\n\n    if (!assertsOn())\n      System.out.println(\"\\nNOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene...', so assertions are enabled\");\n\n    if (onlySegments.size() == 0)\n      onlySegments = null;\n    else if (doFix) {\n      System.out.println(\"ERROR: cannot specify both -fix and -segment\");\n      System.exit(1);\n    }\n\n    System.out.println(\"\\nOpening index @ \" + indexPath + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.open(new File(indexPath));\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not open directory \\\"\" + indexPath + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n\n    CheckIndex checker = new CheckIndex(dir);\n    checker.setInfoStream(System.out);\n\n    Status result = checker.checkIndex(onlySegments);\n    if (result.missingSegments) {\n      System.exit(1);\n    }\n\n    if (!result.clean) {\n      if (!doFix) {\n        System.out.println(\"WARNING: would write new segments file, and \" + result.totLoseDocCount + \" documents would be lost, if -fix were specified\\n\");\n      } else {\n        System.out.println(\"WARNING: \" + result.totLoseDocCount + \" documents will be lost\\n\");\n        System.out.println(\"NOTE: will write new segments file in 5 seconds; this will remove \" + result.totLoseDocCount + \" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!\");\n        for(int s=0;s<5;s++) {\n          Thread.sleep(1000);\n          System.out.println(\"  \" + (5-s) + \"...\");\n        }\n        System.out.println(\"Writing...\");\n        checker.fixIndex(result);\n        System.out.println(\"OK\");\n        System.out.println(\"Wrote new segments file \\\"\" + result.newSegments.getCurrentSegmentFileName() + \"\\\"\");\n      }\n    }\n    System.out.println(\"\");\n\n    final int exitCode;\n    if (result != null && result.clean == true)\n      exitCode = 0;\n    else\n      exitCode = 1;\n    System.exit(exitCode);\n  }\n\n","sourceOld":"  /** Command-line interface to check and fix an index.\n\n    <p>\n    Run it like this:\n    <pre>\n    java -ea:org.apache.lucene... org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\n    </pre>\n    <ul>\n    <li><code>-fix</code>: actually write a new segments_N file, removing any problematic segments\n\n    <li><code>-segment X</code>: only check the specified\n    segment(s).  This can be specified multiple times,\n    to check more than one segment, eg <code>-segment _2\n    -segment _a</code>.  You can't use this with the -fix\n    option.\n    </ul>\n\n    <p><b>WARNING</b>: <code>-fix</code> should only be used on an emergency basis as it will cause\n                       documents (perhaps many) to be permanently removed from the index.  Always make\n                       a backup copy of your index before running this!  Do not run this tool on an index\n                       that is actively being written to.  You have been warned!\n\n    <p>                Run without -fix, this tool will open the index, report version information\n                       and report any exceptions it hits and what action it would take if -fix were\n                       specified.  With -fix, this tool will remove any segments that have issues and\n                       write a new segments_N file.  This means all documents contained in the affected\n                       segments will be removed.\n\n    <p>\n                       This tool exits with exit code 1 if the index cannot be opened or has any\n                       corruption, else 0.\n   */\n  public static void main(String[] args) throws IOException, InterruptedException {\n\n    boolean doFix = false;\n    List onlySegments = new ArrayList();\n    String indexPath = null;\n    int i = 0;\n    while(i < args.length) {\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        i++;\n      } else if (args[i].equals(\"-segment\")) {\n        if (i == args.length-1) {\n          System.out.println(\"ERROR: missing name for -segment option\");\n          System.exit(1);\n        }\n        onlySegments.add(args[i+1]);\n        i += 2;\n      } else {\n        if (indexPath != null) {\n          System.out.println(\"ERROR: unexpected extra argument '\" + args[i] + \"'\");\n          System.exit(1);\n        }\n        indexPath = args[i];\n        i++;\n      }\n    }\n\n    if (indexPath == null) {\n      System.out.println(\"\\nERROR: index path not specified\");\n      System.out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"  -segment X: only check the specified segments.  This can be specified multiple\\n\" + \n                         \"              times, to check more than one segment, eg '-segment _2 -segment _a'.\\n\" +\n                         \"              You can't use this with the -fix option\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\" +\n                         \"\\n\" +\n                         \"This tool exits with exit code 1 if the index cannot be opened or has any\\n\" +\n                         \"corruption, else 0.\\n\");\n      System.exit(1);\n    }\n\n    if (!assertsOn())\n      System.out.println(\"\\nNOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene...', so assertions are enabled\");\n\n    if (onlySegments.size() == 0)\n      onlySegments = null;\n    else if (doFix) {\n      System.out.println(\"ERROR: cannot specify both -fix and -segment\");\n      System.exit(1);\n    }\n\n    System.out.println(\"\\nOpening index @ \" + indexPath + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.open(new File(indexPath));\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not open directory \\\"\" + indexPath + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n\n    CheckIndex checker = new CheckIndex(dir);\n    checker.setInfoStream(System.out);\n\n    Status result = checker.checkIndex(onlySegments);\n    if (result.missingSegments) {\n      System.exit(1);\n    }\n\n    if (!result.clean) {\n      if (!doFix) {\n        System.out.println(\"WARNING: would write new segments file, and \" + result.totLoseDocCount + \" documents would be lost, if -fix were specified\\n\");\n      } else {\n        System.out.println(\"WARNING: \" + result.totLoseDocCount + \" documents will be lost\\n\");\n        System.out.println(\"NOTE: will write new segments file in 5 seconds; this will remove \" + result.totLoseDocCount + \" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!\");\n        for(int s=0;s<5;s++) {\n          Thread.sleep(1000);\n          System.out.println(\"  \" + (5-s) + \"...\");\n        }\n        System.out.println(\"Writing...\");\n        checker.fixIndex(result);\n        System.out.println(\"OK\");\n        System.out.println(\"Wrote new segments file \\\"\" + result.newSegments.getCurrentSegmentFileName() + \"\\\"\");\n      }\n    }\n    System.out.println(\"\");\n\n    final int exitCode;\n    if (result != null && result.clean == true)\n      exitCode = 0;\n    else\n      exitCode = 1;\n    System.exit(exitCode);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a9ac13b5f0ce5ef1b2ce168367d993a79594b23a","date":1267298041,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","pathOld":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","sourceNew":"  /** Command-line interface to check and fix an index.\n\n    <p>\n    Run it like this:\n    <pre>\n    java -ea:org.apache.lucene... org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\n    </pre>\n    <ul>\n    <li><code>-fix</code>: actually write a new segments_N file, removing any problematic segments\n\n    <li><code>-segment X</code>: only check the specified\n    segment(s).  This can be specified multiple times,\n    to check more than one segment, eg <code>-segment _2\n    -segment _a</code>.  You can't use this with the -fix\n    option.\n    </ul>\n\n    <p><b>WARNING</b>: <code>-fix</code> should only be used on an emergency basis as it will cause\n                       documents (perhaps many) to be permanently removed from the index.  Always make\n                       a backup copy of your index before running this!  Do not run this tool on an index\n                       that is actively being written to.  You have been warned!\n\n    <p>                Run without -fix, this tool will open the index, report version information\n                       and report any exceptions it hits and what action it would take if -fix were\n                       specified.  With -fix, this tool will remove any segments that have issues and\n                       write a new segments_N file.  This means all documents contained in the affected\n                       segments will be removed.\n\n    <p>\n                       This tool exits with exit code 1 if the index cannot be opened or has any\n                       corruption, else 0.\n   */\n  public static void main(String[] args) throws IOException, InterruptedException {\n\n    boolean doFix = false;\n    List<String> onlySegments = new ArrayList<String>();\n    String indexPath = null;\n    int i = 0;\n    while(i < args.length) {\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        i++;\n      } else if (args[i].equals(\"-segment\")) {\n        if (i == args.length-1) {\n          System.out.println(\"ERROR: missing name for -segment option\");\n          System.exit(1);\n        }\n        onlySegments.add(args[i+1]);\n        i += 2;\n      } else {\n        if (indexPath != null) {\n          System.out.println(\"ERROR: unexpected extra argument '\" + args[i] + \"'\");\n          System.exit(1);\n        }\n        indexPath = args[i];\n        i++;\n      }\n    }\n\n    if (indexPath == null) {\n      System.out.println(\"\\nERROR: index path not specified\");\n      System.out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"  -segment X: only check the specified segments.  This can be specified multiple\\n\" + \n                         \"              times, to check more than one segment, eg '-segment _2 -segment _a'.\\n\" +\n                         \"              You can't use this with the -fix option\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\" +\n                         \"\\n\" +\n                         \"This tool exits with exit code 1 if the index cannot be opened or has any\\n\" +\n                         \"corruption, else 0.\\n\");\n      System.exit(1);\n    }\n\n    if (!assertsOn())\n      System.out.println(\"\\nNOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene...', so assertions are enabled\");\n\n    if (onlySegments.size() == 0)\n      onlySegments = null;\n    else if (doFix) {\n      System.out.println(\"ERROR: cannot specify both -fix and -segment\");\n      System.exit(1);\n    }\n\n    System.out.println(\"\\nOpening index @ \" + indexPath + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.open(new File(indexPath));\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not open directory \\\"\" + indexPath + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n\n    CheckIndex checker = new CheckIndex(dir);\n    checker.setInfoStream(System.out);\n\n    Status result = checker.checkIndex(onlySegments);\n    if (result.missingSegments) {\n      System.exit(1);\n    }\n\n    if (!result.clean) {\n      if (!doFix) {\n        System.out.println(\"WARNING: would write new segments file, and \" + result.totLoseDocCount + \" documents would be lost, if -fix were specified\\n\");\n      } else {\n        System.out.println(\"WARNING: \" + result.totLoseDocCount + \" documents will be lost\\n\");\n        System.out.println(\"NOTE: will write new segments file in 5 seconds; this will remove \" + result.totLoseDocCount + \" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!\");\n        for(int s=0;s<5;s++) {\n          Thread.sleep(1000);\n          System.out.println(\"  \" + (5-s) + \"...\");\n        }\n        System.out.println(\"Writing...\");\n        checker.fixIndex(result);\n        System.out.println(\"OK\");\n        System.out.println(\"Wrote new segments file \\\"\" + result.newSegments.getCurrentSegmentFileName() + \"\\\"\");\n      }\n    }\n    System.out.println(\"\");\n\n    final int exitCode;\n    if (result.clean == true)\n      exitCode = 0;\n    else\n      exitCode = 1;\n    System.exit(exitCode);\n  }\n\n","sourceOld":"  /** Command-line interface to check and fix an index.\n\n    <p>\n    Run it like this:\n    <pre>\n    java -ea:org.apache.lucene... org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\n    </pre>\n    <ul>\n    <li><code>-fix</code>: actually write a new segments_N file, removing any problematic segments\n\n    <li><code>-segment X</code>: only check the specified\n    segment(s).  This can be specified multiple times,\n    to check more than one segment, eg <code>-segment _2\n    -segment _a</code>.  You can't use this with the -fix\n    option.\n    </ul>\n\n    <p><b>WARNING</b>: <code>-fix</code> should only be used on an emergency basis as it will cause\n                       documents (perhaps many) to be permanently removed from the index.  Always make\n                       a backup copy of your index before running this!  Do not run this tool on an index\n                       that is actively being written to.  You have been warned!\n\n    <p>                Run without -fix, this tool will open the index, report version information\n                       and report any exceptions it hits and what action it would take if -fix were\n                       specified.  With -fix, this tool will remove any segments that have issues and\n                       write a new segments_N file.  This means all documents contained in the affected\n                       segments will be removed.\n\n    <p>\n                       This tool exits with exit code 1 if the index cannot be opened or has any\n                       corruption, else 0.\n   */\n  public static void main(String[] args) throws IOException, InterruptedException {\n\n    boolean doFix = false;\n    List<String> onlySegments = new ArrayList<String>();\n    String indexPath = null;\n    int i = 0;\n    while(i < args.length) {\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        i++;\n      } else if (args[i].equals(\"-segment\")) {\n        if (i == args.length-1) {\n          System.out.println(\"ERROR: missing name for -segment option\");\n          System.exit(1);\n        }\n        onlySegments.add(args[i+1]);\n        i += 2;\n      } else {\n        if (indexPath != null) {\n          System.out.println(\"ERROR: unexpected extra argument '\" + args[i] + \"'\");\n          System.exit(1);\n        }\n        indexPath = args[i];\n        i++;\n      }\n    }\n\n    if (indexPath == null) {\n      System.out.println(\"\\nERROR: index path not specified\");\n      System.out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"  -segment X: only check the specified segments.  This can be specified multiple\\n\" + \n                         \"              times, to check more than one segment, eg '-segment _2 -segment _a'.\\n\" +\n                         \"              You can't use this with the -fix option\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\" +\n                         \"\\n\" +\n                         \"This tool exits with exit code 1 if the index cannot be opened or has any\\n\" +\n                         \"corruption, else 0.\\n\");\n      System.exit(1);\n    }\n\n    if (!assertsOn())\n      System.out.println(\"\\nNOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene...', so assertions are enabled\");\n\n    if (onlySegments.size() == 0)\n      onlySegments = null;\n    else if (doFix) {\n      System.out.println(\"ERROR: cannot specify both -fix and -segment\");\n      System.exit(1);\n    }\n\n    System.out.println(\"\\nOpening index @ \" + indexPath + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.open(new File(indexPath));\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not open directory \\\"\" + indexPath + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n\n    CheckIndex checker = new CheckIndex(dir);\n    checker.setInfoStream(System.out);\n\n    Status result = checker.checkIndex(onlySegments);\n    if (result.missingSegments) {\n      System.exit(1);\n    }\n\n    if (!result.clean) {\n      if (!doFix) {\n        System.out.println(\"WARNING: would write new segments file, and \" + result.totLoseDocCount + \" documents would be lost, if -fix were specified\\n\");\n      } else {\n        System.out.println(\"WARNING: \" + result.totLoseDocCount + \" documents will be lost\\n\");\n        System.out.println(\"NOTE: will write new segments file in 5 seconds; this will remove \" + result.totLoseDocCount + \" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!\");\n        for(int s=0;s<5;s++) {\n          Thread.sleep(1000);\n          System.out.println(\"  \" + (5-s) + \"...\");\n        }\n        System.out.println(\"Writing...\");\n        checker.fixIndex(result);\n        System.out.println(\"OK\");\n        System.out.println(\"Wrote new segments file \\\"\" + result.newSegments.getCurrentSegmentFileName() + \"\\\"\");\n      }\n    }\n    System.out.println(\"\");\n\n    final int exitCode;\n    if (result != null && result.clean == true)\n      exitCode = 0;\n    else\n      exitCode = 1;\n    System.exit(exitCode);\n  }\n\n","bugFix":null,"bugIntro":["f7523916a1350712e1ae710affd4e88ccd7c431d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","pathOld":"src/java/org/apache/lucene/index/CheckIndex#main(String[]).mjava","sourceNew":"  /** Command-line interface to check and fix an index.\n\n    <p>\n    Run it like this:\n    <pre>\n    java -ea:org.apache.lucene... org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\n    </pre>\n    <ul>\n    <li><code>-fix</code>: actually write a new segments_N file, removing any problematic segments\n\n    <li><code>-segment X</code>: only check the specified\n    segment(s).  This can be specified multiple times,\n    to check more than one segment, eg <code>-segment _2\n    -segment _a</code>.  You can't use this with the -fix\n    option.\n    </ul>\n\n    <p><b>WARNING</b>: <code>-fix</code> should only be used on an emergency basis as it will cause\n                       documents (perhaps many) to be permanently removed from the index.  Always make\n                       a backup copy of your index before running this!  Do not run this tool on an index\n                       that is actively being written to.  You have been warned!\n\n    <p>                Run without -fix, this tool will open the index, report version information\n                       and report any exceptions it hits and what action it would take if -fix were\n                       specified.  With -fix, this tool will remove any segments that have issues and\n                       write a new segments_N file.  This means all documents contained in the affected\n                       segments will be removed.\n\n    <p>\n                       This tool exits with exit code 1 if the index cannot be opened or has any\n                       corruption, else 0.\n   */\n  public static void main(String[] args) throws IOException, InterruptedException {\n\n    boolean doFix = false;\n    List<String> onlySegments = new ArrayList<String>();\n    String indexPath = null;\n    int i = 0;\n    while(i < args.length) {\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        i++;\n      } else if (args[i].equals(\"-segment\")) {\n        if (i == args.length-1) {\n          System.out.println(\"ERROR: missing name for -segment option\");\n          System.exit(1);\n        }\n        onlySegments.add(args[i+1]);\n        i += 2;\n      } else {\n        if (indexPath != null) {\n          System.out.println(\"ERROR: unexpected extra argument '\" + args[i] + \"'\");\n          System.exit(1);\n        }\n        indexPath = args[i];\n        i++;\n      }\n    }\n\n    if (indexPath == null) {\n      System.out.println(\"\\nERROR: index path not specified\");\n      System.out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"  -segment X: only check the specified segments.  This can be specified multiple\\n\" + \n                         \"              times, to check more than one segment, eg '-segment _2 -segment _a'.\\n\" +\n                         \"              You can't use this with the -fix option\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\" +\n                         \"\\n\" +\n                         \"This tool exits with exit code 1 if the index cannot be opened or has any\\n\" +\n                         \"corruption, else 0.\\n\");\n      System.exit(1);\n    }\n\n    if (!assertsOn())\n      System.out.println(\"\\nNOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene...', so assertions are enabled\");\n\n    if (onlySegments.size() == 0)\n      onlySegments = null;\n    else if (doFix) {\n      System.out.println(\"ERROR: cannot specify both -fix and -segment\");\n      System.exit(1);\n    }\n\n    System.out.println(\"\\nOpening index @ \" + indexPath + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.open(new File(indexPath));\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not open directory \\\"\" + indexPath + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n\n    CheckIndex checker = new CheckIndex(dir);\n    checker.setInfoStream(System.out);\n\n    Status result = checker.checkIndex(onlySegments);\n    if (result.missingSegments) {\n      System.exit(1);\n    }\n\n    if (!result.clean) {\n      if (!doFix) {\n        System.out.println(\"WARNING: would write new segments file, and \" + result.totLoseDocCount + \" documents would be lost, if -fix were specified\\n\");\n      } else {\n        System.out.println(\"WARNING: \" + result.totLoseDocCount + \" documents will be lost\\n\");\n        System.out.println(\"NOTE: will write new segments file in 5 seconds; this will remove \" + result.totLoseDocCount + \" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!\");\n        for(int s=0;s<5;s++) {\n          Thread.sleep(1000);\n          System.out.println(\"  \" + (5-s) + \"...\");\n        }\n        System.out.println(\"Writing...\");\n        checker.fixIndex(result);\n        System.out.println(\"OK\");\n        System.out.println(\"Wrote new segments file \\\"\" + result.newSegments.getCurrentSegmentFileName() + \"\\\"\");\n      }\n    }\n    System.out.println(\"\");\n\n    final int exitCode;\n    if (result.clean == true)\n      exitCode = 0;\n    else\n      exitCode = 1;\n    System.exit(exitCode);\n  }\n\n","sourceOld":"  /** Command-line interface to check and fix an index.\n\n    <p>\n    Run it like this:\n    <pre>\n    java -ea:org.apache.lucene... org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\n    </pre>\n    <ul>\n    <li><code>-fix</code>: actually write a new segments_N file, removing any problematic segments\n\n    <li><code>-segment X</code>: only check the specified\n    segment(s).  This can be specified multiple times,\n    to check more than one segment, eg <code>-segment _2\n    -segment _a</code>.  You can't use this with the -fix\n    option.\n    </ul>\n\n    <p><b>WARNING</b>: <code>-fix</code> should only be used on an emergency basis as it will cause\n                       documents (perhaps many) to be permanently removed from the index.  Always make\n                       a backup copy of your index before running this!  Do not run this tool on an index\n                       that is actively being written to.  You have been warned!\n\n    <p>                Run without -fix, this tool will open the index, report version information\n                       and report any exceptions it hits and what action it would take if -fix were\n                       specified.  With -fix, this tool will remove any segments that have issues and\n                       write a new segments_N file.  This means all documents contained in the affected\n                       segments will be removed.\n\n    <p>\n                       This tool exits with exit code 1 if the index cannot be opened or has any\n                       corruption, else 0.\n   */\n  public static void main(String[] args) throws IOException, InterruptedException {\n\n    boolean doFix = false;\n    List<String> onlySegments = new ArrayList<String>();\n    String indexPath = null;\n    int i = 0;\n    while(i < args.length) {\n      if (args[i].equals(\"-fix\")) {\n        doFix = true;\n        i++;\n      } else if (args[i].equals(\"-segment\")) {\n        if (i == args.length-1) {\n          System.out.println(\"ERROR: missing name for -segment option\");\n          System.exit(1);\n        }\n        onlySegments.add(args[i+1]);\n        i += 2;\n      } else {\n        if (indexPath != null) {\n          System.out.println(\"ERROR: unexpected extra argument '\" + args[i] + \"'\");\n          System.exit(1);\n        }\n        indexPath = args[i];\n        i++;\n      }\n    }\n\n    if (indexPath == null) {\n      System.out.println(\"\\nERROR: index path not specified\");\n      System.out.println(\"\\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y]\\n\" +\n                         \"\\n\" +\n                         \"  -fix: actually write a new segments_N file, removing any problematic segments\\n\" +\n                         \"  -segment X: only check the specified segments.  This can be specified multiple\\n\" + \n                         \"              times, to check more than one segment, eg '-segment _2 -segment _a'.\\n\" +\n                         \"              You can't use this with the -fix option\\n\" +\n                         \"\\n\" + \n                         \"**WARNING**: -fix should only be used on an emergency basis as it will cause\\n\" +\n                         \"documents (perhaps many) to be permanently removed from the index.  Always make\\n\" +\n                         \"a backup copy of your index before running this!  Do not run this tool on an index\\n\" +\n                         \"that is actively being written to.  You have been warned!\\n\" +\n                         \"\\n\" +\n                         \"Run without -fix, this tool will open the index, report version information\\n\" +\n                         \"and report any exceptions it hits and what action it would take if -fix were\\n\" +\n                         \"specified.  With -fix, this tool will remove any segments that have issues and\\n\" + \n                         \"write a new segments_N file.  This means all documents contained in the affected\\n\" +\n                         \"segments will be removed.\\n\" +\n                         \"\\n\" +\n                         \"This tool exits with exit code 1 if the index cannot be opened or has any\\n\" +\n                         \"corruption, else 0.\\n\");\n      System.exit(1);\n    }\n\n    if (!assertsOn())\n      System.out.println(\"\\nNOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene...', so assertions are enabled\");\n\n    if (onlySegments.size() == 0)\n      onlySegments = null;\n    else if (doFix) {\n      System.out.println(\"ERROR: cannot specify both -fix and -segment\");\n      System.exit(1);\n    }\n\n    System.out.println(\"\\nOpening index @ \" + indexPath + \"\\n\");\n    Directory dir = null;\n    try {\n      dir = FSDirectory.open(new File(indexPath));\n    } catch (Throwable t) {\n      System.out.println(\"ERROR: could not open directory \\\"\" + indexPath + \"\\\"; exiting\");\n      t.printStackTrace(System.out);\n      System.exit(1);\n    }\n\n    CheckIndex checker = new CheckIndex(dir);\n    checker.setInfoStream(System.out);\n\n    Status result = checker.checkIndex(onlySegments);\n    if (result.missingSegments) {\n      System.exit(1);\n    }\n\n    if (!result.clean) {\n      if (!doFix) {\n        System.out.println(\"WARNING: would write new segments file, and \" + result.totLoseDocCount + \" documents would be lost, if -fix were specified\\n\");\n      } else {\n        System.out.println(\"WARNING: \" + result.totLoseDocCount + \" documents will be lost\\n\");\n        System.out.println(\"NOTE: will write new segments file in 5 seconds; this will remove \" + result.totLoseDocCount + \" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!\");\n        for(int s=0;s<5;s++) {\n          Thread.sleep(1000);\n          System.out.println(\"  \" + (5-s) + \"...\");\n        }\n        System.out.println(\"Writing...\");\n        checker.fixIndex(result);\n        System.out.println(\"OK\");\n        System.out.println(\"Wrote new segments file \\\"\" + result.newSegments.getCurrentSegmentFileName() + \"\\\"\");\n      }\n    }\n    System.out.println(\"\");\n\n    final int exitCode;\n    if (result.clean == true)\n      exitCode = 0;\n    else\n      exitCode = 1;\n    System.exit(exitCode);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"f011f01db72fa6f556a9a0843944ecee2de4aaa8":["ba712167ee848727018d8b77aa0c273839fbe15c"],"ba7fd1181f778e9954547e8e6a47587ebf08e3fb":["7391c1f4ab1a6817de8a262f5c1b3de3cf190785"],"7391c1f4ab1a6817de8a262f5c1b3de3cf190785":["cba44a7c8f0e3eb449bcdbd53960b7705c0bf902"],"9cb1313e01866149ff8dde7e80345a5476de305e":["a64db7380e46c730a4ff0f00ebd7b29219312c14"],"326b3b177da8135f97e1832c22fbae8dab7c9400":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ba712167ee848727018d8b77aa0c273839fbe15c":["bf757952ed13ac1d3bec8adf69bcfde39031cdb5"],"a64db7380e46c730a4ff0f00ebd7b29219312c14":["5b38e3f2849cb8d8626cd5368aa64de4fed9edde"],"cba44a7c8f0e3eb449bcdbd53960b7705c0bf902":["9cb1313e01866149ff8dde7e80345a5476de305e"],"996842e9b73111f695c542be757f2b3cd541b60a":["326b3b177da8135f97e1832c22fbae8dab7c9400"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bf757952ed13ac1d3bec8adf69bcfde39031cdb5":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb"],"5b38e3f2849cb8d8626cd5368aa64de4fed9edde":["996842e9b73111f695c542be757f2b3cd541b60a"],"a9ac13b5f0ce5ef1b2ce168367d993a79594b23a":["f011f01db72fa6f556a9a0843944ecee2de4aaa8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a9ac13b5f0ce5ef1b2ce168367d993a79594b23a"]},"commit2Childs":{"f011f01db72fa6f556a9a0843944ecee2de4aaa8":["a9ac13b5f0ce5ef1b2ce168367d993a79594b23a"],"ba7fd1181f778e9954547e8e6a47587ebf08e3fb":["bf757952ed13ac1d3bec8adf69bcfde39031cdb5"],"7391c1f4ab1a6817de8a262f5c1b3de3cf190785":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb"],"9cb1313e01866149ff8dde7e80345a5476de305e":["cba44a7c8f0e3eb449bcdbd53960b7705c0bf902"],"326b3b177da8135f97e1832c22fbae8dab7c9400":["996842e9b73111f695c542be757f2b3cd541b60a"],"ba712167ee848727018d8b77aa0c273839fbe15c":["f011f01db72fa6f556a9a0843944ecee2de4aaa8"],"a64db7380e46c730a4ff0f00ebd7b29219312c14":["9cb1313e01866149ff8dde7e80345a5476de305e"],"cba44a7c8f0e3eb449bcdbd53960b7705c0bf902":["7391c1f4ab1a6817de8a262f5c1b3de3cf190785"],"996842e9b73111f695c542be757f2b3cd541b60a":["5b38e3f2849cb8d8626cd5368aa64de4fed9edde"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["326b3b177da8135f97e1832c22fbae8dab7c9400"],"bf757952ed13ac1d3bec8adf69bcfde39031cdb5":["ba712167ee848727018d8b77aa0c273839fbe15c"],"5b38e3f2849cb8d8626cd5368aa64de4fed9edde":["a64db7380e46c730a4ff0f00ebd7b29219312c14"],"a9ac13b5f0ce5ef1b2ce168367d993a79594b23a":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}