{"path":"lucene/src/java/org/apache/lucene/search/ExactPhraseScorer#phraseFreq().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/ExactPhraseScorer#phraseFreq().mjava","pathOld":"src/java/org/apache/lucene/search/ExactPhraseScorer#phraseFreq().mjava","sourceNew":"  @Override\n  protected final float phraseFreq() throws IOException {\n    // sort list with pq\n    pq.clear();\n    for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n      pp.firstPosition();\n      pq.add(pp);\t\t\t\t  // build pq from list\n    }\n    pqToList();\t\t\t\t\t  // rebuild list from pq\n\n    // for counting how many times the exact phrase is found in current document,\n    // just count how many times all PhrasePosition's have exactly the same position.   \n    int freq = 0;\n    do {\t\t\t\t\t  // find position w/ all terms\n      while (first.position < last.position) {\t  // scan forward in first\n\t    do {\n\t      if (!first.nextPosition())\n\t        return freq;\n\t    } while (first.position < last.position);\n\t      firstToLast();\n      }\n      freq++;\t\t\t\t\t  // all equal: a match\n    } while (last.nextPosition());\n  \n    return freq;\n  }\n\n","sourceOld":"  @Override\n  protected final float phraseFreq() throws IOException {\n    // sort list with pq\n    pq.clear();\n    for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n      pp.firstPosition();\n      pq.add(pp);\t\t\t\t  // build pq from list\n    }\n    pqToList();\t\t\t\t\t  // rebuild list from pq\n\n    // for counting how many times the exact phrase is found in current document,\n    // just count how many times all PhrasePosition's have exactly the same position.   \n    int freq = 0;\n    do {\t\t\t\t\t  // find position w/ all terms\n      while (first.position < last.position) {\t  // scan forward in first\n\t    do {\n\t      if (!first.nextPosition())\n\t        return freq;\n\t    } while (first.position < last.position);\n\t      firstToLast();\n      }\n      freq++;\t\t\t\t\t  // all equal: a match\n    } while (last.nextPosition());\n  \n    return freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/ExactPhraseScorer#phraseFreq().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/ExactPhraseScorer#phraseFreq().mjava","sourceNew":"  @Override\n  protected final float phraseFreq() throws IOException {\n    // sort list with pq\n    pq.clear();\n    for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n      pp.firstPosition();\n      pq.add(pp);\t\t\t\t  // build pq from list\n    }\n    pqToList();\t\t\t\t\t  // rebuild list from pq\n\n    // for counting how many times the exact phrase is found in current document,\n    // just count how many times all PhrasePosition's have exactly the same position.   \n    int freq = 0;\n    do {\t\t\t\t\t  // find position w/ all terms\n      while (first.position < last.position) {\t  // scan forward in first\n        do {\n          if (!first.nextPosition())\n            return freq;\n        } while (first.position < last.position);\n        firstToLast();\n      }\n      freq++;\t\t\t\t\t  // all equal: a match\n    } while (last.nextPosition());\n  \n    return freq;\n  }\n\n","sourceOld":"  @Override\n  protected final float phraseFreq() throws IOException {\n    // sort list with pq\n    pq.clear();\n    for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n      pp.firstPosition();\n      pq.add(pp);\t\t\t\t  // build pq from list\n    }\n    pqToList();\t\t\t\t\t  // rebuild list from pq\n\n    // for counting how many times the exact phrase is found in current document,\n    // just count how many times all PhrasePosition's have exactly the same position.   \n    int freq = 0;\n    do {\t\t\t\t\t  // find position w/ all terms\n      while (first.position < last.position) {\t  // scan forward in first\n\t    do {\n\t      if (!first.nextPosition())\n\t        return freq;\n\t    } while (first.position < last.position);\n\t      firstToLast();\n      }\n      freq++;\t\t\t\t\t  // all equal: a match\n    } while (last.nextPosition());\n  \n    return freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"953de31d76c9d58f1e3f4e41ff8a48a1529226de","date":1277371072,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/ExactPhraseScorer#phraseFreq().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/ExactPhraseScorer#phraseFreq().mjava","sourceNew":"  private int phraseFreq() throws IOException {\n\n    freq = 0;\n\n    // init chunks\n    for(int i=0;i<chunkStates.length;i++) {\n      final ChunkState cs = chunkStates[i];\n      cs.posLimit = cs.posEnum.freq();\n      cs.pos = cs.offset + cs.posEnum.nextPosition();\n      cs.posUpto = 1;\n      cs.lastPos = -1;\n    }\n\n    int chunkStart = 0;\n    int chunkEnd = CHUNK;\n\n    // process chunk by chunk\n    boolean end = false;\n\n    // TODO: we could fold in chunkStart into offset and\n    // save one subtract per pos incr\n\n    while(!end) {\n\n      gen++;\n\n      if (gen == 0) {\n        // wraparound\n        Arrays.fill(gens, 0);\n        gen++;\n      }\n\n      // first term\n      {\n        final ChunkState cs = chunkStates[0];\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            counts[posIndex] = 1;\n            assert gens[posIndex] != gen;\n            gens[posIndex] = gen;\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n      }\n\n      // middle terms\n      boolean any = true;\n      for(int t=1;t<endMinus1;t++) {\n        final ChunkState cs = chunkStates[t];\n        any = false;\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == t) {\n              // viable\n              counts[posIndex]++;\n              any = true;\n            }\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n\n        if (!any) {\n          break;\n        }\n      }\n\n      if (!any) {\n        // petered out for this chunk\n        chunkStart += CHUNK;\n        chunkEnd += CHUNK;\n        continue;\n      }\n\n      // last term\n\n      {\n        final ChunkState cs = chunkStates[endMinus1];\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == endMinus1) {\n              freq++;\n            }\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n      }\n\n      chunkStart += CHUNK;\n      chunkEnd += CHUNK;\n    }\n\n    return freq;\n  }\n\n","sourceOld":"  @Override\n  protected final float phraseFreq() throws IOException {\n    // sort list with pq\n    pq.clear();\n    for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n      pp.firstPosition();\n      pq.add(pp);\t\t\t\t  // build pq from list\n    }\n    pqToList();\t\t\t\t\t  // rebuild list from pq\n\n    // for counting how many times the exact phrase is found in current document,\n    // just count how many times all PhrasePosition's have exactly the same position.   \n    int freq = 0;\n    do {\t\t\t\t\t  // find position w/ all terms\n      while (first.position < last.position) {\t  // scan forward in first\n        do {\n          if (!first.nextPosition())\n            return freq;\n        } while (first.position < last.position);\n        firstToLast();\n      }\n      freq++;\t\t\t\t\t  // all equal: a match\n    } while (last.nextPosition());\n  \n    return freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/search/ExactPhraseScorer#phraseFreq().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/ExactPhraseScorer#phraseFreq().mjava","sourceNew":"  private int phraseFreq() throws IOException {\n\n    freq = 0;\n\n    // init chunks\n    for(int i=0;i<chunkStates.length;i++) {\n      final ChunkState cs = chunkStates[i];\n      cs.posLimit = cs.posEnum.freq();\n      cs.pos = cs.offset + cs.posEnum.nextPosition();\n      cs.posUpto = 1;\n      cs.lastPos = -1;\n    }\n\n    int chunkStart = 0;\n    int chunkEnd = CHUNK;\n\n    // process chunk by chunk\n    boolean end = false;\n\n    // TODO: we could fold in chunkStart into offset and\n    // save one subtract per pos incr\n\n    while(!end) {\n\n      gen++;\n\n      if (gen == 0) {\n        // wraparound\n        Arrays.fill(gens, 0);\n        gen++;\n      }\n\n      // first term\n      {\n        final ChunkState cs = chunkStates[0];\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            counts[posIndex] = 1;\n            assert gens[posIndex] != gen;\n            gens[posIndex] = gen;\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n      }\n\n      // middle terms\n      boolean any = true;\n      for(int t=1;t<endMinus1;t++) {\n        final ChunkState cs = chunkStates[t];\n        any = false;\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == t) {\n              // viable\n              counts[posIndex]++;\n              any = true;\n            }\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n\n        if (!any) {\n          break;\n        }\n      }\n\n      if (!any) {\n        // petered out for this chunk\n        chunkStart += CHUNK;\n        chunkEnd += CHUNK;\n        continue;\n      }\n\n      // last term\n\n      {\n        final ChunkState cs = chunkStates[endMinus1];\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == endMinus1) {\n              freq++;\n            }\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n      }\n\n      chunkStart += CHUNK;\n      chunkEnd += CHUNK;\n    }\n\n    return freq;\n  }\n\n","sourceOld":"  @Override\n  protected final float phraseFreq() throws IOException {\n    // sort list with pq\n    pq.clear();\n    for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n      pp.firstPosition();\n      pq.add(pp);\t\t\t\t  // build pq from list\n    }\n    pqToList();\t\t\t\t\t  // rebuild list from pq\n\n    // for counting how many times the exact phrase is found in current document,\n    // just count how many times all PhrasePosition's have exactly the same position.   \n    int freq = 0;\n    do {\t\t\t\t\t  // find position w/ all terms\n      while (first.position < last.position) {\t  // scan forward in first\n        do {\n          if (!first.nextPosition())\n            return freq;\n        } while (first.position < last.position);\n        firstToLast();\n      }\n      freq++;\t\t\t\t\t  // all equal: a match\n    } while (last.nextPosition());\n  \n    return freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ExactPhraseScorer#phraseFreq().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/ExactPhraseScorer#phraseFreq().mjava","sourceNew":"  private int phraseFreq() throws IOException {\n\n    freq = 0;\n\n    // init chunks\n    for(int i=0;i<chunkStates.length;i++) {\n      final ChunkState cs = chunkStates[i];\n      cs.posLimit = cs.posEnum.freq();\n      cs.pos = cs.offset + cs.posEnum.nextPosition();\n      cs.posUpto = 1;\n      cs.lastPos = -1;\n    }\n\n    int chunkStart = 0;\n    int chunkEnd = CHUNK;\n\n    // process chunk by chunk\n    boolean end = false;\n\n    // TODO: we could fold in chunkStart into offset and\n    // save one subtract per pos incr\n\n    while(!end) {\n\n      gen++;\n\n      if (gen == 0) {\n        // wraparound\n        Arrays.fill(gens, 0);\n        gen++;\n      }\n\n      // first term\n      {\n        final ChunkState cs = chunkStates[0];\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            counts[posIndex] = 1;\n            assert gens[posIndex] != gen;\n            gens[posIndex] = gen;\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n      }\n\n      // middle terms\n      boolean any = true;\n      for(int t=1;t<endMinus1;t++) {\n        final ChunkState cs = chunkStates[t];\n        any = false;\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == t) {\n              // viable\n              counts[posIndex]++;\n              any = true;\n            }\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n\n        if (!any) {\n          break;\n        }\n      }\n\n      if (!any) {\n        // petered out for this chunk\n        chunkStart += CHUNK;\n        chunkEnd += CHUNK;\n        continue;\n      }\n\n      // last term\n\n      {\n        final ChunkState cs = chunkStates[endMinus1];\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == endMinus1) {\n              freq++;\n            }\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n      }\n\n      chunkStart += CHUNK;\n      chunkEnd += CHUNK;\n    }\n\n    return freq;\n  }\n\n","sourceOld":"  private int phraseFreq() throws IOException {\n\n    freq = 0;\n\n    // init chunks\n    for(int i=0;i<chunkStates.length;i++) {\n      final ChunkState cs = chunkStates[i];\n      cs.posLimit = cs.posEnum.freq();\n      cs.pos = cs.offset + cs.posEnum.nextPosition();\n      cs.posUpto = 1;\n      cs.lastPos = -1;\n    }\n\n    int chunkStart = 0;\n    int chunkEnd = CHUNK;\n\n    // process chunk by chunk\n    boolean end = false;\n\n    // TODO: we could fold in chunkStart into offset and\n    // save one subtract per pos incr\n\n    while(!end) {\n\n      gen++;\n\n      if (gen == 0) {\n        // wraparound\n        Arrays.fill(gens, 0);\n        gen++;\n      }\n\n      // first term\n      {\n        final ChunkState cs = chunkStates[0];\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            counts[posIndex] = 1;\n            assert gens[posIndex] != gen;\n            gens[posIndex] = gen;\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n      }\n\n      // middle terms\n      boolean any = true;\n      for(int t=1;t<endMinus1;t++) {\n        final ChunkState cs = chunkStates[t];\n        any = false;\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == t) {\n              // viable\n              counts[posIndex]++;\n              any = true;\n            }\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n\n        if (!any) {\n          break;\n        }\n      }\n\n      if (!any) {\n        // petered out for this chunk\n        chunkStart += CHUNK;\n        chunkEnd += CHUNK;\n        continue;\n      }\n\n      // last term\n\n      {\n        final ChunkState cs = chunkStates[endMinus1];\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == endMinus1) {\n              freq++;\n            }\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n      }\n\n      chunkStart += CHUNK;\n      chunkEnd += CHUNK;\n    }\n\n    return freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"953de31d76c9d58f1e3f4e41ff8a48a1529226de":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["953de31d76c9d58f1e3f4e41ff8a48a1529226de"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"5f4e87790277826a2aea119328600dfb07761f32":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","953de31d76c9d58f1e3f4e41ff8a48a1529226de"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"953de31d76c9d58f1e3f4e41ff8a48a1529226de":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","5f4e87790277826a2aea119328600dfb07761f32"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["953de31d76c9d58f1e3f4e41ff8a48a1529226de","5f4e87790277826a2aea119328600dfb07761f32"],"5f4e87790277826a2aea119328600dfb07761f32":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5f4e87790277826a2aea119328600dfb07761f32","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}