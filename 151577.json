{"path":"src/java/org/apache/lucene/index/SegmentReader#loadDeletedDocs().mjava","commits":[{"id":"3b9d7142a399ac70a71ce5b40ee66695eda5b7e8","date":1195335263,"type":0,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#loadDeletedDocs().mjava","pathOld":"/dev/null","sourceNew":"  private void loadDeletedDocs() throws IOException {\n    // NOTE: the bitvector is stored using the regular directory, not cfs\n    if (hasDeletions(si)) {\n      deletedDocs = new BitVector(directory(), si.getDelFileName());\n     \n      // Verify # deletes does not exceed maxDoc for this segment:\n      if (deletedDocs.count() > maxDoc()) {\n        throw new CorruptIndexException(\"number of deletes (\" + deletedDocs.count() + \") exceeds max doc (\" + maxDoc() + \") for segment \" + si.name);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"34e2c71b6406443562df54db233fde0728502f64","date":1209294850,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#loadDeletedDocs().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#loadDeletedDocs().mjava","sourceNew":"  private void loadDeletedDocs() throws IOException {\n    // NOTE: the bitvector is stored using the regular directory, not cfs\n    if (hasDeletions(si)) {\n      deletedDocs = new BitVector(directory(), si.getDelFileName());\n     \n      assert si.getDelCount() == deletedDocs.count() : \n        \"delete count mismatch: info=\" + si.getDelCount() + \" vs BitVector=\" + deletedDocs.count();\n\n      // Verify # deletes does not exceed maxDoc for this\n      // segment:\n      assert si.getDelCount() <= maxDoc() : \n        \"delete count mismatch: \" + deletedDocs.count() + \") exceeds max doc (\" + maxDoc() + \") for segment \" + si.name;\n\n    } else\n      assert si.getDelCount() == 0;\n  }\n\n","sourceOld":"  private void loadDeletedDocs() throws IOException {\n    // NOTE: the bitvector is stored using the regular directory, not cfs\n    if (hasDeletions(si)) {\n      deletedDocs = new BitVector(directory(), si.getDelFileName());\n     \n      // Verify # deletes does not exceed maxDoc for this segment:\n      if (deletedDocs.count() > maxDoc()) {\n        throw new CorruptIndexException(\"number of deletes (\" + deletedDocs.count() + \") exceeds max doc (\" + maxDoc() + \") for segment \" + si.name);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6db660b56f04fdb2853d25cdee8ee0d36559a521","date":1233313968,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#loadDeletedDocs().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#loadDeletedDocs().mjava","sourceNew":"  private void loadDeletedDocs() throws IOException {\n    // NOTE: the bitvector is stored using the regular directory, not cfs\n    if (hasDeletions(si)) {\n      deletedDocs = new BitVector(directory(), si.getDelFileName());\n      deletedDocsRef = new Ref();\n     \n      assert si.getDelCount() == deletedDocs.count() : \n        \"delete count mismatch: info=\" + si.getDelCount() + \" vs BitVector=\" + deletedDocs.count();\n\n      // Verify # deletes does not exceed maxDoc for this\n      // segment:\n      assert si.getDelCount() <= maxDoc() : \n        \"delete count mismatch: \" + deletedDocs.count() + \") exceeds max doc (\" + maxDoc() + \") for segment \" + si.name;\n\n    } else\n      assert si.getDelCount() == 0;\n  }\n\n","sourceOld":"  private void loadDeletedDocs() throws IOException {\n    // NOTE: the bitvector is stored using the regular directory, not cfs\n    if (hasDeletions(si)) {\n      deletedDocs = new BitVector(directory(), si.getDelFileName());\n     \n      assert si.getDelCount() == deletedDocs.count() : \n        \"delete count mismatch: info=\" + si.getDelCount() + \" vs BitVector=\" + deletedDocs.count();\n\n      // Verify # deletes does not exceed maxDoc for this\n      // segment:\n      assert si.getDelCount() <= maxDoc() : \n        \"delete count mismatch: \" + deletedDocs.count() + \") exceeds max doc (\" + maxDoc() + \") for segment \" + si.name;\n\n    } else\n      assert si.getDelCount() == 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d8514024f885b40613b5ec91876ce5e9d2167d89","date":1260313529,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#loadDeletedDocs().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#loadDeletedDocs().mjava","sourceNew":"  private void loadDeletedDocs() throws IOException {\n    // NOTE: the bitvector is stored using the regular directory, not cfs\n    if (hasDeletions(si)) {\n      deletedDocs = new BitVector(directory(), si.getDelFileName());\n      deletedDocsRef = new AtomicInteger(1);\n     \n      assert si.getDelCount() == deletedDocs.count() : \n        \"delete count mismatch: info=\" + si.getDelCount() + \" vs BitVector=\" + deletedDocs.count();\n\n      // Verify # deletes does not exceed maxDoc for this\n      // segment:\n      assert si.getDelCount() <= maxDoc() : \n        \"delete count mismatch: \" + deletedDocs.count() + \") exceeds max doc (\" + maxDoc() + \") for segment \" + si.name;\n\n    } else\n      assert si.getDelCount() == 0;\n  }\n\n","sourceOld":"  private void loadDeletedDocs() throws IOException {\n    // NOTE: the bitvector is stored using the regular directory, not cfs\n    if (hasDeletions(si)) {\n      deletedDocs = new BitVector(directory(), si.getDelFileName());\n      deletedDocsRef = new Ref();\n     \n      assert si.getDelCount() == deletedDocs.count() : \n        \"delete count mismatch: info=\" + si.getDelCount() + \" vs BitVector=\" + deletedDocs.count();\n\n      // Verify # deletes does not exceed maxDoc for this\n      // segment:\n      assert si.getDelCount() <= maxDoc() : \n        \"delete count mismatch: \" + deletedDocs.count() + \") exceeds max doc (\" + maxDoc() + \") for segment \" + si.name;\n\n    } else\n      assert si.getDelCount() == 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1ee41a444cd904f922cebbaa1d52c166447e46d7","date":1260989504,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#loadDeletedDocs().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#loadDeletedDocs().mjava","sourceNew":"  private void loadDeletedDocs() throws IOException {\n    // NOTE: the bitvector is stored using the regular directory, not cfs\n    if (hasDeletions(si)) {\n      deletedDocs = new BitVector(directory(), si.getDelFileName());\n      deletedDocsRef = new AtomicInteger(1);\n      assert checkDeletedCounts();\n    } else\n      assert si.getDelCount() == 0;\n  }\n\n","sourceOld":"  private void loadDeletedDocs() throws IOException {\n    // NOTE: the bitvector is stored using the regular directory, not cfs\n    if (hasDeletions(si)) {\n      deletedDocs = new BitVector(directory(), si.getDelFileName());\n      deletedDocsRef = new AtomicInteger(1);\n     \n      assert si.getDelCount() == deletedDocs.count() : \n        \"delete count mismatch: info=\" + si.getDelCount() + \" vs BitVector=\" + deletedDocs.count();\n\n      // Verify # deletes does not exceed maxDoc for this\n      // segment:\n      assert si.getDelCount() <= maxDoc() : \n        \"delete count mismatch: \" + deletedDocs.count() + \") exceeds max doc (\" + maxDoc() + \") for segment \" + si.name;\n\n    } else\n      assert si.getDelCount() == 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f50553955f50bbde368558d2b3fced97cc8c7a","date":1263323353,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#loadDeletedDocs().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#loadDeletedDocs().mjava","sourceNew":"  private void loadDeletedDocs() throws IOException {\n    // NOTE: the bitvector is stored using the regular directory, not cfs\n    if (hasDeletions(si)) {\n      deletedDocs = new BitVector(directory(), si.getDelFileName());\n      deletedDocsRef = new AtomicInteger(1);\n      assert checkDeletedCounts();\n      if (deletedDocs.size() != si.docCount) {\n        throw new CorruptIndexException(\"document count mismatch: deleted docs count \" + deletedDocs.size() + \" vs segment doc count \" + si.docCount);\n      }\n    } else\n      assert si.getDelCount() == 0;\n  }\n\n","sourceOld":"  private void loadDeletedDocs() throws IOException {\n    // NOTE: the bitvector is stored using the regular directory, not cfs\n    if (hasDeletions(si)) {\n      deletedDocs = new BitVector(directory(), si.getDelFileName());\n      deletedDocsRef = new AtomicInteger(1);\n      assert checkDeletedCounts();\n    } else\n      assert si.getDelCount() == 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d28fc88c40c08a36c52720dae60beee72d91b031","date":1265661085,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#loadDeletedDocs().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#loadDeletedDocs().mjava","sourceNew":"  private void loadDeletedDocs() throws IOException {\n    // NOTE: the bitvector is stored using the regular directory, not cfs\n    if (hasDeletions(si)) {\n      deletedDocs = new BitVector(directory(), si.getDelFileName());\n      deletedDocsRef = new AtomicInteger(1);\n      assert checkDeletedCounts();\n      if (deletedDocs.size() != si.docCount) {\n        throw new CorruptIndexException(\"document count mismatch: deleted docs count \" + deletedDocs.size() + \" vs segment doc count \" + si.docCount + \" segment=\" + si.name);\n      }\n    } else\n      assert si.getDelCount() == 0;\n  }\n\n","sourceOld":"  private void loadDeletedDocs() throws IOException {\n    // NOTE: the bitvector is stored using the regular directory, not cfs\n    if (hasDeletions(si)) {\n      deletedDocs = new BitVector(directory(), si.getDelFileName());\n      deletedDocsRef = new AtomicInteger(1);\n      assert checkDeletedCounts();\n      if (deletedDocs.size() != si.docCount) {\n        throw new CorruptIndexException(\"document count mismatch: deleted docs count \" + deletedDocs.size() + \" vs segment doc count \" + si.docCount);\n      }\n    } else\n      assert si.getDelCount() == 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentReader#loadDeletedDocs().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#loadDeletedDocs().mjava","sourceNew":"  private void loadDeletedDocs() throws IOException {\n    // NOTE: the bitvector is stored using the regular directory, not cfs\n    if (hasDeletions(si)) {\n      deletedDocs = new BitVector(directory(), si.getDelFileName());\n      deletedDocsRef = new AtomicInteger(1);\n      assert checkDeletedCounts();\n      if (deletedDocs.size() != si.docCount) {\n        throw new CorruptIndexException(\"document count mismatch: deleted docs count \" + deletedDocs.size() + \" vs segment doc count \" + si.docCount + \" segment=\" + si.name);\n      }\n    } else\n      assert si.getDelCount() == 0;\n  }\n\n","sourceOld":"  private void loadDeletedDocs() throws IOException {\n    // NOTE: the bitvector is stored using the regular directory, not cfs\n    if (hasDeletions(si)) {\n      deletedDocs = new BitVector(directory(), si.getDelFileName());\n      deletedDocsRef = new AtomicInteger(1);\n      assert checkDeletedCounts();\n      if (deletedDocs.size() != si.docCount) {\n        throw new CorruptIndexException(\"document count mismatch: deleted docs count \" + deletedDocs.size() + \" vs segment doc count \" + si.docCount + \" segment=\" + si.name);\n      }\n    } else\n      assert si.getDelCount() == 0;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6db660b56f04fdb2853d25cdee8ee0d36559a521":["34e2c71b6406443562df54db233fde0728502f64"],"74f50553955f50bbde368558d2b3fced97cc8c7a":["1ee41a444cd904f922cebbaa1d52c166447e46d7"],"34e2c71b6406443562df54db233fde0728502f64":["3b9d7142a399ac70a71ce5b40ee66695eda5b7e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1ee41a444cd904f922cebbaa1d52c166447e46d7":["d8514024f885b40613b5ec91876ce5e9d2167d89"],"d8514024f885b40613b5ec91876ce5e9d2167d89":["6db660b56f04fdb2853d25cdee8ee0d36559a521"],"3b9d7142a399ac70a71ce5b40ee66695eda5b7e8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["d28fc88c40c08a36c52720dae60beee72d91b031"],"d28fc88c40c08a36c52720dae60beee72d91b031":["74f50553955f50bbde368558d2b3fced97cc8c7a"]},"commit2Childs":{"6db660b56f04fdb2853d25cdee8ee0d36559a521":["d8514024f885b40613b5ec91876ce5e9d2167d89"],"74f50553955f50bbde368558d2b3fced97cc8c7a":["d28fc88c40c08a36c52720dae60beee72d91b031"],"34e2c71b6406443562df54db233fde0728502f64":["6db660b56f04fdb2853d25cdee8ee0d36559a521"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3b9d7142a399ac70a71ce5b40ee66695eda5b7e8"],"1ee41a444cd904f922cebbaa1d52c166447e46d7":["74f50553955f50bbde368558d2b3fced97cc8c7a"],"3b9d7142a399ac70a71ce5b40ee66695eda5b7e8":["34e2c71b6406443562df54db233fde0728502f64"],"d8514024f885b40613b5ec91876ce5e9d2167d89":["1ee41a444cd904f922cebbaa1d52c166447e46d7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d28fc88c40c08a36c52720dae60beee72d91b031":["9454a6510e2db155fb01faa5c049b06ece95fab9"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}