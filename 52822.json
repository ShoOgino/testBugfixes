{"path":"solr/core/src/java/org/apache/solr/api/CustomContainerPlugins#refresh().mjava","commits":[{"id":"650b520f2a4daa4b0712e2393dc29ae7f21f10ac","date":1593054531,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/CustomContainerPlugins#refresh().mjava","pathOld":"/dev/null","sourceNew":"  public synchronized void refresh() {\n    Map<String, Object> pluginInfos = null;\n    try {\n      pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n    } catch (IOException e) {\n      log.error(\"Could not read plugins data\", e);\n      return;\n    }\n    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n    for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n      try {\n        newState.put(e.getKey(),\n            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n      } catch (Exception exp) {\n        log.error(\"Invalid apiInfo configuration :\", exp);\n      }\n    }\n\n    Map<String, PluginMeta> currentState = new HashMap<>();\n    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n      currentState.put(e.getKey(), e.getValue().info);\n    }\n    Map<String, Diff> diff = compareMaps(currentState, newState);\n    if (diff == null) return;//nothing has changed\n    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n      if (e.getValue() == Diff.UNCHANGED) continue;\n      if (e.getValue() == Diff.REMOVED) {\n        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n        if (apiInfo == null) continue;\n        for (ApiHolder holder : apiInfo.holders) {\n          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n          if (old instanceof Closeable) {\n            closeWhileHandlingException((Closeable) old);\n          }\n        }\n      } else {\n        //ADDED or UPDATED\n        PluginMeta info = newState.get(e.getKey());\n        ApiInfo apiInfo = null;\n        List<String> errs = new ArrayList<>();\n        apiInfo = new ApiInfo(info, errs);\n        if (!errs.isEmpty()) {\n          log.error(StrUtils.join(errs, ','));\n          continue;\n        }\n        try {\n          apiInfo.init();\n        } catch (Exception exp) {\n          log.error(\"Cannot install apiInfo \", exp);\n          continue;\n        }\n        if (e.getValue() == Diff.ADDED) {\n          for (ApiHolder holder : apiInfo.holders) {\n            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n          }\n          currentPlugins.put(e.getKey(), apiInfo);\n        } else {\n          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n          List<ApiHolder> replaced = new ArrayList<>();\n          for (ApiHolder holder : apiInfo.holders) {\n            Api oldApi = containerApiBag.lookup(holder.getPath(),\n                holder.getMethod().toString(), null);\n            if (oldApi instanceof ApiHolder) {\n              replaced.add((ApiHolder) oldApi);\n            }\n            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n          }\n          if (old != null) {\n            for (ApiHolder holder : old.holders) {\n              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n            }\n            if (old instanceof Closeable) {\n              closeWhileHandlingException((Closeable) old);\n            }\n          }\n        }\n      }\n\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2c4fba12438c1407e259b55774b5bbb707046a8","date":1593319746,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/CustomContainerPlugins#refresh().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/CustomContainerPlugins#refresh().mjava","sourceNew":"  public synchronized void refresh() {\n    Map<String, Object> pluginInfos = null;\n    try {\n      pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n    } catch (IOException e) {\n      log.error(\"Could not read plugins data\", e);\n      return;\n    }\n    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n    for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n      try {\n        newState.put(e.getKey(),\n            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n      } catch (Exception exp) {\n        log.error(\"Invalid apiInfo configuration :\", exp);\n      }\n    }\n\n    Map<String, PluginMeta> currentState = new HashMap<>();\n    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n      currentState.put(e.getKey(), e.getValue().info);\n    }\n    Map<String, Diff> diff = compareMaps(currentState, newState);\n    if (diff == null) return;//nothing has changed\n    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n      if (e.getValue() == Diff.UNCHANGED) continue;\n      if (e.getValue() == Diff.REMOVED) {\n        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n        if (apiInfo == null) continue;\n        for (ApiHolder holder : apiInfo.holders) {\n          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n          if (old instanceof Closeable) {\n            closeWhileHandlingException((Closeable) old);\n          }\n        }\n      } else {\n        //ADDED or UPDATED\n        PluginMeta info = newState.get(e.getKey());\n        ApiInfo apiInfo = null;\n        List<String> errs = new ArrayList<>();\n        apiInfo = new ApiInfo(info, errs);\n        if (!errs.isEmpty()) {\n          log.error(StrUtils.join(errs, ','));\n          continue;\n        }\n        try {\n          apiInfo.init();\n        } catch (Exception exp) {\n          log.error(\"Cannot install apiInfo \", exp);\n          continue;\n        }\n        if (e.getValue() == Diff.ADDED) {\n          for (ApiHolder holder : apiInfo.holders) {\n            containerApiBag.register(holder, getTemplateVars(apiInfo.info));\n          }\n          currentPlugins.put(e.getKey(), apiInfo);\n        } else {\n          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n          List<ApiHolder> replaced = new ArrayList<>();\n          for (ApiHolder holder : apiInfo.holders) {\n            Api oldApi = containerApiBag.lookup(holder.getPath(),\n                holder.getMethod().toString(), null);\n            if (oldApi instanceof ApiHolder) {\n              replaced.add((ApiHolder) oldApi);\n            }\n            containerApiBag.register(holder, getTemplateVars(apiInfo.info));\n          }\n          if (old != null) {\n            for (ApiHolder holder : old.holders) {\n              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n            }\n            if (old instanceof Closeable) {\n              closeWhileHandlingException((Closeable) old);\n            }\n          }\n        }\n      }\n\n    }\n  }\n\n","sourceOld":"  public synchronized void refresh() {\n    Map<String, Object> pluginInfos = null;\n    try {\n      pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n    } catch (IOException e) {\n      log.error(\"Could not read plugins data\", e);\n      return;\n    }\n    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n    for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n      try {\n        newState.put(e.getKey(),\n            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n      } catch (Exception exp) {\n        log.error(\"Invalid apiInfo configuration :\", exp);\n      }\n    }\n\n    Map<String, PluginMeta> currentState = new HashMap<>();\n    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n      currentState.put(e.getKey(), e.getValue().info);\n    }\n    Map<String, Diff> diff = compareMaps(currentState, newState);\n    if (diff == null) return;//nothing has changed\n    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n      if (e.getValue() == Diff.UNCHANGED) continue;\n      if (e.getValue() == Diff.REMOVED) {\n        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n        if (apiInfo == null) continue;\n        for (ApiHolder holder : apiInfo.holders) {\n          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n          if (old instanceof Closeable) {\n            closeWhileHandlingException((Closeable) old);\n          }\n        }\n      } else {\n        //ADDED or UPDATED\n        PluginMeta info = newState.get(e.getKey());\n        ApiInfo apiInfo = null;\n        List<String> errs = new ArrayList<>();\n        apiInfo = new ApiInfo(info, errs);\n        if (!errs.isEmpty()) {\n          log.error(StrUtils.join(errs, ','));\n          continue;\n        }\n        try {\n          apiInfo.init();\n        } catch (Exception exp) {\n          log.error(\"Cannot install apiInfo \", exp);\n          continue;\n        }\n        if (e.getValue() == Diff.ADDED) {\n          for (ApiHolder holder : apiInfo.holders) {\n            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n          }\n          currentPlugins.put(e.getKey(), apiInfo);\n        } else {\n          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n          List<ApiHolder> replaced = new ArrayList<>();\n          for (ApiHolder holder : apiInfo.holders) {\n            Api oldApi = containerApiBag.lookup(holder.getPath(),\n                holder.getMethod().toString(), null);\n            if (oldApi instanceof ApiHolder) {\n              replaced.add((ApiHolder) oldApi);\n            }\n            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n          }\n          if (old != null) {\n            for (ApiHolder holder : old.holders) {\n              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n            }\n            if (old instanceof Closeable) {\n              closeWhileHandlingException((Closeable) old);\n            }\n          }\n        }\n      }\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86cd0c5a55b09b85b88e1b3e857145f321a696d8","date":1593668656,"type":3,"author":"noblepaul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/CustomContainerPlugins#refresh().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/CustomContainerPlugins#refresh().mjava","sourceNew":"  public synchronized void refresh() {\n    Map<String, Object> pluginInfos = null;\n    try {\n      pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n    } catch (IOException e) {\n      log.error(\"Could not read plugins data\", e);\n      return;\n    }\n    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n    for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n      try {\n        newState.put(e.getKey(),\n            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n      } catch (Exception exp) {\n        log.error(\"Invalid apiInfo configuration :\", exp);\n      }\n    }\n\n    Map<String, PluginMeta> currentState = new HashMap<>();\n    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n      currentState.put(e.getKey(), e.getValue().info);\n    }\n    Map<String, Diff> diff = compareMaps(currentState, newState);\n    if (diff == null) return;//nothing has changed\n    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n      if (e.getValue() == Diff.UNCHANGED) continue;\n      if (e.getValue() == Diff.REMOVED) {\n        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n        if (apiInfo == null) continue;\n        for (ApiHolder holder : apiInfo.holders) {\n          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0],\n              getActualPath(apiInfo, holder.api.getEndPoint().path()[0]));\n          if (old instanceof Closeable) {\n            closeWhileHandlingException((Closeable) old);\n          }\n        }\n      } else {\n        //ADDED or UPDATED\n        PluginMeta info = newState.get(e.getKey());\n        ApiInfo apiInfo = null;\n        List<String> errs = new ArrayList<>();\n        apiInfo = new ApiInfo(info, errs);\n        if (!errs.isEmpty()) {\n          log.error(StrUtils.join(errs, ','));\n          continue;\n        }\n        try {\n          apiInfo.init();\n        } catch (Exception exp) {\n          log.error(\"Cannot install apiInfo \", exp);\n          continue;\n        }\n        if (e.getValue() == Diff.ADDED) {\n          for (ApiHolder holder : apiInfo.holders) {\n            containerApiBag.register(holder, getTemplateVars(apiInfo.info));\n          }\n          currentPlugins.put(e.getKey(), apiInfo);\n        } else {\n          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n          List<ApiHolder> replaced = new ArrayList<>();\n          for (ApiHolder holder : apiInfo.holders) {\n            Api oldApi = containerApiBag.lookup(holder.getPath(),\n                holder.getMethod().toString(), null);\n            if (oldApi instanceof ApiHolder) {\n              replaced.add((ApiHolder) oldApi);\n            }\n            containerApiBag.register(holder, getTemplateVars(apiInfo.info));\n          }\n          if (old != null) {\n            for (ApiHolder holder : old.holders) {\n              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n              containerApiBag.unregister(holder.getMethod(),getActualPath(old, holder.getPath()));\n            }\n            if (old instanceof Closeable) {\n              closeWhileHandlingException((Closeable) old);\n            }\n          }\n        }\n      }\n\n    }\n  }\n\n","sourceOld":"  public synchronized void refresh() {\n    Map<String, Object> pluginInfos = null;\n    try {\n      pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n    } catch (IOException e) {\n      log.error(\"Could not read plugins data\", e);\n      return;\n    }\n    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n    for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n      try {\n        newState.put(e.getKey(),\n            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n      } catch (Exception exp) {\n        log.error(\"Invalid apiInfo configuration :\", exp);\n      }\n    }\n\n    Map<String, PluginMeta> currentState = new HashMap<>();\n    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n      currentState.put(e.getKey(), e.getValue().info);\n    }\n    Map<String, Diff> diff = compareMaps(currentState, newState);\n    if (diff == null) return;//nothing has changed\n    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n      if (e.getValue() == Diff.UNCHANGED) continue;\n      if (e.getValue() == Diff.REMOVED) {\n        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n        if (apiInfo == null) continue;\n        for (ApiHolder holder : apiInfo.holders) {\n          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n          if (old instanceof Closeable) {\n            closeWhileHandlingException((Closeable) old);\n          }\n        }\n      } else {\n        //ADDED or UPDATED\n        PluginMeta info = newState.get(e.getKey());\n        ApiInfo apiInfo = null;\n        List<String> errs = new ArrayList<>();\n        apiInfo = new ApiInfo(info, errs);\n        if (!errs.isEmpty()) {\n          log.error(StrUtils.join(errs, ','));\n          continue;\n        }\n        try {\n          apiInfo.init();\n        } catch (Exception exp) {\n          log.error(\"Cannot install apiInfo \", exp);\n          continue;\n        }\n        if (e.getValue() == Diff.ADDED) {\n          for (ApiHolder holder : apiInfo.holders) {\n            containerApiBag.register(holder, getTemplateVars(apiInfo.info));\n          }\n          currentPlugins.put(e.getKey(), apiInfo);\n        } else {\n          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n          List<ApiHolder> replaced = new ArrayList<>();\n          for (ApiHolder holder : apiInfo.holders) {\n            Api oldApi = containerApiBag.lookup(holder.getPath(),\n                holder.getMethod().toString(), null);\n            if (oldApi instanceof ApiHolder) {\n              replaced.add((ApiHolder) oldApi);\n            }\n            containerApiBag.register(holder, getTemplateVars(apiInfo.info));\n          }\n          if (old != null) {\n            for (ApiHolder holder : old.holders) {\n              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n            }\n            if (old instanceof Closeable) {\n              closeWhileHandlingException((Closeable) old);\n            }\n          }\n        }\n      }\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7ef91c71ddf705aa0ddf58f440d9755745da777","date":1593930515,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/CustomContainerPlugins#refresh().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/CustomContainerPlugins#refresh().mjava","sourceNew":"  public synchronized void refresh() {\n    Map<String, Object> pluginInfos = null;\n    try {\n      pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n    } catch (IOException e) {\n      log.error(\"Could not read plugins data\", e);\n      return;\n    }\n    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n    for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n      try {\n        newState.put(e.getKey(),\n            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n      } catch (Exception exp) {\n        log.error(\"Invalid apiInfo configuration :\", exp);\n      }\n    }\n\n    Map<String, PluginMeta> currentState = new HashMap<>();\n    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n      currentState.put(e.getKey(), e.getValue().info);\n    }\n    Map<String, Diff> diff = compareMaps(currentState, newState);\n    if (diff == null) return;//nothing has changed\n    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n      if (e.getValue() == Diff.UNCHANGED) continue;\n      if (e.getValue() == Diff.REMOVED) {\n        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n        if (apiInfo == null) continue;\n        for (ApiHolder holder : apiInfo.holders) {\n          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0],\n              getActualPath(apiInfo, holder.api.getEndPoint().path()[0]));\n          if (old instanceof Closeable) {\n            closeWhileHandlingException((Closeable) old);\n          }\n        }\n      } else {\n        //ADDED or UPDATED\n        PluginMeta info = newState.get(e.getKey());\n        ApiInfo apiInfo = null;\n        List<String> errs = new ArrayList<>();\n        apiInfo = new ApiInfo(info, errs);\n        if (!errs.isEmpty()) {\n          log.error(StrUtils.join(errs, ','));\n          continue;\n        }\n        try {\n          apiInfo.init();\n        } catch (Exception exp) {\n          log.error(\"Cannot install apiInfo \", exp);\n          continue;\n        }\n        if (e.getValue() == Diff.ADDED) {\n          // this plugin is totally new\n          for (ApiHolder holder : apiInfo.holders) {\n            containerApiBag.register(holder, getTemplateVars(apiInfo.info));\n          }\n          currentPlugins.put(e.getKey(), apiInfo);\n        } else {\n          //this plugin is being updated\n          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n          for (ApiHolder holder : apiInfo.holders) {\n            //register all new paths\n            containerApiBag.register(holder, getTemplateVars(apiInfo.info));\n          }\n          if (old != null) {\n            //this is an update of the plugin. But, it is possible that\n            // some paths are remved in the newer version of the plugin\n            for (ApiHolder oldHolder : old.holders) {\n              if(apiInfo.get(oldHolder.api.getEndPoint()) == null) {\n                //there was a path in the old plugin which is not present in the new one\n                containerApiBag.unregister(oldHolder.getMethod(),getActualPath(old, oldHolder.getPath()));\n              }\n            }\n            if (old instanceof Closeable) {\n              //close the old instance of the plugin\n              closeWhileHandlingException((Closeable) old);\n            }\n          }\n        }\n      }\n\n    }\n  }\n\n","sourceOld":"  public synchronized void refresh() {\n    Map<String, Object> pluginInfos = null;\n    try {\n      pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n    } catch (IOException e) {\n      log.error(\"Could not read plugins data\", e);\n      return;\n    }\n    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n    for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n      try {\n        newState.put(e.getKey(),\n            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n      } catch (Exception exp) {\n        log.error(\"Invalid apiInfo configuration :\", exp);\n      }\n    }\n\n    Map<String, PluginMeta> currentState = new HashMap<>();\n    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n      currentState.put(e.getKey(), e.getValue().info);\n    }\n    Map<String, Diff> diff = compareMaps(currentState, newState);\n    if (diff == null) return;//nothing has changed\n    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n      if (e.getValue() == Diff.UNCHANGED) continue;\n      if (e.getValue() == Diff.REMOVED) {\n        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n        if (apiInfo == null) continue;\n        for (ApiHolder holder : apiInfo.holders) {\n          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0],\n              getActualPath(apiInfo, holder.api.getEndPoint().path()[0]));\n          if (old instanceof Closeable) {\n            closeWhileHandlingException((Closeable) old);\n          }\n        }\n      } else {\n        //ADDED or UPDATED\n        PluginMeta info = newState.get(e.getKey());\n        ApiInfo apiInfo = null;\n        List<String> errs = new ArrayList<>();\n        apiInfo = new ApiInfo(info, errs);\n        if (!errs.isEmpty()) {\n          log.error(StrUtils.join(errs, ','));\n          continue;\n        }\n        try {\n          apiInfo.init();\n        } catch (Exception exp) {\n          log.error(\"Cannot install apiInfo \", exp);\n          continue;\n        }\n        if (e.getValue() == Diff.ADDED) {\n          for (ApiHolder holder : apiInfo.holders) {\n            containerApiBag.register(holder, getTemplateVars(apiInfo.info));\n          }\n          currentPlugins.put(e.getKey(), apiInfo);\n        } else {\n          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n          List<ApiHolder> replaced = new ArrayList<>();\n          for (ApiHolder holder : apiInfo.holders) {\n            Api oldApi = containerApiBag.lookup(holder.getPath(),\n                holder.getMethod().toString(), null);\n            if (oldApi instanceof ApiHolder) {\n              replaced.add((ApiHolder) oldApi);\n            }\n            containerApiBag.register(holder, getTemplateVars(apiInfo.info));\n          }\n          if (old != null) {\n            for (ApiHolder holder : old.holders) {\n              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n              containerApiBag.unregister(holder.getMethod(),getActualPath(old, holder.getPath()));\n            }\n            if (old instanceof Closeable) {\n              closeWhileHandlingException((Closeable) old);\n            }\n          }\n        }\n      }\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"650b520f2a4daa4b0712e2393dc29ae7f21f10ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e2c4fba12438c1407e259b55774b5bbb707046a8":["650b520f2a4daa4b0712e2393dc29ae7f21f10ac"],"86cd0c5a55b09b85b88e1b3e857145f321a696d8":["e2c4fba12438c1407e259b55774b5bbb707046a8"],"b7ef91c71ddf705aa0ddf58f440d9755745da777":["86cd0c5a55b09b85b88e1b3e857145f321a696d8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b7ef91c71ddf705aa0ddf58f440d9755745da777"]},"commit2Childs":{"650b520f2a4daa4b0712e2393dc29ae7f21f10ac":["e2c4fba12438c1407e259b55774b5bbb707046a8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["650b520f2a4daa4b0712e2393dc29ae7f21f10ac"],"e2c4fba12438c1407e259b55774b5bbb707046a8":["86cd0c5a55b09b85b88e1b3e857145f321a696d8"],"86cd0c5a55b09b85b88e1b3e857145f321a696d8":["b7ef91c71ddf705aa0ddf58f440d9755745da777"],"b7ef91c71ddf705aa0ddf58f440d9755745da777":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}