{"path":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","commits":[{"id":"651c3ddf5bc1266d9de0a972ec05e59d77099a4c","date":1500969855,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void test() throws IOException, SolrServerException, KeeperException, InterruptedException {\n    Set<String> coreNames = new HashSet<>();\n    Set<String> coreNodeNames = new HashSet<>();\n\n    int numOperations = random().nextInt(4 * 15);\n    int numLiveReplicas = 4;\n\n    boolean clearedCounter = false;\n    for (int i = 0; i < numOperations; i++) {\n      boolean deleteReplica = random().nextBoolean() && numLiveReplicas > 1;\n      // No need to clear counter more than one time\n      if (random().nextInt(30) < 5 && !clearedCounter) {\n        // clear counter\n        cluster.getZkClient().delete(\"/collections/\"+COLLECTION+\"/counter\", -1, true);\n        clearedCounter = true;\n      }\n      if (deleteReplica) {\n        assertTrue(ClusterStateUtil.waitForLiveAndActiveReplicaCount(\n            cluster.getSolrClient().getZkStateReader(), COLLECTION, numLiveReplicas, 30000));\n        DocCollection dc = getCollectionState(COLLECTION);\n        Replica replica = getRandomReplica(dc.getSlice(\"shard1\"), (r) -> r.getState() == Replica.State.ACTIVE);\n        CollectionAdminRequest.deleteReplica(COLLECTION, \"shard1\", replica.getName()).process(cluster.getSolrClient());\n        numLiveReplicas--;\n      } else {\n        CollectionAdminResponse response = CollectionAdminRequest.addReplicaToShard(COLLECTION, \"shard1\")\n            .process(cluster.getSolrClient());\n        assertTrue(response.isSuccess());\n        String coreName = response.getCollectionCoresStatus()\n            .keySet().iterator().next();\n        assertFalse(\"Core name is not unique coreName=\" + coreName + \" \" + coreNames, coreNames.contains(coreName));\n        coreNames.add(coreName);\n\n        Replica newReplica = getCollectionState(COLLECTION).getReplicas().stream()\n            .filter(r -> r.getCoreName().equals(coreName))\n            .findAny().get();\n        String coreNodeName = newReplica.getName();\n        assertFalse(\"Core node name is not unique\", coreNodeNames.contains(coreName));\n        coreNodeNames.add(coreNodeName);\n\n        numLiveReplicas++;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"936cdd5882761db3b844afd6f84ab81cbb011a75","date":1500973524,"type":0,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void test() throws IOException, SolrServerException, KeeperException, InterruptedException {\n    Set<String> coreNames = new HashSet<>();\n    Set<String> coreNodeNames = new HashSet<>();\n\n    int numOperations = random().nextInt(4 * 15);\n    int numLiveReplicas = 4;\n\n    boolean clearedCounter = false;\n    for (int i = 0; i < numOperations; i++) {\n      boolean deleteReplica = random().nextBoolean() && numLiveReplicas > 1;\n      // No need to clear counter more than one time\n      if (random().nextInt(30) < 5 && !clearedCounter) {\n        // clear counter\n        cluster.getZkClient().delete(\"/collections/\"+COLLECTION+\"/counter\", -1, true);\n        clearedCounter = true;\n      }\n      if (deleteReplica) {\n        assertTrue(ClusterStateUtil.waitForLiveAndActiveReplicaCount(\n            cluster.getSolrClient().getZkStateReader(), COLLECTION, numLiveReplicas, 30000));\n        DocCollection dc = getCollectionState(COLLECTION);\n        Replica replica = getRandomReplica(dc.getSlice(\"shard1\"), (r) -> r.getState() == Replica.State.ACTIVE);\n        CollectionAdminRequest.deleteReplica(COLLECTION, \"shard1\", replica.getName()).process(cluster.getSolrClient());\n        numLiveReplicas--;\n      } else {\n        CollectionAdminResponse response = CollectionAdminRequest.addReplicaToShard(COLLECTION, \"shard1\")\n            .process(cluster.getSolrClient());\n        assertTrue(response.isSuccess());\n        String coreName = response.getCollectionCoresStatus()\n            .keySet().iterator().next();\n        assertFalse(\"Core name is not unique coreName=\" + coreName + \" \" + coreNames, coreNames.contains(coreName));\n        coreNames.add(coreName);\n\n        Replica newReplica = getCollectionState(COLLECTION).getReplicas().stream()\n            .filter(r -> r.getCoreName().equals(coreName))\n            .findAny().get();\n        String coreNodeName = newReplica.getName();\n        assertFalse(\"Core node name is not unique\", coreNodeNames.contains(coreName));\n        coreNodeNames.add(coreNodeName);\n\n        numLiveReplicas++;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a52341299179de5479672f7cf518bf4b173f34b3","date":1501079746,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void test() throws IOException, SolrServerException, KeeperException, InterruptedException {\n    Set<String> coreNames = new HashSet<>();\n    Set<String> coreNodeNames = new HashSet<>();\n\n    int numOperations = random().nextInt(4 * 15);\n    int numLiveReplicas = 4;\n\n    boolean clearedCounter = false;\n    for (int i = 0; i < numOperations; i++) {\n      boolean deleteReplica = random().nextBoolean() && numLiveReplicas > 1;\n      // No need to clear counter more than one time\n      if (random().nextInt(30) < 5 && !clearedCounter) {\n        // clear counter\n        cluster.getZkClient().delete(\"/collections/\"+COLLECTION+\"/counter\", -1, true);\n        clearedCounter = true;\n      }\n      if (deleteReplica) {\n        assertTrue(ClusterStateUtil.waitForLiveAndActiveReplicaCount(\n            cluster.getSolrClient().getZkStateReader(), COLLECTION, numLiveReplicas, 30000));\n        DocCollection dc = getCollectionState(COLLECTION);\n        Replica replica = getRandomReplica(dc.getSlice(\"shard1\"), (r) -> r.getState() == Replica.State.ACTIVE);\n        CollectionAdminRequest.deleteReplica(COLLECTION, \"shard1\", replica.getName()).process(cluster.getSolrClient());\n        numLiveReplicas--;\n      } else {\n        CollectionAdminResponse response = CollectionAdminRequest.addReplicaToShard(COLLECTION, \"shard1\")\n            .process(cluster.getSolrClient());\n        assertTrue(response.isSuccess());\n        String coreName = response.getCollectionCoresStatus()\n            .keySet().iterator().next();\n        assertFalse(\"Core name is not unique coreName=\" + coreName + \" \" + coreNames, coreNames.contains(coreName));\n        coreNames.add(coreName);\n\n        Replica newReplica = getCollectionState(COLLECTION).getReplicas().stream()\n            .filter(r -> r.getCoreName().equals(coreName))\n            .findAny().get();\n        String coreNodeName = newReplica.getName();\n        assertFalse(\"Core node name is not unique\", coreNodeNames.contains(coreName));\n        coreNodeNames.add(coreNodeName);\n\n        numLiveReplicas++;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"acdf5bd70aa60010f071c51eaf1dfc7d7e5b4a0b","date":1509074608,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","sourceNew":"  @Test\n  public void test() throws IOException, SolrServerException, KeeperException, InterruptedException {\n    Set<String> coreNames = new HashSet<>();\n    Set<String> coreNodeNames = new HashSet<>();\n\n    int numOperations = random().nextInt(15) + 15;\n    int numLiveReplicas = 4;\n\n    boolean clearedCounter = false;\n    for (int i = 0; i < numOperations; i++) {\n      log.info(\"Collection counter={} i={}\", getCounter(), i);\n      boolean deleteReplica = random().nextBoolean() && numLiveReplicas > 1;\n      // No need to clear counter more than one time\n      if (random().nextBoolean() && i > 5 && !clearedCounter) {\n        log.info(\"Clear collection counter\");\n        // clear counter\n        cluster.getZkClient().delete(\"/collections/\"+COLLECTION+\"/counter\", -1, true);\n        clearedCounter = true;\n      }\n      if (deleteReplica) {\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n        DocCollection dc = getCollectionState(COLLECTION);\n        Replica replica = getRandomReplica(dc.getSlice(\"shard1\"), (r) -> r.getState() == Replica.State.ACTIVE);\n        CollectionAdminRequest.deleteReplica(COLLECTION, \"shard1\", replica.getName()).process(cluster.getSolrClient());\n        numLiveReplicas--;\n      } else {\n        CollectionAdminResponse response = CollectionAdminRequest.addReplicaToShard(COLLECTION, \"shard1\")\n            .process(cluster.getSolrClient());\n        assertTrue(response.isSuccess());\n        String coreName = response.getCollectionCoresStatus()\n            .keySet().iterator().next();\n        assertFalse(\"Core name is not unique coreName=\" + coreName + \" \" + coreNames, coreNames.contains(coreName));\n        coreNames.add(coreName);\n        numLiveReplicas++;\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n\n        Replica newReplica = getCollectionState(COLLECTION).getReplicas().stream()\n            .filter(r -> r.getCoreName().equals(coreName))\n            .findAny().get();\n        String coreNodeName = newReplica.getName();\n        assertFalse(\"Core node name is not unique\", coreNodeNames.contains(coreName));\n        coreNodeNames.add(coreNodeName);\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void test() throws IOException, SolrServerException, KeeperException, InterruptedException {\n    Set<String> coreNames = new HashSet<>();\n    Set<String> coreNodeNames = new HashSet<>();\n\n    int numOperations = random().nextInt(4 * 15);\n    int numLiveReplicas = 4;\n\n    boolean clearedCounter = false;\n    for (int i = 0; i < numOperations; i++) {\n      boolean deleteReplica = random().nextBoolean() && numLiveReplicas > 1;\n      // No need to clear counter more than one time\n      if (random().nextInt(30) < 5 && !clearedCounter) {\n        // clear counter\n        cluster.getZkClient().delete(\"/collections/\"+COLLECTION+\"/counter\", -1, true);\n        clearedCounter = true;\n      }\n      if (deleteReplica) {\n        assertTrue(ClusterStateUtil.waitForLiveAndActiveReplicaCount(\n            cluster.getSolrClient().getZkStateReader(), COLLECTION, numLiveReplicas, 30000));\n        DocCollection dc = getCollectionState(COLLECTION);\n        Replica replica = getRandomReplica(dc.getSlice(\"shard1\"), (r) -> r.getState() == Replica.State.ACTIVE);\n        CollectionAdminRequest.deleteReplica(COLLECTION, \"shard1\", replica.getName()).process(cluster.getSolrClient());\n        numLiveReplicas--;\n      } else {\n        CollectionAdminResponse response = CollectionAdminRequest.addReplicaToShard(COLLECTION, \"shard1\")\n            .process(cluster.getSolrClient());\n        assertTrue(response.isSuccess());\n        String coreName = response.getCollectionCoresStatus()\n            .keySet().iterator().next();\n        assertFalse(\"Core name is not unique coreName=\" + coreName + \" \" + coreNames, coreNames.contains(coreName));\n        coreNames.add(coreName);\n\n        Replica newReplica = getCollectionState(COLLECTION).getReplicas().stream()\n            .filter(r -> r.getCoreName().equals(coreName))\n            .findAny().get();\n        String coreNodeName = newReplica.getName();\n        assertFalse(\"Core node name is not unique\", coreNodeNames.contains(coreName));\n        coreNodeNames.add(coreNodeName);\n\n        numLiveReplicas++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43ad790248d7f7daee5d9cced548c546f37c7218","date":1527269998,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void test() throws IOException, SolrServerException, KeeperException, InterruptedException {\n    Set<String> coreNames = new HashSet<>();\n    Set<String> coreNodeNames = new HashSet<>();\n\n    int numOperations = random().nextInt(15) + 15;\n    int numLiveReplicas = 4;\n\n    boolean clearedCounter = false;\n    for (int i = 0; i < numOperations; i++) {\n      log.info(\"Collection counter={} i={}\", getCounter(), i);\n      boolean deleteReplica = random().nextBoolean() && numLiveReplicas > 1;\n      // No need to clear counter more than one time\n      if (random().nextBoolean() && i > 5 && !clearedCounter) {\n        log.info(\"Clear collection counter\");\n        // clear counter\n        cluster.getZkClient().delete(\"/collections/\"+COLLECTION+\"/counter\", -1, true);\n        clearedCounter = true;\n      }\n      if (deleteReplica) {\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n        DocCollection dc = getCollectionState(COLLECTION);\n        Replica replica = getRandomReplica(dc.getSlice(\"shard1\"), (r) -> r.getState() == Replica.State.ACTIVE);\n        CollectionAdminRequest.deleteReplica(COLLECTION, \"shard1\", replica.getName()).process(cluster.getSolrClient());\n        numLiveReplicas--;\n      } else {\n        CollectionAdminResponse response = CollectionAdminRequest.addReplicaToShard(COLLECTION, \"shard1\")\n            .process(cluster.getSolrClient());\n        assertTrue(response.isSuccess());\n        String coreName = response.getCollectionCoresStatus()\n            .keySet().iterator().next();\n        assertFalse(\"Core name is not unique coreName=\" + coreName + \" \" + coreNames, coreNames.contains(coreName));\n        coreNames.add(coreName);\n        numLiveReplicas++;\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n\n        Replica newReplica = getCollectionState(COLLECTION).getReplicas().stream()\n            .filter(r -> r.getCoreName().equals(coreName))\n            .findAny().get();\n        String coreNodeName = newReplica.getName();\n        assertFalse(\"Core node name is not unique\", coreNodeNames.contains(coreName));\n        coreNodeNames.add(coreNodeName);\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void test() throws IOException, SolrServerException, KeeperException, InterruptedException {\n    Set<String> coreNames = new HashSet<>();\n    Set<String> coreNodeNames = new HashSet<>();\n\n    int numOperations = random().nextInt(15) + 15;\n    int numLiveReplicas = 4;\n\n    boolean clearedCounter = false;\n    for (int i = 0; i < numOperations; i++) {\n      log.info(\"Collection counter={} i={}\", getCounter(), i);\n      boolean deleteReplica = random().nextBoolean() && numLiveReplicas > 1;\n      // No need to clear counter more than one time\n      if (random().nextBoolean() && i > 5 && !clearedCounter) {\n        log.info(\"Clear collection counter\");\n        // clear counter\n        cluster.getZkClient().delete(\"/collections/\"+COLLECTION+\"/counter\", -1, true);\n        clearedCounter = true;\n      }\n      if (deleteReplica) {\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n        DocCollection dc = getCollectionState(COLLECTION);\n        Replica replica = getRandomReplica(dc.getSlice(\"shard1\"), (r) -> r.getState() == Replica.State.ACTIVE);\n        CollectionAdminRequest.deleteReplica(COLLECTION, \"shard1\", replica.getName()).process(cluster.getSolrClient());\n        numLiveReplicas--;\n      } else {\n        CollectionAdminResponse response = CollectionAdminRequest.addReplicaToShard(COLLECTION, \"shard1\")\n            .process(cluster.getSolrClient());\n        assertTrue(response.isSuccess());\n        String coreName = response.getCollectionCoresStatus()\n            .keySet().iterator().next();\n        assertFalse(\"Core name is not unique coreName=\" + coreName + \" \" + coreNames, coreNames.contains(coreName));\n        coreNames.add(coreName);\n        numLiveReplicas++;\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n\n        Replica newReplica = getCollectionState(COLLECTION).getReplicas().stream()\n            .filter(r -> r.getCoreName().equals(coreName))\n            .findAny().get();\n        String coreNodeName = newReplica.getName();\n        assertFalse(\"Core node name is not unique\", coreNodeNames.contains(coreName));\n        coreNodeNames.add(coreNodeName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f607a0a2e930f55385c7a24afb68ef661ef7e3ee","date":1530823671,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","sourceNew":"  @Test\n  //05-Jul-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void test() throws IOException, SolrServerException, KeeperException, InterruptedException {\n    Set<String> coreNames = new HashSet<>();\n    Set<String> coreNodeNames = new HashSet<>();\n\n    int numOperations = random().nextInt(15) + 15;\n    int numLiveReplicas = 4;\n\n    boolean clearedCounter = false;\n    for (int i = 0; i < numOperations; i++) {\n      log.info(\"Collection counter={} i={}\", getCounter(), i);\n      boolean deleteReplica = random().nextBoolean() && numLiveReplicas > 1;\n      // No need to clear counter more than one time\n      if (random().nextBoolean() && i > 5 && !clearedCounter) {\n        log.info(\"Clear collection counter\");\n        // clear counter\n        cluster.getZkClient().delete(\"/collections/\"+COLLECTION+\"/counter\", -1, true);\n        clearedCounter = true;\n      }\n      if (deleteReplica) {\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n        DocCollection dc = getCollectionState(COLLECTION);\n        Replica replica = getRandomReplica(dc.getSlice(\"shard1\"), (r) -> r.getState() == Replica.State.ACTIVE);\n        CollectionAdminRequest.deleteReplica(COLLECTION, \"shard1\", replica.getName()).process(cluster.getSolrClient());\n        numLiveReplicas--;\n      } else {\n        CollectionAdminResponse response = CollectionAdminRequest.addReplicaToShard(COLLECTION, \"shard1\")\n            .process(cluster.getSolrClient());\n        assertTrue(response.isSuccess());\n        String coreName = response.getCollectionCoresStatus()\n            .keySet().iterator().next();\n        assertFalse(\"Core name is not unique coreName=\" + coreName + \" \" + coreNames, coreNames.contains(coreName));\n        coreNames.add(coreName);\n        numLiveReplicas++;\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n\n        Replica newReplica = getCollectionState(COLLECTION).getReplicas().stream()\n            .filter(r -> r.getCoreName().equals(coreName))\n            .findAny().get();\n        String coreNodeName = newReplica.getName();\n        assertFalse(\"Core node name is not unique\", coreNodeNames.contains(coreName));\n        coreNodeNames.add(coreNodeName);\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void test() throws IOException, SolrServerException, KeeperException, InterruptedException {\n    Set<String> coreNames = new HashSet<>();\n    Set<String> coreNodeNames = new HashSet<>();\n\n    int numOperations = random().nextInt(15) + 15;\n    int numLiveReplicas = 4;\n\n    boolean clearedCounter = false;\n    for (int i = 0; i < numOperations; i++) {\n      log.info(\"Collection counter={} i={}\", getCounter(), i);\n      boolean deleteReplica = random().nextBoolean() && numLiveReplicas > 1;\n      // No need to clear counter more than one time\n      if (random().nextBoolean() && i > 5 && !clearedCounter) {\n        log.info(\"Clear collection counter\");\n        // clear counter\n        cluster.getZkClient().delete(\"/collections/\"+COLLECTION+\"/counter\", -1, true);\n        clearedCounter = true;\n      }\n      if (deleteReplica) {\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n        DocCollection dc = getCollectionState(COLLECTION);\n        Replica replica = getRandomReplica(dc.getSlice(\"shard1\"), (r) -> r.getState() == Replica.State.ACTIVE);\n        CollectionAdminRequest.deleteReplica(COLLECTION, \"shard1\", replica.getName()).process(cluster.getSolrClient());\n        numLiveReplicas--;\n      } else {\n        CollectionAdminResponse response = CollectionAdminRequest.addReplicaToShard(COLLECTION, \"shard1\")\n            .process(cluster.getSolrClient());\n        assertTrue(response.isSuccess());\n        String coreName = response.getCollectionCoresStatus()\n            .keySet().iterator().next();\n        assertFalse(\"Core name is not unique coreName=\" + coreName + \" \" + coreNames, coreNames.contains(coreName));\n        coreNames.add(coreName);\n        numLiveReplicas++;\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n\n        Replica newReplica = getCollectionState(COLLECTION).getReplicas().stream()\n            .filter(r -> r.getCoreName().equals(coreName))\n            .findAny().get();\n        String coreNodeName = newReplica.getName();\n        assertFalse(\"Core node name is not unique\", coreNodeNames.contains(coreName));\n        coreNodeNames.add(coreNodeName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","sourceNew":"  @Test\n  //05-Jul-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void test() throws IOException, SolrServerException, KeeperException, InterruptedException {\n    Set<String> coreNames = new HashSet<>();\n    Set<String> coreNodeNames = new HashSet<>();\n\n    int numOperations = random().nextInt(15) + 15;\n    int numLiveReplicas = 4;\n\n    boolean clearedCounter = false;\n    for (int i = 0; i < numOperations; i++) {\n      log.info(\"Collection counter={} i={}\", getCounter(), i);\n      boolean deleteReplica = random().nextBoolean() && numLiveReplicas > 1;\n      // No need to clear counter more than one time\n      if (random().nextBoolean() && i > 5 && !clearedCounter) {\n        log.info(\"Clear collection counter\");\n        // clear counter\n        cluster.getZkClient().delete(\"/collections/\"+COLLECTION+\"/counter\", -1, true);\n        clearedCounter = true;\n      }\n      if (deleteReplica) {\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n        DocCollection dc = getCollectionState(COLLECTION);\n        Replica replica = getRandomReplica(dc.getSlice(\"shard1\"), (r) -> r.getState() == Replica.State.ACTIVE);\n        CollectionAdminRequest.deleteReplica(COLLECTION, \"shard1\", replica.getName()).process(cluster.getSolrClient());\n        numLiveReplicas--;\n      } else {\n        CollectionAdminResponse response = CollectionAdminRequest.addReplicaToShard(COLLECTION, \"shard1\")\n            .process(cluster.getSolrClient());\n        assertTrue(response.isSuccess());\n        String coreName = response.getCollectionCoresStatus()\n            .keySet().iterator().next();\n        assertFalse(\"Core name is not unique coreName=\" + coreName + \" \" + coreNames, coreNames.contains(coreName));\n        coreNames.add(coreName);\n        numLiveReplicas++;\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n\n        Replica newReplica = getCollectionState(COLLECTION).getReplicas().stream()\n            .filter(r -> r.getCoreName().equals(coreName))\n            .findAny().get();\n        String coreNodeName = newReplica.getName();\n        assertFalse(\"Core node name is not unique\", coreNodeNames.contains(coreName));\n        coreNodeNames.add(coreNodeName);\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void test() throws IOException, SolrServerException, KeeperException, InterruptedException {\n    Set<String> coreNames = new HashSet<>();\n    Set<String> coreNodeNames = new HashSet<>();\n\n    int numOperations = random().nextInt(15) + 15;\n    int numLiveReplicas = 4;\n\n    boolean clearedCounter = false;\n    for (int i = 0; i < numOperations; i++) {\n      log.info(\"Collection counter={} i={}\", getCounter(), i);\n      boolean deleteReplica = random().nextBoolean() && numLiveReplicas > 1;\n      // No need to clear counter more than one time\n      if (random().nextBoolean() && i > 5 && !clearedCounter) {\n        log.info(\"Clear collection counter\");\n        // clear counter\n        cluster.getZkClient().delete(\"/collections/\"+COLLECTION+\"/counter\", -1, true);\n        clearedCounter = true;\n      }\n      if (deleteReplica) {\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n        DocCollection dc = getCollectionState(COLLECTION);\n        Replica replica = getRandomReplica(dc.getSlice(\"shard1\"), (r) -> r.getState() == Replica.State.ACTIVE);\n        CollectionAdminRequest.deleteReplica(COLLECTION, \"shard1\", replica.getName()).process(cluster.getSolrClient());\n        numLiveReplicas--;\n      } else {\n        CollectionAdminResponse response = CollectionAdminRequest.addReplicaToShard(COLLECTION, \"shard1\")\n            .process(cluster.getSolrClient());\n        assertTrue(response.isSuccess());\n        String coreName = response.getCollectionCoresStatus()\n            .keySet().iterator().next();\n        assertFalse(\"Core name is not unique coreName=\" + coreName + \" \" + coreNames, coreNames.contains(coreName));\n        coreNames.add(coreName);\n        numLiveReplicas++;\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n\n        Replica newReplica = getCollectionState(COLLECTION).getReplicas().stream()\n            .filter(r -> r.getCoreName().equals(coreName))\n            .findAny().get();\n        String coreNodeName = newReplica.getName();\n        assertFalse(\"Core node name is not unique\", coreNodeNames.contains(coreName));\n        coreNodeNames.add(coreNodeName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","sourceNew":"  @Test\n  //05-Jul-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void test() throws IOException, SolrServerException, KeeperException, InterruptedException {\n    Set<String> coreNames = new HashSet<>();\n    Set<String> coreNodeNames = new HashSet<>();\n\n    int numOperations = random().nextInt(15) + 15;\n    int numLiveReplicas = 4;\n\n    boolean clearedCounter = false;\n    for (int i = 0; i < numOperations; i++) {\n      log.info(\"Collection counter={} i={}\", getCounter(), i);\n      boolean deleteReplica = random().nextBoolean() && numLiveReplicas > 1;\n      // No need to clear counter more than one time\n      if (random().nextBoolean() && i > 5 && !clearedCounter) {\n        log.info(\"Clear collection counter\");\n        // clear counter\n        cluster.getZkClient().delete(\"/collections/\"+COLLECTION+\"/counter\", -1, true);\n        clearedCounter = true;\n      }\n      if (deleteReplica) {\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n        DocCollection dc = getCollectionState(COLLECTION);\n        Replica replica = getRandomReplica(dc.getSlice(\"shard1\"), (r) -> r.getState() == Replica.State.ACTIVE);\n        CollectionAdminRequest.deleteReplica(COLLECTION, \"shard1\", replica.getName()).process(cluster.getSolrClient());\n        numLiveReplicas--;\n      } else {\n        CollectionAdminResponse response = CollectionAdminRequest.addReplicaToShard(COLLECTION, \"shard1\")\n            .process(cluster.getSolrClient());\n        assertTrue(response.isSuccess());\n        String coreName = response.getCollectionCoresStatus()\n            .keySet().iterator().next();\n        assertFalse(\"Core name is not unique coreName=\" + coreName + \" \" + coreNames, coreNames.contains(coreName));\n        coreNames.add(coreName);\n        numLiveReplicas++;\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n\n        Replica newReplica = getCollectionState(COLLECTION).getReplicas().stream()\n            .filter(r -> r.getCoreName().equals(coreName))\n            .findAny().get();\n        String coreNodeName = newReplica.getName();\n        assertFalse(\"Core node name is not unique\", coreNodeNames.contains(coreName));\n        coreNodeNames.add(coreNodeName);\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void test() throws IOException, SolrServerException, KeeperException, InterruptedException {\n    Set<String> coreNames = new HashSet<>();\n    Set<String> coreNodeNames = new HashSet<>();\n\n    int numOperations = random().nextInt(15) + 15;\n    int numLiveReplicas = 4;\n\n    boolean clearedCounter = false;\n    for (int i = 0; i < numOperations; i++) {\n      log.info(\"Collection counter={} i={}\", getCounter(), i);\n      boolean deleteReplica = random().nextBoolean() && numLiveReplicas > 1;\n      // No need to clear counter more than one time\n      if (random().nextBoolean() && i > 5 && !clearedCounter) {\n        log.info(\"Clear collection counter\");\n        // clear counter\n        cluster.getZkClient().delete(\"/collections/\"+COLLECTION+\"/counter\", -1, true);\n        clearedCounter = true;\n      }\n      if (deleteReplica) {\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n        DocCollection dc = getCollectionState(COLLECTION);\n        Replica replica = getRandomReplica(dc.getSlice(\"shard1\"), (r) -> r.getState() == Replica.State.ACTIVE);\n        CollectionAdminRequest.deleteReplica(COLLECTION, \"shard1\", replica.getName()).process(cluster.getSolrClient());\n        numLiveReplicas--;\n      } else {\n        CollectionAdminResponse response = CollectionAdminRequest.addReplicaToShard(COLLECTION, \"shard1\")\n            .process(cluster.getSolrClient());\n        assertTrue(response.isSuccess());\n        String coreName = response.getCollectionCoresStatus()\n            .keySet().iterator().next();\n        assertFalse(\"Core name is not unique coreName=\" + coreName + \" \" + coreNames, coreNames.contains(coreName));\n        coreNames.add(coreName);\n        numLiveReplicas++;\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n\n        Replica newReplica = getCollectionState(COLLECTION).getReplicas().stream()\n            .filter(r -> r.getCoreName().equals(coreName))\n            .findAny().get();\n        String coreNodeName = newReplica.getName();\n        assertFalse(\"Core node name is not unique\", coreNodeNames.contains(coreName));\n        coreNodeNames.add(coreNodeName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a","date":1536291831,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","sourceNew":"  @Test\n  //05-Jul-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void test() throws IOException, SolrServerException, KeeperException, InterruptedException {\n    Set<String> coreNames = new HashSet<>();\n    Set<String> coreNodeNames = new HashSet<>();\n\n    int numOperations = random().nextInt(15) + 15;\n    int numLiveReplicas = 4;\n\n    boolean clearedCounter = false;\n    for (int i = 0; i < numOperations; i++) {\n      log.info(\"Collection counter={} i={}\", getCounter(), i);\n      boolean deleteReplica = random().nextBoolean() && numLiveReplicas > 1;\n      // No need to clear counter more than one time\n      if (random().nextBoolean() && i > 5 && !clearedCounter) {\n        log.info(\"Clear collection counter\");\n        // clear counter\n        cluster.getZkClient().delete(\"/collections/\"+COLLECTION+\"/counter\", -1, true);\n        clearedCounter = true;\n      }\n      if (deleteReplica) {\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n        DocCollection dc = getCollectionState(COLLECTION);\n        Replica replica = getRandomReplica(dc.getSlice(\"shard1\"), (r) -> r.getState() == Replica.State.ACTIVE);\n        CollectionAdminRequest.deleteReplica(COLLECTION, \"shard1\", replica.getName()).process(cluster.getSolrClient());\n        numLiveReplicas--;\n      } else {\n        CollectionAdminResponse response = CollectionAdminRequest.addReplicaToShard(COLLECTION, \"shard1\")\n            .process(cluster.getSolrClient());\n        assertTrue(response.isSuccess());\n        String coreName = response.getCollectionCoresStatus()\n            .keySet().iterator().next();\n        assertFalse(\"Core name is not unique coreName=\" + coreName + \" \" + coreNames, coreNames.contains(coreName));\n        coreNames.add(coreName);\n        numLiveReplicas++;\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n\n        Replica newReplica = getCollectionState(COLLECTION).getReplicas().stream()\n            .filter(r -> r.getCoreName().equals(coreName))\n            .findAny().get();\n        String coreNodeName = newReplica.getName();\n        assertFalse(\"Core node name is not unique\", coreNodeNames.contains(coreName));\n        coreNodeNames.add(coreNodeName);\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  //05-Jul-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void test() throws IOException, SolrServerException, KeeperException, InterruptedException {\n    Set<String> coreNames = new HashSet<>();\n    Set<String> coreNodeNames = new HashSet<>();\n\n    int numOperations = random().nextInt(15) + 15;\n    int numLiveReplicas = 4;\n\n    boolean clearedCounter = false;\n    for (int i = 0; i < numOperations; i++) {\n      log.info(\"Collection counter={} i={}\", getCounter(), i);\n      boolean deleteReplica = random().nextBoolean() && numLiveReplicas > 1;\n      // No need to clear counter more than one time\n      if (random().nextBoolean() && i > 5 && !clearedCounter) {\n        log.info(\"Clear collection counter\");\n        // clear counter\n        cluster.getZkClient().delete(\"/collections/\"+COLLECTION+\"/counter\", -1, true);\n        clearedCounter = true;\n      }\n      if (deleteReplica) {\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n        DocCollection dc = getCollectionState(COLLECTION);\n        Replica replica = getRandomReplica(dc.getSlice(\"shard1\"), (r) -> r.getState() == Replica.State.ACTIVE);\n        CollectionAdminRequest.deleteReplica(COLLECTION, \"shard1\", replica.getName()).process(cluster.getSolrClient());\n        numLiveReplicas--;\n      } else {\n        CollectionAdminResponse response = CollectionAdminRequest.addReplicaToShard(COLLECTION, \"shard1\")\n            .process(cluster.getSolrClient());\n        assertTrue(response.isSuccess());\n        String coreName = response.getCollectionCoresStatus()\n            .keySet().iterator().next();\n        assertFalse(\"Core name is not unique coreName=\" + coreName + \" \" + coreNames, coreNames.contains(coreName));\n        coreNames.add(coreName);\n        numLiveReplicas++;\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n\n        Replica newReplica = getCollectionState(COLLECTION).getReplicas().stream()\n            .filter(r -> r.getCoreName().equals(coreName))\n            .findAny().get();\n        String coreNodeName = newReplica.getName();\n        assertFalse(\"Core node name is not unique\", coreNodeNames.contains(coreName));\n        coreNodeNames.add(coreNodeName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","sourceNew":"  @Test\n  public void test() throws IOException, SolrServerException, KeeperException, InterruptedException {\n    Set<String> coreNames = new HashSet<>();\n    Set<String> coreNodeNames = new HashSet<>();\n\n    int numOperations = random().nextInt(15) + 15;\n    int numLiveReplicas = 4;\n\n    boolean clearedCounter = false;\n    for (int i = 0; i < numOperations; i++) {\n      log.info(\"Collection counter={} i={}\", getCounter(), i);\n      boolean deleteReplica = random().nextBoolean() && numLiveReplicas > 1;\n      // No need to clear counter more than one time\n      if (random().nextBoolean() && i > 5 && !clearedCounter) {\n        log.info(\"Clear collection counter\");\n        // clear counter\n        cluster.getZkClient().delete(\"/collections/\"+COLLECTION+\"/counter\", -1, true);\n        clearedCounter = true;\n      }\n      if (deleteReplica) {\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n        DocCollection dc = getCollectionState(COLLECTION);\n        Replica replica = getRandomReplica(dc.getSlice(\"shard1\"), (r) -> r.getState() == Replica.State.ACTIVE);\n        CollectionAdminRequest.deleteReplica(COLLECTION, \"shard1\", replica.getName()).process(cluster.getSolrClient());\n        coreNames.remove(replica.getCoreName());\n        numLiveReplicas--;\n      } else {\n        CollectionAdminResponse response = CollectionAdminRequest.addReplicaToShard(COLLECTION, \"shard1\")\n            .process(cluster.getSolrClient());\n        assertTrue(response.isSuccess());\n        String coreName = response.getCollectionCoresStatus()\n            .keySet().iterator().next();\n        assertFalse(\"Core name is not unique coreName=\" + coreName + \" \" + coreNames, coreNames.contains(coreName));\n        coreNames.add(coreName);\n        numLiveReplicas++;\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n\n        Replica newReplica = getCollectionState(COLLECTION).getReplicas().stream()\n            .filter(r -> r.getCoreName().equals(coreName))\n            .findAny().get();\n        String coreNodeName = newReplica.getName();\n        assertFalse(\"Core node name is not unique\", coreNodeNames.contains(coreName));\n        coreNodeNames.add(coreNodeName);\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  //05-Jul-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 2-Aug-2018\n  public void test() throws IOException, SolrServerException, KeeperException, InterruptedException {\n    Set<String> coreNames = new HashSet<>();\n    Set<String> coreNodeNames = new HashSet<>();\n\n    int numOperations = random().nextInt(15) + 15;\n    int numLiveReplicas = 4;\n\n    boolean clearedCounter = false;\n    for (int i = 0; i < numOperations; i++) {\n      log.info(\"Collection counter={} i={}\", getCounter(), i);\n      boolean deleteReplica = random().nextBoolean() && numLiveReplicas > 1;\n      // No need to clear counter more than one time\n      if (random().nextBoolean() && i > 5 && !clearedCounter) {\n        log.info(\"Clear collection counter\");\n        // clear counter\n        cluster.getZkClient().delete(\"/collections/\"+COLLECTION+\"/counter\", -1, true);\n        clearedCounter = true;\n      }\n      if (deleteReplica) {\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n        DocCollection dc = getCollectionState(COLLECTION);\n        Replica replica = getRandomReplica(dc.getSlice(\"shard1\"), (r) -> r.getState() == Replica.State.ACTIVE);\n        CollectionAdminRequest.deleteReplica(COLLECTION, \"shard1\", replica.getName()).process(cluster.getSolrClient());\n        numLiveReplicas--;\n      } else {\n        CollectionAdminResponse response = CollectionAdminRequest.addReplicaToShard(COLLECTION, \"shard1\")\n            .process(cluster.getSolrClient());\n        assertTrue(response.isSuccess());\n        String coreName = response.getCollectionCoresStatus()\n            .keySet().iterator().next();\n        assertFalse(\"Core name is not unique coreName=\" + coreName + \" \" + coreNames, coreNames.contains(coreName));\n        coreNames.add(coreName);\n        numLiveReplicas++;\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n\n        Replica newReplica = getCollectionState(COLLECTION).getReplicas().stream()\n            .filter(r -> r.getCoreName().equals(coreName))\n            .findAny().get();\n        String coreNodeName = newReplica.getName();\n        assertFalse(\"Core node name is not unique\", coreNodeNames.contains(coreName));\n        coreNodeNames.add(coreNodeName);\n      }\n    }\n  }\n\n","bugFix":["f607a0a2e930f55385c7a24afb68ef661ef7e3ee","f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"abfeda0a9738b1b31db7c43aa5f067596bf5c9e1","date":1544401888,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","sourceNew":"  @Test\n  public void test() throws IOException, SolrServerException, KeeperException, InterruptedException {\n    Set<String> coreNames = new HashSet<>();\n    Set<String> coreNodeNames = new HashSet<>();\n\n    int numOperations = random().nextInt(15) + 15;\n    int numLiveReplicas = 4;\n\n    boolean clearedCounter = false;\n    for (int i = 0; i < numOperations; i++) {\n      log.info(\"Collection counter={} i={}\", getCounter(), i);\n      boolean deleteReplica = random().nextBoolean() && numLiveReplicas > 1;\n      // No need to clear counter more than one time\n      if (random().nextBoolean() && i > 5 && !clearedCounter) {\n        log.info(\"Clear collection counter\");\n        // clear counter\n        cluster.getZkClient().delete(\"/collections/\"+COLLECTION+\"/counter\", -1, true);\n        clearedCounter = true;\n      }\n      if (deleteReplica) {\n        cluster.waitForActiveCollection(COLLECTION, 1, numLiveReplicas);\n        DocCollection dc = getCollectionState(COLLECTION);\n        Replica replica = getRandomReplica(dc.getSlice(\"shard1\"), (r) -> r.getState() == Replica.State.ACTIVE);\n        CollectionAdminRequest.deleteReplica(COLLECTION, \"shard1\", replica.getName()).process(cluster.getSolrClient());\n        coreNames.remove(replica.getCoreName());\n        numLiveReplicas--;\n      } else {\n        CollectionAdminResponse response = CollectionAdminRequest.addReplicaToShard(COLLECTION, \"shard1\")\n            .process(cluster.getSolrClient());\n        assertTrue(response.isSuccess());\n        String coreName = response.getCollectionCoresStatus()\n            .keySet().iterator().next();\n        assertFalse(\"Core name is not unique coreName=\" + coreName + \" \" + coreNames, coreNames.contains(coreName));\n        coreNames.add(coreName);\n        numLiveReplicas++;\n        cluster.waitForActiveCollection(COLLECTION, 1, numLiveReplicas);\n\n        Replica newReplica = getCollectionState(COLLECTION).getReplicas().stream()\n            .filter(r -> r.getCoreName().equals(coreName))\n            .findAny().get();\n        String coreNodeName = newReplica.getName();\n        assertFalse(\"Core node name is not unique\", coreNodeNames.contains(coreName));\n        coreNodeNames.add(coreNodeName);\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void test() throws IOException, SolrServerException, KeeperException, InterruptedException {\n    Set<String> coreNames = new HashSet<>();\n    Set<String> coreNodeNames = new HashSet<>();\n\n    int numOperations = random().nextInt(15) + 15;\n    int numLiveReplicas = 4;\n\n    boolean clearedCounter = false;\n    for (int i = 0; i < numOperations; i++) {\n      log.info(\"Collection counter={} i={}\", getCounter(), i);\n      boolean deleteReplica = random().nextBoolean() && numLiveReplicas > 1;\n      // No need to clear counter more than one time\n      if (random().nextBoolean() && i > 5 && !clearedCounter) {\n        log.info(\"Clear collection counter\");\n        // clear counter\n        cluster.getZkClient().delete(\"/collections/\"+COLLECTION+\"/counter\", -1, true);\n        clearedCounter = true;\n      }\n      if (deleteReplica) {\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n        DocCollection dc = getCollectionState(COLLECTION);\n        Replica replica = getRandomReplica(dc.getSlice(\"shard1\"), (r) -> r.getState() == Replica.State.ACTIVE);\n        CollectionAdminRequest.deleteReplica(COLLECTION, \"shard1\", replica.getName()).process(cluster.getSolrClient());\n        coreNames.remove(replica.getCoreName());\n        numLiveReplicas--;\n      } else {\n        CollectionAdminResponse response = CollectionAdminRequest.addReplicaToShard(COLLECTION, \"shard1\")\n            .process(cluster.getSolrClient());\n        assertTrue(response.isSuccess());\n        String coreName = response.getCollectionCoresStatus()\n            .keySet().iterator().next();\n        assertFalse(\"Core name is not unique coreName=\" + coreName + \" \" + coreNames, coreNames.contains(coreName));\n        coreNames.add(coreName);\n        numLiveReplicas++;\n        waitForState(\"Expected \" + numLiveReplicas + \" active replicas\", COLLECTION, clusterShape(1, numLiveReplicas));\n\n        Replica newReplica = getCollectionState(COLLECTION).getReplicas().stream()\n            .filter(r -> r.getCoreName().equals(coreName))\n            .findAny().get();\n        String coreNodeName = newReplica.getName();\n        assertFalse(\"Core node name is not unique\", coreNodeNames.contains(coreName));\n        coreNodeNames.add(coreNodeName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AssignBackwardCompatibilityTest#test().mjava","sourceNew":"  @Test\n  public void test() throws IOException, SolrServerException, KeeperException, InterruptedException {\n    Set<String> coreNames = new HashSet<>();\n    Set<String> coreNodeNames = new HashSet<>();\n\n    int numOperations = random().nextInt(15) + 15;\n    int numLiveReplicas = 4;\n\n    boolean clearedCounter = false;\n    for (int i = 0; i < numOperations; i++) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Collection counter={} i={}\", getCounter(), i);\n      }\n      boolean deleteReplica = random().nextBoolean() && numLiveReplicas > 1;\n      // No need to clear counter more than one time\n      if (random().nextBoolean() && i > 5 && !clearedCounter) {\n        log.info(\"Clear collection counter\");\n        // clear counter\n        cluster.getZkClient().delete(\"/collections/\"+COLLECTION+\"/counter\", -1, true);\n        clearedCounter = true;\n      }\n      if (deleteReplica) {\n        cluster.waitForActiveCollection(COLLECTION, 1, numLiveReplicas);\n        DocCollection dc = getCollectionState(COLLECTION);\n        Replica replica = getRandomReplica(dc.getSlice(\"shard1\"), (r) -> r.getState() == Replica.State.ACTIVE);\n        CollectionAdminRequest.deleteReplica(COLLECTION, \"shard1\", replica.getName()).process(cluster.getSolrClient());\n        coreNames.remove(replica.getCoreName());\n        numLiveReplicas--;\n      } else {\n        CollectionAdminResponse response = CollectionAdminRequest.addReplicaToShard(COLLECTION, \"shard1\")\n            .process(cluster.getSolrClient());\n        assertTrue(response.isSuccess());\n        String coreName = response.getCollectionCoresStatus()\n            .keySet().iterator().next();\n        assertFalse(\"Core name is not unique coreName=\" + coreName + \" \" + coreNames, coreNames.contains(coreName));\n        coreNames.add(coreName);\n        numLiveReplicas++;\n        cluster.waitForActiveCollection(COLLECTION, 1, numLiveReplicas);\n\n        Replica newReplica = getCollectionState(COLLECTION).getReplicas().stream()\n            .filter(r -> r.getCoreName().equals(coreName))\n            .findAny().get();\n        String coreNodeName = newReplica.getName();\n        assertFalse(\"Core node name is not unique\", coreNodeNames.contains(coreName));\n        coreNodeNames.add(coreNodeName);\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void test() throws IOException, SolrServerException, KeeperException, InterruptedException {\n    Set<String> coreNames = new HashSet<>();\n    Set<String> coreNodeNames = new HashSet<>();\n\n    int numOperations = random().nextInt(15) + 15;\n    int numLiveReplicas = 4;\n\n    boolean clearedCounter = false;\n    for (int i = 0; i < numOperations; i++) {\n      log.info(\"Collection counter={} i={}\", getCounter(), i);\n      boolean deleteReplica = random().nextBoolean() && numLiveReplicas > 1;\n      // No need to clear counter more than one time\n      if (random().nextBoolean() && i > 5 && !clearedCounter) {\n        log.info(\"Clear collection counter\");\n        // clear counter\n        cluster.getZkClient().delete(\"/collections/\"+COLLECTION+\"/counter\", -1, true);\n        clearedCounter = true;\n      }\n      if (deleteReplica) {\n        cluster.waitForActiveCollection(COLLECTION, 1, numLiveReplicas);\n        DocCollection dc = getCollectionState(COLLECTION);\n        Replica replica = getRandomReplica(dc.getSlice(\"shard1\"), (r) -> r.getState() == Replica.State.ACTIVE);\n        CollectionAdminRequest.deleteReplica(COLLECTION, \"shard1\", replica.getName()).process(cluster.getSolrClient());\n        coreNames.remove(replica.getCoreName());\n        numLiveReplicas--;\n      } else {\n        CollectionAdminResponse response = CollectionAdminRequest.addReplicaToShard(COLLECTION, \"shard1\")\n            .process(cluster.getSolrClient());\n        assertTrue(response.isSuccess());\n        String coreName = response.getCollectionCoresStatus()\n            .keySet().iterator().next();\n        assertFalse(\"Core name is not unique coreName=\" + coreName + \" \" + coreNames, coreNames.contains(coreName));\n        coreNames.add(coreName);\n        numLiveReplicas++;\n        cluster.waitForActiveCollection(COLLECTION, 1, numLiveReplicas);\n\n        Replica newReplica = getCollectionState(COLLECTION).getReplicas().stream()\n            .filter(r -> r.getCoreName().equals(coreName))\n            .findAny().get();\n        String coreNodeName = newReplica.getName();\n        assertFalse(\"Core node name is not unique\", coreNodeNames.contains(coreName));\n        coreNodeNames.add(coreNodeName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"acdf5bd70aa60010f071c51eaf1dfc7d7e5b4a0b":["a52341299179de5479672f7cf518bf4b173f34b3"],"651c3ddf5bc1266d9de0a972ec05e59d77099a4c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a"],"936cdd5882761db3b844afd6f84ab81cbb011a75":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","651c3ddf5bc1266d9de0a972ec05e59d77099a4c"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["abfeda0a9738b1b31db7c43aa5f067596bf5c9e1"],"43ad790248d7f7daee5d9cced548c546f37c7218":["acdf5bd70aa60010f071c51eaf1dfc7d7e5b4a0b"],"abfeda0a9738b1b31db7c43aa5f067596bf5c9e1":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"a52341299179de5479672f7cf518bf4b173f34b3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","651c3ddf5bc1266d9de0a972ec05e59d77099a4c"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["43ad790248d7f7daee5d9cced548c546f37c7218","f607a0a2e930f55385c7a24afb68ef661ef7e3ee"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a":["f607a0a2e930f55385c7a24afb68ef661ef7e3ee"],"f607a0a2e930f55385c7a24afb68ef661ef7e3ee":["43ad790248d7f7daee5d9cced548c546f37c7218"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["43ad790248d7f7daee5d9cced548c546f37c7218","f607a0a2e930f55385c7a24afb68ef661ef7e3ee"]},"commit2Childs":{"acdf5bd70aa60010f071c51eaf1dfc7d7e5b4a0b":["43ad790248d7f7daee5d9cced548c546f37c7218"],"651c3ddf5bc1266d9de0a972ec05e59d77099a4c":["936cdd5882761db3b844afd6f84ab81cbb011a75","a52341299179de5479672f7cf518bf4b173f34b3"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["abfeda0a9738b1b31db7c43aa5f067596bf5c9e1"],"936cdd5882761db3b844afd6f84ab81cbb011a75":[],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"43ad790248d7f7daee5d9cced548c546f37c7218":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","f607a0a2e930f55385c7a24afb68ef661ef7e3ee","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"abfeda0a9738b1b31db7c43aa5f067596bf5c9e1":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"a52341299179de5479672f7cf518bf4b173f34b3":["acdf5bd70aa60010f071c51eaf1dfc7d7e5b4a0b"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["651c3ddf5bc1266d9de0a972ec05e59d77099a4c","936cdd5882761db3b844afd6f84ab81cbb011a75","a52341299179de5479672f7cf518bf4b173f34b3"],"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"f607a0a2e930f55385c7a24afb68ef661ef7e3ee":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["936cdd5882761db3b844afd6f84ab81cbb011a75","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}