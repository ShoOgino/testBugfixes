{"path":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(double,double,double,double,LatLonFilter,SortedNumericDocValues).mjava","commits":[{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(double,double,double,double,LatLonFilter,SortedNumericDocValues).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(Bits,double,double,double,double,LatLonFilter,SortedNumericDocValues).mjava","sourceNew":"  public DocIdSet intersect(double latMin, double latMax, double lonMin, double lonMax, LatLonFilter filter, SortedNumericDocValues sndv) throws IOException {\n    if (BKDTreeWriter.validLat(latMin) == false) {\n      throw new IllegalArgumentException(\"invalid latMin: \" + latMin);\n    }\n    if (BKDTreeWriter.validLat(latMax) == false) {\n      throw new IllegalArgumentException(\"invalid latMax: \" + latMax);\n    }\n    if (BKDTreeWriter.validLon(lonMin) == false) {\n      throw new IllegalArgumentException(\"invalid lonMin: \" + lonMin);\n    }\n    if (BKDTreeWriter.validLon(lonMax) == false) {\n      throw new IllegalArgumentException(\"invalid lonMax: \" + lonMax);\n    }\n\n    int latMinEnc = BKDTreeWriter.encodeLat(latMin);\n    int latMaxEnc = BKDTreeWriter.encodeLat(latMax);\n    int lonMinEnc = BKDTreeWriter.encodeLon(lonMin);\n    int lonMaxEnc = BKDTreeWriter.encodeLon(lonMax);\n\n    // TODO: we should use a sparse bit collector here, but BitDocIdSet.Builder is 2.4X slower than straight FixedBitSet.\n    // Maybe we should use simple int[] (not de-duping) up until size X, then cutover.  Or maybe SentinelIntSet when it's\n    // small.\n\n    QueryState state = new QueryState(in.clone(), maxDoc,\n                                      latMinEnc, latMaxEnc,\n                                      lonMinEnc, lonMaxEnc,\n                                      filter,\n                                      sndv);\n\n    int hitCount = intersect(state, 1,\n                             BKDTreeWriter.encodeLat(-90.0),\n                             BKDTreeWriter.encodeLat(Math.nextAfter(90.0, Double.POSITIVE_INFINITY)),\n                             BKDTreeWriter.encodeLon(-180.0),\n                             BKDTreeWriter.encodeLon(Math.nextAfter(180.0, Double.POSITIVE_INFINITY)));\n\n    // NOTE: hitCount is an over-estimate in the multi-valued case:\n    return new BitDocIdSet(state.bits, hitCount);\n  }\n\n","sourceOld":"  public DocIdSet intersect(Bits acceptDocs, double latMin, double latMax, double lonMin, double lonMax, LatLonFilter filter, SortedNumericDocValues sndv) throws IOException {\n    if (BKDTreeWriter.validLat(latMin) == false) {\n      throw new IllegalArgumentException(\"invalid latMin: \" + latMin);\n    }\n    if (BKDTreeWriter.validLat(latMax) == false) {\n      throw new IllegalArgumentException(\"invalid latMax: \" + latMax);\n    }\n    if (BKDTreeWriter.validLon(lonMin) == false) {\n      throw new IllegalArgumentException(\"invalid lonMin: \" + lonMin);\n    }\n    if (BKDTreeWriter.validLon(lonMax) == false) {\n      throw new IllegalArgumentException(\"invalid lonMax: \" + lonMax);\n    }\n\n    int latMinEnc = BKDTreeWriter.encodeLat(latMin);\n    int latMaxEnc = BKDTreeWriter.encodeLat(latMax);\n    int lonMinEnc = BKDTreeWriter.encodeLon(lonMin);\n    int lonMaxEnc = BKDTreeWriter.encodeLon(lonMax);\n\n    // TODO: we should use a sparse bit collector here, but BitDocIdSet.Builder is 2.4X slower than straight FixedBitSet.\n    // Maybe we should use simple int[] (not de-duping) up until size X, then cutover.  Or maybe SentinelIntSet when it's\n    // small.\n\n    QueryState state = new QueryState(in.clone(), maxDoc,\n                                      latMinEnc, latMaxEnc,\n                                      lonMinEnc, lonMaxEnc,\n                                      filter,\n                                      sndv);\n\n    int hitCount = intersect(acceptDocs, state, 1,\n                             BKDTreeWriter.encodeLat(-90.0),\n                             BKDTreeWriter.encodeLat(Math.nextAfter(90.0, Double.POSITIVE_INFINITY)),\n                             BKDTreeWriter.encodeLon(-180.0),\n                             BKDTreeWriter.encodeLon(Math.nextAfter(180.0, Double.POSITIVE_INFINITY)));\n\n    // NOTE: hitCount is an over-estimate in the multi-valued case:\n    return new BitDocIdSet(state.bits, hitCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e91a2d9ed80172872da0f517870da6756289554","date":1436431140,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(double,double,double,double,LatLonFilter,SortedNumericDocValues).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(double,double,double,double,LatLonFilter,SortedNumericDocValues).mjava","sourceNew":"  public DocIdSet intersect(double latMin, double latMax, double lonMin, double lonMax, LatLonFilter filter, SortedNumericDocValues sndv) throws IOException {\n    if (BKDTreeWriter.validLat(latMin) == false) {\n      throw new IllegalArgumentException(\"invalid latMin: \" + latMin);\n    }\n    if (BKDTreeWriter.validLat(latMax) == false) {\n      throw new IllegalArgumentException(\"invalid latMax: \" + latMax);\n    }\n    if (BKDTreeWriter.validLon(lonMin) == false) {\n      throw new IllegalArgumentException(\"invalid lonMin: \" + lonMin);\n    }\n    if (BKDTreeWriter.validLon(lonMax) == false) {\n      throw new IllegalArgumentException(\"invalid lonMax: \" + lonMax);\n    }\n\n    int latMinEnc = BKDTreeWriter.encodeLat(latMin);\n    int latMaxEnc = BKDTreeWriter.encodeLat(latMax);\n    int lonMinEnc = BKDTreeWriter.encodeLon(lonMin);\n    int lonMaxEnc = BKDTreeWriter.encodeLon(lonMax);\n\n    // TODO: we should use a sparse bit collector here, but BitDocIdSet.Builder is 2.4X slower than straight FixedBitSet.\n    // Maybe we should use simple int[] (not de-duping) up until size X, then cutover.  Or maybe SentinelIntSet when it's\n    // small.\n\n    QueryState state = new QueryState(in.clone(), maxDoc,\n                                      latMinEnc, latMaxEnc,\n                                      lonMinEnc, lonMaxEnc,\n                                      filter,\n                                      sndv);\n\n    int hitCount = intersect(state, 1,\n                             BKDTreeWriter.encodeLat(-90.0),\n                             BKDTreeWriter.encodeLat(Math.nextAfter(90.0, Double.POSITIVE_INFINITY)),\n                             BKDTreeWriter.encodeLon(-180.0),\n                             BKDTreeWriter.encodeLon(Math.nextAfter(180.0, Double.POSITIVE_INFINITY)));\n\n    // NOTE: hitCount is an over-estimate in the multi-valued case:\n    return state.docs.build(hitCount);\n  }\n\n","sourceOld":"  public DocIdSet intersect(double latMin, double latMax, double lonMin, double lonMax, LatLonFilter filter, SortedNumericDocValues sndv) throws IOException {\n    if (BKDTreeWriter.validLat(latMin) == false) {\n      throw new IllegalArgumentException(\"invalid latMin: \" + latMin);\n    }\n    if (BKDTreeWriter.validLat(latMax) == false) {\n      throw new IllegalArgumentException(\"invalid latMax: \" + latMax);\n    }\n    if (BKDTreeWriter.validLon(lonMin) == false) {\n      throw new IllegalArgumentException(\"invalid lonMin: \" + lonMin);\n    }\n    if (BKDTreeWriter.validLon(lonMax) == false) {\n      throw new IllegalArgumentException(\"invalid lonMax: \" + lonMax);\n    }\n\n    int latMinEnc = BKDTreeWriter.encodeLat(latMin);\n    int latMaxEnc = BKDTreeWriter.encodeLat(latMax);\n    int lonMinEnc = BKDTreeWriter.encodeLon(lonMin);\n    int lonMaxEnc = BKDTreeWriter.encodeLon(lonMax);\n\n    // TODO: we should use a sparse bit collector here, but BitDocIdSet.Builder is 2.4X slower than straight FixedBitSet.\n    // Maybe we should use simple int[] (not de-duping) up until size X, then cutover.  Or maybe SentinelIntSet when it's\n    // small.\n\n    QueryState state = new QueryState(in.clone(), maxDoc,\n                                      latMinEnc, latMaxEnc,\n                                      lonMinEnc, lonMaxEnc,\n                                      filter,\n                                      sndv);\n\n    int hitCount = intersect(state, 1,\n                             BKDTreeWriter.encodeLat(-90.0),\n                             BKDTreeWriter.encodeLat(Math.nextAfter(90.0, Double.POSITIVE_INFINITY)),\n                             BKDTreeWriter.encodeLon(-180.0),\n                             BKDTreeWriter.encodeLon(Math.nextAfter(180.0, Double.POSITIVE_INFINITY)));\n\n    // NOTE: hitCount is an over-estimate in the multi-valued case:\n    return new BitDocIdSet(state.bits, hitCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f64b7098768253180859cd8faeae6b1a185b06ed","date":1441223971,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(double,double,double,double,LatLonFilter,SortedNumericDocValues).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(double,double,double,double,LatLonFilter,SortedNumericDocValues).mjava","sourceNew":"  // TODO: move DVs/encoding out on top: this method should take ints, and encode should be done up above\n  public DocIdSet intersect(double latMin, double latMax, double lonMin, double lonMax, LatLonFilter filter, SortedNumericDocValues sndv) throws IOException {\n    if (BKDTreeWriter.validLat(latMin) == false) {\n      throw new IllegalArgumentException(\"invalid latMin: \" + latMin);\n    }\n    if (BKDTreeWriter.validLat(latMax) == false) {\n      throw new IllegalArgumentException(\"invalid latMax: \" + latMax);\n    }\n    if (BKDTreeWriter.validLon(lonMin) == false) {\n      throw new IllegalArgumentException(\"invalid lonMin: \" + lonMin);\n    }\n    if (BKDTreeWriter.validLon(lonMax) == false) {\n      throw new IllegalArgumentException(\"invalid lonMax: \" + lonMax);\n    }\n\n    int latMinEnc = BKDTreeWriter.encodeLat(latMin);\n    int latMaxEnc = BKDTreeWriter.encodeLat(latMax);\n    int lonMinEnc = BKDTreeWriter.encodeLon(lonMin);\n    int lonMaxEnc = BKDTreeWriter.encodeLon(lonMax);\n\n    QueryState state = new QueryState(in.clone(), maxDoc,\n                                      latMinEnc, latMaxEnc,\n                                      lonMinEnc, lonMaxEnc,\n                                      filter,\n                                      sndv);\n\n    int hitCount = intersect(state, 1,\n                             BKDTreeWriter.encodeLat(-90.0),\n                             BKDTreeWriter.encodeLat(Math.nextAfter(90.0, Double.POSITIVE_INFINITY)),\n                             BKDTreeWriter.encodeLon(-180.0),\n                             BKDTreeWriter.encodeLon(Math.nextAfter(180.0, Double.POSITIVE_INFINITY)));\n\n    // NOTE: hitCount is an over-estimate in the multi-valued case:\n    return state.docs.build(hitCount);\n  }\n\n","sourceOld":"  public DocIdSet intersect(double latMin, double latMax, double lonMin, double lonMax, LatLonFilter filter, SortedNumericDocValues sndv) throws IOException {\n    if (BKDTreeWriter.validLat(latMin) == false) {\n      throw new IllegalArgumentException(\"invalid latMin: \" + latMin);\n    }\n    if (BKDTreeWriter.validLat(latMax) == false) {\n      throw new IllegalArgumentException(\"invalid latMax: \" + latMax);\n    }\n    if (BKDTreeWriter.validLon(lonMin) == false) {\n      throw new IllegalArgumentException(\"invalid lonMin: \" + lonMin);\n    }\n    if (BKDTreeWriter.validLon(lonMax) == false) {\n      throw new IllegalArgumentException(\"invalid lonMax: \" + lonMax);\n    }\n\n    int latMinEnc = BKDTreeWriter.encodeLat(latMin);\n    int latMaxEnc = BKDTreeWriter.encodeLat(latMax);\n    int lonMinEnc = BKDTreeWriter.encodeLon(lonMin);\n    int lonMaxEnc = BKDTreeWriter.encodeLon(lonMax);\n\n    // TODO: we should use a sparse bit collector here, but BitDocIdSet.Builder is 2.4X slower than straight FixedBitSet.\n    // Maybe we should use simple int[] (not de-duping) up until size X, then cutover.  Or maybe SentinelIntSet when it's\n    // small.\n\n    QueryState state = new QueryState(in.clone(), maxDoc,\n                                      latMinEnc, latMaxEnc,\n                                      lonMinEnc, lonMaxEnc,\n                                      filter,\n                                      sndv);\n\n    int hitCount = intersect(state, 1,\n                             BKDTreeWriter.encodeLat(-90.0),\n                             BKDTreeWriter.encodeLat(Math.nextAfter(90.0, Double.POSITIVE_INFINITY)),\n                             BKDTreeWriter.encodeLon(-180.0),\n                             BKDTreeWriter.encodeLon(Math.nextAfter(180.0, Double.POSITIVE_INFINITY)));\n\n    // NOTE: hitCount is an over-estimate in the multi-valued case:\n    return state.docs.build(hitCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(double,double,double,double,LatLonFilter,SortedNumericDocValues).mjava","sourceNew":null,"sourceOld":"  // TODO: move DVs/encoding out on top: this method should take ints, and encode should be done up above\n  public DocIdSet intersect(double latMin, double latMax, double lonMin, double lonMax, LatLonFilter filter, SortedNumericDocValues sndv) throws IOException {\n    if (BKDTreeWriter.validLat(latMin) == false) {\n      throw new IllegalArgumentException(\"invalid latMin: \" + latMin);\n    }\n    if (BKDTreeWriter.validLat(latMax) == false) {\n      throw new IllegalArgumentException(\"invalid latMax: \" + latMax);\n    }\n    if (BKDTreeWriter.validLon(lonMin) == false) {\n      throw new IllegalArgumentException(\"invalid lonMin: \" + lonMin);\n    }\n    if (BKDTreeWriter.validLon(lonMax) == false) {\n      throw new IllegalArgumentException(\"invalid lonMax: \" + lonMax);\n    }\n\n    int latMinEnc = BKDTreeWriter.encodeLat(latMin);\n    int latMaxEnc = BKDTreeWriter.encodeLat(latMax);\n    int lonMinEnc = BKDTreeWriter.encodeLon(lonMin);\n    int lonMaxEnc = BKDTreeWriter.encodeLon(lonMax);\n\n    QueryState state = new QueryState(in.clone(), maxDoc,\n                                      latMinEnc, latMaxEnc,\n                                      lonMinEnc, lonMaxEnc,\n                                      filter,\n                                      sndv);\n\n    int hitCount = intersect(state, 1,\n                             BKDTreeWriter.encodeLat(-90.0),\n                             BKDTreeWriter.encodeLat(Math.nextAfter(90.0, Double.POSITIVE_INFINITY)),\n                             BKDTreeWriter.encodeLon(-180.0),\n                             BKDTreeWriter.encodeLon(Math.nextAfter(180.0, Double.POSITIVE_INFINITY)));\n\n    // NOTE: hitCount is an over-estimate in the multi-valued case:\n    return state.docs.build(hitCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0f4464508ee83288c8c4585b533f9faaa93aa314":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f64b7098768253180859cd8faeae6b1a185b06ed":["0e91a2d9ed80172872da0f517870da6756289554"],"0e91a2d9ed80172872da0f517870da6756289554":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1904709ea0185dc04e3d77ea01c79e909caf2796":["f64b7098768253180859cd8faeae6b1a185b06ed"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1904709ea0185dc04e3d77ea01c79e909caf2796"]},"commit2Childs":{"0f4464508ee83288c8c4585b533f9faaa93aa314":["0e91a2d9ed80172872da0f517870da6756289554"],"f64b7098768253180859cd8faeae6b1a185b06ed":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"0e91a2d9ed80172872da0f517870da6756289554":["f64b7098768253180859cd8faeae6b1a185b06ed"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}