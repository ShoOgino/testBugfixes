{"path":"lucene/core/src/java/org/apache/lucene/util/graph/GraphTokenStreamFiniteStrings#build(TokenStream).mjava","commits":[{"id":"e52c30617998e1bc2a946cc226f52e9b35162b1e","date":1483438353,"type":0,"author":"Matt Weber","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/graph/GraphTokenStreamFiniteStrings#build(TokenStream).mjava","pathOld":"/dev/null","sourceNew":"  private void build(final TokenStream in) throws IOException {\n    if (det != null) {\n      throw new IllegalStateException(\"Automation already built\");\n    }\n\n    final TermToBytesRefAttribute termBytesAtt = in.addAttribute(TermToBytesRefAttribute.class);\n    final PositionIncrementAttribute posIncAtt = in.addAttribute(PositionIncrementAttribute.class);\n    final PositionLengthAttribute posLengthAtt = in.addAttribute(PositionLengthAttribute.class);\n\n    in.reset();\n\n    int pos = -1;\n    int prevIncr = 1;\n    int state = -1;\n    while (in.incrementToken()) {\n      int currentIncr = posIncAtt.getPositionIncrement();\n      if (pos == -1 && currentIncr < 1) {\n        throw new IllegalStateException(\"Malformed TokenStream, start token can't have increment less than 1\");\n      }\n\n      // always use inc 1 while building, but save original increment\n      int incr = Math.min(1, currentIncr);\n      if (incr > 0) {\n        pos += incr;\n      }\n\n      int endPos = pos + posLengthAtt.getPositionLength();\n      while (state < endPos) {\n        state = createState();\n      }\n\n      BytesRef term = termBytesAtt.getBytesRef();\n      int id = getTermID(currentIncr, prevIncr, term);\n      addTransition(pos, endPos, currentIncr, id);\n\n      // only save last increment on non-zero increment in case we have multiple stacked tokens\n      if (currentIncr > 0) {\n        prevIncr = currentIncr;\n      }\n    }\n\n    in.end();\n    setAccept(state, true);\n    finish();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5d4c0aa821ee9328c0d7a6ba3c682de39e1d7e4a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/graph/GraphTokenStreamFiniteStrings#build(TokenStream).mjava","pathOld":"/dev/null","sourceNew":"  private void build(final TokenStream in) throws IOException {\n    if (det != null) {\n      throw new IllegalStateException(\"Automation already built\");\n    }\n\n    final TermToBytesRefAttribute termBytesAtt = in.addAttribute(TermToBytesRefAttribute.class);\n    final PositionIncrementAttribute posIncAtt = in.addAttribute(PositionIncrementAttribute.class);\n    final PositionLengthAttribute posLengthAtt = in.addAttribute(PositionLengthAttribute.class);\n\n    in.reset();\n\n    int pos = -1;\n    int prevIncr = 1;\n    int state = -1;\n    while (in.incrementToken()) {\n      int currentIncr = posIncAtt.getPositionIncrement();\n      if (pos == -1 && currentIncr < 1) {\n        throw new IllegalStateException(\"Malformed TokenStream, start token can't have increment less than 1\");\n      }\n\n      // always use inc 1 while building, but save original increment\n      int incr = Math.min(1, currentIncr);\n      if (incr > 0) {\n        pos += incr;\n      }\n\n      int endPos = pos + posLengthAtt.getPositionLength();\n      while (state < endPos) {\n        state = createState();\n      }\n\n      BytesRef term = termBytesAtt.getBytesRef();\n      int id = getTermID(currentIncr, prevIncr, term);\n      addTransition(pos, endPos, currentIncr, id);\n\n      // only save last increment on non-zero increment in case we have multiple stacked tokens\n      if (currentIncr > 0) {\n        prevIncr = currentIncr;\n      }\n    }\n\n    in.end();\n    setAccept(state, true);\n    finish();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e0d75d7d3cda2b33e79d0eb0e716169cebec4db","date":1486463279,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/graph/GraphTokenStreamFiniteStrings#build(TokenStream).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/graph/GraphTokenStreamFiniteStrings#build(TokenStream).mjava","sourceNew":"  /**\n   * Build an automaton from the provided {@link TokenStream}.\n   */\n  private Automaton build(final TokenStream in) throws IOException {\n    Automaton.Builder builder = new Automaton.Builder();\n    final TermToBytesRefAttribute termBytesAtt = in.addAttribute(TermToBytesRefAttribute.class);\n    final PositionIncrementAttribute posIncAtt = in.addAttribute(PositionIncrementAttribute.class);\n    final PositionLengthAttribute posLengthAtt = in.addAttribute(PositionLengthAttribute.class);\n\n    in.reset();\n\n    int pos = -1;\n    int prevIncr = 1;\n    int state = -1;\n    while (in.incrementToken()) {\n      int currentIncr = posIncAtt.getPositionIncrement();\n      if (pos == -1 && currentIncr < 1) {\n        throw new IllegalStateException(\"Malformed TokenStream, start token can't have increment less than 1\");\n      }\n\n      // always use inc 1 while building, but save original increment\n      int incr = Math.min(1, currentIncr);\n      if (incr > 0) {\n        pos += incr;\n      }\n\n      int endPos = pos + posLengthAtt.getPositionLength();\n      while (state < endPos) {\n        state = builder.createState();\n      }\n\n      BytesRef term = termBytesAtt.getBytesRef();\n      int id = getTermID(currentIncr, prevIncr, term);\n      builder.addTransition(pos, endPos, id);\n\n      // only save last increment on non-zero increment in case we have multiple stacked tokens\n      if (currentIncr > 0) {\n        prevIncr = currentIncr;\n      }\n    }\n\n    in.end();\n    if (state != -1) {\n      builder.setAccept(state, true);\n    }\n    return builder.finish();\n  }\n\n","sourceOld":"  private void build(final TokenStream in) throws IOException {\n    if (det != null) {\n      throw new IllegalStateException(\"Automation already built\");\n    }\n\n    final TermToBytesRefAttribute termBytesAtt = in.addAttribute(TermToBytesRefAttribute.class);\n    final PositionIncrementAttribute posIncAtt = in.addAttribute(PositionIncrementAttribute.class);\n    final PositionLengthAttribute posLengthAtt = in.addAttribute(PositionLengthAttribute.class);\n\n    in.reset();\n\n    int pos = -1;\n    int prevIncr = 1;\n    int state = -1;\n    while (in.incrementToken()) {\n      int currentIncr = posIncAtt.getPositionIncrement();\n      if (pos == -1 && currentIncr < 1) {\n        throw new IllegalStateException(\"Malformed TokenStream, start token can't have increment less than 1\");\n      }\n\n      // always use inc 1 while building, but save original increment\n      int incr = Math.min(1, currentIncr);\n      if (incr > 0) {\n        pos += incr;\n      }\n\n      int endPos = pos + posLengthAtt.getPositionLength();\n      while (state < endPos) {\n        state = createState();\n      }\n\n      BytesRef term = termBytesAtt.getBytesRef();\n      int id = getTermID(currentIncr, prevIncr, term);\n      addTransition(pos, endPos, currentIncr, id);\n\n      // only save last increment on non-zero increment in case we have multiple stacked tokens\n      if (currentIncr > 0) {\n        prevIncr = currentIncr;\n      }\n    }\n\n    in.end();\n    setAccept(state, true);\n    finish();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5d4c0aa821ee9328c0d7a6ba3c682de39e1d7e4a","date":1550584577,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/graph/GraphTokenStreamFiniteStrings#build(TokenStream).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/graph/GraphTokenStreamFiniteStrings#build(TokenStream).mjava","sourceNew":"  /**\n   * Build an automaton from the provided {@link TokenStream}.\n   */\n  private Automaton build(final TokenStream in) throws IOException {\n    Automaton.Builder builder = new Automaton.Builder();\n    final TermToBytesRefAttribute termBytesAtt = in.addAttribute(TermToBytesRefAttribute.class);\n    final PositionIncrementAttribute posIncAtt = in.addAttribute(PositionIncrementAttribute.class);\n    final PositionLengthAttribute posLengthAtt = in.addAttribute(PositionLengthAttribute.class);\n\n    in.reset();\n\n    int pos = -1;\n    int prevIncr = 1;\n    int state = -1;\n    int gap = 0;\n    while (in.incrementToken()) {\n      int currentIncr = posIncAtt.getPositionIncrement();\n      if (pos == -1 && currentIncr < 1) {\n        throw new IllegalStateException(\"Malformed TokenStream, start token can't have increment less than 1\");\n      }\n\n      if (currentIncr == 0) {\n        if (gap > 0) {\n          pos -= gap;\n        }\n      }\n      else {\n        pos++;\n        gap = currentIncr - 1;\n      }\n\n      int endPos = pos + posLengthAtt.getPositionLength() + gap;\n      while (state < endPos) {\n        state = builder.createState();\n      }\n\n      BytesRef term = termBytesAtt.getBytesRef();\n      int id = getTermID(currentIncr, prevIncr, term);\n      //System.out.println(\"Adding transition: \" + term.utf8ToString() + \"@\" + pos + \"->\" + endPos);\n      builder.addTransition(pos, endPos, id);\n      pos += gap;\n\n      // only save last increment on non-zero increment in case we have multiple stacked tokens\n      if (currentIncr > 0) {\n        prevIncr = currentIncr;\n      }\n    }\n\n    in.end();\n    if (state != -1) {\n      builder.setAccept(state, true);\n    }\n    return builder.finish();\n  }\n\n","sourceOld":"  /**\n   * Build an automaton from the provided {@link TokenStream}.\n   */\n  private Automaton build(final TokenStream in) throws IOException {\n    Automaton.Builder builder = new Automaton.Builder();\n    final TermToBytesRefAttribute termBytesAtt = in.addAttribute(TermToBytesRefAttribute.class);\n    final PositionIncrementAttribute posIncAtt = in.addAttribute(PositionIncrementAttribute.class);\n    final PositionLengthAttribute posLengthAtt = in.addAttribute(PositionLengthAttribute.class);\n\n    in.reset();\n\n    int pos = -1;\n    int prevIncr = 1;\n    int state = -1;\n    while (in.incrementToken()) {\n      int currentIncr = posIncAtt.getPositionIncrement();\n      if (pos == -1 && currentIncr < 1) {\n        throw new IllegalStateException(\"Malformed TokenStream, start token can't have increment less than 1\");\n      }\n\n      // always use inc 1 while building, but save original increment\n      int incr = Math.min(1, currentIncr);\n      if (incr > 0) {\n        pos += incr;\n      }\n\n      int endPos = pos + posLengthAtt.getPositionLength();\n      while (state < endPos) {\n        state = builder.createState();\n      }\n\n      BytesRef term = termBytesAtt.getBytesRef();\n      int id = getTermID(currentIncr, prevIncr, term);\n      builder.addTransition(pos, endPos, id);\n\n      // only save last increment on non-zero increment in case we have multiple stacked tokens\n      if (currentIncr > 0) {\n        prevIncr = currentIncr;\n      }\n    }\n\n    in.end();\n    if (state != -1) {\n      builder.setAccept(state, true);\n    }\n    return builder.finish();\n  }\n\n","bugFix":["e52c30617998e1bc2a946cc226f52e9b35162b1e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a1183e4d02ec8307ffca25b9879752bea1822f1","date":1563533185,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/graph/GraphTokenStreamFiniteStrings#build(TokenStream).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/graph/GraphTokenStreamFiniteStrings#build(TokenStream).mjava","sourceNew":"  /**\n   * Build an automaton from the provided {@link TokenStream}.\n   */\n  private Automaton build(final TokenStream in) throws IOException {\n    Automaton.Builder builder = new Automaton.Builder();\n\n    final PositionIncrementAttribute posIncAtt = in.addAttribute(PositionIncrementAttribute.class);\n    final PositionLengthAttribute posLengthAtt = in.addAttribute(PositionLengthAttribute.class);\n\n    in.reset();\n\n    int pos = -1;\n    int prevIncr = 1;\n    int state = -1;\n    int id = -1;\n    int gap = 0;\n    while (in.incrementToken()) {\n      int currentIncr = posIncAtt.getPositionIncrement();\n      if (pos == -1 && currentIncr < 1) {\n        throw new IllegalStateException(\"Malformed TokenStream, start token can't have increment less than 1\");\n      }\n\n      if (currentIncr == 0) {\n        if (gap > 0) {\n          pos -= gap;\n        }\n      }\n      else {\n        pos++;\n        gap = currentIncr - 1;\n      }\n\n      int endPos = pos + posLengthAtt.getPositionLength() + gap;\n      while (state < endPos) {\n        state = builder.createState();\n      }\n\n      id++;\n      if (tokens.length < id + 1) {\n        tokens = ArrayUtil.grow(tokens, id + 1);\n      }\n\n      tokens[id] = in.cloneAttributes();\n      builder.addTransition(pos, endPos, id);\n      pos += gap;\n\n      // we always produce linear token graphs from getFiniteStrings(), so we need to adjust\n      // posLength and posIncrement accordingly\n      tokens[id].addAttribute(PositionLengthAttribute.class).setPositionLength(1);\n      if (currentIncr == 0) {\n        // stacked token should have the same increment as original token at this position\n        tokens[id].addAttribute(PositionIncrementAttribute.class).setPositionIncrement(prevIncr);\n      }\n\n      // only save last increment on non-zero increment in case we have multiple stacked tokens\n      if (currentIncr > 0) {\n        prevIncr = currentIncr;\n      }\n    }\n\n    in.end();\n    if (state != -1) {\n      builder.setAccept(state, true);\n    }\n    return builder.finish();\n  }\n\n","sourceOld":"  /**\n   * Build an automaton from the provided {@link TokenStream}.\n   */\n  private Automaton build(final TokenStream in) throws IOException {\n    Automaton.Builder builder = new Automaton.Builder();\n    final TermToBytesRefAttribute termBytesAtt = in.addAttribute(TermToBytesRefAttribute.class);\n    final PositionIncrementAttribute posIncAtt = in.addAttribute(PositionIncrementAttribute.class);\n    final PositionLengthAttribute posLengthAtt = in.addAttribute(PositionLengthAttribute.class);\n\n    in.reset();\n\n    int pos = -1;\n    int prevIncr = 1;\n    int state = -1;\n    int gap = 0;\n    while (in.incrementToken()) {\n      int currentIncr = posIncAtt.getPositionIncrement();\n      if (pos == -1 && currentIncr < 1) {\n        throw new IllegalStateException(\"Malformed TokenStream, start token can't have increment less than 1\");\n      }\n\n      if (currentIncr == 0) {\n        if (gap > 0) {\n          pos -= gap;\n        }\n      }\n      else {\n        pos++;\n        gap = currentIncr - 1;\n      }\n\n      int endPos = pos + posLengthAtt.getPositionLength() + gap;\n      while (state < endPos) {\n        state = builder.createState();\n      }\n\n      BytesRef term = termBytesAtt.getBytesRef();\n      int id = getTermID(currentIncr, prevIncr, term);\n      //System.out.println(\"Adding transition: \" + term.utf8ToString() + \"@\" + pos + \"->\" + endPos);\n      builder.addTransition(pos, endPos, id);\n      pos += gap;\n\n      // only save last increment on non-zero increment in case we have multiple stacked tokens\n      if (currentIncr > 0) {\n        prevIncr = currentIncr;\n      }\n    }\n\n    in.end();\n    if (state != -1) {\n      builder.setAccept(state, true);\n    }\n    return builder.finish();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5d4c0aa821ee9328c0d7a6ba3c682de39e1d7e4a":["7e0d75d7d3cda2b33e79d0eb0e716169cebec4db"],"e52c30617998e1bc2a946cc226f52e9b35162b1e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2a1183e4d02ec8307ffca25b9879752bea1822f1":["5d4c0aa821ee9328c0d7a6ba3c682de39e1d7e4a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2a1183e4d02ec8307ffca25b9879752bea1822f1"],"7e0d75d7d3cda2b33e79d0eb0e716169cebec4db":["e52c30617998e1bc2a946cc226f52e9b35162b1e"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e52c30617998e1bc2a946cc226f52e9b35162b1e"]},"commit2Childs":{"5d4c0aa821ee9328c0d7a6ba3c682de39e1d7e4a":["2a1183e4d02ec8307ffca25b9879752bea1822f1"],"e52c30617998e1bc2a946cc226f52e9b35162b1e":["7e0d75d7d3cda2b33e79d0eb0e716169cebec4db","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e52c30617998e1bc2a946cc226f52e9b35162b1e","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"2a1183e4d02ec8307ffca25b9879752bea1822f1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7e0d75d7d3cda2b33e79d0eb0e716169cebec4db":["5d4c0aa821ee9328c0d7a6ba3c682de39e1d7e4a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}