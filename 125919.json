{"path":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetIntervalCounts().mjava","commits":[{"id":"84b24f47dd3dfa4e2396cd6f819a35445b0a53fd","date":1406137403,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetIntervalCounts().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns a <code>NamedList</code> with each entry having the \"key\" of the interval as name and the count of docs \n   * in that interval as value. All intervals added in the request are included in the returned \n   * <code>NamedList</code> (included those with 0 count), and it's required that the order of the intervals\n   * is deterministic and equals in all shards of a distributed request, otherwise the collation of results\n   * will fail. \n   * \n   */\n  public NamedList<Object> getFacetIntervalCounts() throws IOException, SyntaxError {\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] fields = params.getParams(FacetParams.FACET_INTERVAL);\n    if (fields == null || fields.length == 0) return res;\n\n    for (String field : fields) {\n      parseParams(FacetParams.FACET_INTERVAL, field);\n      String[] intervalStrs = required.getFieldParams(field, FacetParams.FACET_INTERVAL_SET);\n      SchemaField schemaField = searcher.getCore().getLatestSchema().getField(field);\n      if (!schemaField.hasDocValues()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Interval Faceting only on fields with doc values\");\n      }\n      if (params.getBool(GroupParams.GROUP_FACET, false)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Interval Faceting can't be used with \" + GroupParams.GROUP_FACET);\n      }\n      \n      SimpleOrderedMap<Integer> fieldResults = new SimpleOrderedMap<Integer>();\n      res.add(field, fieldResults);\n      IntervalFacets intervalFacets = new IntervalFacets(schemaField, searcher, docs, intervalStrs);\n      for (FacetInterval interval : intervalFacets) {\n        fieldResults.add(interval.getKey(), interval.getCount());\n      }\n    }\n\n    return res;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c20fa646779d398a61a14cc6f9e00447475c0325","aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0e3055974cda209e4f95efadcd904f0ebf03ada","date":1406238198,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetIntervalCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetIntervalCounts().mjava","sourceNew":"  /**\n   * Returns a <code>NamedList</code> with each entry having the \"key\" of the interval as name and the count of docs \n   * in that interval as value. All intervals added in the request are included in the returned \n   * <code>NamedList</code> (included those with 0 count), and it's required that the order of the intervals\n   * is deterministic and equals in all shards of a distributed request, otherwise the collation of results\n   * will fail. \n   * \n   */\n  public NamedList<Object> getFacetIntervalCounts() throws IOException, SyntaxError {\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] fields = params.getParams(FacetParams.FACET_INTERVAL);\n    if (fields == null || fields.length == 0) return res;\n\n    for (String field : fields) {\n      parseParams(FacetParams.FACET_INTERVAL, field);\n      String[] intervalStrs = required.getFieldParams(field, FacetParams.FACET_INTERVAL_SET);\n      SchemaField schemaField = searcher.getCore().getLatestSchema().getField(field);\n      if (!schemaField.hasDocValues()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Interval Faceting only on fields with doc values\");\n      }\n      if (params.getBool(GroupParams.GROUP_FACET, false)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Interval Faceting can't be used with \" + GroupParams.GROUP_FACET);\n      }\n      \n      SimpleOrderedMap<Integer> fieldResults = new SimpleOrderedMap<Integer>();\n      res.add(field, fieldResults);\n      IntervalFacets intervalFacets = new IntervalFacets(schemaField, searcher, docs, intervalStrs, params);\n      for (FacetInterval interval : intervalFacets) {\n        fieldResults.add(interval.getKey(), interval.getCount());\n      }\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a <code>NamedList</code> with each entry having the \"key\" of the interval as name and the count of docs \n   * in that interval as value. All intervals added in the request are included in the returned \n   * <code>NamedList</code> (included those with 0 count), and it's required that the order of the intervals\n   * is deterministic and equals in all shards of a distributed request, otherwise the collation of results\n   * will fail. \n   * \n   */\n  public NamedList<Object> getFacetIntervalCounts() throws IOException, SyntaxError {\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] fields = params.getParams(FacetParams.FACET_INTERVAL);\n    if (fields == null || fields.length == 0) return res;\n\n    for (String field : fields) {\n      parseParams(FacetParams.FACET_INTERVAL, field);\n      String[] intervalStrs = required.getFieldParams(field, FacetParams.FACET_INTERVAL_SET);\n      SchemaField schemaField = searcher.getCore().getLatestSchema().getField(field);\n      if (!schemaField.hasDocValues()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Interval Faceting only on fields with doc values\");\n      }\n      if (params.getBool(GroupParams.GROUP_FACET, false)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Interval Faceting can't be used with \" + GroupParams.GROUP_FACET);\n      }\n      \n      SimpleOrderedMap<Integer> fieldResults = new SimpleOrderedMap<Integer>();\n      res.add(field, fieldResults);\n      IntervalFacets intervalFacets = new IntervalFacets(schemaField, searcher, docs, intervalStrs);\n      for (FacetInterval interval : intervalFacets) {\n        fieldResults.add(interval.getKey(), interval.getCount());\n      }\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c20fa646779d398a61a14cc6f9e00447475c0325","date":1423618933,"type":3,"author":"Tomas Eduardo Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetIntervalCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetIntervalCounts().mjava","sourceNew":"  /**\n   * Returns a <code>NamedList</code> with each entry having the \"key\" of the interval as name and the count of docs \n   * in that interval as value. All intervals added in the request are included in the returned \n   * <code>NamedList</code> (included those with 0 count), and it's required that the order of the intervals\n   * is deterministic and equals in all shards of a distributed request, otherwise the collation of results\n   * will fail. \n   * \n   */\n  public NamedList<Object> getFacetIntervalCounts() throws IOException, SyntaxError {\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] fields = params.getParams(FacetParams.FACET_INTERVAL);\n    if (fields == null || fields.length == 0) return res;\n\n    for (String field : fields) {\n      parseParams(FacetParams.FACET_INTERVAL, field);\n      String[] intervalStrs = required.getFieldParams(facetValue, FacetParams.FACET_INTERVAL_SET);\n      SchemaField schemaField = searcher.getCore().getLatestSchema().getField(facetValue);\n      if (!schemaField.hasDocValues()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Interval Faceting only on fields with doc values\");\n      }\n      if (params.getBool(GroupParams.GROUP_FACET, false)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Interval Faceting can't be used with \" + GroupParams.GROUP_FACET);\n      }\n      \n      SimpleOrderedMap<Integer> fieldResults = new SimpleOrderedMap<Integer>();\n      res.add(key, fieldResults);\n      IntervalFacets intervalFacets = new IntervalFacets(schemaField, searcher, docs, intervalStrs, params);\n      for (FacetInterval interval : intervalFacets) {\n        fieldResults.add(interval.getKey(), interval.getCount());\n      }\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a <code>NamedList</code> with each entry having the \"key\" of the interval as name and the count of docs \n   * in that interval as value. All intervals added in the request are included in the returned \n   * <code>NamedList</code> (included those with 0 count), and it's required that the order of the intervals\n   * is deterministic and equals in all shards of a distributed request, otherwise the collation of results\n   * will fail. \n   * \n   */\n  public NamedList<Object> getFacetIntervalCounts() throws IOException, SyntaxError {\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] fields = params.getParams(FacetParams.FACET_INTERVAL);\n    if (fields == null || fields.length == 0) return res;\n\n    for (String field : fields) {\n      parseParams(FacetParams.FACET_INTERVAL, field);\n      String[] intervalStrs = required.getFieldParams(field, FacetParams.FACET_INTERVAL_SET);\n      SchemaField schemaField = searcher.getCore().getLatestSchema().getField(field);\n      if (!schemaField.hasDocValues()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Interval Faceting only on fields with doc values\");\n      }\n      if (params.getBool(GroupParams.GROUP_FACET, false)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Interval Faceting can't be used with \" + GroupParams.GROUP_FACET);\n      }\n      \n      SimpleOrderedMap<Integer> fieldResults = new SimpleOrderedMap<Integer>();\n      res.add(field, fieldResults);\n      IntervalFacets intervalFacets = new IntervalFacets(schemaField, searcher, docs, intervalStrs, params);\n      for (FacetInterval interval : intervalFacets) {\n        fieldResults.add(interval.getKey(), interval.getCount());\n      }\n    }\n\n    return res;\n  }\n\n","bugFix":["84b24f47dd3dfa4e2396cd6f819a35445b0a53fd"],"bugIntro":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6d7fd8888854b7c6f30f35246057c92ddf5a750","date":1429938426,"type":3,"author":"Tomas Eduardo Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetIntervalCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetIntervalCounts().mjava","sourceNew":"  /**\n   * Returns a <code>NamedList</code> with each entry having the \"key\" of the interval as name and the count of docs \n   * in that interval as value. All intervals added in the request are included in the returned \n   * <code>NamedList</code> (included those with 0 count), and it's required that the order of the intervals\n   * is deterministic and equals in all shards of a distributed request, otherwise the collation of results\n   * will fail. \n   * \n   */\n  public NamedList<Object> getFacetIntervalCounts() throws IOException, SyntaxError {\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] fields = params.getParams(FacetParams.FACET_INTERVAL);\n    if (fields == null || fields.length == 0) return res;\n\n    for (String field : fields) {\n      parseParams(FacetParams.FACET_INTERVAL, field);\n      String[] intervalStrs = required.getFieldParams(facetValue, FacetParams.FACET_INTERVAL_SET);\n      SchemaField schemaField = searcher.getCore().getLatestSchema().getField(facetValue);\n      if (params.getBool(GroupParams.GROUP_FACET, false)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Interval Faceting can't be used with \" + GroupParams.GROUP_FACET);\n      }\n      \n      SimpleOrderedMap<Integer> fieldResults = new SimpleOrderedMap<Integer>();\n      res.add(key, fieldResults);\n      IntervalFacets intervalFacets = new IntervalFacets(schemaField, searcher, docs, intervalStrs, params);\n      for (FacetInterval interval : intervalFacets) {\n        fieldResults.add(interval.getKey(), interval.getCount());\n      }\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a <code>NamedList</code> with each entry having the \"key\" of the interval as name and the count of docs \n   * in that interval as value. All intervals added in the request are included in the returned \n   * <code>NamedList</code> (included those with 0 count), and it's required that the order of the intervals\n   * is deterministic and equals in all shards of a distributed request, otherwise the collation of results\n   * will fail. \n   * \n   */\n  public NamedList<Object> getFacetIntervalCounts() throws IOException, SyntaxError {\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] fields = params.getParams(FacetParams.FACET_INTERVAL);\n    if (fields == null || fields.length == 0) return res;\n\n    for (String field : fields) {\n      parseParams(FacetParams.FACET_INTERVAL, field);\n      String[] intervalStrs = required.getFieldParams(facetValue, FacetParams.FACET_INTERVAL_SET);\n      SchemaField schemaField = searcher.getCore().getLatestSchema().getField(facetValue);\n      if (!schemaField.hasDocValues()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Interval Faceting only on fields with doc values\");\n      }\n      if (params.getBool(GroupParams.GROUP_FACET, false)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Interval Faceting can't be used with \" + GroupParams.GROUP_FACET);\n      }\n      \n      SimpleOrderedMap<Integer> fieldResults = new SimpleOrderedMap<Integer>();\n      res.add(key, fieldResults);\n      IntervalFacets intervalFacets = new IntervalFacets(schemaField, searcher, docs, intervalStrs, params);\n      for (FacetInterval interval : intervalFacets) {\n        fieldResults.add(interval.getKey(), interval.getCount());\n      }\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aa62c79a7afa4d7f22e1f71b883659f3213d7db1","date":1435334422,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetIntervalCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetIntervalCounts().mjava","sourceNew":"  /**\n   * Returns a <code>NamedList</code> with each entry having the \"key\" of the interval as name and the count of docs \n   * in that interval as value. All intervals added in the request are included in the returned \n   * <code>NamedList</code> (included those with 0 count), and it's required that the order of the intervals\n   * is deterministic and equals in all shards of a distributed request, otherwise the collation of results\n   * will fail. \n   * \n   */\n  public NamedList<Object> getFacetIntervalCounts() throws IOException, SyntaxError {\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] fields = global.getParams(FacetParams.FACET_INTERVAL);\n    if (fields == null || fields.length == 0) return res;\n\n    for (String field : fields) {\n      final ParsedParams parsed = parseParams(FacetParams.FACET_INTERVAL, field);\n      String[] intervalStrs = parsed.required.getFieldParams(parsed.facetValue, FacetParams.FACET_INTERVAL_SET);\n      SchemaField schemaField = searcher.getCore().getLatestSchema().getField(parsed.facetValue);\n      if (parsed.params.getBool(GroupParams.GROUP_FACET, false)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Interval Faceting can't be used with \" + GroupParams.GROUP_FACET);\n      }\n      \n      SimpleOrderedMap<Integer> fieldResults = new SimpleOrderedMap<Integer>();\n      res.add(parsed.key, fieldResults);\n      IntervalFacets intervalFacets = new IntervalFacets(schemaField, searcher, parsed.docs, intervalStrs, parsed.params);\n      for (FacetInterval interval : intervalFacets) {\n        fieldResults.add(interval.getKey(), interval.getCount());\n      }\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a <code>NamedList</code> with each entry having the \"key\" of the interval as name and the count of docs \n   * in that interval as value. All intervals added in the request are included in the returned \n   * <code>NamedList</code> (included those with 0 count), and it's required that the order of the intervals\n   * is deterministic and equals in all shards of a distributed request, otherwise the collation of results\n   * will fail. \n   * \n   */\n  public NamedList<Object> getFacetIntervalCounts() throws IOException, SyntaxError {\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] fields = params.getParams(FacetParams.FACET_INTERVAL);\n    if (fields == null || fields.length == 0) return res;\n\n    for (String field : fields) {\n      parseParams(FacetParams.FACET_INTERVAL, field);\n      String[] intervalStrs = required.getFieldParams(facetValue, FacetParams.FACET_INTERVAL_SET);\n      SchemaField schemaField = searcher.getCore().getLatestSchema().getField(facetValue);\n      if (params.getBool(GroupParams.GROUP_FACET, false)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Interval Faceting can't be used with \" + GroupParams.GROUP_FACET);\n      }\n      \n      SimpleOrderedMap<Integer> fieldResults = new SimpleOrderedMap<Integer>();\n      res.add(key, fieldResults);\n      IntervalFacets intervalFacets = new IntervalFacets(schemaField, searcher, docs, intervalStrs, params);\n      for (FacetInterval interval : intervalFacets) {\n        fieldResults.add(interval.getKey(), interval.getCount());\n      }\n    }\n\n    return res;\n  }\n\n","bugFix":["84b24f47dd3dfa4e2396cd6f819a35445b0a53fd","a0e3055974cda209e4f95efadcd904f0ebf03ada","c20fa646779d398a61a14cc6f9e00447475c0325"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46dc9ac8b3e748407baaef82453138ff3974480c","date":1484789241,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetIntervalCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetIntervalCounts().mjava","sourceNew":"  /**\n   * Returns a <code>NamedList</code> with each entry having the \"key\" of the interval as name and the count of docs \n   * in that interval as value. All intervals added in the request are included in the returned \n   * <code>NamedList</code> (included those with 0 count), and it's required that the order of the intervals\n   * is deterministic and equals in all shards of a distributed request, otherwise the collation of results\n   * will fail. \n   * \n   */\n  public NamedList<Object> getFacetIntervalCounts() throws IOException, SyntaxError {\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] fields = global.getParams(FacetParams.FACET_INTERVAL);\n    if (fields == null || fields.length == 0) return res;\n\n    for (String field : fields) {\n      final ParsedParams parsed = parseParams(FacetParams.FACET_INTERVAL, field);\n      String[] intervalStrs = parsed.required.getFieldParams(parsed.facetValue, FacetParams.FACET_INTERVAL_SET);\n      SchemaField schemaField = searcher.getCore().getLatestSchema().getField(parsed.facetValue);\n      if (parsed.params.getBool(GroupParams.GROUP_FACET, false)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Interval Faceting can't be used with \" + GroupParams.GROUP_FACET);\n      }\n      if (schemaField.getType().isPointField() && !schemaField.hasDocValues()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Can't use interval faceting on a PointField without docValues\");\n      }\n      \n      SimpleOrderedMap<Integer> fieldResults = new SimpleOrderedMap<Integer>();\n      res.add(parsed.key, fieldResults);\n      IntervalFacets intervalFacets = new IntervalFacets(schemaField, searcher, parsed.docs, intervalStrs, parsed.params);\n      for (FacetInterval interval : intervalFacets) {\n        fieldResults.add(interval.getKey(), interval.getCount());\n      }\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a <code>NamedList</code> with each entry having the \"key\" of the interval as name and the count of docs \n   * in that interval as value. All intervals added in the request are included in the returned \n   * <code>NamedList</code> (included those with 0 count), and it's required that the order of the intervals\n   * is deterministic and equals in all shards of a distributed request, otherwise the collation of results\n   * will fail. \n   * \n   */\n  public NamedList<Object> getFacetIntervalCounts() throws IOException, SyntaxError {\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] fields = global.getParams(FacetParams.FACET_INTERVAL);\n    if (fields == null || fields.length == 0) return res;\n\n    for (String field : fields) {\n      final ParsedParams parsed = parseParams(FacetParams.FACET_INTERVAL, field);\n      String[] intervalStrs = parsed.required.getFieldParams(parsed.facetValue, FacetParams.FACET_INTERVAL_SET);\n      SchemaField schemaField = searcher.getCore().getLatestSchema().getField(parsed.facetValue);\n      if (parsed.params.getBool(GroupParams.GROUP_FACET, false)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Interval Faceting can't be used with \" + GroupParams.GROUP_FACET);\n      }\n      \n      SimpleOrderedMap<Integer> fieldResults = new SimpleOrderedMap<Integer>();\n      res.add(parsed.key, fieldResults);\n      IntervalFacets intervalFacets = new IntervalFacets(schemaField, searcher, parsed.docs, intervalStrs, parsed.params);\n      for (FacetInterval interval : intervalFacets) {\n        fieldResults.add(interval.getKey(), interval.getCount());\n      }\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetIntervalCounts().mjava","pathOld":"solr/core/src/java/org/apache/solr/request/SimpleFacets#getFacetIntervalCounts().mjava","sourceNew":"  /**\n   * Returns a <code>NamedList</code> with each entry having the \"key\" of the interval as name and the count of docs \n   * in that interval as value. All intervals added in the request are included in the returned \n   * <code>NamedList</code> (included those with 0 count), and it's required that the order of the intervals\n   * is deterministic and equals in all shards of a distributed request, otherwise the collation of results\n   * will fail. \n   * \n   */\n  public NamedList<Object> getFacetIntervalCounts() throws IOException, SyntaxError {\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] fields = global.getParams(FacetParams.FACET_INTERVAL);\n    if (fields == null || fields.length == 0) return res;\n\n    for (String field : fields) {\n      final ParsedParams parsed = parseParams(FacetParams.FACET_INTERVAL, field);\n      String[] intervalStrs = parsed.required.getFieldParams(parsed.facetValue, FacetParams.FACET_INTERVAL_SET);\n      SchemaField schemaField = searcher.getCore().getLatestSchema().getField(parsed.facetValue);\n      if (parsed.params.getBool(GroupParams.GROUP_FACET, false)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Interval Faceting can't be used with \" + GroupParams.GROUP_FACET);\n      }\n      if (schemaField.getType().isPointField() && !schemaField.hasDocValues()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Can't use interval faceting on a PointField without docValues\");\n      }\n      \n      SimpleOrderedMap<Integer> fieldResults = new SimpleOrderedMap<Integer>();\n      res.add(parsed.key, fieldResults);\n      IntervalFacets intervalFacets = new IntervalFacets(schemaField, searcher, parsed.docs, intervalStrs, parsed.params);\n      for (FacetInterval interval : intervalFacets) {\n        fieldResults.add(interval.getKey(), interval.getCount());\n      }\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /**\n   * Returns a <code>NamedList</code> with each entry having the \"key\" of the interval as name and the count of docs \n   * in that interval as value. All intervals added in the request are included in the returned \n   * <code>NamedList</code> (included those with 0 count), and it's required that the order of the intervals\n   * is deterministic and equals in all shards of a distributed request, otherwise the collation of results\n   * will fail. \n   * \n   */\n  public NamedList<Object> getFacetIntervalCounts() throws IOException, SyntaxError {\n    NamedList<Object> res = new SimpleOrderedMap<Object>();\n    String[] fields = global.getParams(FacetParams.FACET_INTERVAL);\n    if (fields == null || fields.length == 0) return res;\n\n    for (String field : fields) {\n      final ParsedParams parsed = parseParams(FacetParams.FACET_INTERVAL, field);\n      String[] intervalStrs = parsed.required.getFieldParams(parsed.facetValue, FacetParams.FACET_INTERVAL_SET);\n      SchemaField schemaField = searcher.getCore().getLatestSchema().getField(parsed.facetValue);\n      if (parsed.params.getBool(GroupParams.GROUP_FACET, false)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Interval Faceting can't be used with \" + GroupParams.GROUP_FACET);\n      }\n      \n      SimpleOrderedMap<Integer> fieldResults = new SimpleOrderedMap<Integer>();\n      res.add(parsed.key, fieldResults);\n      IntervalFacets intervalFacets = new IntervalFacets(schemaField, searcher, parsed.docs, intervalStrs, parsed.params);\n      for (FacetInterval interval : intervalFacets) {\n        fieldResults.add(interval.getKey(), interval.getCount());\n      }\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"46dc9ac8b3e748407baaef82453138ff3974480c":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c20fa646779d398a61a14cc6f9e00447475c0325":["a0e3055974cda209e4f95efadcd904f0ebf03ada"],"a6d7fd8888854b7c6f30f35246057c92ddf5a750":["c20fa646779d398a61a14cc6f9e00447475c0325"],"84b24f47dd3dfa4e2396cd6f819a35445b0a53fd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e3055974cda209e4f95efadcd904f0ebf03ada":["84b24f47dd3dfa4e2396cd6f819a35445b0a53fd"],"aa62c79a7afa4d7f22e1f71b883659f3213d7db1":["a6d7fd8888854b7c6f30f35246057c92ddf5a750"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1","46dc9ac8b3e748407baaef82453138ff3974480c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["46dc9ac8b3e748407baaef82453138ff3974480c"]},"commit2Childs":{"46dc9ac8b3e748407baaef82453138ff3974480c":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["84b24f47dd3dfa4e2396cd6f819a35445b0a53fd"],"c20fa646779d398a61a14cc6f9e00447475c0325":["a6d7fd8888854b7c6f30f35246057c92ddf5a750"],"a6d7fd8888854b7c6f30f35246057c92ddf5a750":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"84b24f47dd3dfa4e2396cd6f819a35445b0a53fd":["a0e3055974cda209e4f95efadcd904f0ebf03ada"],"a0e3055974cda209e4f95efadcd904f0ebf03ada":["c20fa646779d398a61a14cc6f9e00447475c0325"],"aa62c79a7afa4d7f22e1f71b883659f3213d7db1":["46dc9ac8b3e748407baaef82453138ff3974480c","90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}