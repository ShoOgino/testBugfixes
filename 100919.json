{"path":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","commits":[{"id":"112d77ac8d3e10a362516ad834c9a11d35c94234","date":1456784319,"type":1,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","sourceNew":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Query query = strategy.makeQuery(args);\n      TopDocs docs = indexSearcher.search(query, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      Document doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Query query = strategy.makeQuery(args);\n      TopDocs docs = indexSearcher.search(query, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      Document doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","sourceNew":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Query query = strategy.makeQuery(args);\n      TopDocs docs = indexSearcher.search(query, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      Document doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Query query = strategy.makeQuery(args);\n      TopDocs docs = indexSearcher.search(query, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      Document doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"32b9119890a8e82252b6cc341ac491d18fa1e49b","date":1498575219,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","sourceNew":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Query query = strategy.makeQuery(args);\n      TopDocs docs = indexSearcher.search(query, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      Document doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      DoubleValuesSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Query query = strategy.makeQuery(args);\n      TopDocs docs = indexSearcher.search(query, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      Document doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98f11c416d30e556e0004a9a84960702d12d35b1","date":1498628359,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","sourceNew":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Query query = strategy.makeQuery(args);\n      TopDocs docs = indexSearcher.search(query, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      Document doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      DoubleValuesSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Query query = strategy.makeQuery(args);\n      TopDocs docs = indexSearcher.search(query, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      Document doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","sourceNew":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Query query = strategy.makeQuery(args);\n      TopDocs docs = indexSearcher.search(query, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      Document doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      DoubleValuesSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Query query = strategy.makeQuery(args);\n      TopDocs docs = indexSearcher.search(query, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      Document doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      ValueSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2","date":1591961131,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","pathOld":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/SpatialExample#search().mjava","sourceNew":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.getShapeFactory().circle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Query query = strategy.makeQuery(args);\n      TopDocs docs = indexSearcher.search(query, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      Document doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.getShapeFactory().pointXY(60, -50);\n      DoubleValuesSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.getShapeFactory().circle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","sourceOld":"  private void search() throws Exception {\n    IndexReader indexReader = DirectoryReader.open(directory);\n    IndexSearcher indexSearcher = new IndexSearcher(indexReader);\n    Sort idSort = new Sort(new SortField(\"id\", SortField.Type.INT));\n\n    //--Filter by circle (<= distance from a point)\n    {\n      //Search with circle\n      //note: SpatialArgs can be parsed from a string\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, DistanceUtils.dist2Degrees(200, DistanceUtils.EARTH_MEAN_RADIUS_KM)));\n      Query query = strategy.makeQuery(args);\n      TopDocs docs = indexSearcher.search(query, 10, idSort);\n      assertDocMatchedIds(indexSearcher, docs, 2);\n      //Now, lets get the distance for the 1st doc via computing from stored point value:\n      // (this computation is usually not redundant)\n      Document doc1 = indexSearcher.doc(docs.scoreDocs[0].doc);\n      String doc1Str = doc1.getField(strategy.getFieldName()).stringValue();\n      //assume doc1Str is \"x y\" as written in newSampleDocument()\n      int spaceIdx = doc1Str.indexOf(' ');\n      double x = Double.parseDouble(doc1Str.substring(0, spaceIdx));\n      double y = Double.parseDouble(doc1Str.substring(spaceIdx+1));\n      double doc1DistDEG = ctx.calcDistance(args.getShape().getCenter(), x, y);\n      assertEquals(121.6d, DistanceUtils.degrees2Dist(doc1DistDEG, DistanceUtils.EARTH_MEAN_RADIUS_KM), 0.1);\n      //or more simply:\n      assertEquals(121.6d, doc1DistDEG * DistanceUtils.DEG_TO_KM, 0.1);\n    }\n    //--Match all, order by distance ascending\n    {\n      Point pt = ctx.makePoint(60, -50);\n      DoubleValuesSource valueSource = strategy.makeDistanceValueSource(pt, DistanceUtils.DEG_TO_KM);//the distance (in km)\n      Sort distSort = new Sort(valueSource.getSortField(false)).rewrite(indexSearcher);//false=asc dist\n      TopDocs docs = indexSearcher.search(new MatchAllDocsQuery(), 10, distSort);\n      assertDocMatchedIds(indexSearcher, docs, 4, 20, 2);\n      //To get the distance, we could compute from stored values like earlier.\n      // However in this example we sorted on it, and the distance will get\n      // computed redundantly.  If the distance is only needed for the top-X\n      // search results then that's not a big deal. Alternatively, try wrapping\n      // the ValueSource with CachingDoubleValueSource then retrieve the value\n      // from the ValueSource now. See LUCENE-4541 for an example.\n    }\n    //demo arg parsing\n    {\n      SpatialArgs args = new SpatialArgs(SpatialOperation.Intersects,\n          ctx.makeCircle(-80.0, 33.0, 1));\n      SpatialArgs args2 = new SpatialArgsParser().parse(\"Intersects(BUFFER(POINT(-80 33),1))\", ctx);\n      assertEquals(args.toString(),args2.toString());\n    }\n\n    indexReader.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","112d77ac8d3e10a362516ad834c9a11d35c94234"],"32b9119890a8e82252b6cc341ac491d18fa1e49b":["af2638813028b254a88b418ebeafb541afb49653"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"112d77ac8d3e10a362516ad834c9a11d35c94234":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["af2638813028b254a88b418ebeafb541afb49653","32b9119890a8e82252b6cc341ac491d18fa1e49b"],"98f11c416d30e556e0004a9a84960702d12d35b1":["af2638813028b254a88b418ebeafb541afb49653","32b9119890a8e82252b6cc341ac491d18fa1e49b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["32b9119890a8e82252b6cc341ac491d18fa1e49b","28288370235ed02234a64753cdbf0c6ec096304a","98f11c416d30e556e0004a9a84960702d12d35b1"],"32b9119890a8e82252b6cc341ac491d18fa1e49b":["28288370235ed02234a64753cdbf0c6ec096304a","98f11c416d30e556e0004a9a84960702d12d35b1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["af2638813028b254a88b418ebeafb541afb49653","112d77ac8d3e10a362516ad834c9a11d35c94234"],"112d77ac8d3e10a362516ad834c9a11d35c94234":["af2638813028b254a88b418ebeafb541afb49653"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"28288370235ed02234a64753cdbf0c6ec096304a":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"],"98f11c416d30e556e0004a9a84960702d12d35b1":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["98f11c416d30e556e0004a9a84960702d12d35b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}