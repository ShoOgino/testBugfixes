{"path":"solr/core/src/test/org/apache/solr/search/facet/DistributedFacetSimpleRefinementLongTailTest#buildIndexes(List[SolrClient],String).mjava","commits":[{"id":"5445bd5bf6ab5e2fbb1a1b4ff8a36ba1cafa18ba","date":1513104620,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/DistributedFacetSimpleRefinementLongTailTest#buildIndexes(List[SolrClient],String).mjava","pathOld":"/dev/null","sourceNew":"  public static void buildIndexes(final List<SolrClient> clients, final String statField) throws Exception {\n\n    assertEquals(\"This indexing code assumes exactly 3 shards/clients\", 3, clients.size());\n    \n    final AtomicInteger docNum = new AtomicInteger();\n    final SolrClient shard0 = clients.get(0);\n    final SolrClient shard1 = clients.get(1);\n    final SolrClient shard2 = clients.get(2);\n    \n    // the 5 top foo_s terms have 100 docs each on every shard\n    for (int i = 0; i < 100; i++) {\n      for (int j = 0; j < 5; j++) {\n        shard0.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"aaa\"+j, statField, j * 13 - i));\n        shard1.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"aaa\"+j, statField, j * 3 + i));\n        shard2.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"aaa\"+j, statField, i * 7 + j));\n      }\n    }\n\n    // 20 foo_s terms that come in \"second\" with 50 docs each \n    // on both shard0 & shard1 (\"bbb_\")\n    for (int i = 0; i < 50; i++) {\n      for (int j = 0; j < 20; j++) {\n        shard0.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"bbb\"+j, statField, 0));\n        shard1.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"bbb\"+j, statField, 1));\n      }\n      // distracting term appears on only on shard2 50 times\n      shard2.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"junkA\"));\n    }\n    // put \"bbb0\" on shard2 exactly once to sanity check refinement\n    shard2.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"bbb0\", statField, -2));\n\n    // long 'tail' foo_s term appears in 45 docs on every shard\n    // foo_s:tail is the only term with bar_s sub-pivot terms\n    for (int i = 0; i < 45; i++) {\n\n      // for sub-pivot, shard0 & shard1 have 6 docs each for \"tailB\"\n      // but the top 5 terms are ccc(0-4) -- 7 on each shard\n      // (4 docs each have junk terms)\n      String sub_term = (i < 35) ? \"ccc\"+(i % 5) : ((i < 41) ? \"tailB\" : \"junkA\");\n      shard0.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"tail\", \"bar_s\", sub_term, statField, i));\n      shard1.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"tail\", \"bar_s\", sub_term, statField, i));\n\n      // shard2's top 5 sub-pivot terms are junk only it has with 8 docs each\n      // and 5 docs that use \"tailB\"\n      // NOTE: none of these get statField ! !\n      sub_term = (i < 40) ? \"junkB\"+(i % 5) : \"tailB\";\n      shard2.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"tail\", \"bar_s\", sub_term));\n    }\n\n    // really long tail uncommon foo_s terms on shard2\n    for (int i = 0; i < 30; i++) {\n      // NOTE: using \"Z\" here so these sort before bbb0 when they tie for '1' instance each on shard2\n      shard2.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"ZZZ\"+i));\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"927e6deec13723e5fd6fb8f1e0457e8597dae15e","date":1513167013,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/DistributedFacetSimpleRefinementLongTailTest#buildIndexes(List[SolrClient],String).mjava","pathOld":"/dev/null","sourceNew":"  public static void buildIndexes(final List<SolrClient> clients, final String statField) throws Exception {\n\n    assertEquals(\"This indexing code assumes exactly 3 shards/clients\", 3, clients.size());\n    \n    final AtomicInteger docNum = new AtomicInteger();\n    final SolrClient shard0 = clients.get(0);\n    final SolrClient shard1 = clients.get(1);\n    final SolrClient shard2 = clients.get(2);\n    \n    // the 5 top foo_s terms have 100 docs each on every shard\n    for (int i = 0; i < 100; i++) {\n      for (int j = 0; j < 5; j++) {\n        shard0.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"aaa\"+j, statField, j * 13 - i));\n        shard1.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"aaa\"+j, statField, j * 3 + i));\n        shard2.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"aaa\"+j, statField, i * 7 + j));\n      }\n    }\n\n    // 20 foo_s terms that come in \"second\" with 50 docs each \n    // on both shard0 & shard1 (\"bbb_\")\n    for (int i = 0; i < 50; i++) {\n      for (int j = 0; j < 20; j++) {\n        shard0.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"bbb\"+j, statField, 0));\n        shard1.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"bbb\"+j, statField, 1));\n      }\n      // distracting term appears on only on shard2 50 times\n      shard2.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"junkA\"));\n    }\n    // put \"bbb0\" on shard2 exactly once to sanity check refinement\n    shard2.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"bbb0\", statField, -2));\n\n    // long 'tail' foo_s term appears in 45 docs on every shard\n    // foo_s:tail is the only term with bar_s sub-pivot terms\n    for (int i = 0; i < 45; i++) {\n\n      // for sub-pivot, shard0 & shard1 have 6 docs each for \"tailB\"\n      // but the top 5 terms are ccc(0-4) -- 7 on each shard\n      // (4 docs each have junk terms)\n      String sub_term = (i < 35) ? \"ccc\"+(i % 5) : ((i < 41) ? \"tailB\" : \"junkA\");\n      shard0.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"tail\", \"bar_s\", sub_term, statField, i));\n      shard1.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"tail\", \"bar_s\", sub_term, statField, i));\n\n      // shard2's top 5 sub-pivot terms are junk only it has with 8 docs each\n      // and 5 docs that use \"tailB\"\n      // NOTE: none of these get statField ! !\n      sub_term = (i < 40) ? \"junkB\"+(i % 5) : \"tailB\";\n      shard2.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"tail\", \"bar_s\", sub_term));\n    }\n\n    // really long tail uncommon foo_s terms on shard2\n    for (int i = 0; i < 30; i++) {\n      // NOTE: using \"Z\" here so these sort before bbb0 when they tie for '1' instance each on shard2\n      shard2.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"ZZZ\"+i));\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8ab0d0e3eeff82234ea56bd0a3bf61cc196bf316","date":1573886531,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/DistributedFacetSimpleRefinementLongTailTest#buildIndexes(List[SolrClient],String).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/facet/DistributedFacetSimpleRefinementLongTailTest#buildIndexes(List[SolrClient],String).mjava","sourceNew":"  public static void buildIndexes(final List<SolrClient> clients, final String statField) throws Exception {\n\n    assertEquals(\"This indexing code assumes exactly 3 shards/clients\", 3, clients.size());\n    \n    final AtomicInteger docNum = new AtomicInteger();\n    final SolrClient shard0 = clients.get(0);\n    final SolrClient shard1 = clients.get(1);\n    final SolrClient shard2 = clients.get(2);\n\n    // the 5 top foo_s terms have 100 docs each on every shard\n    for (int i = 0; i < 100; i++) {\n      for (int j = 0; j < 5; j++) {\n        shard0.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"aaa\"+j, statField, j * 13 - i));\n        shard1.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"aaa\"+j, statField, j * 3 + i));\n        shard2.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"aaa\"+j, statField, i * 7 + j));\n      }\n    }\n\n    // 20 foo_s terms that come in \"second\" with 50 docs each\n    // on both shard0 & shard1 (\"bbb_\")\n    for (int i = 0; i < 50; i++) {\n      for (int j = 0; j < 20; j++) {\n        shard0.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"bbb\"+j, statField, 0));\n        shard1.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"bbb\"+j, statField, 1));\n      }\n      // distracting term appears on only on shard2 50 times\n      shard2.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"junkA\"));\n    }\n    // put \"bbb0\" on shard2 exactly once to sanity check refinement\n    shard2.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"bbb0\", statField, -2));\n\n    // long 'tail' foo_s term appears in 45 docs on every shard\n    // foo_s:tail is the only term with bar_s sub-pivot terms\n    for (int i = 0; i < 45; i++) {\n\n      // for sub-pivot, shard0 & shard1 have 6 docs each for \"tailB\"\n      // but the top 5 terms are ccc(0-4) -- 7 on each shard\n      // (4 docs each have junk terms)\n      String sub_term = (i < 35) ? \"ccc\"+(i % 5) : ((i < 41) ? \"tailB\" : \"junkA\");\n      shard0.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"tail\", \"bar_s\", sub_term, statField, i));\n      shard1.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"tail\", \"bar_s\", sub_term, statField, i));\n\n      // shard2's top 5 sub-pivot terms are junk only it has with 8 docs each\n      // and 5 docs that use \"tailB\"\n      // NOTE: none of these get statField ! !\n      sub_term = (i < 40) ? \"junkB\"+(i % 5) : \"tailB\";\n      shard2.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"tail\", \"bar_s\", sub_term));\n    }\n\n    // really long tail uncommon foo_s terms on shard2\n    for (int i = 0; i < 30; i++) {\n      // NOTE: using \"Z\" here so these sort before bbb0 when they tie for '1' instance each on shard2\n      shard2.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"ZZZ\"+i));\n    }\n\n  }\n\n","sourceOld":"  public static void buildIndexes(final List<SolrClient> clients, final String statField) throws Exception {\n\n    assertEquals(\"This indexing code assumes exactly 3 shards/clients\", 3, clients.size());\n    \n    final AtomicInteger docNum = new AtomicInteger();\n    final SolrClient shard0 = clients.get(0);\n    final SolrClient shard1 = clients.get(1);\n    final SolrClient shard2 = clients.get(2);\n    \n    // the 5 top foo_s terms have 100 docs each on every shard\n    for (int i = 0; i < 100; i++) {\n      for (int j = 0; j < 5; j++) {\n        shard0.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"aaa\"+j, statField, j * 13 - i));\n        shard1.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"aaa\"+j, statField, j * 3 + i));\n        shard2.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"aaa\"+j, statField, i * 7 + j));\n      }\n    }\n\n    // 20 foo_s terms that come in \"second\" with 50 docs each \n    // on both shard0 & shard1 (\"bbb_\")\n    for (int i = 0; i < 50; i++) {\n      for (int j = 0; j < 20; j++) {\n        shard0.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"bbb\"+j, statField, 0));\n        shard1.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"bbb\"+j, statField, 1));\n      }\n      // distracting term appears on only on shard2 50 times\n      shard2.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"junkA\"));\n    }\n    // put \"bbb0\" on shard2 exactly once to sanity check refinement\n    shard2.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"bbb0\", statField, -2));\n\n    // long 'tail' foo_s term appears in 45 docs on every shard\n    // foo_s:tail is the only term with bar_s sub-pivot terms\n    for (int i = 0; i < 45; i++) {\n\n      // for sub-pivot, shard0 & shard1 have 6 docs each for \"tailB\"\n      // but the top 5 terms are ccc(0-4) -- 7 on each shard\n      // (4 docs each have junk terms)\n      String sub_term = (i < 35) ? \"ccc\"+(i % 5) : ((i < 41) ? \"tailB\" : \"junkA\");\n      shard0.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"tail\", \"bar_s\", sub_term, statField, i));\n      shard1.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"tail\", \"bar_s\", sub_term, statField, i));\n\n      // shard2's top 5 sub-pivot terms are junk only it has with 8 docs each\n      // and 5 docs that use \"tailB\"\n      // NOTE: none of these get statField ! !\n      sub_term = (i < 40) ? \"junkB\"+(i % 5) : \"tailB\";\n      shard2.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"tail\", \"bar_s\", sub_term));\n    }\n\n    // really long tail uncommon foo_s terms on shard2\n    for (int i = 0; i < 30; i++) {\n      // NOTE: using \"Z\" here so these sort before bbb0 when they tie for '1' instance each on shard2\n      shard2.add(sdoc(\"id\", docNum.incrementAndGet(), \"foo_s\", \"ZZZ\"+i));\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8ab0d0e3eeff82234ea56bd0a3bf61cc196bf316":["927e6deec13723e5fd6fb8f1e0457e8597dae15e"],"5445bd5bf6ab5e2fbb1a1b4ff8a36ba1cafa18ba":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"927e6deec13723e5fd6fb8f1e0457e8597dae15e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5445bd5bf6ab5e2fbb1a1b4ff8a36ba1cafa18ba"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8ab0d0e3eeff82234ea56bd0a3bf61cc196bf316"]},"commit2Childs":{"8ab0d0e3eeff82234ea56bd0a3bf61cc196bf316":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5445bd5bf6ab5e2fbb1a1b4ff8a36ba1cafa18ba":["927e6deec13723e5fd6fb8f1e0457e8597dae15e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5445bd5bf6ab5e2fbb1a1b4ff8a36ba1cafa18ba","927e6deec13723e5fd6fb8f1e0457e8597dae15e"],"927e6deec13723e5fd6fb8f1e0457e8597dae15e":["8ab0d0e3eeff82234ea56bd0a3bf61cc196bf316"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}