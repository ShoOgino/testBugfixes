{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/FixedShingleFilter#incrementToken().mjava","commits":[{"id":"739747d2d107745148aac3687c9c797f1b97c50b","date":1521639903,"type":0,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/FixedShingleFilter#incrementToken().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n    int posInc = 0;\n    if (nextShingle() == false) {\n      Token nextRoot = nextTokenInStream(currentShingleTokens[0]);\n      if (nextRoot == endToken)\n        return false;\n      recycleToken(currentShingleTokens[0]);\n      if (resetShingleRoot(nextRoot) == false) {\n        return false;\n      }\n      posInc = currentShingleTokens[0].posInc();\n    }\n    clearAttributes();\n    incAtt.setPositionIncrement(posInc);\n    offsetAtt.setOffset(currentShingleTokens[0].startOffset(), lastTokenInShingle().endOffset());\n    termAtt.setEmpty();\n    termAtt.append(currentShingleTokens[0].term());\n    typeAtt.setType(\"shingle\");\n    posLenAtt.setPositionLength(shingleSize);\n    for (int i = 1; i < shingleSize; i++) {\n      termAtt.append(tokenSeparator).append(currentShingleTokens[i].term());\n    }\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["046741043ec34853ef81098738c092de8f69e23d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","date":1521731438,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/FixedShingleFilter#incrementToken().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n    int posInc = 0;\n    if (nextShingle() == false) {\n      Token nextRoot = nextTokenInStream(currentShingleTokens[0]);\n      if (nextRoot == endToken)\n        return false;\n      recycleToken(currentShingleTokens[0]);\n      if (resetShingleRoot(nextRoot) == false) {\n        return false;\n      }\n      posInc = currentShingleTokens[0].posInc();\n    }\n    clearAttributes();\n    incAtt.setPositionIncrement(posInc);\n    offsetAtt.setOffset(currentShingleTokens[0].startOffset(), lastTokenInShingle().endOffset());\n    termAtt.setEmpty();\n    termAtt.append(currentShingleTokens[0].term());\n    typeAtt.setType(\"shingle\");\n    posLenAtt.setPositionLength(shingleSize);\n    for (int i = 1; i < shingleSize; i++) {\n      termAtt.append(tokenSeparator).append(currentShingleTokens[i].term());\n    }\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89b8d38d08ee2b91459a65e16393722e4548f37c","date":1521980569,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/FixedShingleFilter#incrementToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/FixedShingleFilter#incrementToken().mjava","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n    int posInc = 0;\n    if (nextShingle() == false) {\n      Token nextRoot = nextTokenInStream(currentShingleTokens[0]);\n      if (nextRoot == endToken)\n        return false;\n      recycleToken(currentShingleTokens[0]);\n      if (resetShingleRoot(nextRoot) == false) {\n        return false;\n      }\n      posInc = currentShingleTokens[0].posInc();\n    }\n    clearAttributes();\n    incAtt.setPositionIncrement(posInc);\n    offsetAtt.setOffset(currentShingleTokens[0].startOffset(), lastTokenInShingle().endOffset());\n    termAtt.setEmpty();\n    termAtt.append(currentShingleTokens[0].term());\n    typeAtt.setType(\"shingle\");\n    for (int i = 1; i < shingleSize; i++) {\n      termAtt.append(tokenSeparator).append(currentShingleTokens[i].term());\n    }\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public boolean incrementToken() throws IOException {\n    int posInc = 0;\n    if (nextShingle() == false) {\n      Token nextRoot = nextTokenInStream(currentShingleTokens[0]);\n      if (nextRoot == endToken)\n        return false;\n      recycleToken(currentShingleTokens[0]);\n      if (resetShingleRoot(nextRoot) == false) {\n        return false;\n      }\n      posInc = currentShingleTokens[0].posInc();\n    }\n    clearAttributes();\n    incAtt.setPositionIncrement(posInc);\n    offsetAtt.setOffset(currentShingleTokens[0].startOffset(), lastTokenInShingle().endOffset());\n    termAtt.setEmpty();\n    termAtt.append(currentShingleTokens[0].term());\n    typeAtt.setType(\"shingle\");\n    posLenAtt.setPositionLength(shingleSize);\n    for (int i = 1; i < shingleSize; i++) {\n      termAtt.append(tokenSeparator).append(currentShingleTokens[i].term());\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"91286985ff2a4aea4ce949a9bd6dc750db6c207a","date":1521994854,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/FixedShingleFilter#incrementToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/FixedShingleFilter#incrementToken().mjava","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n    int posInc = 0;\n    if (nextShingle() == false) {\n      Token nextRoot = nextTokenInStream(currentShingleTokens[0]);\n      if (nextRoot == endToken)\n        return false;\n      recycleToken(currentShingleTokens[0]);\n      if (resetShingleRoot(nextRoot) == false) {\n        return false;\n      }\n      posInc = currentShingleTokens[0].posInc();\n    }\n    clearAttributes();\n    incAtt.setPositionIncrement(posInc);\n    offsetAtt.setOffset(currentShingleTokens[0].startOffset(), lastTokenInShingle().endOffset());\n    termAtt.setEmpty();\n    termAtt.append(currentShingleTokens[0].term());\n    typeAtt.setType(\"shingle\");\n    for (int i = 1; i < shingleSize; i++) {\n      termAtt.append(tokenSeparator).append(currentShingleTokens[i].term());\n    }\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public boolean incrementToken() throws IOException {\n    int posInc = 0;\n    if (nextShingle() == false) {\n      Token nextRoot = nextTokenInStream(currentShingleTokens[0]);\n      if (nextRoot == endToken)\n        return false;\n      recycleToken(currentShingleTokens[0]);\n      if (resetShingleRoot(nextRoot) == false) {\n        return false;\n      }\n      posInc = currentShingleTokens[0].posInc();\n    }\n    clearAttributes();\n    incAtt.setPositionIncrement(posInc);\n    offsetAtt.setOffset(currentShingleTokens[0].startOffset(), lastTokenInShingle().endOffset());\n    termAtt.setEmpty();\n    termAtt.append(currentShingleTokens[0].term());\n    typeAtt.setType(\"shingle\");\n    posLenAtt.setPositionLength(shingleSize);\n    for (int i = 1; i < shingleSize; i++) {\n      termAtt.append(tokenSeparator).append(currentShingleTokens[i].term());\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7836a9b132efc1162fb9d817b3e766f0a82212be","date":1543916862,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/FixedShingleFilter#incrementToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/FixedShingleFilter#incrementToken().mjava","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n\n    int shinglePosInc;\n    if (incrementGraph() == false) {\n      if (incrementBaseToken() == false) {\n        return false;\n      }\n      // starting a shingle at a new base position, use base position increment\n      shinglePosInc = incAtt.getPositionIncrement();\n    }\n    else {\n      // starting a new shingle at the same base with a different graph, use a 0\n      // position increment\n      shinglePosInc = 0;\n    }\n\n    final int startOffset = offsetAtt.startOffset();\n    int endOffset = offsetAtt.endOffset();\n    this.buffer.setEmpty();\n    this.buffer.append(termAtt);\n\n    // build the shingle by iterating over the current graph, adding\n    // filler tokens if we encounter gaps\n    for (int i = 1; i < shingleSize; i++) {\n      if (incrementGraphToken() == false) {\n        // we've reached the end of the token stream, check for trailing\n        // positions and add fillers if necessary\n        int trailingPositions = getTrailingPositions();\n        if (i + trailingPositions < shingleSize) {\n          // not enough trailing positions to make a full shingle\n          return false;\n        }\n        while (i < shingleSize) {\n          this.buffer.append(tokenSeparator).append(fillerToken);\n          i++;\n        }\n        break;\n      }\n      int posInc = incAtt.getPositionIncrement();\n      if (posInc > 1) {\n        // if we have a posInc > 1, we need to fill in the gaps\n        if (i + posInc > shingleSize) {\n          // if the posInc is greater than the shingle size, we need to add fillers\n          // up to the shingle size but no further\n          while (i < shingleSize) {\n            this.buffer.append(tokenSeparator).append(fillerToken);\n            i++;\n          }\n          break;\n        }\n        // otherwise just add them in as far as we need\n        while (posInc > 1) {\n          this.buffer.append(tokenSeparator).append(fillerToken);\n          posInc--;\n          i++;\n        }\n      }\n      this.buffer.append(tokenSeparator).append(termAtt);\n      endOffset = offsetAtt.endOffset();\n    }\n    clearAttributes();\n    this.offsetAtt.setOffset(startOffset, endOffset);\n    this.incAtt.setPositionIncrement(shinglePosInc);\n    this.termAtt.setEmpty().append(buffer);\n    this.typeAtt.setType(\"shingle\");\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public boolean incrementToken() throws IOException {\n    int posInc = 0;\n    if (nextShingle() == false) {\n      Token nextRoot = nextTokenInStream(currentShingleTokens[0]);\n      if (nextRoot == endToken)\n        return false;\n      recycleToken(currentShingleTokens[0]);\n      if (resetShingleRoot(nextRoot) == false) {\n        return false;\n      }\n      posInc = currentShingleTokens[0].posInc();\n    }\n    clearAttributes();\n    incAtt.setPositionIncrement(posInc);\n    offsetAtt.setOffset(currentShingleTokens[0].startOffset(), lastTokenInShingle().endOffset());\n    termAtt.setEmpty();\n    termAtt.append(currentShingleTokens[0].term());\n    typeAtt.setType(\"shingle\");\n    for (int i = 1; i < shingleSize; i++) {\n      termAtt.append(tokenSeparator).append(currentShingleTokens[i].term());\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["046741043ec34853ef81098738c092de8f69e23d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"046741043ec34853ef81098738c092de8f69e23d","date":1552561802,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/FixedShingleFilter#incrementToken().mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/shingle/FixedShingleFilter#incrementToken().mjava","sourceNew":"  @Override\n  public boolean incrementToken() throws IOException {\n\n    int shinglePosInc, startOffset, endOffset;\n\n    outer: while (true) {\n      if (incrementGraph() == false) {\n        if (incrementBaseToken() == false) {\n          return false;\n        }\n        // starting a shingle at a new base position, use base position increment\n        shinglePosInc = incAtt.getPositionIncrement();\n      } else {\n        // starting a new shingle at the same base with a different graph, use a 0\n        // position increment\n        shinglePosInc = 0;\n      }\n\n      startOffset = offsetAtt.startOffset();\n      endOffset = offsetAtt.endOffset();\n      this.buffer.setEmpty();\n      this.buffer.append(termAtt);\n\n      // build the shingle by iterating over the current graph, adding\n      // filler tokens if we encounter gaps\n      for (int i = 1; i < shingleSize; i++) {\n        if (incrementGraphToken() == false) {\n          // we've reached the end of the token stream, check for trailing\n          // positions and add fillers if necessary\n          int trailingPositions = getTrailingPositions();\n          if (i + trailingPositions < shingleSize) {\n            // not enough trailing positions to make a full shingle\n            // start again at a different graph\n            continue outer;\n          }\n          while (i < shingleSize) {\n            this.buffer.append(tokenSeparator).append(fillerToken);\n            i++;\n          }\n          break;\n        }\n        int posInc = incAtt.getPositionIncrement();\n        if (posInc > 1) {\n          // if we have a posInc > 1, we need to fill in the gaps\n          if (i + posInc > shingleSize) {\n            // if the posInc is greater than the shingle size, we need to add fillers\n            // up to the shingle size but no further\n            while (i < shingleSize) {\n              this.buffer.append(tokenSeparator).append(fillerToken);\n              i++;\n            }\n            break;\n          }\n          // otherwise just add them in as far as we need\n          while (posInc > 1) {\n            this.buffer.append(tokenSeparator).append(fillerToken);\n            posInc--;\n            i++;\n          }\n        }\n        this.buffer.append(tokenSeparator).append(termAtt);\n        endOffset = offsetAtt.endOffset();\n      }\n      break;\n    }\n    clearAttributes();\n    this.offsetAtt.setOffset(startOffset, endOffset);\n    this.incAtt.setPositionIncrement(shinglePosInc);\n    this.termAtt.setEmpty().append(buffer);\n    this.typeAtt.setType(\"shingle\");\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public boolean incrementToken() throws IOException {\n\n    int shinglePosInc;\n    if (incrementGraph() == false) {\n      if (incrementBaseToken() == false) {\n        return false;\n      }\n      // starting a shingle at a new base position, use base position increment\n      shinglePosInc = incAtt.getPositionIncrement();\n    }\n    else {\n      // starting a new shingle at the same base with a different graph, use a 0\n      // position increment\n      shinglePosInc = 0;\n    }\n\n    final int startOffset = offsetAtt.startOffset();\n    int endOffset = offsetAtt.endOffset();\n    this.buffer.setEmpty();\n    this.buffer.append(termAtt);\n\n    // build the shingle by iterating over the current graph, adding\n    // filler tokens if we encounter gaps\n    for (int i = 1; i < shingleSize; i++) {\n      if (incrementGraphToken() == false) {\n        // we've reached the end of the token stream, check for trailing\n        // positions and add fillers if necessary\n        int trailingPositions = getTrailingPositions();\n        if (i + trailingPositions < shingleSize) {\n          // not enough trailing positions to make a full shingle\n          return false;\n        }\n        while (i < shingleSize) {\n          this.buffer.append(tokenSeparator).append(fillerToken);\n          i++;\n        }\n        break;\n      }\n      int posInc = incAtt.getPositionIncrement();\n      if (posInc > 1) {\n        // if we have a posInc > 1, we need to fill in the gaps\n        if (i + posInc > shingleSize) {\n          // if the posInc is greater than the shingle size, we need to add fillers\n          // up to the shingle size but no further\n          while (i < shingleSize) {\n            this.buffer.append(tokenSeparator).append(fillerToken);\n            i++;\n          }\n          break;\n        }\n        // otherwise just add them in as far as we need\n        while (posInc > 1) {\n          this.buffer.append(tokenSeparator).append(fillerToken);\n          posInc--;\n          i++;\n        }\n      }\n      this.buffer.append(tokenSeparator).append(termAtt);\n      endOffset = offsetAtt.endOffset();\n    }\n    clearAttributes();\n    this.offsetAtt.setOffset(startOffset, endOffset);\n    this.incAtt.setPositionIncrement(shinglePosInc);\n    this.termAtt.setEmpty().append(buffer);\n    this.typeAtt.setType(\"shingle\");\n    return true;\n  }\n\n","bugFix":["739747d2d107745148aac3687c9c797f1b97c50b","7836a9b132efc1162fb9d817b3e766f0a82212be"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","739747d2d107745148aac3687c9c797f1b97c50b"],"046741043ec34853ef81098738c092de8f69e23d":["7836a9b132efc1162fb9d817b3e766f0a82212be"],"91286985ff2a4aea4ce949a9bd6dc750db6c207a":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","89b8d38d08ee2b91459a65e16393722e4548f37c"],"739747d2d107745148aac3687c9c797f1b97c50b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7836a9b132efc1162fb9d817b3e766f0a82212be":["91286985ff2a4aea4ce949a9bd6dc750db6c207a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"89b8d38d08ee2b91459a65e16393722e4548f37c":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["046741043ec34853ef81098738c092de8f69e23d"]},"commit2Childs":{"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["91286985ff2a4aea4ce949a9bd6dc750db6c207a","89b8d38d08ee2b91459a65e16393722e4548f37c"],"046741043ec34853ef81098738c092de8f69e23d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"91286985ff2a4aea4ce949a9bd6dc750db6c207a":["7836a9b132efc1162fb9d817b3e766f0a82212be"],"739747d2d107745148aac3687c9c797f1b97c50b":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","739747d2d107745148aac3687c9c797f1b97c50b"],"7836a9b132efc1162fb9d817b3e766f0a82212be":["046741043ec34853ef81098738c092de8f69e23d"],"89b8d38d08ee2b91459a65e16393722e4548f37c":["91286985ff2a4aea4ce949a9bd6dc750db6c207a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}