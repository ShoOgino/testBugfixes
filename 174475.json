{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentCommitInfo,boolean).mjava","commits":[{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentCommitInfo,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfoPerCommit,boolean).mjava","sourceNew":"    /**\n     * Obtain a ReadersAndLiveDocs instance from the\n     * readerPool.  If create is true, you must later call\n     * {@link #release(ReadersAndUpdates)}.\n     */\n    public synchronized ReadersAndUpdates get(SegmentCommitInfo info, boolean create) {\n\n      assert info.info.dir == directory: \"info.dir=\" + info.info.dir + \" vs \" + directory;\n\n      ReadersAndUpdates rld = readerMap.get(info);\n      if (rld == null) {\n        if (!create) {\n          return null;\n        }\n        rld = new ReadersAndUpdates(IndexWriter.this, info);\n        // Steal initial reference:\n        readerMap.put(info, rld);\n      } else {\n        assert rld.info == info: \"rld.info=\" + rld.info + \" info=\" + info + \" isLive?=\" + infoIsLive(rld.info) + \" vs \" + infoIsLive(info);\n      }\n\n      if (create) {\n        // Return ref to caller:\n        rld.incRef();\n      }\n\n      assert noDups();\n\n      return rld;\n    }\n\n","sourceOld":"    /**\n     * Obtain a ReadersAndLiveDocs instance from the\n     * readerPool.  If create is true, you must later call\n     * {@link #release(ReadersAndLiveDocs)}.\n     */\n    public synchronized ReadersAndLiveDocs get(SegmentInfoPerCommit info, boolean create) {\n\n      assert info.info.dir == directory: \"info.dir=\" + info.info.dir + \" vs \" + directory;\n\n      ReadersAndLiveDocs rld = readerMap.get(info);\n      if (rld == null) {\n        if (!create) {\n          return null;\n        }\n        rld = new ReadersAndLiveDocs(IndexWriter.this, info);\n        // Steal initial reference:\n        readerMap.put(info, rld);\n      } else {\n        assert rld.info == info: \"rld.info=\" + rld.info + \" info=\" + info + \" isLive?=\" + infoIsLive(rld.info) + \" vs \" + infoIsLive(info);\n      }\n\n      if (create) {\n        // Return ref to caller:\n        rld.incRef();\n      }\n\n      assert noDups();\n\n      return rld;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"901d103ab7c2eeae92b111fc91bb1b00580a3fd7","date":1422827173,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentCommitInfo,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentCommitInfo,boolean).mjava","sourceNew":"    /**\n     * Obtain a ReadersAndLiveDocs instance from the\n     * readerPool.  If create is true, you must later call\n     * {@link #release(ReadersAndUpdates)}.\n     */\n    public synchronized ReadersAndUpdates get(SegmentCommitInfo info, boolean create) {\n\n      // Make sure no new readers can be opened if another thread just closed us:\n      ensureOpen(false);\n\n      assert info.info.dir == directory: \"info.dir=\" + info.info.dir + \" vs \" + directory;\n\n      ReadersAndUpdates rld = readerMap.get(info);\n      if (rld == null) {\n        if (!create) {\n          return null;\n        }\n        rld = new ReadersAndUpdates(IndexWriter.this, info);\n        // Steal initial reference:\n        readerMap.put(info, rld);\n      } else {\n        assert rld.info == info: \"rld.info=\" + rld.info + \" info=\" + info + \" isLive?=\" + infoIsLive(rld.info) + \" vs \" + infoIsLive(info);\n      }\n\n      if (create) {\n        // Return ref to caller:\n        rld.incRef();\n      }\n\n      assert noDups();\n\n      return rld;\n    }\n\n","sourceOld":"    /**\n     * Obtain a ReadersAndLiveDocs instance from the\n     * readerPool.  If create is true, you must later call\n     * {@link #release(ReadersAndUpdates)}.\n     */\n    public synchronized ReadersAndUpdates get(SegmentCommitInfo info, boolean create) {\n\n      assert info.info.dir == directory: \"info.dir=\" + info.info.dir + \" vs \" + directory;\n\n      ReadersAndUpdates rld = readerMap.get(info);\n      if (rld == null) {\n        if (!create) {\n          return null;\n        }\n        rld = new ReadersAndUpdates(IndexWriter.this, info);\n        // Steal initial reference:\n        readerMap.put(info, rld);\n      } else {\n        assert rld.info == info: \"rld.info=\" + rld.info + \" info=\" + info + \" isLive?=\" + infoIsLive(rld.info) + \" vs \" + infoIsLive(info);\n      }\n\n      if (create) {\n        // Return ref to caller:\n        rld.incRef();\n      }\n\n      assert noDups();\n\n      return rld;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"618635065f043788c9e034f96ca5cd5cea1b4592","date":1433442044,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentCommitInfo,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentCommitInfo,boolean).mjava","sourceNew":"    /**\n     * Obtain a ReadersAndLiveDocs instance from the\n     * readerPool.  If create is true, you must later call\n     * {@link #release(ReadersAndUpdates)}.\n     */\n    public synchronized ReadersAndUpdates get(SegmentCommitInfo info, boolean create) {\n\n      // Make sure no new readers can be opened if another thread just closed us:\n      ensureOpen(false);\n\n      assert info.info.dir == directoryOrig: \"info.dir=\" + info.info.dir + \" vs \" + directoryOrig;\n\n      ReadersAndUpdates rld = readerMap.get(info);\n      if (rld == null) {\n        if (!create) {\n          return null;\n        }\n        rld = new ReadersAndUpdates(IndexWriter.this, info);\n        // Steal initial reference:\n        readerMap.put(info, rld);\n      } else {\n        assert rld.info == info: \"rld.info=\" + rld.info + \" info=\" + info + \" isLive?=\" + infoIsLive(rld.info) + \" vs \" + infoIsLive(info);\n      }\n\n      if (create) {\n        // Return ref to caller:\n        rld.incRef();\n      }\n\n      assert noDups();\n\n      return rld;\n    }\n\n","sourceOld":"    /**\n     * Obtain a ReadersAndLiveDocs instance from the\n     * readerPool.  If create is true, you must later call\n     * {@link #release(ReadersAndUpdates)}.\n     */\n    public synchronized ReadersAndUpdates get(SegmentCommitInfo info, boolean create) {\n\n      // Make sure no new readers can be opened if another thread just closed us:\n      ensureOpen(false);\n\n      assert info.info.dir == directory: \"info.dir=\" + info.info.dir + \" vs \" + directory;\n\n      ReadersAndUpdates rld = readerMap.get(info);\n      if (rld == null) {\n        if (!create) {\n          return null;\n        }\n        rld = new ReadersAndUpdates(IndexWriter.this, info);\n        // Steal initial reference:\n        readerMap.put(info, rld);\n      } else {\n        assert rld.info == info: \"rld.info=\" + rld.info + \" info=\" + info + \" isLive?=\" + infoIsLive(rld.info) + \" vs \" + infoIsLive(info);\n      }\n\n      if (create) {\n        // Return ref to caller:\n        rld.incRef();\n      }\n\n      assert noDups();\n\n      return rld;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentCommitInfo,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentCommitInfo,boolean).mjava","sourceNew":"    /**\n     * Obtain a ReadersAndLiveDocs instance from the\n     * readerPool.  If create is true, you must later call\n     * {@link #release(ReadersAndUpdates)}.\n     */\n    public synchronized ReadersAndUpdates get(SegmentCommitInfo info, boolean create) {\n\n      // Make sure no new readers can be opened if another thread just closed us:\n      ensureOpen(false);\n\n      assert info.info.dir == directoryOrig: \"info.dir=\" + info.info.dir + \" vs \" + directoryOrig;\n\n      ReadersAndUpdates rld = readerMap.get(info);\n      if (rld == null) {\n        if (create == false) {\n          return null;\n        }\n        rld = new ReadersAndUpdates(IndexWriter.this, info);\n        // Steal initial reference:\n        readerMap.put(info, rld);\n      } else {\n        assert rld.info == info: \"rld.info=\" + rld.info + \" info=\" + info + \" isLive?=\" + assertInfoIsLive(rld.info) + \" vs \" + assertInfoIsLive(info);\n      }\n\n      if (create) {\n        // Return ref to caller:\n        rld.incRef();\n      }\n\n      assert noDups();\n\n      return rld;\n    }\n\n","sourceOld":"    /**\n     * Obtain a ReadersAndLiveDocs instance from the\n     * readerPool.  If create is true, you must later call\n     * {@link #release(ReadersAndUpdates)}.\n     */\n    public synchronized ReadersAndUpdates get(SegmentCommitInfo info, boolean create) {\n\n      // Make sure no new readers can be opened if another thread just closed us:\n      ensureOpen(false);\n\n      assert info.info.dir == directoryOrig: \"info.dir=\" + info.info.dir + \" vs \" + directoryOrig;\n\n      ReadersAndUpdates rld = readerMap.get(info);\n      if (rld == null) {\n        if (!create) {\n          return null;\n        }\n        rld = new ReadersAndUpdates(IndexWriter.this, info);\n        // Steal initial reference:\n        readerMap.put(info, rld);\n      } else {\n        assert rld.info == info: \"rld.info=\" + rld.info + \" info=\" + info + \" isLive?=\" + infoIsLive(rld.info) + \" vs \" + infoIsLive(info);\n      }\n\n      if (create) {\n        // Return ref to caller:\n        rld.incRef();\n      }\n\n      assert noDups();\n\n      return rld;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentCommitInfo,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentCommitInfo,boolean).mjava","sourceNew":"    /**\n     * Obtain a ReadersAndLiveDocs instance from the\n     * readerPool.  If create is true, you must later call\n     * {@link #release(ReadersAndUpdates)}.\n     */\n    public synchronized ReadersAndUpdates get(SegmentCommitInfo info, boolean create) {\n\n      // Make sure no new readers can be opened if another thread just closed us:\n      ensureOpen(false);\n\n      assert info.info.dir == directoryOrig: \"info.dir=\" + info.info.dir + \" vs \" + directoryOrig;\n\n      ReadersAndUpdates rld = readerMap.get(info);\n      if (rld == null) {\n        if (create == false) {\n          return null;\n        }\n        rld = new ReadersAndUpdates(IndexWriter.this, info);\n        // Steal initial reference:\n        readerMap.put(info, rld);\n      } else {\n        assert rld.info == info: \"rld.info=\" + rld.info + \" info=\" + info + \" isLive?=\" + assertInfoIsLive(rld.info) + \" vs \" + assertInfoIsLive(info);\n      }\n\n      if (create) {\n        // Return ref to caller:\n        rld.incRef();\n      }\n\n      assert noDups();\n\n      return rld;\n    }\n\n","sourceOld":"    /**\n     * Obtain a ReadersAndLiveDocs instance from the\n     * readerPool.  If create is true, you must later call\n     * {@link #release(ReadersAndUpdates)}.\n     */\n    public synchronized ReadersAndUpdates get(SegmentCommitInfo info, boolean create) {\n\n      // Make sure no new readers can be opened if another thread just closed us:\n      ensureOpen(false);\n\n      assert info.info.dir == directoryOrig: \"info.dir=\" + info.info.dir + \" vs \" + directoryOrig;\n\n      ReadersAndUpdates rld = readerMap.get(info);\n      if (rld == null) {\n        if (!create) {\n          return null;\n        }\n        rld = new ReadersAndUpdates(IndexWriter.this, info);\n        // Steal initial reference:\n        readerMap.put(info, rld);\n      } else {\n        assert rld.info == info: \"rld.info=\" + rld.info + \" info=\" + info + \" isLive?=\" + infoIsLive(rld.info) + \" vs \" + infoIsLive(info);\n      }\n\n      if (create) {\n        // Return ref to caller:\n        rld.incRef();\n      }\n\n      assert noDups();\n\n      return rld;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentCommitInfo,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentCommitInfo,boolean).mjava","sourceNew":"    /**\n     * Obtain a ReadersAndLiveDocs instance from the\n     * readerPool.  If create is true, you must later call\n     * {@link #release(ReadersAndUpdates)}.\n     */\n    public synchronized ReadersAndUpdates get(SegmentCommitInfo info, boolean create) {\n\n      // Make sure no new readers can be opened if another thread just closed us:\n      ensureOpen(false);\n\n      assert info.info.dir == directoryOrig: \"info.dir=\" + info.info.dir + \" vs \" + directoryOrig;\n\n      ReadersAndUpdates rld = readerMap.get(info);\n      if (rld == null) {\n        if (create == false) {\n          return null;\n        }\n        rld = new ReadersAndUpdates(IndexWriter.this, info);\n        // Steal initial reference:\n        readerMap.put(info, rld);\n      } else {\n        assert rld.info == info: \"rld.info=\" + rld.info + \" info=\" + info + \" isLive?=\" + assertInfoIsLive(rld.info) + \" vs \" + assertInfoIsLive(info);\n      }\n\n      if (create) {\n        // Return ref to caller:\n        rld.incRef();\n      }\n\n      assert noDups();\n\n      return rld;\n    }\n\n","sourceOld":"    /**\n     * Obtain a ReadersAndLiveDocs instance from the\n     * readerPool.  If create is true, you must later call\n     * {@link #release(ReadersAndUpdates)}.\n     */\n    public synchronized ReadersAndUpdates get(SegmentCommitInfo info, boolean create) {\n\n      // Make sure no new readers can be opened if another thread just closed us:\n      ensureOpen(false);\n\n      assert info.info.dir == directoryOrig: \"info.dir=\" + info.info.dir + \" vs \" + directoryOrig;\n\n      ReadersAndUpdates rld = readerMap.get(info);\n      if (rld == null) {\n        if (!create) {\n          return null;\n        }\n        rld = new ReadersAndUpdates(IndexWriter.this, info);\n        // Steal initial reference:\n        readerMap.put(info, rld);\n      } else {\n        assert rld.info == info: \"rld.info=\" + rld.info + \" info=\" + info + \" isLive?=\" + infoIsLive(rld.info) + \" vs \" + infoIsLive(info);\n      }\n\n      if (create) {\n        // Return ref to caller:\n        rld.incRef();\n      }\n\n      assert noDups();\n\n      return rld;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d60c1bb96a28a26d197c36299f7b6c9c5da617a1","date":1522484702,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentCommitInfo,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentCommitInfo,boolean).mjava","sourceNew":"    /**\n     * Obtain a ReadersAndLiveDocs instance from the\n     * readerPool.  If create is true, you must later call\n     * {@link #release(ReadersAndUpdates)}.\n     */\n    public synchronized ReadersAndUpdates get(SegmentCommitInfo info, boolean create) {\n\n      // Make sure no new readers can be opened if another thread just closed us:\n      ensureOpen(false);\n\n      assert info.info.dir == directoryOrig: \"info.dir=\" + info.info.dir + \" vs \" + directoryOrig;\n\n      ReadersAndUpdates rld = readerMap.get(info);\n      if (rld == null) {\n        if (create == false) {\n          return null;\n        }\n        rld = new ReadersAndUpdates(segmentInfos.getIndexCreatedVersionMajor(), info, null, new PendingDeletes(null, info));\n        // Steal initial reference:\n        readerMap.put(info, rld);\n      } else {\n        assert rld.info == info: \"rld.info=\" + rld.info + \" info=\" + info + \" isLive?=\" + assertInfoIsLive(rld.info) + \" vs \" + assertInfoIsLive(info);\n      }\n\n      if (create) {\n        // Return ref to caller:\n        rld.incRef();\n      }\n\n      assert noDups();\n\n      return rld;\n    }\n\n","sourceOld":"    /**\n     * Obtain a ReadersAndLiveDocs instance from the\n     * readerPool.  If create is true, you must later call\n     * {@link #release(ReadersAndUpdates)}.\n     */\n    public synchronized ReadersAndUpdates get(SegmentCommitInfo info, boolean create) {\n\n      // Make sure no new readers can be opened if another thread just closed us:\n      ensureOpen(false);\n\n      assert info.info.dir == directoryOrig: \"info.dir=\" + info.info.dir + \" vs \" + directoryOrig;\n\n      ReadersAndUpdates rld = readerMap.get(info);\n      if (rld == null) {\n        if (create == false) {\n          return null;\n        }\n        rld = new ReadersAndUpdates(IndexWriter.this, info);\n        // Steal initial reference:\n        readerMap.put(info, rld);\n      } else {\n        assert rld.info == info: \"rld.info=\" + rld.info + \" info=\" + info + \" isLive?=\" + assertInfoIsLive(rld.info) + \" vs \" + assertInfoIsLive(info);\n      }\n\n      if (create) {\n        // Return ref to caller:\n        rld.incRef();\n      }\n\n      assert noDups();\n\n      return rld;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa5e39259dfd4a68287c824d3b7e1bc9097dc895","date":1522505041,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentCommitInfo,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentCommitInfo,boolean).mjava","sourceNew":"    /**\n     * Obtain a ReadersAndLiveDocs instance from the\n     * readerPool.  If create is true, you must later call\n     * {@link #release(ReadersAndUpdates)}.\n     */\n    public synchronized ReadersAndUpdates get(SegmentCommitInfo info, boolean create) {\n\n      // Make sure no new readers can be opened if another thread just closed us:\n      ensureOpen(false);\n\n      assert info.info.dir == directoryOrig: \"info.dir=\" + info.info.dir + \" vs \" + directoryOrig;\n\n      ReadersAndUpdates rld = readerMap.get(info);\n      if (rld == null) {\n        if (create == false) {\n          return null;\n        }\n        rld = new ReadersAndUpdates(segmentInfos.getIndexCreatedVersionMajor(), info, null, new PendingDeletes(null, info));\n        // Steal initial reference:\n        readerMap.put(info, rld);\n      } else {\n        assert rld.info == info: \"rld.info=\" + rld.info + \" info=\" + info + \" isLive?=\" + assertInfoIsLive(rld.info) + \" vs \" + assertInfoIsLive(info);\n      }\n\n      if (create) {\n        // Return ref to caller:\n        rld.incRef();\n      }\n\n      assert noDups();\n\n      return rld;\n    }\n\n","sourceOld":"    /**\n     * Obtain a ReadersAndLiveDocs instance from the\n     * readerPool.  If create is true, you must later call\n     * {@link #release(ReadersAndUpdates)}.\n     */\n    public synchronized ReadersAndUpdates get(SegmentCommitInfo info, boolean create) {\n\n      // Make sure no new readers can be opened if another thread just closed us:\n      ensureOpen(false);\n\n      assert info.info.dir == directoryOrig: \"info.dir=\" + info.info.dir + \" vs \" + directoryOrig;\n\n      ReadersAndUpdates rld = readerMap.get(info);\n      if (rld == null) {\n        if (create == false) {\n          return null;\n        }\n        rld = new ReadersAndUpdates(IndexWriter.this, info);\n        // Steal initial reference:\n        readerMap.put(info, rld);\n      } else {\n        assert rld.info == info: \"rld.info=\" + rld.info + \" info=\" + info + \" isLive?=\" + assertInfoIsLive(rld.info) + \" vs \" + assertInfoIsLive(info);\n      }\n\n      if (create) {\n        // Return ref to caller:\n        rld.incRef();\n      }\n\n      assert noDups();\n\n      return rld;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ee0394b8176abd7c90a4be8c05465be1879db79","date":1522842314,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentCommitInfo,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentCommitInfo,boolean).mjava","sourceNew":"    /**\n     * Obtain a ReadersAndLiveDocs instance from the\n     * readerPool.  If create is true, you must later call\n     * {@link #release(ReadersAndUpdates)}.\n     */\n    public synchronized ReadersAndUpdates get(SegmentCommitInfo info, boolean create) {\n\n      // Make sure no new readers can be opened if another thread just closed us:\n      ensureOpen(false);\n\n      assert info.info.dir == directoryOrig: \"info.dir=\" + info.info.dir + \" vs \" + directoryOrig;\n\n      ReadersAndUpdates rld = readerMap.get(info);\n      if (rld == null) {\n        if (create == false) {\n          return null;\n        }\n        rld = new ReadersAndUpdates(segmentInfos.getIndexCreatedVersionMajor(), info, newPendingDeletes(info));\n        // Steal initial reference:\n        readerMap.put(info, rld);\n      } else {\n        assert rld.info == info: \"rld.info=\" + rld.info + \" info=\" + info + \" isLive?=\" + assertInfoIsLive(rld.info) + \" vs \" + assertInfoIsLive(info);\n      }\n\n      if (create) {\n        // Return ref to caller:\n        rld.incRef();\n      }\n\n      assert noDups();\n\n      return rld;\n    }\n\n","sourceOld":"    /**\n     * Obtain a ReadersAndLiveDocs instance from the\n     * readerPool.  If create is true, you must later call\n     * {@link #release(ReadersAndUpdates)}.\n     */\n    public synchronized ReadersAndUpdates get(SegmentCommitInfo info, boolean create) {\n\n      // Make sure no new readers can be opened if another thread just closed us:\n      ensureOpen(false);\n\n      assert info.info.dir == directoryOrig: \"info.dir=\" + info.info.dir + \" vs \" + directoryOrig;\n\n      ReadersAndUpdates rld = readerMap.get(info);\n      if (rld == null) {\n        if (create == false) {\n          return null;\n        }\n        rld = new ReadersAndUpdates(segmentInfos.getIndexCreatedVersionMajor(), info, null, new PendingDeletes(null, info));\n        // Steal initial reference:\n        readerMap.put(info, rld);\n      } else {\n        assert rld.info == info: \"rld.info=\" + rld.info + \" info=\" + info + \" isLive?=\" + assertInfoIsLive(rld.info) + \" vs \" + assertInfoIsLive(info);\n      }\n\n      if (create) {\n        // Return ref to caller:\n        rld.incRef();\n      }\n\n      assert noDups();\n\n      return rld;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1926100d9b67becc9701c54266fee3ba7878a5f0","date":1524472150,"type":4,"author":"Simon Willnauer","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentCommitInfo,boolean).mjava","sourceNew":null,"sourceOld":"    /**\n     * Obtain a ReadersAndLiveDocs instance from the\n     * readerPool.  If create is true, you must later call\n     * {@link #release(ReadersAndUpdates)}.\n     */\n    public synchronized ReadersAndUpdates get(SegmentCommitInfo info, boolean create) {\n\n      // Make sure no new readers can be opened if another thread just closed us:\n      ensureOpen(false);\n\n      assert info.info.dir == directoryOrig: \"info.dir=\" + info.info.dir + \" vs \" + directoryOrig;\n\n      ReadersAndUpdates rld = readerMap.get(info);\n      if (rld == null) {\n        if (create == false) {\n          return null;\n        }\n        rld = new ReadersAndUpdates(segmentInfos.getIndexCreatedVersionMajor(), info, newPendingDeletes(info));\n        // Steal initial reference:\n        readerMap.put(info, rld);\n      } else {\n        assert rld.info == info: \"rld.info=\" + rld.info + \" info=\" + info + \" isLive?=\" + assertInfoIsLive(rld.info) + \" vs \" + assertInfoIsLive(info);\n      }\n\n      if (create) {\n        // Return ref to caller:\n        rld.incRef();\n      }\n\n      assert noDups();\n\n      return rld;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"618635065f043788c9e034f96ca5cd5cea1b4592":["901d103ab7c2eeae92b111fc91bb1b00580a3fd7"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["618635065f043788c9e034f96ca5cd5cea1b4592"],"5ee0394b8176abd7c90a4be8c05465be1879db79":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"aa5e39259dfd4a68287c824d3b7e1bc9097dc895":["28288370235ed02234a64753cdbf0c6ec096304a","d60c1bb96a28a26d197c36299f7b6c9c5da617a1"],"1926100d9b67becc9701c54266fee3ba7878a5f0":["5ee0394b8176abd7c90a4be8c05465be1879db79"],"d60c1bb96a28a26d197c36299f7b6c9c5da617a1":["28288370235ed02234a64753cdbf0c6ec096304a"],"901d103ab7c2eeae92b111fc91bb1b00580a3fd7":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["618635065f043788c9e034f96ca5cd5cea1b4592","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["618635065f043788c9e034f96ca5cd5cea1b4592","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1926100d9b67becc9701c54266fee3ba7878a5f0"]},"commit2Childs":{"618635065f043788c9e034f96ca5cd5cea1b4592":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["901d103ab7c2eeae92b111fc91bb1b00580a3fd7"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"5ee0394b8176abd7c90a4be8c05465be1879db79":["1926100d9b67becc9701c54266fee3ba7878a5f0"],"aa5e39259dfd4a68287c824d3b7e1bc9097dc895":["5ee0394b8176abd7c90a4be8c05465be1879db79"],"d60c1bb96a28a26d197c36299f7b6c9c5da617a1":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895"],"1926100d9b67becc9701c54266fee3ba7878a5f0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"901d103ab7c2eeae92b111fc91bb1b00580a3fd7":["618635065f043788c9e034f96ca5cd5cea1b4592"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["aa5e39259dfd4a68287c824d3b7e1bc9097dc895","d60c1bb96a28a26d197c36299f7b6c9c5da617a1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}