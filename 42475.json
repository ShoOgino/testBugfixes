{"path":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.PerReplicaCallable#call().mjava","commits":[{"id":"389d072b64597cdcf75c2d536aaec3e8afe3393f","date":1427818698,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.PerReplicaCallable#call().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public Boolean call() throws Exception {\n      long startTime = System.currentTimeMillis();\n      int attempts = 0;\n      try (HttpSolrClient solr = new HttpSolrClient(coreUrl)) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (true) {\n          try {\n            long timeElapsed = (System.currentTimeMillis() - startTime) / 1000;\n            if (timeElapsed >= maxWait) {\n              return false;\n            }\n            log.info(\"Time elapsed : {} secs, maxWait {}\", timeElapsed, maxWait);\n            Thread.sleep(100);\n            NamedList<Object> resp = solr.httpUriRequest(this).future.get();\n            if (resp != null) {\n              Map m = (Map) resp.get(ZNODEVER);\n              if (m != null) {\n                remoteVersion = (Number) m.get(prop);\n                if (remoteVersion != null && remoteVersion.intValue() >= expectedZkVersion) break;\n              }\n            }\n\n            attempts++;\n            log.info(formatString(\"Could not get expectedVersion {0} from {1} for prop {2}   after {3} attempts\", expectedZkVersion, coreUrl, prop, attempts));\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      }\n      return true;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fab172655716b96f7e42376116235017a922de3a","date":1427850611,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.PerReplicaCallable#call().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public Boolean call() throws Exception {\n      long startTime = System.currentTimeMillis();\n      int attempts = 0;\n      try (HttpSolrClient solr = new HttpSolrClient(coreUrl)) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (true) {\n          try {\n            long timeElapsed = (System.currentTimeMillis() - startTime) / 1000;\n            if (timeElapsed >= maxWait) {\n              return false;\n            }\n            log.info(\"Time elapsed : {} secs, maxWait {}\", timeElapsed, maxWait);\n            Thread.sleep(100);\n            NamedList<Object> resp = solr.httpUriRequest(this).future.get();\n            if (resp != null) {\n              Map m = (Map) resp.get(ZNODEVER);\n              if (m != null) {\n                remoteVersion = (Number) m.get(prop);\n                if (remoteVersion != null && remoteVersion.intValue() >= expectedZkVersion) break;\n              }\n            }\n\n            attempts++;\n            log.info(formatString(\"Could not get expectedVersion {0} from {1} for prop {2}   after {3} attempts\", expectedZkVersion, coreUrl, prop, attempts));\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      }\n      return true;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bcf9886c8ff537aafde14de48ebf744f5673f08b","date":1439041198,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.PerReplicaCallable#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.PerReplicaCallable#call().mjava","sourceNew":"    @Override\n    public Boolean call() throws Exception {\n      final RTimer timer = new RTimer();\n      int attempts = 0;\n      try (HttpSolrClient solr = new HttpSolrClient(coreUrl)) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (true) {\n          try {\n            long timeElapsed = (long) timer.getTime() / 1000;\n            if (timeElapsed >= maxWait) {\n              return false;\n            }\n            log.info(\"Time elapsed : {} secs, maxWait {}\", timeElapsed, maxWait);\n            Thread.sleep(100);\n            NamedList<Object> resp = solr.httpUriRequest(this).future.get();\n            if (resp != null) {\n              Map m = (Map) resp.get(ZNODEVER);\n              if (m != null) {\n                remoteVersion = (Number) m.get(prop);\n                if (remoteVersion != null && remoteVersion.intValue() >= expectedZkVersion) break;\n              }\n            }\n\n            attempts++;\n            log.info(formatString(\"Could not get expectedVersion {0} from {1} for prop {2}   after {3} attempts\", expectedZkVersion, coreUrl, prop, attempts));\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      }\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public Boolean call() throws Exception {\n      long startTime = System.currentTimeMillis();\n      int attempts = 0;\n      try (HttpSolrClient solr = new HttpSolrClient(coreUrl)) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (true) {\n          try {\n            long timeElapsed = (System.currentTimeMillis() - startTime) / 1000;\n            if (timeElapsed >= maxWait) {\n              return false;\n            }\n            log.info(\"Time elapsed : {} secs, maxWait {}\", timeElapsed, maxWait);\n            Thread.sleep(100);\n            NamedList<Object> resp = solr.httpUriRequest(this).future.get();\n            if (resp != null) {\n              Map m = (Map) resp.get(ZNODEVER);\n              if (m != null) {\n                remoteVersion = (Number) m.get(prop);\n                if (remoteVersion != null && remoteVersion.intValue() >= expectedZkVersion) break;\n              }\n            }\n\n            attempts++;\n            log.info(formatString(\"Could not get expectedVersion {0} from {1} for prop {2}   after {3} attempts\", expectedZkVersion, coreUrl, prop, attempts));\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.PerReplicaCallable#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.PerReplicaCallable#call().mjava","sourceNew":"    @Override\n    public Boolean call() throws Exception {\n      final RTimer timer = new RTimer();\n      int attempts = 0;\n      try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (true) {\n          try {\n            long timeElapsed = (long) timer.getTime() / 1000;\n            if (timeElapsed >= maxWait) {\n              return false;\n            }\n            log.info(\"Time elapsed : {} secs, maxWait {}\", timeElapsed, maxWait);\n            Thread.sleep(100);\n            NamedList<Object> resp = solr.httpUriRequest(this).future.get();\n            if (resp != null) {\n              Map m = (Map) resp.get(ZNODEVER);\n              if (m != null) {\n                remoteVersion = (Number) m.get(prop);\n                if (remoteVersion != null && remoteVersion.intValue() >= expectedZkVersion) break;\n              }\n            }\n\n            attempts++;\n            log.info(formatString(\"Could not get expectedVersion {0} from {1} for prop {2}   after {3} attempts\", expectedZkVersion, coreUrl, prop, attempts));\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      }\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public Boolean call() throws Exception {\n      final RTimer timer = new RTimer();\n      int attempts = 0;\n      try (HttpSolrClient solr = new HttpSolrClient(coreUrl)) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (true) {\n          try {\n            long timeElapsed = (long) timer.getTime() / 1000;\n            if (timeElapsed >= maxWait) {\n              return false;\n            }\n            log.info(\"Time elapsed : {} secs, maxWait {}\", timeElapsed, maxWait);\n            Thread.sleep(100);\n            NamedList<Object> resp = solr.httpUriRequest(this).future.get();\n            if (resp != null) {\n              Map m = (Map) resp.get(ZNODEVER);\n              if (m != null) {\n                remoteVersion = (Number) m.get(prop);\n                if (remoteVersion != null && remoteVersion.intValue() >= expectedZkVersion) break;\n              }\n            }\n\n            attempts++;\n            log.info(formatString(\"Could not get expectedVersion {0} from {1} for prop {2}   after {3} attempts\", expectedZkVersion, coreUrl, prop, attempts));\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.PerReplicaCallable#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.PerReplicaCallable#call().mjava","sourceNew":"    @Override\n    public Boolean call() throws Exception {\n      final RTimer timer = new RTimer();\n      int attempts = 0;\n      try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (true) {\n          try {\n            long timeElapsed = (long) timer.getTime() / 1000;\n            if (timeElapsed >= maxWait) {\n              return false;\n            }\n            log.info(\"Time elapsed : {} secs, maxWait {}\", timeElapsed, maxWait);\n            Thread.sleep(100);\n            NamedList<Object> resp = solr.httpUriRequest(this).future.get();\n            if (resp != null) {\n              Map m = (Map) resp.get(ZNODEVER);\n              if (m != null) {\n                remoteVersion = (Number) m.get(prop);\n                if (remoteVersion != null && remoteVersion.intValue() >= expectedZkVersion) break;\n              }\n            }\n\n            attempts++;\n            log.info(formatString(\"Could not get expectedVersion {0} from {1} for prop {2}   after {3} attempts\", expectedZkVersion, coreUrl, prop, attempts));\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      }\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public Boolean call() throws Exception {\n      final RTimer timer = new RTimer();\n      int attempts = 0;\n      try (HttpSolrClient solr = new HttpSolrClient(coreUrl)) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (true) {\n          try {\n            long timeElapsed = (long) timer.getTime() / 1000;\n            if (timeElapsed >= maxWait) {\n              return false;\n            }\n            log.info(\"Time elapsed : {} secs, maxWait {}\", timeElapsed, maxWait);\n            Thread.sleep(100);\n            NamedList<Object> resp = solr.httpUriRequest(this).future.get();\n            if (resp != null) {\n              Map m = (Map) resp.get(ZNODEVER);\n              if (m != null) {\n                remoteVersion = (Number) m.get(prop);\n                if (remoteVersion != null && remoteVersion.intValue() >= expectedZkVersion) break;\n              }\n            }\n\n            attempts++;\n            log.info(formatString(\"Could not get expectedVersion {0} from {1} for prop {2}   after {3} attempts\", expectedZkVersion, coreUrl, prop, attempts));\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb50877dc038c021eba3a70999fd1f6ed85001c1","date":1563596432,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.PerReplicaCallable#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.PerReplicaCallable#call().mjava","sourceNew":"    @Override\n    public Boolean call() throws Exception {\n      final RTimer timer = new RTimer();\n      int attempts = 0;\n      try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (true) {\n          try {\n            long timeElapsed = (long) timer.getTime() / 1000;\n            if (timeElapsed >= maxWait) {\n              return false;\n            }\n            log.info(\"Time elapsed : {} secs, maxWait {}\", timeElapsed, maxWait);\n            Thread.sleep(100);\n            MapWriter resp = solr.httpUriRequest(this).future.get();\n            if (verifyResponse(resp, attempts)) break;\n            attempts++;\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      }\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public Boolean call() throws Exception {\n      final RTimer timer = new RTimer();\n      int attempts = 0;\n      try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (true) {\n          try {\n            long timeElapsed = (long) timer.getTime() / 1000;\n            if (timeElapsed >= maxWait) {\n              return false;\n            }\n            log.info(\"Time elapsed : {} secs, maxWait {}\", timeElapsed, maxWait);\n            Thread.sleep(100);\n            NamedList<Object> resp = solr.httpUriRequest(this).future.get();\n            if (resp != null) {\n              Map m = (Map) resp.get(ZNODEVER);\n              if (m != null) {\n                remoteVersion = (Number) m.get(prop);\n                if (remoteVersion != null && remoteVersion.intValue() >= expectedZkVersion) break;\n              }\n            }\n\n            attempts++;\n            log.info(formatString(\"Could not get expectedVersion {0} from {1} for prop {2}   after {3} attempts\", expectedZkVersion, coreUrl, prop, attempts));\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c44cc06c26e456fe9c215072b79fce30babe3975","date":1570365040,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.PerReplicaCallable#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.PerReplicaCallable#call().mjava","sourceNew":"    @Override\n    public Boolean call() throws Exception {\n      final RTimer timer = new RTimer();\n      int attempts = 0;\n      try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (true) {\n          try {\n            long timeElapsed = (long) timer.getTime() / 1000;\n            if (timeElapsed >= maxWait) {\n              return false;\n            }\n            log.info(\"Time elapsed : {} secs, maxWait {}\", timeElapsed, maxWait);\n            Thread.sleep(100);\n            NamedList<Object> resp = solr.httpUriRequest(this).future.get();\n            if (resp != null) {\n              Map m = (Map) resp.get(ZNODEVER);\n              if (m != null) {\n                remoteVersion = (Number) m.get(prop);\n                if (remoteVersion != null && remoteVersion.intValue() >= expectedZkVersion) break;\n              }\n            }\n\n            attempts++;\n            log.info(formatString(\"Could not get expectedVersion {0} from {1} for prop {2}   after {3} attempts\", expectedZkVersion, coreUrl, prop, attempts));\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      }\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public Boolean call() throws Exception {\n      final RTimer timer = new RTimer();\n      int attempts = 0;\n      try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (true) {\n          try {\n            long timeElapsed = (long) timer.getTime() / 1000;\n            if (timeElapsed >= maxWait) {\n              return false;\n            }\n            log.info(\"Time elapsed : {} secs, maxWait {}\", timeElapsed, maxWait);\n            Thread.sleep(100);\n            MapWriter resp = solr.httpUriRequest(this).future.get();\n            if (verifyResponse(resp, attempts)) break;\n            attempts++;\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.PerReplicaCallable#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.PerReplicaCallable#call().mjava","sourceNew":"    @Override\n    public Boolean call() throws Exception {\n      final RTimer timer = new RTimer();\n      int attempts = 0;\n      try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (true) {\n          try {\n            long timeElapsed = (long) timer.getTime() / 1000;\n            if (timeElapsed >= maxWait) {\n              return false;\n            }\n            log.info(\"Time elapsed : {} secs, maxWait {}\", timeElapsed, maxWait);\n            Thread.sleep(100);\n            NamedList<Object> resp = solr.httpUriRequest(this).future.get();\n            if (resp != null) {\n              Map m = (Map) resp.get(ZNODEVER);\n              if (m != null) {\n                remoteVersion = (Number) m.get(prop);\n                if (remoteVersion != null && remoteVersion.intValue() >= expectedZkVersion) break;\n              }\n            }\n\n            attempts++;\n            log.info(formatString(\"Could not get expectedVersion {0} from {1} for prop {2}   after {3} attempts\", expectedZkVersion, coreUrl, prop, attempts));\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      }\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public Boolean call() throws Exception {\n      final RTimer timer = new RTimer();\n      int attempts = 0;\n      try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (true) {\n          try {\n            long timeElapsed = (long) timer.getTime() / 1000;\n            if (timeElapsed >= maxWait) {\n              return false;\n            }\n            log.info(\"Time elapsed : {} secs, maxWait {}\", timeElapsed, maxWait);\n            Thread.sleep(100);\n            MapWriter resp = solr.httpUriRequest(this).future.get();\n            if (verifyResponse(resp, attempts)) break;\n            attempts++;\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4","date":1588172214,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.PerReplicaCallable#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.PerReplicaCallable#call().mjava","sourceNew":"    @Override\n    public Boolean call() throws Exception {\n      final RTimer timer = new RTimer();\n      int attempts = 0;\n      try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (true) {\n          try {\n            long timeElapsed = (long) timer.getTime() / 1000;\n            if (timeElapsed >= maxWait) {\n              return false;\n            }\n            log.info(\"Time elapsed : {} secs, maxWait {}\", timeElapsed, maxWait);\n            Thread.sleep(100);\n            NamedList<Object> resp = solr.httpUriRequest(this).future.get();\n            if (resp != null) {\n              Map m = (Map) resp.get(ZNODEVER);\n              if (m != null) {\n                remoteVersion = (Number) m.get(prop);\n                if (remoteVersion != null && remoteVersion.intValue() >= expectedZkVersion) break;\n              }\n            }\n\n            attempts++;\n            if (log.isInfoEnabled()) {\n              log.info(formatString(\"Could not get expectedVersion {0} from {1} for prop {2}   after {3} attempts\", expectedZkVersion, coreUrl, prop, attempts));\n            }\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from {} due to: \", coreUrl, e);\n            }\n          }\n        }\n      }\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public Boolean call() throws Exception {\n      final RTimer timer = new RTimer();\n      int attempts = 0;\n      try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (true) {\n          try {\n            long timeElapsed = (long) timer.getTime() / 1000;\n            if (timeElapsed >= maxWait) {\n              return false;\n            }\n            log.info(\"Time elapsed : {} secs, maxWait {}\", timeElapsed, maxWait);\n            Thread.sleep(100);\n            NamedList<Object> resp = solr.httpUriRequest(this).future.get();\n            if (resp != null) {\n              Map m = (Map) resp.get(ZNODEVER);\n              if (m != null) {\n                remoteVersion = (Number) m.get(prop);\n                if (remoteVersion != null && remoteVersion.intValue() >= expectedZkVersion) break;\n              }\n            }\n\n            attempts++;\n            log.info(formatString(\"Could not get expectedVersion {0} from {1} for prop {2}   after {3} attempts\", expectedZkVersion, coreUrl, prop, attempts));\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from \" + coreUrl + \" due to: \" + e);\n            }\n          }\n        }\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5","date":1591384964,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.PerReplicaCallable#call().mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.PerReplicaCallable#call().mjava","sourceNew":"    @Override\n    public Boolean call() throws Exception {\n      final RTimer timer = new RTimer();\n      int attempts = 0;\n      try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (true) {\n          try {\n            long timeElapsed = (long) timer.getTime() / 1000;\n            if (timeElapsed >= maxWait) {\n              return false;\n            }\n            log.info(\"Time elapsed : {} secs, maxWait {}\", timeElapsed, maxWait);\n            Thread.sleep(100);\n            NamedList<Object> resp = solr.httpUriRequest(this).future.get();\n            if (resp != null) {\n              @SuppressWarnings({\"rawtypes\"})\n              Map m = (Map) resp.get(ZNODEVER);\n              if (m != null) {\n                remoteVersion = (Number) m.get(prop);\n                if (remoteVersion != null && remoteVersion.intValue() >= expectedZkVersion) break;\n              }\n            }\n\n            attempts++;\n            if (log.isInfoEnabled()) {\n              log.info(formatString(\"Could not get expectedVersion {0} from {1} for prop {2}   after {3} attempts\", expectedZkVersion, coreUrl, prop, attempts));\n            }\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from {} due to: \", coreUrl, e);\n            }\n          }\n        }\n      }\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public Boolean call() throws Exception {\n      final RTimer timer = new RTimer();\n      int attempts = 0;\n      try (HttpSolrClient solr = new HttpSolrClient.Builder(coreUrl).build()) {\n        // eventually, this loop will get killed by the ExecutorService's timeout\n        while (true) {\n          try {\n            long timeElapsed = (long) timer.getTime() / 1000;\n            if (timeElapsed >= maxWait) {\n              return false;\n            }\n            log.info(\"Time elapsed : {} secs, maxWait {}\", timeElapsed, maxWait);\n            Thread.sleep(100);\n            NamedList<Object> resp = solr.httpUriRequest(this).future.get();\n            if (resp != null) {\n              Map m = (Map) resp.get(ZNODEVER);\n              if (m != null) {\n                remoteVersion = (Number) m.get(prop);\n                if (remoteVersion != null && remoteVersion.intValue() >= expectedZkVersion) break;\n              }\n            }\n\n            attempts++;\n            if (log.isInfoEnabled()) {\n              log.info(formatString(\"Could not get expectedVersion {0} from {1} for prop {2}   after {3} attempts\", expectedZkVersion, coreUrl, prop, attempts));\n            }\n          } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n              break; // stop looping\n            } else {\n              log.warn(\"Failed to get /schema/zkversion from {} due to: \", coreUrl, e);\n            }\n          }\n        }\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"389d072b64597cdcf75c2d536aaec3e8afe3393f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fb50877dc038c021eba3a70999fd1f6ed85001c1":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["c44cc06c26e456fe9c215072b79fce30babe3975"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["bcf9886c8ff537aafde14de48ebf744f5673f08b","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["389d072b64597cdcf75c2d536aaec3e8afe3393f"],"c44cc06c26e456fe9c215072b79fce30babe3975":["fb50877dc038c021eba3a70999fd1f6ed85001c1"],"fab172655716b96f7e42376116235017a922de3a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","389d072b64597cdcf75c2d536aaec3e8afe3393f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5"],"b0b597c65628ca9e73913a07e81691f8229bae35":["fb50877dc038c021eba3a70999fd1f6ed85001c1","c44cc06c26e456fe9c215072b79fce30babe3975"]},"commit2Childs":{"389d072b64597cdcf75c2d536aaec3e8afe3393f":["bcf9886c8ff537aafde14de48ebf744f5673f08b","fab172655716b96f7e42376116235017a922de3a"],"fb50877dc038c021eba3a70999fd1f6ed85001c1":["c44cc06c26e456fe9c215072b79fce30babe3975","b0b597c65628ca9e73913a07e81691f8229bae35"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["389d072b64597cdcf75c2d536aaec3e8afe3393f","fab172655716b96f7e42376116235017a922de3a"],"2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["2caf6d6e842e1a4e4ae68ec6dfa5139c31a84ec5"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["fb50877dc038c021eba3a70999fd1f6ed85001c1"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"c44cc06c26e456fe9c215072b79fce30babe3975":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4","b0b597c65628ca9e73913a07e81691f8229bae35"],"fab172655716b96f7e42376116235017a922de3a":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["fab172655716b96f7e42376116235017a922de3a","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}