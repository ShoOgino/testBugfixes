{"path":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","sourceNew":"  public void testDataInputOutput() throws Exception {\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      final PagedBytes p = new PagedBytes(_TestUtil.nextInt(random, 1, 20));\n      final DataOutput out = p.getDataOutput();\n      final int numBytes = random.nextInt(10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random.nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random.nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random.nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n\n      p.freeze(random.nextBoolean());\n\n      final DataInput in = p.getDataInput();\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random.nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random.nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n    }\n  }\n\n","sourceOld":"  public void testDataInputOutput() throws Exception {\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      final PagedBytes p = new PagedBytes(_TestUtil.nextInt(random, 1, 20));\n      final DataOutput out = p.getDataOutput();\n      final int numBytes = random.nextInt(10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random.nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random.nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random.nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n\n      p.freeze(random.nextBoolean());\n\n      final DataInput in = p.getDataInput();\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random.nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random.nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ebb4b4370532662eb5f3238d02b002836b38b2","date":1331733267,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","sourceNew":"  public void testDataInputOutput() throws Exception {\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      final int blockBits = _TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final DataOutput out = p.getDataOutput();\n      final int numBytes = random.nextInt(10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random.nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random.nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random.nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final DataInput in = p.getDataInput();\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random.nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random.nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testDataInputOutput() throws Exception {\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      final PagedBytes p = new PagedBytes(_TestUtil.nextInt(random, 1, 20));\n      final DataOutput out = p.getDataOutput();\n      final int numBytes = random.nextInt(10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random.nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random.nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random.nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n\n      p.freeze(random.nextBoolean());\n\n      final DataInput in = p.getDataInput();\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random.nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random.nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","sourceNew":"  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      final int blockBits = _TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final DataOutput out = p.getDataOutput();\n      final int numBytes = random().nextInt(10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final DataInput in = p.getDataInput();\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testDataInputOutput() throws Exception {\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      final int blockBits = _TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final DataOutput out = p.getDataOutput();\n      final int numBytes = random.nextInt(10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random.nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random.nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random.nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final DataInput in = p.getDataInput();\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random.nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random.nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d559e16df1162ba11760bbc51f99d891fbd96b8b","date":1349872764,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","sourceNew":"  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      final int blockBits = _TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final DataOutput out = p.getDataOutput();\n      final int numBytes = _TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final DataInput in = p.getDataInput();\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      final int blockBits = _TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final DataOutput out = p.getDataOutput();\n      final int numBytes = random().nextInt(10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final DataInput in = p.getDataInput();\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fa968010b9c6598d02666b7b879c12e3cb0db4ee","date":1359063766,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","sourceNew":null,"sourceOld":"  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      final int blockBits = _TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final DataOutput out = p.getDataOutput();\n      final int numBytes = _TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final DataInput in = p.getDataInput();\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e7235ca8bb75e738a30076c041000782ed1a501f","date":1359986155,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","pathOld":"/dev/null","sourceNew":"  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(_TestUtil.getTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = _TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes = _TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["71da933d30aea361ccc224d6544c451cbf49916d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","sourceNew":"  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(_TestUtil.getTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = _TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes = _TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      final int blockBits = _TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final DataOutput out = p.getDataOutput();\n      final int numBytes = _TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final DataInput in = p.getDataInput();\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n    }\n  }\n\n","bugFix":["39509e0276e70b38a5e76aa9d2c468955a1c7855"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c024a3e8fec0a081cbf9539845db12f0dc84d029","date":1376654698,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","sourceNew":"  // Writes random byte/s to \"normal\" file in dir, then\n  // copies into PagedBytes and verifies with\n  // PagedBytes.Reader: \n  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(_TestUtil.getTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = _TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes = _TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(_TestUtil.getTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = _TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes = _TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2ceca04c06658aeb20e0a319ade784ad9a0576dd","date":1376662287,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","sourceNew":"  // Writes random byte/s to \"normal\" file in dir, then\n  // copies into PagedBytes and verifies with\n  // PagedBytes.Reader: \n  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(_TestUtil.getTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = _TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes = _TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(_TestUtil.getTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = _TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes = _TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","sourceNew":"  // Writes random byte/s to \"normal\" file in dir, then\n  // copies into PagedBytes and verifies with\n  // PagedBytes.Reader: \n  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(_TestUtil.getTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = _TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes = _TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(_TestUtil.getTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = _TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes = _TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","sourceNew":"  // Writes random byte/s to \"normal\" file in dir, then\n  // copies into PagedBytes and verifies with\n  // PagedBytes.Reader: \n  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(TestUtil.getTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes = TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  // Writes random byte/s to \"normal\" file in dir, then\n  // copies into PagedBytes and verifies with\n  // PagedBytes.Reader: \n  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(_TestUtil.getTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = _TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes = _TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0d579490a72f2e6297eaa648940611234c57cf1","date":1395917140,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","sourceNew":"  // Writes random byte/s to \"normal\" file in dir, then\n  // copies into PagedBytes and verifies with\n  // PagedBytes.Reader: \n  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(TestUtil.createTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes = TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  // Writes random byte/s to \"normal\" file in dir, then\n  // copies into PagedBytes and verifies with\n  // PagedBytes.Reader: \n  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(TestUtil.getTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes = TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c","date":1396633078,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","sourceNew":"  // Writes random byte/s to \"normal\" file in dir, then\n  // copies into PagedBytes and verifies with\n  // PagedBytes.Reader: \n  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(createTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes = TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  // Writes random byte/s to \"normal\" file in dir, then\n  // copies into PagedBytes and verifies with\n  // PagedBytes.Reader: \n  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(TestUtil.createTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes = TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a0f5bb79c600763ffe7b8141df59a3169d31e48","date":1396689440,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","sourceNew":"  // Writes random byte/s to \"normal\" file in dir, then\n  // copies into PagedBytes and verifies with\n  // PagedBytes.Reader: \n  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(createTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes = TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  // Writes random byte/s to \"normal\" file in dir, then\n  // copies into PagedBytes and verifies with\n  // PagedBytes.Reader: \n  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(TestUtil.getTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes = TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"71da933d30aea361ccc224d6544c451cbf49916d","date":1579874339,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","sourceNew":"  // Writes random byte/s to \"normal\" file in dir, then\n  // copies into PagedBytes and verifies with\n  // PagedBytes.Reader: \n  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    int numIters = atLeast(1);\n    for(int iter=0;iter<numIters;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(createTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes = TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  // Writes random byte/s to \"normal\" file in dir, then\n  // copies into PagedBytes and verifies with\n  // PagedBytes.Reader: \n  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    for(int iter=0;iter<5*RANDOM_MULTIPLIER;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(createTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes = TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","bugFix":["e7235ca8bb75e738a30076c041000782ed1a501f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"617d6d4150e0fb2acef8980ce51e3b8e628fb200","date":1580326292,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","sourceNew":"  // Writes random byte/s to \"normal\" file in dir, then\n  // copies into PagedBytes and verifies with\n  // PagedBytes.Reader: \n  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    int numIters = atLeast(1);\n    for(int iter=0;iter<numIters;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(createTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes = TestUtil.nextInt(random, 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random.nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random.nextInt(100) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random.nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random.nextInt(100) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random.nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  // Writes random byte/s to \"normal\" file in dir, then\n  // copies into PagedBytes and verifies with\n  // PagedBytes.Reader: \n  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    int numIters = atLeast(1);\n    for(int iter=0;iter<numIters;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(createTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes = TestUtil.nextInt(random(), 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random().nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random().nextInt(10) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random().nextInt(10) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random().nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5acb8730dbbbb0f88bb8db80769aa6e9b29d817b","date":1583461779,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestPagedBytes#testDataInputOutput().mjava","sourceNew":"  // Writes random byte/s to \"normal\" file in dir, then\n  // copies into PagedBytes and verifies with\n  // PagedBytes.Reader: \n  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    int numIters = atLeast(1);\n    for(int iter=0;iter<numIters;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(createTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes;\n      if (TEST_NIGHTLY) {\n        numBytes = TestUtil.nextInt(random(), 2, 10_000_000);\n      } else {\n        numBytes = TestUtil.nextInt(random(), 2, 1_000_000);\n      }\n\n      final byte[] answer = new byte[numBytes];\n      random.nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random.nextInt(100) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random.nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random.nextInt(100) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random.nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  // Writes random byte/s to \"normal\" file in dir, then\n  // copies into PagedBytes and verifies with\n  // PagedBytes.Reader: \n  public void testDataInputOutput() throws Exception {\n    Random random = random();\n    int numIters = atLeast(1);\n    for(int iter=0;iter<numIters;iter++) {\n      BaseDirectoryWrapper dir = newFSDirectory(createTempDir(\"testOverflow\"));\n      if (dir instanceof MockDirectoryWrapper) {\n        ((MockDirectoryWrapper)dir).setThrottling(MockDirectoryWrapper.Throttling.NEVER);\n      }\n      final int blockBits = TestUtil.nextInt(random, 1, 20);\n      final int blockSize = 1 << blockBits;\n      final PagedBytes p = new PagedBytes(blockBits);\n      final IndexOutput out = dir.createOutput(\"foo\", IOContext.DEFAULT);\n      final int numBytes = TestUtil.nextInt(random, 2, 10000000);\n\n      final byte[] answer = new byte[numBytes];\n      random.nextBytes(answer);\n      int written = 0;\n      while(written < numBytes) {\n        if (random.nextInt(100) == 7) {\n          out.writeByte(answer[written++]);\n        } else {\n          int chunk = Math.min(random.nextInt(1000), numBytes - written);\n          out.writeBytes(answer, written, chunk);\n          written += chunk;\n        }\n      }\n      \n      out.close();\n      final IndexInput input = dir.openInput(\"foo\", IOContext.DEFAULT);\n      final DataInput in = input.clone();\n      \n      p.copy(input, input.length());\n      final PagedBytes.Reader reader = p.freeze(random.nextBoolean());\n\n      final byte[] verify = new byte[numBytes];\n      int read = 0;\n      while(read < numBytes) {\n        if (random.nextInt(100) == 7) {\n          verify[read++] = in.readByte();\n        } else {\n          int chunk = Math.min(random.nextInt(1000), numBytes - read);\n          in.readBytes(verify, read, chunk);\n          read += chunk;\n        }\n      }\n      assertTrue(Arrays.equals(answer, verify));\n\n      final BytesRef slice = new BytesRef();\n      for(int iter2=0;iter2<100;iter2++) {\n        final int pos = random.nextInt(numBytes-1);\n        final int len = random.nextInt(Math.min(blockSize+1, numBytes - pos));\n        reader.fillSlice(slice, pos, len);\n        for(int byteUpto=0;byteUpto<len;byteUpto++) {\n          assertEquals(answer[pos + byteUpto], slice.bytes[slice.offset + byteUpto]);\n        }\n      }\n      input.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fa968010b9c6598d02666b7b879c12e3cb0db4ee":["d559e16df1162ba11760bbc51f99d891fbd96b8b"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["6613659748fe4411a7dcf85266e55db1f95f7315","a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"6613659748fe4411a7dcf85266e55db1f95f7315":["c024a3e8fec0a081cbf9539845db12f0dc84d029"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["d4d69c535930b5cce125cff868d40f6373dc27d4","c024a3e8fec0a081cbf9539845db12f0dc84d029"],"617d6d4150e0fb2acef8980ce51e3b8e628fb200":["71da933d30aea361ccc224d6544c451cbf49916d"],"d0d579490a72f2e6297eaa648940611234c57cf1":["6613659748fe4411a7dcf85266e55db1f95f7315"],"2ceca04c06658aeb20e0a319ade784ad9a0576dd":["d4d69c535930b5cce125cff868d40f6373dc27d4","c024a3e8fec0a081cbf9539845db12f0dc84d029"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["d559e16df1162ba11760bbc51f99d891fbd96b8b","e7235ca8bb75e738a30076c041000782ed1a501f"],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["d0d579490a72f2e6297eaa648940611234c57cf1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e7235ca8bb75e738a30076c041000782ed1a501f":["fa968010b9c6598d02666b7b879c12e3cb0db4ee"],"d559e16df1162ba11760bbc51f99d891fbd96b8b":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["09ebb4b4370532662eb5f3238d02b002836b38b2"],"c024a3e8fec0a081cbf9539845db12f0dc84d029":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"5acb8730dbbbb0f88bb8db80769aa6e9b29d817b":["617d6d4150e0fb2acef8980ce51e3b8e628fb200"],"09ebb4b4370532662eb5f3238d02b002836b38b2":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5acb8730dbbbb0f88bb8db80769aa6e9b29d817b"],"71da933d30aea361ccc224d6544c451cbf49916d":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"]},"commit2Childs":{"fa968010b9c6598d02666b7b879c12e3cb0db4ee":["e7235ca8bb75e738a30076c041000782ed1a501f"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["71da933d30aea361ccc224d6544c451cbf49916d"],"6613659748fe4411a7dcf85266e55db1f95f7315":["2a0f5bb79c600763ffe7b8141df59a3169d31e48","d0d579490a72f2e6297eaa648940611234c57cf1"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["09ebb4b4370532662eb5f3238d02b002836b38b2"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"617d6d4150e0fb2acef8980ce51e3b8e628fb200":["5acb8730dbbbb0f88bb8db80769aa6e9b29d817b"],"d0d579490a72f2e6297eaa648940611234c57cf1":["a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"2ceca04c06658aeb20e0a319ade784ad9a0576dd":[],"d4d69c535930b5cce125cff868d40f6373dc27d4":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","2ceca04c06658aeb20e0a319ade784ad9a0576dd","c024a3e8fec0a081cbf9539845db12f0dc84d029"],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"e7235ca8bb75e738a30076c041000782ed1a501f":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"d559e16df1162ba11760bbc51f99d891fbd96b8b":["fa968010b9c6598d02666b7b879c12e3cb0db4ee","d4d69c535930b5cce125cff868d40f6373dc27d4"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["d559e16df1162ba11760bbc51f99d891fbd96b8b"],"c024a3e8fec0a081cbf9539845db12f0dc84d029":["6613659748fe4411a7dcf85266e55db1f95f7315","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","2ceca04c06658aeb20e0a319ade784ad9a0576dd"],"09ebb4b4370532662eb5f3238d02b002836b38b2":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"5acb8730dbbbb0f88bb8db80769aa6e9b29d817b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"71da933d30aea361ccc224d6544c451cbf49916d":["617d6d4150e0fb2acef8980ce51e3b8e628fb200"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","2ceca04c06658aeb20e0a319ade784ad9a0576dd","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}