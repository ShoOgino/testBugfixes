{"path":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","commits":[{"id":"a851824c09818632c94eba41e60ef5e72e323c8e","date":1337355760,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","pathOld":"/dev/null","sourceNew":"    // NOTE: this method does not carry over termVector\n    // booleans nor docValuesType; the indexer chain\n    // (TermVectorsConsumerPerField, DocFieldProcessor) must\n    // set these fields when they succeed in consuming\n    // the document:\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, fieldType.indexed(), false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), null, null);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","pathOld":"/dev/null","sourceNew":"    // NOTE: this method does not carry over termVector\n    // booleans nor docValuesType; the indexer chain\n    // (TermVectorsConsumerPerField, DocFieldProcessor) must\n    // set these fields when they succeed in consuming\n    // the document:\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, fieldType.indexed(), false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), null, null);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"33e9fa3b49f4a365a04fdfc8a32dbcd0df798f5a","date":1341524239,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","sourceNew":"    // NOTE: this method does not carry over termVector\n    // booleans nor docValuesType; the indexer chain\n    // (TermVectorsConsumerPerField, DocFieldProcessor) must\n    // set these fields when they succeed in consuming\n    // the document:\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, true, false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), null, null);\n    }\n\n","sourceOld":"    // NOTE: this method does not carry over termVector\n    // booleans nor docValuesType; the indexer chain\n    // (TermVectorsConsumerPerField, DocFieldProcessor) must\n    // set these fields when they succeed in consuming\n    // the document:\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, fieldType.indexed(), false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), null, null);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4","date":1341839195,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","sourceNew":"    // NOTE: this method does not carry over termVector\n    // booleans nor docValuesType; the indexer chain\n    // (TermVectorsConsumerPerField, DocFieldProcessor) must\n    // set these fields when they succeed in consuming\n    // the document:\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, fieldType.indexed(), false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), null, null);\n    }\n\n","sourceOld":"    // NOTE: this method does not carry over termVector\n    // booleans nor docValuesType; the indexer chain\n    // (TermVectorsConsumerPerField, DocFieldProcessor) must\n    // set these fields when they succeed in consuming\n    // the document:\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, true, false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), null, null);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d5aaf10912e1f20c504e70ff8ab9b899727179b","date":1345132836,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","sourceNew":"    /** NOTE: this method does not carry over termVector\n     *  booleans nor docValuesType; the indexer chain\n     *  (TermVectorsConsumerPerField, DocFieldProcessor) must\n     *  set these fields when they succeed in consuming\n     *  the document */\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, fieldType.indexed(), false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), null, null);\n    }\n\n","sourceOld":"    // NOTE: this method does not carry over termVector\n    // booleans nor docValuesType; the indexer chain\n    // (TermVectorsConsumerPerField, DocFieldProcessor) must\n    // set these fields when they succeed in consuming\n    // the document:\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, fieldType.indexed(), false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), null, null);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"70fa1c0f4d75735ff2e1485e059d9bc5efa50598","date":1345296911,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","sourceNew":"    /** NOTE: this method does not carry over termVector\n     *  booleans nor docValuesType; the indexer chain\n     *  (TermVectorsConsumerPerField, DocFieldProcessor) must\n     *  set these fields when they succeed in consuming\n     *  the document */\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, fieldType.indexed(), false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), null, null);\n    }\n\n","sourceOld":"    // NOTE: this method does not carry over termVector\n    // booleans nor docValuesType; the indexer chain\n    // (TermVectorsConsumerPerField, DocFieldProcessor) must\n    // set these fields when they succeed in consuming\n    // the document:\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, fieldType.indexed(), false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), null, null);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"616c1830142ff5c1ddedec1ed898733b73c8e23b","date":1345368925,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","sourceNew":"    /** NOTE: this method does not carry over termVector\n     *  booleans nor docValuesType; the indexer chain\n     *  (TermVectorsConsumerPerField, DocFieldProcessor) must\n     *  set these fields when they succeed in consuming\n     *  the document */\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, fieldType.indexed(), false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), null, null);\n    }\n\n","sourceOld":"    // NOTE: this method does not carry over termVector\n    // booleans nor docValuesType; the indexer chain\n    // (TermVectorsConsumerPerField, DocFieldProcessor) must\n    // set these fields when they succeed in consuming\n    // the document:\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, fieldType.indexed(), false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), null, null);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e2893fd5349134af382d33ccc3d84840394c6c1","date":1353682567,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","sourceNew":"    /** NOTE: this method does not carry over termVector\n     *  booleans nor docValuesType; the indexer chain\n     *  (TermVectorsConsumerPerField, DocFieldProcessor) must\n     *  set these fields when they succeed in consuming\n     *  the document */\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, fieldType.indexed(), false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), fieldType.docValueType(), null);\n    }\n\n","sourceOld":"    /** NOTE: this method does not carry over termVector\n     *  booleans nor docValuesType; the indexer chain\n     *  (TermVectorsConsumerPerField, DocFieldProcessor) must\n     *  set these fields when they succeed in consuming\n     *  the document */\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, fieldType.indexed(), false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), null, null);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","sourceNew":"    /** NOTE: this method does not carry over termVector\n     *  booleans nor docValuesType; the indexer chain\n     *  (TermVectorsConsumerPerField, DocFieldProcessor) must\n     *  set these fields when they succeed in consuming\n     *  the document */\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, fieldType.indexed(), false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), fieldType.docValueType(), null);\n    }\n\n","sourceOld":"    /** NOTE: this method does not carry over termVector\n     *  booleans nor docValuesType; the indexer chain\n     *  (TermVectorsConsumerPerField, DocFieldProcessor) must\n     *  set these fields when they succeed in consuming\n     *  the document */\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, fieldType.indexed(), false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), null, null);\n    }\n\n","bugFix":["a851824c09818632c94eba41e60ef5e72e323c8e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05da2d758a6089e737cdfc230e57a51b472b94b6","date":1413392310,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","sourceNew":"    /** NOTE: this method does not carry over termVector\n     *  the indexer chain must set these fields when they\n     *  succeed in consuming the document */\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, fieldType.indexed(), false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), fieldType.docValueType());\n    }\n\n","sourceOld":"    /** NOTE: this method does not carry over termVector\n     *  booleans nor docValuesType; the indexer chain\n     *  (TermVectorsConsumerPerField, DocFieldProcessor) must\n     *  set these fields when they succeed in consuming\n     *  the document */\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, fieldType.indexed(), false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), fieldType.docValueType(), null);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","date":1413458798,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","sourceNew":"    /** NOTE: this method does not carry over termVector\n     *  the indexer chain must set these fields when they\n     *  succeed in consuming the document */\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, fieldType.indexed(), false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), fieldType.docValueType());\n    }\n\n","sourceOld":"    /** NOTE: this method does not carry over termVector\n     *  booleans nor docValuesType; the indexer chain\n     *  (TermVectorsConsumerPerField, DocFieldProcessor) must\n     *  set these fields when they succeed in consuming\n     *  the document */\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, fieldType.indexed(), false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), fieldType.docValueType(), null);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3184874f7f3aca850248483485b4995343066875","date":1413876758,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","sourceNew":"    /** NOTE: this method does not carry over termVector\n     *  the indexer chain must set these fields when they\n     *  succeed in consuming the document */\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), fieldType.docValueType());\n    }\n\n","sourceOld":"    /** NOTE: this method does not carry over termVector\n     *  the indexer chain must set these fields when they\n     *  succeed in consuming the document */\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, fieldType.indexed(), false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), fieldType.docValueType());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a22eafe3f72a4c2945eaad9547e6c78816978f4","date":1413956657,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","sourceNew":"    /** NOTE: this method does not carry over termVector\n     *  the indexer chain must set these fields when they\n     *  succeed in consuming the document */\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), fieldType.docValueType());\n    }\n\n","sourceOld":"    /** NOTE: this method does not carry over termVector\n     *  the indexer chain must set these fields when they\n     *  succeed in consuming the document */\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, fieldType.indexed(), false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), fieldType.docValueType());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eac6ccb51c439bec7f67cb0e299d3cb77b62b87e","date":1415435053,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdate(String,IndexableFieldType).mjava","sourceNew":null,"sourceOld":"    /** NOTE: this method does not carry over termVector\n     *  the indexer chain must set these fields when they\n     *  succeed in consuming the document */\n    public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {\n      // TODO: really, indexer shouldn't even call this\n      // method (it's only called from DocFieldProcessor);\n      // rather, each component in the chain should update\n      // what it \"owns\".  EG fieldType.indexOptions() should\n      // be updated by maybe FreqProxTermsWriterPerField:\n      return addOrUpdateInternal(name, -1, false,\n                                 fieldType.omitNorms(), false,\n                                 fieldType.indexOptions(), fieldType.docValueType());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"05da2d758a6089e737cdfc230e57a51b472b94b6":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84":["d4d69c535930b5cce125cff868d40f6373dc27d4","05da2d758a6089e737cdfc230e57a51b472b94b6"],"8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4":["33e9fa3b49f4a365a04fdfc8a32dbcd0df798f5a"],"616c1830142ff5c1ddedec1ed898733b73c8e23b":["8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4","0d5aaf10912e1f20c504e70ff8ab9b899727179b"],"6e2893fd5349134af382d33ccc3d84840394c6c1":["0d5aaf10912e1f20c504e70ff8ab9b899727179b"],"0d5aaf10912e1f20c504e70ff8ab9b899727179b":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"a851824c09818632c94eba41e60ef5e72e323c8e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3184874f7f3aca850248483485b4995343066875":["05da2d758a6089e737cdfc230e57a51b472b94b6"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a851824c09818632c94eba41e60ef5e72e323c8e"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","3184874f7f3aca850248483485b4995343066875"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["0d5aaf10912e1f20c504e70ff8ab9b899727179b","6e2893fd5349134af382d33ccc3d84840394c6c1"],"33e9fa3b49f4a365a04fdfc8a32dbcd0df798f5a":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"70fa1c0f4d75735ff2e1485e059d9bc5efa50598":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","0d5aaf10912e1f20c504e70ff8ab9b899727179b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"eac6ccb51c439bec7f67cb0e299d3cb77b62b87e":["3184874f7f3aca850248483485b4995343066875"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["eac6ccb51c439bec7f67cb0e299d3cb77b62b87e"]},"commit2Childs":{"05da2d758a6089e737cdfc230e57a51b472b94b6":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","3184874f7f3aca850248483485b4995343066875"],"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84":["0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4":["616c1830142ff5c1ddedec1ed898733b73c8e23b"],"616c1830142ff5c1ddedec1ed898733b73c8e23b":[],"6e2893fd5349134af382d33ccc3d84840394c6c1":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"0d5aaf10912e1f20c504e70ff8ab9b899727179b":["616c1830142ff5c1ddedec1ed898733b73c8e23b","6e2893fd5349134af382d33ccc3d84840394c6c1","d4d69c535930b5cce125cff868d40f6373dc27d4","70fa1c0f4d75735ff2e1485e059d9bc5efa50598"],"a851824c09818632c94eba41e60ef5e72e323c8e":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"3184874f7f3aca850248483485b4995343066875":["0a22eafe3f72a4c2945eaad9547e6c78816978f4","eac6ccb51c439bec7f67cb0e299d3cb77b62b87e"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["0d5aaf10912e1f20c504e70ff8ab9b899727179b","33e9fa3b49f4a365a04fdfc8a32dbcd0df798f5a","70fa1c0f4d75735ff2e1485e059d9bc5efa50598"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":[],"d4d69c535930b5cce125cff868d40f6373dc27d4":["05da2d758a6089e737cdfc230e57a51b472b94b6","c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84"],"33e9fa3b49f4a365a04fdfc8a32dbcd0df798f5a":["8f0e28f2a7f0f3f0fca1a2ffedaa10c7ac9536c4"],"70fa1c0f4d75735ff2e1485e059d9bc5efa50598":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a851824c09818632c94eba41e60ef5e72e323c8e","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"eac6ccb51c439bec7f67cb0e299d3cb77b62b87e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["616c1830142ff5c1ddedec1ed898733b73c8e23b","0a22eafe3f72a4c2945eaad9547e6c78816978f4","70fa1c0f4d75735ff2e1485e059d9bc5efa50598","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}