{"path":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","commits":[{"id":"be320990bdc77e643388fa801e75017f19289c42","date":1489477067,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) {\n        return;\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f996f8177b9204bdc92f7164460c6cefad9ac99a","date":1489482690,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) {\n        return;\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ce726d03c5bbc59a658256500cf204bd139c6c95","date":1489972914,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","sourceNew":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) {\n        return;\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","sourceOld":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) {\n        return;\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) {\n        return;\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec4ae21df3663f9b7cbfe543da7779b40f383672","date":1490280011,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","sourceNew":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) {\n        return;\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","sourceOld":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) {\n        return;\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n                AddUpdateCommand cmd = new AddUpdateCommand(req);\n                cmd.solrDoc = sdoc;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f09dfe4eae83c6f3ce87c6267cb774e4da0a2d73","date":1504185139,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","sourceNew":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   * @param omitCommitted if a tlog is already committed then don't read it\n   */\n  public void copyOverOldUpdates(long commitVersion, boolean omitCommitted) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (omitCommitted && oldTlog.endsWithCommit()) return;\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","sourceOld":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) {\n        return;\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":5,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","sourceNew":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   * @param omitCommitted if a tlog is already committed then don't read it\n   */\n  public void copyOverOldUpdates(long commitVersion, boolean omitCommitted) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (omitCommitted && oldTlog.endsWithCommit()) return;\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","sourceOld":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) {\n        return;\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","date":1504848000,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","sourceNew":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   * @param omitCommitted if a tlog is already committed then don't read it\n   */\n  public void copyOverOldUpdates(long commitVersion, boolean omitCommitted) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (omitCommitted && oldTlog.endsWithCommit()) return;\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","sourceOld":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) {\n        return;\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04ecf884544ff74add5faa452748f160c4af904b","date":1506527215,"type":1,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long,boolean).mjava","sourceNew":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) return;\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n    copyOverOldUpdatesMeter.mark();\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","sourceOld":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   * @param omitCommitted if a tlog is already committed then don't read it\n   */\n  public void copyOverOldUpdates(long commitVersion, boolean omitCommitted) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (omitCommitted && oldTlog.endsWithCommit()) return;\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long,boolean).mjava","sourceNew":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) return;\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n    copyOverOldUpdatesMeter.mark();\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","sourceOld":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   * @param omitCommitted if a tlog is already committed then don't read it\n   */\n  public void copyOverOldUpdates(long commitVersion, boolean omitCommitted) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (omitCommitted && oldTlog.endsWithCommit()) return;\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1455c941cc4ce652efc776fc23471b0e499246f6","date":1528086751,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","sourceNew":"  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) return;\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n    copyOverOldUpdates(commitVersion, oldTlog);\n  }\n\n","sourceOld":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) return;\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n    copyOverOldUpdatesMeter.mark();\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","sourceNew":"  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) return;\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n    copyOverOldUpdates(commitVersion, oldTlog);\n  }\n\n","sourceOld":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) return;\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n    copyOverOldUpdatesMeter.mark();\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","sourceNew":"  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) return;\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n    copyOverOldUpdates(commitVersion, oldTlog);\n  }\n\n","sourceOld":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) return;\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n    copyOverOldUpdatesMeter.mark();\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"04ecf884544ff74add5faa452748f160c4af904b":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"ce726d03c5bbc59a658256500cf204bd139c6c95":["be320990bdc77e643388fa801e75017f19289c42"],"1455c941cc4ce652efc776fc23471b0e499246f6":["04ecf884544ff74add5faa452748f160c4af904b"],"ec4ae21df3663f9b7cbfe543da7779b40f383672":["ab68488225b6a6c357dda72ed11dedca9914a192"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["ce726d03c5bbc59a658256500cf204bd139c6c95","f09dfe4eae83c6f3ce87c6267cb774e4da0a2d73"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["ec4ae21df3663f9b7cbfe543da7779b40f383672","f09dfe4eae83c6f3ce87c6267cb774e4da0a2d73"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","04ecf884544ff74add5faa452748f160c4af904b"],"f09dfe4eae83c6f3ce87c6267cb774e4da0a2d73":["ce726d03c5bbc59a658256500cf204bd139c6c95"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["04ecf884544ff74add5faa452748f160c4af904b","1455c941cc4ce652efc776fc23471b0e499246f6"],"be320990bdc77e643388fa801e75017f19289c42":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f592209545c71895260367152601e9200399776d":["04ecf884544ff74add5faa452748f160c4af904b","1455c941cc4ce652efc776fc23471b0e499246f6"],"ab68488225b6a6c357dda72ed11dedca9914a192":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1455c941cc4ce652efc776fc23471b0e499246f6"]},"commit2Childs":{"04ecf884544ff74add5faa452748f160c4af904b":["1455c941cc4ce652efc776fc23471b0e499246f6","6240b74b884c5587f2a4062dd27d6c32bf228889","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"ce726d03c5bbc59a658256500cf204bd139c6c95":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","f09dfe4eae83c6f3ce87c6267cb774e4da0a2d73"],"1455c941cc4ce652efc776fc23471b0e499246f6":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ec4ae21df3663f9b7cbfe543da7779b40f383672":["3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["ab68488225b6a6c357dda72ed11dedca9914a192"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["04ecf884544ff74add5faa452748f160c4af904b"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["6240b74b884c5587f2a4062dd27d6c32bf228889"],"6240b74b884c5587f2a4062dd27d6c32bf228889":[],"f09dfe4eae83c6f3ce87c6267cb774e4da0a2d73":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f996f8177b9204bdc92f7164460c6cefad9ac99a","be320990bdc77e643388fa801e75017f19289c42","ab68488225b6a6c357dda72ed11dedca9914a192"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"be320990bdc77e643388fa801e75017f19289c42":["ce726d03c5bbc59a658256500cf204bd139c6c95"],"ab68488225b6a6c357dda72ed11dedca9914a192":["ec4ae21df3663f9b7cbfe543da7779b40f383672"],"f592209545c71895260367152601e9200399776d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["6240b74b884c5587f2a4062dd27d6c32bf228889","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}