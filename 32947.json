{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#waitForDependentUpdates(AddUpdateCommand,long,boolean,VersionBucket).mjava","commits":[{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#waitForDependentUpdates(AddUpdateCommand,long,boolean,VersionBucket).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This method checks the update/transaction logs and index to find out if the update (\"previous update\") that the current update\n   * depends on (in the case that this current update is an in-place update) has already been completed. If not,\n   * this method will wait for the missing update until it has arrived. If it doesn't arrive within a timeout threshold,\n   * then this actively fetches from the leader.\n   * \n   * @return -1 if the current in-place should be dropped, or last found version if previous update has been indexed.\n   */\n  private long waitForDependentUpdates(AddUpdateCommand cmd, long versionOnUpdate,\n                               boolean isReplayOrPeersync, VersionBucket bucket) throws IOException {\n    long lastFoundVersion = 0;\n    TimeOut waitTimeout = new TimeOut(5, TimeUnit.SECONDS); \n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        Long lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n        lastFoundVersion = lookedUpVersion == null ? 0L: lookedUpVersion;\n\n        if (Math.abs(lastFoundVersion) < cmd.prevVersion) {\n          log.debug(\"Re-ordered inplace update. version={}, prevVersion={}, lastVersion={}, replayOrPeerSync={}, id={}\", \n              (cmd.getVersion() == 0 ? versionOnUpdate : cmd.getVersion()), cmd.prevVersion, lastFoundVersion, isReplayOrPeersync, cmd.getPrintableId());\n        }\n\n        while (Math.abs(lastFoundVersion) < cmd.prevVersion && !waitTimeout.hasTimedOut())  {\n          try {\n            long timeLeft = waitTimeout.timeLeft(TimeUnit.MILLISECONDS);\n            if (timeLeft > 0) { // wait(0) waits forever until notified, but we don't want that.\n              bucket.wait(timeLeft);\n            }\n          } catch (InterruptedException ie) {\n            throw new RuntimeException(ie);\n          }\n          lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          lastFoundVersion = lookedUpVersion == null ? 0L: lookedUpVersion;\n        }\n      }\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n\n    if (Math.abs(lastFoundVersion) > cmd.prevVersion) {\n      // This must've been the case due to a higher version full update succeeding concurrently, while we were waiting or\n      // trying to index this partial update. Since a full update more recent than this partial update has succeeded,\n      // we can drop the current update.\n      if (log.isDebugEnabled()) {\n        log.debug(\"Update was applied on version: {}, but last version I have is: {}\"\n            + \". Current update should be dropped. id={}\", cmd.prevVersion, lastFoundVersion, cmd.getPrintableId());\n      }\n      return -1;\n    } else if (Math.abs(lastFoundVersion) == cmd.prevVersion) {\n      assert 0 < lastFoundVersion : \"prevVersion \" + cmd.prevVersion + \" found but is a delete!\";\n      if (log.isDebugEnabled()) {\n        log.debug(\"Dependent update found. id={}\", cmd.getPrintableId());\n      }\n      return lastFoundVersion;\n    }\n\n    // We have waited enough, but dependent update didn't arrive. Its time to actively fetch it from leader\n    log.info(\"Missing update, on which current in-place update depends on, hasn't arrived. id={}, looking for version={}, last found version={}\", \n        cmd.getPrintableId(), cmd.prevVersion, lastFoundVersion);\n    \n    UpdateCommand missingUpdate = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n    if (missingUpdate instanceof DeleteUpdateCommand) {\n      log.info(\"Tried to fetch document {} from the leader, but the leader says document has been deleted. \" \n          + \"Deleting the document here and skipping this update: Last found version: {}, was looking for: {}\", cmd.getPrintableId(), lastFoundVersion, cmd.prevVersion);\n      versionDelete((DeleteUpdateCommand)missingUpdate);\n      return -1;\n    } else {\n      assert missingUpdate instanceof AddUpdateCommand;\n      log.info(\"Fetched the document: {}\", ((AddUpdateCommand)missingUpdate).getSolrInputDocument());\n      versionAdd((AddUpdateCommand)missingUpdate);\n      log.info(\"Added the fetched document, id=\"+((AddUpdateCommand)missingUpdate).getPrintableId()+\", version=\"+missingUpdate.getVersion());\n    }\n    return missingUpdate.getVersion();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#waitForDependentUpdates(AddUpdateCommand,long,boolean,VersionBucket).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This method checks the update/transaction logs and index to find out if the update (\"previous update\") that the current update\n   * depends on (in the case that this current update is an in-place update) has already been completed. If not,\n   * this method will wait for the missing update until it has arrived. If it doesn't arrive within a timeout threshold,\n   * then this actively fetches from the leader.\n   * \n   * @return -1 if the current in-place should be dropped, or last found version if previous update has been indexed.\n   */\n  private long waitForDependentUpdates(AddUpdateCommand cmd, long versionOnUpdate,\n                               boolean isReplayOrPeersync, VersionBucket bucket) throws IOException {\n    long lastFoundVersion = 0;\n    TimeOut waitTimeout = new TimeOut(5, TimeUnit.SECONDS); \n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        Long lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n        lastFoundVersion = lookedUpVersion == null ? 0L: lookedUpVersion;\n\n        if (Math.abs(lastFoundVersion) < cmd.prevVersion) {\n          log.debug(\"Re-ordered inplace update. version={}, prevVersion={}, lastVersion={}, replayOrPeerSync={}, id={}\", \n              (cmd.getVersion() == 0 ? versionOnUpdate : cmd.getVersion()), cmd.prevVersion, lastFoundVersion, isReplayOrPeersync, cmd.getPrintableId());\n        }\n\n        while (Math.abs(lastFoundVersion) < cmd.prevVersion && !waitTimeout.hasTimedOut())  {\n          try {\n            long timeLeft = waitTimeout.timeLeft(TimeUnit.MILLISECONDS);\n            if (timeLeft > 0) { // wait(0) waits forever until notified, but we don't want that.\n              bucket.wait(timeLeft);\n            }\n          } catch (InterruptedException ie) {\n            throw new RuntimeException(ie);\n          }\n          lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          lastFoundVersion = lookedUpVersion == null ? 0L: lookedUpVersion;\n        }\n      }\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n\n    if (Math.abs(lastFoundVersion) > cmd.prevVersion) {\n      // This must've been the case due to a higher version full update succeeding concurrently, while we were waiting or\n      // trying to index this partial update. Since a full update more recent than this partial update has succeeded,\n      // we can drop the current update.\n      if (log.isDebugEnabled()) {\n        log.debug(\"Update was applied on version: {}, but last version I have is: {}\"\n            + \". Current update should be dropped. id={}\", cmd.prevVersion, lastFoundVersion, cmd.getPrintableId());\n      }\n      return -1;\n    } else if (Math.abs(lastFoundVersion) == cmd.prevVersion) {\n      assert 0 < lastFoundVersion : \"prevVersion \" + cmd.prevVersion + \" found but is a delete!\";\n      if (log.isDebugEnabled()) {\n        log.debug(\"Dependent update found. id={}\", cmd.getPrintableId());\n      }\n      return lastFoundVersion;\n    }\n\n    // We have waited enough, but dependent update didn't arrive. Its time to actively fetch it from leader\n    log.info(\"Missing update, on which current in-place update depends on, hasn't arrived. id={}, looking for version={}, last found version={}\", \n        cmd.getPrintableId(), cmd.prevVersion, lastFoundVersion);\n    \n    UpdateCommand missingUpdate = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n    if (missingUpdate instanceof DeleteUpdateCommand) {\n      log.info(\"Tried to fetch document {} from the leader, but the leader says document has been deleted. \" \n          + \"Deleting the document here and skipping this update: Last found version: {}, was looking for: {}\", cmd.getPrintableId(), lastFoundVersion, cmd.prevVersion);\n      versionDelete((DeleteUpdateCommand)missingUpdate);\n      return -1;\n    } else {\n      assert missingUpdate instanceof AddUpdateCommand;\n      log.info(\"Fetched the document: {}\", ((AddUpdateCommand)missingUpdate).getSolrInputDocument());\n      versionAdd((AddUpdateCommand)missingUpdate);\n      log.info(\"Added the fetched document, id=\"+((AddUpdateCommand)missingUpdate).getPrintableId()+\", version=\"+missingUpdate.getVersion());\n    }\n    return missingUpdate.getVersion();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461","date":1487476295,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#waitForDependentUpdates(AddUpdateCommand,long,boolean,VersionBucket).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#waitForDependentUpdates(AddUpdateCommand,long,boolean,VersionBucket).mjava","sourceNew":"  /**\n   * This method checks the update/transaction logs and index to find out if the update (\"previous update\") that the current update\n   * depends on (in the case that this current update is an in-place update) has already been completed. If not,\n   * this method will wait for the missing update until it has arrived. If it doesn't arrive within a timeout threshold,\n   * then this actively fetches from the leader.\n   * \n   * @return -1 if the current in-place should be dropped, or last found version if previous update has been indexed.\n   */\n  private long waitForDependentUpdates(AddUpdateCommand cmd, long versionOnUpdate,\n                               boolean isReplayOrPeersync, VersionBucket bucket) throws IOException {\n    long lastFoundVersion = 0;\n    TimeOut waitTimeout = new TimeOut(5, TimeUnit.SECONDS); \n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        Long lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n        lastFoundVersion = lookedUpVersion == null ? 0L: lookedUpVersion;\n\n        if (Math.abs(lastFoundVersion) < cmd.prevVersion) {\n          log.debug(\"Re-ordered inplace update. version={}, prevVersion={}, lastVersion={}, replayOrPeerSync={}, id={}\", \n              (cmd.getVersion() == 0 ? versionOnUpdate : cmd.getVersion()), cmd.prevVersion, lastFoundVersion, isReplayOrPeersync, cmd.getPrintableId());\n        }\n\n        while (Math.abs(lastFoundVersion) < cmd.prevVersion && !waitTimeout.hasTimedOut())  {\n          try {\n            long timeLeft = waitTimeout.timeLeft(TimeUnit.MILLISECONDS);\n            if (timeLeft > 0) { // wait(0) waits forever until notified, but we don't want that.\n              bucket.wait(timeLeft);\n            }\n          } catch (InterruptedException ie) {\n            throw new RuntimeException(ie);\n          }\n          lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          lastFoundVersion = lookedUpVersion == null ? 0L: lookedUpVersion;\n        }\n      }\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n\n    if (Math.abs(lastFoundVersion) > cmd.prevVersion) {\n      // This must've been the case due to a higher version full update succeeding concurrently, while we were waiting or\n      // trying to index this partial update. Since a full update more recent than this partial update has succeeded,\n      // we can drop the current update.\n      if (log.isDebugEnabled()) {\n        log.debug(\"Update was applied on version: {}, but last version I have is: {}\"\n            + \". Current update should be dropped. id={}\", cmd.prevVersion, lastFoundVersion, cmd.getPrintableId());\n      }\n      return -1;\n    } else if (Math.abs(lastFoundVersion) == cmd.prevVersion) {\n      assert 0 < lastFoundVersion : \"prevVersion \" + cmd.prevVersion + \" found but is a delete!\";\n      if (log.isDebugEnabled()) {\n        log.debug(\"Dependent update found. id={}\", cmd.getPrintableId());\n      }\n      return lastFoundVersion;\n    }\n\n    // We have waited enough, but dependent update didn't arrive. Its time to actively fetch it from leader\n    log.info(\"Missing update, on which current in-place update depends on, hasn't arrived. id={}, looking for version={}, last found version={}\", \n        cmd.getPrintableId(), cmd.prevVersion, lastFoundVersion);\n    \n    UpdateCommand missingUpdate = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n    if (missingUpdate instanceof DeleteUpdateCommand) {\n      log.info(\"Tried to fetch document {} from the leader, but the leader says document has been deleted. \" \n          + \"Deleting the document here and skipping this update: Last found version: {}, was looking for: {}\", cmd.getPrintableId(), lastFoundVersion, cmd.prevVersion);\n      versionDelete((DeleteUpdateCommand)missingUpdate);\n      return -1;\n    } else {\n      assert missingUpdate instanceof AddUpdateCommand;\n      log.debug(\"Fetched the document: {}\", ((AddUpdateCommand)missingUpdate).getSolrInputDocument());\n      versionAdd((AddUpdateCommand)missingUpdate);\n      log.info(\"Added the fetched document, id=\"+((AddUpdateCommand)missingUpdate).getPrintableId()+\", version=\"+missingUpdate.getVersion());\n    }\n    return missingUpdate.getVersion();\n  }\n\n","sourceOld":"  /**\n   * This method checks the update/transaction logs and index to find out if the update (\"previous update\") that the current update\n   * depends on (in the case that this current update is an in-place update) has already been completed. If not,\n   * this method will wait for the missing update until it has arrived. If it doesn't arrive within a timeout threshold,\n   * then this actively fetches from the leader.\n   * \n   * @return -1 if the current in-place should be dropped, or last found version if previous update has been indexed.\n   */\n  private long waitForDependentUpdates(AddUpdateCommand cmd, long versionOnUpdate,\n                               boolean isReplayOrPeersync, VersionBucket bucket) throws IOException {\n    long lastFoundVersion = 0;\n    TimeOut waitTimeout = new TimeOut(5, TimeUnit.SECONDS); \n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        Long lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n        lastFoundVersion = lookedUpVersion == null ? 0L: lookedUpVersion;\n\n        if (Math.abs(lastFoundVersion) < cmd.prevVersion) {\n          log.debug(\"Re-ordered inplace update. version={}, prevVersion={}, lastVersion={}, replayOrPeerSync={}, id={}\", \n              (cmd.getVersion() == 0 ? versionOnUpdate : cmd.getVersion()), cmd.prevVersion, lastFoundVersion, isReplayOrPeersync, cmd.getPrintableId());\n        }\n\n        while (Math.abs(lastFoundVersion) < cmd.prevVersion && !waitTimeout.hasTimedOut())  {\n          try {\n            long timeLeft = waitTimeout.timeLeft(TimeUnit.MILLISECONDS);\n            if (timeLeft > 0) { // wait(0) waits forever until notified, but we don't want that.\n              bucket.wait(timeLeft);\n            }\n          } catch (InterruptedException ie) {\n            throw new RuntimeException(ie);\n          }\n          lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          lastFoundVersion = lookedUpVersion == null ? 0L: lookedUpVersion;\n        }\n      }\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n\n    if (Math.abs(lastFoundVersion) > cmd.prevVersion) {\n      // This must've been the case due to a higher version full update succeeding concurrently, while we were waiting or\n      // trying to index this partial update. Since a full update more recent than this partial update has succeeded,\n      // we can drop the current update.\n      if (log.isDebugEnabled()) {\n        log.debug(\"Update was applied on version: {}, but last version I have is: {}\"\n            + \". Current update should be dropped. id={}\", cmd.prevVersion, lastFoundVersion, cmd.getPrintableId());\n      }\n      return -1;\n    } else if (Math.abs(lastFoundVersion) == cmd.prevVersion) {\n      assert 0 < lastFoundVersion : \"prevVersion \" + cmd.prevVersion + \" found but is a delete!\";\n      if (log.isDebugEnabled()) {\n        log.debug(\"Dependent update found. id={}\", cmd.getPrintableId());\n      }\n      return lastFoundVersion;\n    }\n\n    // We have waited enough, but dependent update didn't arrive. Its time to actively fetch it from leader\n    log.info(\"Missing update, on which current in-place update depends on, hasn't arrived. id={}, looking for version={}, last found version={}\", \n        cmd.getPrintableId(), cmd.prevVersion, lastFoundVersion);\n    \n    UpdateCommand missingUpdate = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n    if (missingUpdate instanceof DeleteUpdateCommand) {\n      log.info(\"Tried to fetch document {} from the leader, but the leader says document has been deleted. \" \n          + \"Deleting the document here and skipping this update: Last found version: {}, was looking for: {}\", cmd.getPrintableId(), lastFoundVersion, cmd.prevVersion);\n      versionDelete((DeleteUpdateCommand)missingUpdate);\n      return -1;\n    } else {\n      assert missingUpdate instanceof AddUpdateCommand;\n      log.info(\"Fetched the document: {}\", ((AddUpdateCommand)missingUpdate).getSolrInputDocument());\n      versionAdd((AddUpdateCommand)missingUpdate);\n      log.info(\"Added the fetched document, id=\"+((AddUpdateCommand)missingUpdate).getPrintableId()+\", version=\"+missingUpdate.getVersion());\n    }\n    return missingUpdate.getVersion();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#waitForDependentUpdates(AddUpdateCommand,long,boolean,VersionBucket).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#waitForDependentUpdates(AddUpdateCommand,long,boolean,VersionBucket).mjava","sourceNew":"  /**\n   * This method checks the update/transaction logs and index to find out if the update (\"previous update\") that the current update\n   * depends on (in the case that this current update is an in-place update) has already been completed. If not,\n   * this method will wait for the missing update until it has arrived. If it doesn't arrive within a timeout threshold,\n   * then this actively fetches from the leader.\n   * \n   * @return -1 if the current in-place should be dropped, or last found version if previous update has been indexed.\n   */\n  private long waitForDependentUpdates(AddUpdateCommand cmd, long versionOnUpdate,\n                               boolean isReplayOrPeersync, VersionBucket bucket) throws IOException {\n    long lastFoundVersion = 0;\n    TimeOut waitTimeout = new TimeOut(5, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        Long lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n        lastFoundVersion = lookedUpVersion == null ? 0L: lookedUpVersion;\n\n        if (Math.abs(lastFoundVersion) < cmd.prevVersion) {\n          log.debug(\"Re-ordered inplace update. version={}, prevVersion={}, lastVersion={}, replayOrPeerSync={}, id={}\", \n              (cmd.getVersion() == 0 ? versionOnUpdate : cmd.getVersion()), cmd.prevVersion, lastFoundVersion, isReplayOrPeersync, cmd.getPrintableId());\n        }\n\n        while (Math.abs(lastFoundVersion) < cmd.prevVersion && !waitTimeout.hasTimedOut())  {\n          try {\n            long timeLeft = waitTimeout.timeLeft(TimeUnit.MILLISECONDS);\n            if (timeLeft > 0) { // wait(0) waits forever until notified, but we don't want that.\n              bucket.wait(timeLeft);\n            }\n          } catch (InterruptedException ie) {\n            throw new RuntimeException(ie);\n          }\n          lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          lastFoundVersion = lookedUpVersion == null ? 0L: lookedUpVersion;\n        }\n      }\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n\n    if (Math.abs(lastFoundVersion) > cmd.prevVersion) {\n      // This must've been the case due to a higher version full update succeeding concurrently, while we were waiting or\n      // trying to index this partial update. Since a full update more recent than this partial update has succeeded,\n      // we can drop the current update.\n      if (log.isDebugEnabled()) {\n        log.debug(\"Update was applied on version: {}, but last version I have is: {}\"\n            + \". Current update should be dropped. id={}\", cmd.prevVersion, lastFoundVersion, cmd.getPrintableId());\n      }\n      return -1;\n    } else if (Math.abs(lastFoundVersion) == cmd.prevVersion) {\n      assert 0 < lastFoundVersion : \"prevVersion \" + cmd.prevVersion + \" found but is a delete!\";\n      if (log.isDebugEnabled()) {\n        log.debug(\"Dependent update found. id={}\", cmd.getPrintableId());\n      }\n      return lastFoundVersion;\n    }\n\n    // We have waited enough, but dependent update didn't arrive. Its time to actively fetch it from leader\n    log.info(\"Missing update, on which current in-place update depends on, hasn't arrived. id={}, looking for version={}, last found version={}\", \n        cmd.getPrintableId(), cmd.prevVersion, lastFoundVersion);\n    \n    UpdateCommand missingUpdate = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n    if (missingUpdate instanceof DeleteUpdateCommand) {\n      log.info(\"Tried to fetch document {} from the leader, but the leader says document has been deleted. \" \n          + \"Deleting the document here and skipping this update: Last found version: {}, was looking for: {}\", cmd.getPrintableId(), lastFoundVersion, cmd.prevVersion);\n      versionDelete((DeleteUpdateCommand)missingUpdate);\n      return -1;\n    } else {\n      assert missingUpdate instanceof AddUpdateCommand;\n      log.debug(\"Fetched the document: {}\", ((AddUpdateCommand)missingUpdate).getSolrInputDocument());\n      versionAdd((AddUpdateCommand)missingUpdate);\n      log.info(\"Added the fetched document, id=\"+((AddUpdateCommand)missingUpdate).getPrintableId()+\", version=\"+missingUpdate.getVersion());\n    }\n    return missingUpdate.getVersion();\n  }\n\n","sourceOld":"  /**\n   * This method checks the update/transaction logs and index to find out if the update (\"previous update\") that the current update\n   * depends on (in the case that this current update is an in-place update) has already been completed. If not,\n   * this method will wait for the missing update until it has arrived. If it doesn't arrive within a timeout threshold,\n   * then this actively fetches from the leader.\n   * \n   * @return -1 if the current in-place should be dropped, or last found version if previous update has been indexed.\n   */\n  private long waitForDependentUpdates(AddUpdateCommand cmd, long versionOnUpdate,\n                               boolean isReplayOrPeersync, VersionBucket bucket) throws IOException {\n    long lastFoundVersion = 0;\n    TimeOut waitTimeout = new TimeOut(5, TimeUnit.SECONDS); \n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        Long lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n        lastFoundVersion = lookedUpVersion == null ? 0L: lookedUpVersion;\n\n        if (Math.abs(lastFoundVersion) < cmd.prevVersion) {\n          log.debug(\"Re-ordered inplace update. version={}, prevVersion={}, lastVersion={}, replayOrPeerSync={}, id={}\", \n              (cmd.getVersion() == 0 ? versionOnUpdate : cmd.getVersion()), cmd.prevVersion, lastFoundVersion, isReplayOrPeersync, cmd.getPrintableId());\n        }\n\n        while (Math.abs(lastFoundVersion) < cmd.prevVersion && !waitTimeout.hasTimedOut())  {\n          try {\n            long timeLeft = waitTimeout.timeLeft(TimeUnit.MILLISECONDS);\n            if (timeLeft > 0) { // wait(0) waits forever until notified, but we don't want that.\n              bucket.wait(timeLeft);\n            }\n          } catch (InterruptedException ie) {\n            throw new RuntimeException(ie);\n          }\n          lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          lastFoundVersion = lookedUpVersion == null ? 0L: lookedUpVersion;\n        }\n      }\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n\n    if (Math.abs(lastFoundVersion) > cmd.prevVersion) {\n      // This must've been the case due to a higher version full update succeeding concurrently, while we were waiting or\n      // trying to index this partial update. Since a full update more recent than this partial update has succeeded,\n      // we can drop the current update.\n      if (log.isDebugEnabled()) {\n        log.debug(\"Update was applied on version: {}, but last version I have is: {}\"\n            + \". Current update should be dropped. id={}\", cmd.prevVersion, lastFoundVersion, cmd.getPrintableId());\n      }\n      return -1;\n    } else if (Math.abs(lastFoundVersion) == cmd.prevVersion) {\n      assert 0 < lastFoundVersion : \"prevVersion \" + cmd.prevVersion + \" found but is a delete!\";\n      if (log.isDebugEnabled()) {\n        log.debug(\"Dependent update found. id={}\", cmd.getPrintableId());\n      }\n      return lastFoundVersion;\n    }\n\n    // We have waited enough, but dependent update didn't arrive. Its time to actively fetch it from leader\n    log.info(\"Missing update, on which current in-place update depends on, hasn't arrived. id={}, looking for version={}, last found version={}\", \n        cmd.getPrintableId(), cmd.prevVersion, lastFoundVersion);\n    \n    UpdateCommand missingUpdate = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n    if (missingUpdate instanceof DeleteUpdateCommand) {\n      log.info(\"Tried to fetch document {} from the leader, but the leader says document has been deleted. \" \n          + \"Deleting the document here and skipping this update: Last found version: {}, was looking for: {}\", cmd.getPrintableId(), lastFoundVersion, cmd.prevVersion);\n      versionDelete((DeleteUpdateCommand)missingUpdate);\n      return -1;\n    } else {\n      assert missingUpdate instanceof AddUpdateCommand;\n      log.debug(\"Fetched the document: {}\", ((AddUpdateCommand)missingUpdate).getSolrInputDocument());\n      versionAdd((AddUpdateCommand)missingUpdate);\n      log.info(\"Added the fetched document, id=\"+((AddUpdateCommand)missingUpdate).getPrintableId()+\", version=\"+missingUpdate.getVersion());\n    }\n    return missingUpdate.getVersion();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d65446e37ead9e278d9fd19ba6ac154a512916ea","date":1544107016,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#waitForDependentUpdates(AddUpdateCommand,long,boolean,VersionBucket).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#waitForDependentUpdates(AddUpdateCommand,long,boolean,VersionBucket).mjava","sourceNew":"  /**\n   * This method checks the update/transaction logs and index to find out if the update (\"previous update\") that the current update\n   * depends on (in the case that this current update is an in-place update) has already been completed. If not,\n   * this method will wait for the missing update until it has arrived. If it doesn't arrive within a timeout threshold,\n   * then this actively fetches from the leader.\n   * \n   * @return -1 if the current in-place should be dropped, or last found version if previous update has been indexed.\n   */\n  private long waitForDependentUpdates(AddUpdateCommand cmd, long versionOnUpdate,\n                               boolean isReplayOrPeersync, VersionBucket bucket) throws IOException {\n    long lastFoundVersion = 0;\n    TimeOut waitTimeout = new TimeOut(5, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        Long lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n        lastFoundVersion = lookedUpVersion == null ? 0L : lookedUpVersion;\n\n        if (Math.abs(lastFoundVersion) < cmd.prevVersion) {\n          log.debug(\"Re-ordered inplace update. version={}, prevVersion={}, lastVersion={}, replayOrPeerSync={}, id={}\",\n              (cmd.getVersion() == 0 ? versionOnUpdate : cmd.getVersion()), cmd.prevVersion, lastFoundVersion,\n              isReplayOrPeersync, cmd.getPrintableId());\n        }\n\n        while (Math.abs(lastFoundVersion) < cmd.prevVersion && !waitTimeout.hasTimedOut()) {\n          bucket.awaitNanos(waitTimeout.timeLeft(TimeUnit.NANOSECONDS));\n          lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          lastFoundVersion = lookedUpVersion == null ? 0L : lookedUpVersion;\n        }\n      } finally {\n\n        bucket.unlock();\n\n        vinfo.unlockForUpdate();\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n\n    if (Math.abs(lastFoundVersion) > cmd.prevVersion) {\n      // This must've been the case due to a higher version full update succeeding concurrently, while we were waiting or\n      // trying to index this partial update. Since a full update more recent than this partial update has succeeded,\n      // we can drop the current update.\n      if (log.isDebugEnabled()) {\n        log.debug(\"Update was applied on version: {}, but last version I have is: {}\"\n            + \". Current update should be dropped. id={}\", cmd.prevVersion, lastFoundVersion, cmd.getPrintableId());\n      }\n      return -1;\n    } else if (Math.abs(lastFoundVersion) == cmd.prevVersion) {\n      assert 0 < lastFoundVersion : \"prevVersion \" + cmd.prevVersion + \" found but is a delete!\";\n      if (log.isDebugEnabled()) {\n        log.debug(\"Dependent update found. id={}\", cmd.getPrintableId());\n      }\n      return lastFoundVersion;\n    }\n\n    // We have waited enough, but dependent update didn't arrive. Its time to actively fetch it from leader\n    log.info(\"Missing update, on which current in-place update depends on, hasn't arrived. id={}, looking for version={}, last found version={}\", \n        cmd.getPrintableId(), cmd.prevVersion, lastFoundVersion);\n    \n    UpdateCommand missingUpdate = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n    if (missingUpdate instanceof DeleteUpdateCommand) {\n      log.info(\"Tried to fetch document {} from the leader, but the leader says document has been deleted. \" \n          + \"Deleting the document here and skipping this update: Last found version: {}, was looking for: {}\", cmd.getPrintableId(), lastFoundVersion, cmd.prevVersion);\n      versionDelete((DeleteUpdateCommand)missingUpdate);\n      return -1;\n    } else {\n      assert missingUpdate instanceof AddUpdateCommand;\n      log.debug(\"Fetched the document: {}\", ((AddUpdateCommand)missingUpdate).getSolrInputDocument());\n      versionAdd((AddUpdateCommand)missingUpdate);\n      log.info(\"Added the fetched document, id=\"+((AddUpdateCommand)missingUpdate).getPrintableId()+\", version=\"+missingUpdate.getVersion());\n    }\n    return missingUpdate.getVersion();\n  }\n\n","sourceOld":"  /**\n   * This method checks the update/transaction logs and index to find out if the update (\"previous update\") that the current update\n   * depends on (in the case that this current update is an in-place update) has already been completed. If not,\n   * this method will wait for the missing update until it has arrived. If it doesn't arrive within a timeout threshold,\n   * then this actively fetches from the leader.\n   * \n   * @return -1 if the current in-place should be dropped, or last found version if previous update has been indexed.\n   */\n  private long waitForDependentUpdates(AddUpdateCommand cmd, long versionOnUpdate,\n                               boolean isReplayOrPeersync, VersionBucket bucket) throws IOException {\n    long lastFoundVersion = 0;\n    TimeOut waitTimeout = new TimeOut(5, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n\n    vinfo.lockForUpdate();\n    try {\n      synchronized (bucket) {\n        Long lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n        lastFoundVersion = lookedUpVersion == null ? 0L: lookedUpVersion;\n\n        if (Math.abs(lastFoundVersion) < cmd.prevVersion) {\n          log.debug(\"Re-ordered inplace update. version={}, prevVersion={}, lastVersion={}, replayOrPeerSync={}, id={}\", \n              (cmd.getVersion() == 0 ? versionOnUpdate : cmd.getVersion()), cmd.prevVersion, lastFoundVersion, isReplayOrPeersync, cmd.getPrintableId());\n        }\n\n        while (Math.abs(lastFoundVersion) < cmd.prevVersion && !waitTimeout.hasTimedOut())  {\n          try {\n            long timeLeft = waitTimeout.timeLeft(TimeUnit.MILLISECONDS);\n            if (timeLeft > 0) { // wait(0) waits forever until notified, but we don't want that.\n              bucket.wait(timeLeft);\n            }\n          } catch (InterruptedException ie) {\n            throw new RuntimeException(ie);\n          }\n          lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          lastFoundVersion = lookedUpVersion == null ? 0L: lookedUpVersion;\n        }\n      }\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n\n    if (Math.abs(lastFoundVersion) > cmd.prevVersion) {\n      // This must've been the case due to a higher version full update succeeding concurrently, while we were waiting or\n      // trying to index this partial update. Since a full update more recent than this partial update has succeeded,\n      // we can drop the current update.\n      if (log.isDebugEnabled()) {\n        log.debug(\"Update was applied on version: {}, but last version I have is: {}\"\n            + \". Current update should be dropped. id={}\", cmd.prevVersion, lastFoundVersion, cmd.getPrintableId());\n      }\n      return -1;\n    } else if (Math.abs(lastFoundVersion) == cmd.prevVersion) {\n      assert 0 < lastFoundVersion : \"prevVersion \" + cmd.prevVersion + \" found but is a delete!\";\n      if (log.isDebugEnabled()) {\n        log.debug(\"Dependent update found. id={}\", cmd.getPrintableId());\n      }\n      return lastFoundVersion;\n    }\n\n    // We have waited enough, but dependent update didn't arrive. Its time to actively fetch it from leader\n    log.info(\"Missing update, on which current in-place update depends on, hasn't arrived. id={}, looking for version={}, last found version={}\", \n        cmd.getPrintableId(), cmd.prevVersion, lastFoundVersion);\n    \n    UpdateCommand missingUpdate = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n    if (missingUpdate instanceof DeleteUpdateCommand) {\n      log.info(\"Tried to fetch document {} from the leader, but the leader says document has been deleted. \" \n          + \"Deleting the document here and skipping this update: Last found version: {}, was looking for: {}\", cmd.getPrintableId(), lastFoundVersion, cmd.prevVersion);\n      versionDelete((DeleteUpdateCommand)missingUpdate);\n      return -1;\n    } else {\n      assert missingUpdate instanceof AddUpdateCommand;\n      log.debug(\"Fetched the document: {}\", ((AddUpdateCommand)missingUpdate).getSolrInputDocument());\n      versionAdd((AddUpdateCommand)missingUpdate);\n      log.info(\"Added the fetched document, id=\"+((AddUpdateCommand)missingUpdate).getPrintableId()+\", version=\"+missingUpdate.getVersion());\n    }\n    return missingUpdate.getVersion();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9b3824fcbd3256db359391630ae05b3917ab369a","date":1556656304,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#waitForDependentUpdates(AddUpdateCommand,long,boolean,VersionBucket).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#waitForDependentUpdates(AddUpdateCommand,long,boolean,VersionBucket).mjava","sourceNew":"  /**\n   * This method checks the update/transaction logs and index to find out if the update (\"previous update\") that the current update\n   * depends on (in the case that this current update is an in-place update) has already been completed. If not,\n   * this method will wait for the missing update until it has arrived. If it doesn't arrive within a timeout threshold,\n   * then this actively fetches from the leader.\n   * \n   * @return -1 if the current in-place should be dropped, or last found version if previous update has been indexed.\n   */\n  private long waitForDependentUpdates(AddUpdateCommand cmd, long versionOnUpdate,\n                               boolean isReplayOrPeersync, VersionBucket bucket) throws IOException {\n    long lastFoundVersion = 0;\n    TimeOut waitTimeout = new TimeOut(5, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n\n    vinfo.lockForUpdate();\n    try {\n      lastFoundVersion = bucket.runWithLock(vinfo.getVersionBucketLockTimeoutMs(), () -> doWaitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket, waitTimeout));\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n\n    if (Math.abs(lastFoundVersion) > cmd.prevVersion) {\n      // This must've been the case due to a higher version full update succeeding concurrently, while we were waiting or\n      // trying to index this partial update. Since a full update more recent than this partial update has succeeded,\n      // we can drop the current update.\n      if (log.isDebugEnabled()) {\n        log.debug(\"Update was applied on version: {}, but last version I have is: {}\"\n            + \". Current update should be dropped. id={}\", cmd.prevVersion, lastFoundVersion, cmd.getPrintableId());\n      }\n      return -1;\n    } else if (Math.abs(lastFoundVersion) == cmd.prevVersion) {\n      assert 0 < lastFoundVersion : \"prevVersion \" + cmd.prevVersion + \" found but is a delete!\";\n      if (log.isDebugEnabled()) {\n        log.debug(\"Dependent update found. id={}\", cmd.getPrintableId());\n      }\n      return lastFoundVersion;\n    }\n\n    // We have waited enough, but dependent update didn't arrive. Its time to actively fetch it from leader\n    log.info(\"Missing update, on which current in-place update depends on, hasn't arrived. id={}, looking for version={}, last found version={}\", \n        cmd.getPrintableId(), cmd.prevVersion, lastFoundVersion);\n    \n    UpdateCommand missingUpdate = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n    if (missingUpdate instanceof DeleteUpdateCommand) {\n      log.info(\"Tried to fetch document {} from the leader, but the leader says document has been deleted. \" \n          + \"Deleting the document here and skipping this update: Last found version: {}, was looking for: {}\", cmd.getPrintableId(), lastFoundVersion, cmd.prevVersion);\n      versionDelete((DeleteUpdateCommand)missingUpdate);\n      return -1;\n    } else {\n      assert missingUpdate instanceof AddUpdateCommand;\n      log.debug(\"Fetched the document: {}\", ((AddUpdateCommand)missingUpdate).getSolrInputDocument());\n      versionAdd((AddUpdateCommand)missingUpdate);\n      log.info(\"Added the fetched document, id=\"+((AddUpdateCommand)missingUpdate).getPrintableId()+\", version=\"+missingUpdate.getVersion());\n    }\n    return missingUpdate.getVersion();\n  }\n\n","sourceOld":"  /**\n   * This method checks the update/transaction logs and index to find out if the update (\"previous update\") that the current update\n   * depends on (in the case that this current update is an in-place update) has already been completed. If not,\n   * this method will wait for the missing update until it has arrived. If it doesn't arrive within a timeout threshold,\n   * then this actively fetches from the leader.\n   * \n   * @return -1 if the current in-place should be dropped, or last found version if previous update has been indexed.\n   */\n  private long waitForDependentUpdates(AddUpdateCommand cmd, long versionOnUpdate,\n                               boolean isReplayOrPeersync, VersionBucket bucket) throws IOException {\n    long lastFoundVersion = 0;\n    TimeOut waitTimeout = new TimeOut(5, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        Long lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n        lastFoundVersion = lookedUpVersion == null ? 0L : lookedUpVersion;\n\n        if (Math.abs(lastFoundVersion) < cmd.prevVersion) {\n          log.debug(\"Re-ordered inplace update. version={}, prevVersion={}, lastVersion={}, replayOrPeerSync={}, id={}\",\n              (cmd.getVersion() == 0 ? versionOnUpdate : cmd.getVersion()), cmd.prevVersion, lastFoundVersion,\n              isReplayOrPeersync, cmd.getPrintableId());\n        }\n\n        while (Math.abs(lastFoundVersion) < cmd.prevVersion && !waitTimeout.hasTimedOut()) {\n          bucket.awaitNanos(waitTimeout.timeLeft(TimeUnit.NANOSECONDS));\n          lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          lastFoundVersion = lookedUpVersion == null ? 0L : lookedUpVersion;\n        }\n      } finally {\n\n        bucket.unlock();\n\n        vinfo.unlockForUpdate();\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n\n    if (Math.abs(lastFoundVersion) > cmd.prevVersion) {\n      // This must've been the case due to a higher version full update succeeding concurrently, while we were waiting or\n      // trying to index this partial update. Since a full update more recent than this partial update has succeeded,\n      // we can drop the current update.\n      if (log.isDebugEnabled()) {\n        log.debug(\"Update was applied on version: {}, but last version I have is: {}\"\n            + \". Current update should be dropped. id={}\", cmd.prevVersion, lastFoundVersion, cmd.getPrintableId());\n      }\n      return -1;\n    } else if (Math.abs(lastFoundVersion) == cmd.prevVersion) {\n      assert 0 < lastFoundVersion : \"prevVersion \" + cmd.prevVersion + \" found but is a delete!\";\n      if (log.isDebugEnabled()) {\n        log.debug(\"Dependent update found. id={}\", cmd.getPrintableId());\n      }\n      return lastFoundVersion;\n    }\n\n    // We have waited enough, but dependent update didn't arrive. Its time to actively fetch it from leader\n    log.info(\"Missing update, on which current in-place update depends on, hasn't arrived. id={}, looking for version={}, last found version={}\", \n        cmd.getPrintableId(), cmd.prevVersion, lastFoundVersion);\n    \n    UpdateCommand missingUpdate = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n    if (missingUpdate instanceof DeleteUpdateCommand) {\n      log.info(\"Tried to fetch document {} from the leader, but the leader says document has been deleted. \" \n          + \"Deleting the document here and skipping this update: Last found version: {}, was looking for: {}\", cmd.getPrintableId(), lastFoundVersion, cmd.prevVersion);\n      versionDelete((DeleteUpdateCommand)missingUpdate);\n      return -1;\n    } else {\n      assert missingUpdate instanceof AddUpdateCommand;\n      log.debug(\"Fetched the document: {}\", ((AddUpdateCommand)missingUpdate).getSolrInputDocument());\n      versionAdd((AddUpdateCommand)missingUpdate);\n      log.info(\"Added the fetched document, id=\"+((AddUpdateCommand)missingUpdate).getPrintableId()+\", version=\"+missingUpdate.getVersion());\n    }\n    return missingUpdate.getVersion();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#waitForDependentUpdates(AddUpdateCommand,long,boolean,VersionBucket).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#waitForDependentUpdates(AddUpdateCommand,long,boolean,VersionBucket).mjava","sourceNew":"  /**\n   * This method checks the update/transaction logs and index to find out if the update (\"previous update\") that the current update\n   * depends on (in the case that this current update is an in-place update) has already been completed. If not,\n   * this method will wait for the missing update until it has arrived. If it doesn't arrive within a timeout threshold,\n   * then this actively fetches from the leader.\n   * \n   * @return -1 if the current in-place should be dropped, or last found version if previous update has been indexed.\n   */\n  private long waitForDependentUpdates(AddUpdateCommand cmd, long versionOnUpdate,\n                               boolean isReplayOrPeersync, VersionBucket bucket) throws IOException {\n    long lastFoundVersion = 0;\n    TimeOut waitTimeout = new TimeOut(5, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n\n    vinfo.lockForUpdate();\n    try {\n      lastFoundVersion = bucket.runWithLock(vinfo.getVersionBucketLockTimeoutMs(), () -> doWaitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket, waitTimeout));\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n\n    if (Math.abs(lastFoundVersion) > cmd.prevVersion) {\n      // This must've been the case due to a higher version full update succeeding concurrently, while we were waiting or\n      // trying to index this partial update. Since a full update more recent than this partial update has succeeded,\n      // we can drop the current update.\n      if (log.isDebugEnabled()) {\n        log.debug(\"Update was applied on version: {}, but last version I have is: {}\"\n            + \". Current update should be dropped. id={}\", cmd.prevVersion, lastFoundVersion, cmd.getPrintableId());\n      }\n      return -1;\n    } else if (Math.abs(lastFoundVersion) == cmd.prevVersion) {\n      assert 0 < lastFoundVersion : \"prevVersion \" + cmd.prevVersion + \" found but is a delete!\";\n      if (log.isDebugEnabled()) {\n        log.debug(\"Dependent update found. id={}\", cmd.getPrintableId());\n      }\n      return lastFoundVersion;\n    }\n\n    // We have waited enough, but dependent update didn't arrive. Its time to actively fetch it from leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Missing update, on which current in-place update depends on, hasn't arrived. id={}, looking for version={}, last found version={}\",\n          cmd.getPrintableId(), cmd.prevVersion, lastFoundVersion);\n    }\n    \n    UpdateCommand missingUpdate = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n    if (missingUpdate instanceof DeleteUpdateCommand) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Tried to fetch document {} from the leader, but the leader says document has been deleted. \"\n            + \"Deleting the document here and skipping this update: Last found version: {}, was looking for: {}\", cmd.getPrintableId(), lastFoundVersion, cmd.prevVersion);\n        versionDelete((DeleteUpdateCommand) missingUpdate);\n      }\n      return -1;\n    } else {\n      assert missingUpdate instanceof AddUpdateCommand;\n      if (log.isDebugEnabled()) {\n        log.debug(\"Fetched the document: {}\", ((AddUpdateCommand) missingUpdate).getSolrInputDocument());\n      }\n      versionAdd((AddUpdateCommand)missingUpdate);\n      if (log.isInfoEnabled()) {\n        log.info(\"Added the fetched document, id= {}, version={}\"\n            , ((AddUpdateCommand) missingUpdate).getPrintableId(), missingUpdate.getVersion());\n      }\n    }\n    return missingUpdate.getVersion();\n  }\n\n","sourceOld":"  /**\n   * This method checks the update/transaction logs and index to find out if the update (\"previous update\") that the current update\n   * depends on (in the case that this current update is an in-place update) has already been completed. If not,\n   * this method will wait for the missing update until it has arrived. If it doesn't arrive within a timeout threshold,\n   * then this actively fetches from the leader.\n   * \n   * @return -1 if the current in-place should be dropped, or last found version if previous update has been indexed.\n   */\n  private long waitForDependentUpdates(AddUpdateCommand cmd, long versionOnUpdate,\n                               boolean isReplayOrPeersync, VersionBucket bucket) throws IOException {\n    long lastFoundVersion = 0;\n    TimeOut waitTimeout = new TimeOut(5, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n\n    vinfo.lockForUpdate();\n    try {\n      lastFoundVersion = bucket.runWithLock(vinfo.getVersionBucketLockTimeoutMs(), () -> doWaitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket, waitTimeout));\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n\n    if (Math.abs(lastFoundVersion) > cmd.prevVersion) {\n      // This must've been the case due to a higher version full update succeeding concurrently, while we were waiting or\n      // trying to index this partial update. Since a full update more recent than this partial update has succeeded,\n      // we can drop the current update.\n      if (log.isDebugEnabled()) {\n        log.debug(\"Update was applied on version: {}, but last version I have is: {}\"\n            + \". Current update should be dropped. id={}\", cmd.prevVersion, lastFoundVersion, cmd.getPrintableId());\n      }\n      return -1;\n    } else if (Math.abs(lastFoundVersion) == cmd.prevVersion) {\n      assert 0 < lastFoundVersion : \"prevVersion \" + cmd.prevVersion + \" found but is a delete!\";\n      if (log.isDebugEnabled()) {\n        log.debug(\"Dependent update found. id={}\", cmd.getPrintableId());\n      }\n      return lastFoundVersion;\n    }\n\n    // We have waited enough, but dependent update didn't arrive. Its time to actively fetch it from leader\n    log.info(\"Missing update, on which current in-place update depends on, hasn't arrived. id={}, looking for version={}, last found version={}\", \n        cmd.getPrintableId(), cmd.prevVersion, lastFoundVersion);\n    \n    UpdateCommand missingUpdate = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n    if (missingUpdate instanceof DeleteUpdateCommand) {\n      log.info(\"Tried to fetch document {} from the leader, but the leader says document has been deleted. \" \n          + \"Deleting the document here and skipping this update: Last found version: {}, was looking for: {}\", cmd.getPrintableId(), lastFoundVersion, cmd.prevVersion);\n      versionDelete((DeleteUpdateCommand)missingUpdate);\n      return -1;\n    } else {\n      assert missingUpdate instanceof AddUpdateCommand;\n      log.debug(\"Fetched the document: {}\", ((AddUpdateCommand)missingUpdate).getSolrInputDocument());\n      versionAdd((AddUpdateCommand)missingUpdate);\n      log.info(\"Added the fetched document, id=\"+((AddUpdateCommand)missingUpdate).getPrintableId()+\", version=\"+missingUpdate.getVersion());\n    }\n    return missingUpdate.getVersion();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#waitForDependentUpdates(AddUpdateCommand,long,boolean,VersionBucket).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#waitForDependentUpdates(AddUpdateCommand,long,boolean,VersionBucket).mjava","sourceNew":"  /**\n   * This method checks the update/transaction logs and index to find out if the update (\"previous update\") that the current update\n   * depends on (in the case that this current update is an in-place update) has already been completed. If not,\n   * this method will wait for the missing update until it has arrived. If it doesn't arrive within a timeout threshold,\n   * then this actively fetches from the leader.\n   * \n   * @return -1 if the current in-place should be dropped, or last found version if previous update has been indexed.\n   */\n  private long waitForDependentUpdates(AddUpdateCommand cmd, long versionOnUpdate,\n                               boolean isReplayOrPeersync, VersionBucket bucket) throws IOException {\n    long lastFoundVersion = 0;\n    TimeOut waitTimeout = new TimeOut(5, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n\n    vinfo.lockForUpdate();\n    try {\n      lastFoundVersion = bucket.runWithLock(vinfo.getVersionBucketLockTimeoutMs(), () -> doWaitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket, waitTimeout));\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n\n    if (Math.abs(lastFoundVersion) > cmd.prevVersion) {\n      // This must've been the case due to a higher version full update succeeding concurrently, while we were waiting or\n      // trying to index this partial update. Since a full update more recent than this partial update has succeeded,\n      // we can drop the current update.\n      if (log.isDebugEnabled()) {\n        log.debug(\"Update was applied on version: {}, but last version I have is: {} . Current update should be dropped. id={}\"\n            , cmd.prevVersion, lastFoundVersion, cmd.getPrintableId());\n      }\n      return -1;\n    } else if (Math.abs(lastFoundVersion) == cmd.prevVersion) {\n      assert 0 < lastFoundVersion : \"prevVersion \" + cmd.prevVersion + \" found but is a delete!\";\n      if (log.isDebugEnabled()) {\n        log.debug(\"Dependent update found. id={}\", cmd.getPrintableId());\n      }\n      return lastFoundVersion;\n    }\n\n    // We have waited enough, but dependent update didn't arrive. Its time to actively fetch it from leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Missing update, on which current in-place update depends on, hasn't arrived. id={}, looking for version={}, last found version={}\",\n          cmd.getPrintableId(), cmd.prevVersion, lastFoundVersion);\n    }\n    \n    UpdateCommand missingUpdate = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n    if (missingUpdate instanceof DeleteUpdateCommand) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Tried to fetch document {} from the leader, but the leader says document has been deleted. Deleting the document here and skipping this update: Last found version: {}, was looking for: {}\"\n            , cmd.getPrintableId(), lastFoundVersion, cmd.prevVersion);\n      }\n      versionDelete((DeleteUpdateCommand) missingUpdate);\n      return -1;\n    } else {\n      assert missingUpdate instanceof AddUpdateCommand;\n      if (log.isDebugEnabled()) {\n        log.debug(\"Fetched the document: {}\", ((AddUpdateCommand) missingUpdate).getSolrInputDocument());\n      }\n      versionAdd((AddUpdateCommand)missingUpdate);\n      if (log.isInfoEnabled()) {\n        log.info(\"Added the fetched document, id= {}, version={}\"\n            , ((AddUpdateCommand) missingUpdate).getPrintableId(), missingUpdate.getVersion());\n      }\n    }\n    return missingUpdate.getVersion();\n  }\n\n","sourceOld":"  /**\n   * This method checks the update/transaction logs and index to find out if the update (\"previous update\") that the current update\n   * depends on (in the case that this current update is an in-place update) has already been completed. If not,\n   * this method will wait for the missing update until it has arrived. If it doesn't arrive within a timeout threshold,\n   * then this actively fetches from the leader.\n   * \n   * @return -1 if the current in-place should be dropped, or last found version if previous update has been indexed.\n   */\n  private long waitForDependentUpdates(AddUpdateCommand cmd, long versionOnUpdate,\n                               boolean isReplayOrPeersync, VersionBucket bucket) throws IOException {\n    long lastFoundVersion = 0;\n    TimeOut waitTimeout = new TimeOut(5, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n\n    vinfo.lockForUpdate();\n    try {\n      lastFoundVersion = bucket.runWithLock(vinfo.getVersionBucketLockTimeoutMs(), () -> doWaitForDependentUpdates(cmd, versionOnUpdate, isReplayOrPeersync, bucket, waitTimeout));\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n\n    if (Math.abs(lastFoundVersion) > cmd.prevVersion) {\n      // This must've been the case due to a higher version full update succeeding concurrently, while we were waiting or\n      // trying to index this partial update. Since a full update more recent than this partial update has succeeded,\n      // we can drop the current update.\n      if (log.isDebugEnabled()) {\n        log.debug(\"Update was applied on version: {}, but last version I have is: {}\"\n            + \". Current update should be dropped. id={}\", cmd.prevVersion, lastFoundVersion, cmd.getPrintableId());\n      }\n      return -1;\n    } else if (Math.abs(lastFoundVersion) == cmd.prevVersion) {\n      assert 0 < lastFoundVersion : \"prevVersion \" + cmd.prevVersion + \" found but is a delete!\";\n      if (log.isDebugEnabled()) {\n        log.debug(\"Dependent update found. id={}\", cmd.getPrintableId());\n      }\n      return lastFoundVersion;\n    }\n\n    // We have waited enough, but dependent update didn't arrive. Its time to actively fetch it from leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Missing update, on which current in-place update depends on, hasn't arrived. id={}, looking for version={}, last found version={}\",\n          cmd.getPrintableId(), cmd.prevVersion, lastFoundVersion);\n    }\n    \n    UpdateCommand missingUpdate = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n    if (missingUpdate instanceof DeleteUpdateCommand) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Tried to fetch document {} from the leader, but the leader says document has been deleted. \"\n            + \"Deleting the document here and skipping this update: Last found version: {}, was looking for: {}\", cmd.getPrintableId(), lastFoundVersion, cmd.prevVersion);\n        versionDelete((DeleteUpdateCommand) missingUpdate);\n      }\n      return -1;\n    } else {\n      assert missingUpdate instanceof AddUpdateCommand;\n      if (log.isDebugEnabled()) {\n        log.debug(\"Fetched the document: {}\", ((AddUpdateCommand) missingUpdate).getSolrInputDocument());\n      }\n      versionAdd((AddUpdateCommand)missingUpdate);\n      if (log.isInfoEnabled()) {\n        log.info(\"Added the fetched document, id= {}, version={}\"\n            , ((AddUpdateCommand) missingUpdate).getPrintableId(), missingUpdate.getVersion());\n      }\n    }\n    return missingUpdate.getVersion();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9b3824fcbd3256db359391630ae05b3917ab369a":["d65446e37ead9e278d9fd19ba6ac154a512916ea"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","415bbbe7da8065dd3c477bdc3c703c6425622998"],"740d649f013f07efbeb73ca854f106c60166e7c0":["9b3824fcbd3256db359391630ae05b3917ab369a"],"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"575e66bd4b2349209027f6801184da7fc3cba13f":["740d649f013f07efbeb73ca854f106c60166e7c0"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["c2795aeb0b4c10d1588f672d3d5ac7a394fc8461"],"d65446e37ead9e278d9fd19ba6ac154a512916ea":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["575e66bd4b2349209027f6801184da7fc3cba13f"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","c2795aeb0b4c10d1588f672d3d5ac7a394fc8461"],"9b3824fcbd3256db359391630ae05b3917ab369a":["740d649f013f07efbeb73ca854f106c60166e7c0"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"740d649f013f07efbeb73ca854f106c60166e7c0":["575e66bd4b2349209027f6801184da7fc3cba13f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"c2795aeb0b4c10d1588f672d3d5ac7a394fc8461":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"575e66bd4b2349209027f6801184da7fc3cba13f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["d65446e37ead9e278d9fd19ba6ac154a512916ea"],"d65446e37ead9e278d9fd19ba6ac154a512916ea":["9b3824fcbd3256db359391630ae05b3917ab369a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}