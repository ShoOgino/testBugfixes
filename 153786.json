{"path":"modules/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","commits":[{"id":"bede0ec3497c48e70d55196c5065d97a4bc1db3d","date":1329668585,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"modules/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    TermFreq[] keys = new TermFreq[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random.nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new TermFreq(s, (float) weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new TermFreqArrayIterator(keys));\n    \n    for (String prefix : allPrefixes) {\n    \n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(prefix, false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), (float)e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.key.compareTo(right.key);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key, r.get(hit).key);\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6ecc52400551de6a7d8daf646be839487911627c","date":1330076979,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"modules/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","pathOld":"modules/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    TermFreq[] keys = new TermFreq[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random.nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new TermFreq(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new TermFreqArrayIterator(keys));\n    \n    for (String prefix : allPrefixes) {\n    \n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(_TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), (float)e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    TermFreq[] keys = new TermFreq[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random.nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new TermFreq(s, (float) weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new TermFreqArrayIterator(keys));\n    \n    for (String prefix : allPrefixes) {\n    \n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(prefix, false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), (float)e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.key.compareTo(right.key);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key, r.get(hit).key);\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dc3c850c5222a1ce7d619563f67bf047a11b32b6","date":1330703995,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"modules/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","pathOld":"modules/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    TermFreq[] keys = new TermFreq[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random.nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new TermFreq(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new TermFreqArrayIterator(keys));\n    \n    for (String prefix : allPrefixes) {\n    \n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(_TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    TermFreq[] keys = new TermFreq[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random.nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new TermFreq(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new TermFreqArrayIterator(keys));\n    \n    for (String prefix : allPrefixes) {\n    \n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(_TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), (float)e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"modules/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","pathOld":"modules/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    TermFreq[] keys = new TermFreq[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random.nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new TermFreq(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new TermFreqArrayIterator(keys));\n    \n    for (String prefix : allPrefixes) {\n    \n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(_TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    TermFreq[] keys = new TermFreq[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random.nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new TermFreq(s, (float) weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new TermFreqArrayIterator(keys));\n    \n    for (String prefix : allPrefixes) {\n    \n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(prefix, false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), (float)e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.key.compareTo(right.key);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key, r.get(hit).key);\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"modules/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","pathOld":"modules/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    TermFreq[] keys = new TermFreq[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new TermFreq(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new TermFreqArrayIterator(keys));\n\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(_TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    TermFreq[] keys = new TermFreq[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random);\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random.nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new TermFreq(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new TermFreqArrayIterator(keys));\n    \n    for (String prefix : allPrefixes) {\n    \n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(_TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","pathOld":"modules/suggest/src/test/org/apache/lucene/search/suggest/fst/WFSTCompletionTest#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    TermFreq[] keys = new TermFreq[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new TermFreq(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new TermFreqArrayIterator(keys));\n\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(_TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    int numWords = atLeast(1000);\n    \n    final TreeMap<String,Long> slowCompletor = new TreeMap<String,Long>();\n    final TreeSet<String> allPrefixes = new TreeSet<String>();\n    \n    TermFreq[] keys = new TermFreq[numWords];\n    \n    for (int i = 0; i < numWords; i++) {\n      String s;\n      while (true) {\n        // TODO: would be nice to fix this slowCompletor/comparator to\n        // use full range, but we might lose some coverage too...\n        s = _TestUtil.randomSimpleString(random());\n        if (!slowCompletor.containsKey(s)) {\n          break;\n        }\n      }\n      \n      for (int j = 1; j < s.length(); j++) {\n        allPrefixes.add(s.substring(0, j));\n      }\n      // we can probably do Integer.MAX_VALUE here, but why worry.\n      int weight = random().nextInt(1<<24);\n      slowCompletor.put(s, (long)weight);\n      keys[i] = new TermFreq(s, weight);\n    }\n\n    WFSTCompletionLookup suggester = new WFSTCompletionLookup(false);\n    suggester.build(new TermFreqArrayIterator(keys));\n\n    Random random = new Random(random().nextLong());\n    for (String prefix : allPrefixes) {\n      final int topN = _TestUtil.nextInt(random, 1, 10);\n      List<LookupResult> r = suggester.lookup(_TestUtil.stringToCharSequence(prefix, random), false, topN);\n\n      // 2. go thru whole treemap (slowCompletor) and check its actually the best suggestion\n      final List<LookupResult> matches = new ArrayList<LookupResult>();\n\n      // TODO: could be faster... but its slowCompletor for a reason\n      for (Map.Entry<String,Long> e : slowCompletor.entrySet()) {\n        if (e.getKey().startsWith(prefix)) {\n          matches.add(new LookupResult(e.getKey(), e.getValue().longValue()));\n        }\n      }\n\n      assertTrue(matches.size() > 0);\n      Collections.sort(matches, new Comparator<LookupResult>() {\n        public int compare(LookupResult left, LookupResult right) {\n          int cmp = Float.compare(right.value, left.value);\n          if (cmp == 0) {\n            return left.compareTo(right);\n          } else {\n            return cmp;\n          }\n        }\n      });\n      if (matches.size() > topN) {\n        matches.subList(topN, matches.size()).clear();\n      }\n\n      assertEquals(matches.size(), r.size());\n\n      for(int hit=0;hit<r.size();hit++) {\n        //System.out.println(\"  check hit \" + hit);\n        assertEquals(matches.get(hit).key.toString(), r.get(hit).key.toString());\n        assertEquals(matches.get(hit).value, r.get(hit).value, 0f);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["bede0ec3497c48e70d55196c5065d97a4bc1db3d","dc3c850c5222a1ce7d619563f67bf047a11b32b6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6ecc52400551de6a7d8daf646be839487911627c":["bede0ec3497c48e70d55196c5065d97a4bc1db3d"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["dc3c850c5222a1ce7d619563f67bf047a11b32b6"],"dc3c850c5222a1ce7d619563f67bf047a11b32b6":["6ecc52400551de6a7d8daf646be839487911627c"],"bede0ec3497c48e70d55196c5065d97a4bc1db3d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bede0ec3497c48e70d55196c5065d97a4bc1db3d"],"6ecc52400551de6a7d8daf646be839487911627c":["dc3c850c5222a1ce7d619563f67bf047a11b32b6"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"dc3c850c5222a1ce7d619563f67bf047a11b32b6":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"bede0ec3497c48e70d55196c5065d97a4bc1db3d":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","6ecc52400551de6a7d8daf646be839487911627c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}