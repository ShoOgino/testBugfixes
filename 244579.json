{"path":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","commits":[{"id":"2c30e4c1cee08b3b229a77991882594fe7250b66","date":1344448871,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"/dev/null","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AbstractDistributedZkTestCase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa64435b5902ce266c23755a4a00691a3285dab8","date":1347243290,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,ZkNodeProps> shards = entry.getValue().getShards();\n        for (Map.Entry<String,ZkNodeProps> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().get(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().get(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().get(\n                  ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e19067e820b148e8dc0b240da4f2771cf7b68252","date":1347730768,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e97ea29d4c70fa0eaf3167b0495c28516d91fee0","date":1351447463,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out\n          .println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            printLayout();\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad4a95e4e24f12ea4dad18db456c92edd64fca4e","date":1351468815,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out\n          .println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Map<Thread,StackTraceElement[]> stackTraces = Thread.getAllStackTraces();\n            for (Map.Entry<Thread,StackTraceElement[]>  entry : stackTraces.entrySet()) {\n              System.out.println(\"\");\n              System.out.println(entry.getKey().toString());\n              for (StackTraceElement st : entry.getValue()) {\n                System.out.println(st);\n              }\n            }\n            printLayout();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out\n          .println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            printLayout();\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out\n          .println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Map<Thread,StackTraceElement[]> stackTraces = Thread.getAllStackTraces();\n            for (Map.Entry<Thread,StackTraceElement[]>  entry : stackTraces.entrySet()) {\n              System.out.println(\"\");\n              System.out.println(entry.getKey().toString());\n              for (StackTraceElement st : entry.getValue()) {\n                System.out.println(st);\n              }\n            }\n            printLayout();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (failOnTimeout) {\n            fail(\"There are still nodes recoverying\");\n            printLayout();\n            return;\n          }\n          if (verbose) System.out\n              .println(\"gave up waiting for recovery to finish..\");\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5a558d54519c651068ddb202f03befefb1514a7","date":1354382006,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out\n          .println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Map<Thread,StackTraceElement[]> stackTraces = Thread.getAllStackTraces();\n            for (Map.Entry<Thread,StackTraceElement[]>  entry : stackTraces.entrySet()) {\n              System.out.println(\"\");\n              System.out.println(entry.getKey().toString());\n              for (StackTraceElement st : entry.getValue()) {\n                System.out.println(st);\n              }\n            }\n            printLayout();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out\n          .println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Map<Thread,StackTraceElement[]> stackTraces = Thread.getAllStackTraces();\n            for (Map.Entry<Thread,StackTraceElement[]>  entry : stackTraces.entrySet()) {\n              System.out.println(\"\");\n              System.out.println(entry.getKey().toString());\n              for (StackTraceElement st : entry.getValue()) {\n                System.out.println(st);\n              }\n            }\n            printLayout();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":["344b0840364d990b29b97467bfcc766ff8325d11"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e7754464847b06ced605515bd48219280ede29e9","date":1354586462,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out\n          .println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Map<Thread,StackTraceElement[]> stackTraces = Thread.getAllStackTraces();\n            for (Map.Entry<Thread,StackTraceElement[]>  entry : stackTraces.entrySet()) {\n              System.out.println(\"\");\n              System.out.println(entry.getKey().toString());\n              for (StackTraceElement st : entry.getValue()) {\n                System.out.println(st);\n              }\n            }\n            printLayout();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out\n          .println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Map<Thread,StackTraceElement[]> stackTraces = Thread.getAllStackTraces();\n            for (Map.Entry<Thread,StackTraceElement[]>  entry : stackTraces.entrySet()) {\n              System.out.println(\"\");\n              System.out.println(entry.getKey().toString());\n              for (StackTraceElement st : entry.getValue()) {\n                System.out.println(st);\n              }\n            }\n            printLayout();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out\n          .println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Map<Thread,StackTraceElement[]> stackTraces = Thread.getAllStackTraces();\n            for (Map.Entry<Thread,StackTraceElement[]>  entry : stackTraces.entrySet()) {\n              System.out.println(\"\");\n              System.out.println(entry.getKey().toString());\n              for (StackTraceElement st : entry.getValue()) {\n                System.out.println(st);\n              }\n            }\n            printLayout();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlices(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out\n          .println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Map<Thread,StackTraceElement[]> stackTraces = Thread.getAllStackTraces();\n            for (Map.Entry<Thread,StackTraceElement[]>  entry : stackTraces.entrySet()) {\n              System.out.println(\"\");\n              System.out.println(entry.getKey().toString());\n              for (StackTraceElement st : entry.getValue()) {\n                System.out.println(st);\n              }\n            }\n            printLayout();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e08e84a194bcd52c44aefc809195617e1188bf25","date":1357178686,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            printLayout();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out\n          .println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Map<Thread,StackTraceElement[]> stackTraces = Thread.getAllStackTraces();\n            for (Map.Entry<Thread,StackTraceElement[]>  entry : stackTraces.entrySet()) {\n              System.out.println(\"\");\n              System.out.println(entry.getKey().toString());\n              for (StackTraceElement st : entry.getValue()) {\n                System.out.println(st);\n              }\n            }\n            printLayout();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            printLayout();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out\n          .println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Map<Thread,StackTraceElement[]> stackTraces = Thread.getAllStackTraces();\n            for (Map.Entry<Thread,StackTraceElement[]>  entry : stackTraces.entrySet()) {\n              System.out.println(\"\");\n              System.out.println(entry.getKey().toString());\n              for (StackTraceElement st : entry.getValue()) {\n                System.out.println(st);\n              }\n            }\n            printLayout();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"849494cf2f3a96af5c8c84995108ddd8456fcd04","date":1372277913,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            printLayout();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            printLayout();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            printLayout();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP)));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            printLayout();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dcb5de84d260a8919bf0f2d4d180df543a2ad07a","date":1381378233,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            printLayout();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            printLayout();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1fc56848da7b3f927bb9840e8aedf09ee11cede1","date":1424871235,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            zkStateReader.getZkClient().printLayoutToStdOut();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            printLayout();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            zkStateReader.getZkClient().printLayoutToStdOut();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","sourceOld":"  protected void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            printLayout();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          final Replica.State state = shard.getValue().getState();\n          if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN)\n              && clusterState.liveNodesContain(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            zkStateReader.getZkClient().printLayoutToStdOut();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","sourceOld":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          String state = shard.getValue().getStr(ZkStateReader.STATE_PROP);\n          if ((state.equals(ZkStateReader.RECOVERING) || state\n              .equals(ZkStateReader.SYNC) || state.equals(ZkStateReader.DOWN))\n              && clusterState.liveNodesContain(shard.getValue().getStr(\n              ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            zkStateReader.getZkClient().printLayoutToStdOut();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"102da6baafc0f534a59f31729343dbab9d3b9e9a","date":1438410244,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          final Replica.State state = shard.getValue().getState();\n          if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN)\n              && clusterState.liveNodesContain(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            zkStateReader.getZkClient().printLayoutToStdOut();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","sourceOld":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState(true);\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          final Replica.State state = shard.getValue().getState();\n          if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN)\n              && clusterState.liveNodesContain(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            zkStateReader.getZkClient().printLayoutToStdOut();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"536b47681314488eb94706248be6047a3f142841","date":1450372090,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          final Replica.State state = shard.getValue().getState();\n          if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN || state == Replica.State.RECOVERY_FAILED)\n              && clusterState.liveNodesContain(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            zkStateReader.getZkClient().printLayoutToStdOut();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","sourceOld":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          final Replica.State state = shard.getValue().getState();\n          if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN)\n              && clusterState.liveNodesContain(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            zkStateReader.getZkClient().printLayoutToStdOut();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","date":1457343183,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          final Replica.State state = shard.getValue().getState();\n          if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN || state == Replica.State.RECOVERY_FAILED)\n              && clusterState.liveNodesContain(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            zkStateReader.getZkClient().printLayoutToStdOut();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","sourceOld":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      zkStateReader.updateClusterState();\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          final Replica.State state = shard.getValue().getState();\n          if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN || state == Replica.State.RECOVERY_FAILED)\n              && clusterState.liveNodesContain(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            zkStateReader.getZkClient().printLayoutToStdOut();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5c99ad021f3da085fcb66220598a8f91dc5e453","date":1462242046,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Slice slice = entry.getValue();\n        if (slice.getState() == Slice.State.CONSTRUCTION) { // similar to replica recovering; pretend its the same thing\n          if (verbose) System.out.println(\"Found a slice in construction state; will wait.\");\n          sawLiveRecovering = true;\n        }\n        Map<String,Replica> shards = slice.getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          final Replica.State state = shard.getValue().getState();\n          if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN || state == Replica.State.RECOVERY_FAILED)\n              && clusterState.liveNodesContain(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            zkStateReader.getZkClient().printLayoutToStdOut();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","sourceOld":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          final Replica.State state = shard.getValue().getState();\n          if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN || state == Replica.State.RECOVERY_FAILED)\n              && clusterState.liveNodesContain(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            zkStateReader.getZkClient().printLayoutToStdOut();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1c7a21395bae9e2f61aeb639f47aaca771c426ed","date":1462255690,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Slice slice = entry.getValue();\n        if (slice.getState() == Slice.State.CONSTRUCTION) { // similar to replica recovering; pretend its the same thing\n          if (verbose) System.out.println(\"Found a slice in construction state; will wait.\");\n          sawLiveRecovering = true;\n        }\n        Map<String,Replica> shards = slice.getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          final Replica.State state = shard.getValue().getState();\n          if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN || state == Replica.State.RECOVERY_FAILED)\n              && clusterState.liveNodesContain(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            zkStateReader.getZkClient().printLayoutToStdOut();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","sourceOld":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          final Replica.State state = shard.getValue().getState();\n          if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN || state == Replica.State.RECOVERY_FAILED)\n              && clusterState.liveNodesContain(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            zkStateReader.getZkClient().printLayoutToStdOut();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55b50463286869f584cf849d1587a0fcd54d1dfa","date":1462378517,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Slice slice = entry.getValue();\n        if (slice.getState() == Slice.State.CONSTRUCTION) { // similar to replica recovering; pretend its the same thing\n          if (verbose) System.out.println(\"Found a slice in construction state; will wait.\");\n          sawLiveRecovering = true;\n        }\n        Map<String,Replica> shards = slice.getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          final Replica.State state = shard.getValue().getState();\n          if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN || state == Replica.State.RECOVERY_FAILED)\n              && clusterState.liveNodesContain(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            zkStateReader.getZkClient().printLayoutToStdOut();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","sourceOld":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Map<String,Replica> shards = entry.getValue().getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          final Replica.State state = shard.getValue().getState();\n          if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN || state == Replica.State.RECOVERY_FAILED)\n              && clusterState.liveNodesContain(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            zkStateReader.getZkClient().printLayoutToStdOut();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"344b0840364d990b29b97467bfcc766ff8325d11","date":1501574100,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      ClusterState clusterState = zkStateReader.getClusterState();\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n      assertNotNull(\"Could not find collection:\" + collection, docCollection);\n      Map<String,Slice> slices = docCollection.getSlicesMap();\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Slice slice = entry.getValue();\n        if (slice.getState() == Slice.State.CONSTRUCTION) { // similar to replica recovering; pretend its the same thing\n          if (verbose) System.out.println(\"Found a slice in construction state; will wait.\");\n          sawLiveRecovering = true;\n        }\n        Map<String,Replica> shards = slice.getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          final Replica.State state = shard.getValue().getState();\n          if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN || state == Replica.State.RECOVERY_FAILED)\n              && clusterState.liveNodesContain(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            zkStateReader.getZkClient().printLayoutToStdOut();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","sourceOld":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Slice slice = entry.getValue();\n        if (slice.getState() == Slice.State.CONSTRUCTION) { // similar to replica recovering; pretend its the same thing\n          if (verbose) System.out.println(\"Found a slice in construction state; will wait.\");\n          sawLiveRecovering = true;\n        }\n        Map<String,Replica> shards = slice.getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          final Replica.State state = shard.getValue().getState();\n          if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN || state == Replica.State.RECOVERY_FAILED)\n              && clusterState.liveNodesContain(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            zkStateReader.getZkClient().printLayoutToStdOut();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","bugFix":["c5a558d54519c651068ddb202f03befefb1514a7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      ClusterState clusterState = zkStateReader.getClusterState();\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n      assertNotNull(\"Could not find collection:\" + collection, docCollection);\n      Map<String,Slice> slices = docCollection.getSlicesMap();\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Slice slice = entry.getValue();\n        if (slice.getState() == Slice.State.CONSTRUCTION) { // similar to replica recovering; pretend its the same thing\n          if (verbose) System.out.println(\"Found a slice in construction state; will wait.\");\n          sawLiveRecovering = true;\n        }\n        Map<String,Replica> shards = slice.getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          final Replica.State state = shard.getValue().getState();\n          if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN || state == Replica.State.RECOVERY_FAILED)\n              && clusterState.liveNodesContain(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            zkStateReader.getZkClient().printLayoutToStdOut();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","sourceOld":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      ClusterState clusterState = zkStateReader.getClusterState();\n      Map<String,Slice> slices = clusterState.getSlicesMap(collection);\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Slice slice = entry.getValue();\n        if (slice.getState() == Slice.State.CONSTRUCTION) { // similar to replica recovering; pretend its the same thing\n          if (verbose) System.out.println(\"Found a slice in construction state; will wait.\");\n          sawLiveRecovering = true;\n        }\n        Map<String,Replica> shards = slice.getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          final Replica.State state = shard.getValue().getState();\n          if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN || state == Replica.State.RECOVERY_FAILED)\n              && clusterState.liveNodesContain(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            zkStateReader.getZkClient().printLayoutToStdOut();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":4,"author":"markrmiller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/AbstractDistribZkTestBase#waitForRecoveriesToFinish(String,ZkStateReader,boolean,boolean,int).mjava","sourceNew":null,"sourceOld":"  public static void waitForRecoveriesToFinish(String collection,\n      ZkStateReader zkStateReader, boolean verbose, boolean failOnTimeout, int timeoutSeconds)\n      throws Exception {\n    log.info(\"Wait for recoveries to finish - collection: \" + collection + \" failOnTimeout:\" + failOnTimeout + \" timeout (sec):\" + timeoutSeconds);\n    boolean cont = true;\n    int cnt = 0;\n    \n    while (cont) {\n      if (verbose) System.out.println(\"-\");\n      boolean sawLiveRecovering = false;\n      ClusterState clusterState = zkStateReader.getClusterState();\n      final DocCollection docCollection = clusterState.getCollectionOrNull(collection);\n      assertNotNull(\"Could not find collection:\" + collection, docCollection);\n      Map<String,Slice> slices = docCollection.getSlicesMap();\n      assertNotNull(\"Could not find collection:\" + collection, slices);\n      for (Map.Entry<String,Slice> entry : slices.entrySet()) {\n        Slice slice = entry.getValue();\n        if (slice.getState() == Slice.State.CONSTRUCTION) { // similar to replica recovering; pretend its the same thing\n          if (verbose) System.out.println(\"Found a slice in construction state; will wait.\");\n          sawLiveRecovering = true;\n        }\n        Map<String,Replica> shards = slice.getReplicasMap();\n        for (Map.Entry<String,Replica> shard : shards.entrySet()) {\n          if (verbose) System.out.println(\"replica:\" + shard.getValue().getName() + \" rstate:\"\n              + shard.getValue().getStr(ZkStateReader.STATE_PROP)\n              + \" live:\"\n              + clusterState.liveNodesContain(shard.getValue().getNodeName()));\n          final Replica.State state = shard.getValue().getState();\n          if ((state == Replica.State.RECOVERING || state == Replica.State.DOWN || state == Replica.State.RECOVERY_FAILED)\n              && clusterState.liveNodesContain(shard.getValue().getStr(ZkStateReader.NODE_NAME_PROP))) {\n            sawLiveRecovering = true;\n          }\n        }\n      }\n      if (!sawLiveRecovering || cnt == timeoutSeconds) {\n        if (!sawLiveRecovering) {\n          if (verbose) System.out.println(\"no one is recoverying\");\n        } else {\n          if (verbose) System.out.println(\"Gave up waiting for recovery to finish..\");\n          if (failOnTimeout) {\n            Diagnostics.logThreadDumps(\"Gave up waiting for recovery to finish.  THREAD DUMP:\");\n            zkStateReader.getZkClient().printLayoutToStdOut();\n            fail(\"There are still nodes recoverying - waited for \" + timeoutSeconds + \" seconds\");\n            // won't get here\n            return;\n          }\n        }\n        cont = false;\n      } else {\n        Thread.sleep(1000);\n      }\n      cnt++;\n    }\n\n    log.info(\"Recoveries finished - collection: \" + collection);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","e08e84a194bcd52c44aefc809195617e1188bf25"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["e08e84a194bcd52c44aefc809195617e1188bf25","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["344b0840364d990b29b97467bfcc766ff8325d11"],"344b0840364d990b29b97467bfcc766ff8325d11":["1c7a21395bae9e2f61aeb639f47aaca771c426ed"],"e08e84a194bcd52c44aefc809195617e1188bf25":["e7754464847b06ced605515bd48219280ede29e9"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["536b47681314488eb94706248be6047a3f142841"],"55b50463286869f584cf849d1587a0fcd54d1dfa":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","1c7a21395bae9e2f61aeb639f47aaca771c426ed"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["1fc56848da7b3f927bb9840e8aedf09ee11cede1"],"e7754464847b06ced605515bd48219280ede29e9":["c5a558d54519c651068ddb202f03befefb1514a7"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["dcb5de84d260a8919bf0f2d4d180df543a2ad07a","1fc56848da7b3f927bb9840e8aedf09ee11cede1"],"dcb5de84d260a8919bf0f2d4d180df543a2ad07a":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c30e4c1cee08b3b229a77991882594fe7250b66"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e97ea29d4c70fa0eaf3167b0495c28516d91fee0":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"f2126b84bd093fa3d921582a109a0ee578c28126":["e19067e820b148e8dc0b240da4f2771cf7b68252","ad4a95e4e24f12ea4dad18db456c92edd64fca4e"],"2c30e4c1cee08b3b229a77991882594fe7250b66":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c5c99ad021f3da085fcb66220598a8f91dc5e453":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"536b47681314488eb94706248be6047a3f142841":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"ad4a95e4e24f12ea4dad18db456c92edd64fca4e":["e97ea29d4c70fa0eaf3167b0495c28516d91fee0"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"fa64435b5902ce266c23755a4a00691a3285dab8":["2c30e4c1cee08b3b229a77991882594fe7250b66"],"407687e67faf6e1f02a211ca078d8e3eed631027":["ad4a95e4e24f12ea4dad18db456c92edd64fca4e","e7754464847b06ced605515bd48219280ede29e9"],"e19067e820b148e8dc0b240da4f2771cf7b68252":["fa64435b5902ce266c23755a4a00691a3285dab8"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["e08e84a194bcd52c44aefc809195617e1188bf25"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["1c7a21395bae9e2f61aeb639f47aaca771c426ed","344b0840364d990b29b97467bfcc766ff8325d11"],"1fc56848da7b3f927bb9840e8aedf09ee11cede1":["dcb5de84d260a8919bf0f2d4d180df543a2ad07a"],"1c7a21395bae9e2f61aeb639f47aaca771c426ed":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","c5c99ad021f3da085fcb66220598a8f91dc5e453"],"c5a558d54519c651068ddb202f03befefb1514a7":["ad4a95e4e24f12ea4dad18db456c92edd64fca4e"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c30e4c1cee08b3b229a77991882594fe7250b66"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"344b0840364d990b29b97467bfcc766ff8325d11":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"e08e84a194bcd52c44aefc809195617e1188bf25":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","37a0f60745e53927c4c876cfe5b5a58170f0646c","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["55b50463286869f584cf849d1587a0fcd54d1dfa","c5c99ad021f3da085fcb66220598a8f91dc5e453","1c7a21395bae9e2f61aeb639f47aaca771c426ed"],"55b50463286869f584cf849d1587a0fcd54d1dfa":[],"a219f1dcad1700e84807666bdbd2b573e8de7021":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"e7754464847b06ced605515bd48219280ede29e9":["e08e84a194bcd52c44aefc809195617e1188bf25","407687e67faf6e1f02a211ca078d8e3eed631027"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"dcb5de84d260a8919bf0f2d4d180df543a2ad07a":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","1fc56848da7b3f927bb9840e8aedf09ee11cede1"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c7869f64c874ebf7f317d22c00baf2b6857797a6","2c30e4c1cee08b3b229a77991882594fe7250b66","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"e97ea29d4c70fa0eaf3167b0495c28516d91fee0":["ad4a95e4e24f12ea4dad18db456c92edd64fca4e"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"2c30e4c1cee08b3b229a77991882594fe7250b66":["c7869f64c874ebf7f317d22c00baf2b6857797a6","fa64435b5902ce266c23755a4a00691a3285dab8","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"c5c99ad021f3da085fcb66220598a8f91dc5e453":["1c7a21395bae9e2f61aeb639f47aaca771c426ed"],"536b47681314488eb94706248be6047a3f142841":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"ad4a95e4e24f12ea4dad18db456c92edd64fca4e":["f2126b84bd093fa3d921582a109a0ee578c28126","407687e67faf6e1f02a211ca078d8e3eed631027","c5a558d54519c651068ddb202f03befefb1514a7"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["536b47681314488eb94706248be6047a3f142841"],"fa64435b5902ce266c23755a4a00691a3285dab8":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"e19067e820b148e8dc0b240da4f2771cf7b68252":["e97ea29d4c70fa0eaf3167b0495c28516d91fee0","f2126b84bd093fa3d921582a109a0ee578c28126"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["37a0f60745e53927c4c876cfe5b5a58170f0646c","dcb5de84d260a8919bf0f2d4d180df543a2ad07a"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"1c7a21395bae9e2f61aeb639f47aaca771c426ed":["344b0840364d990b29b97467bfcc766ff8325d11","55b50463286869f584cf849d1587a0fcd54d1dfa","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"1fc56848da7b3f927bb9840e8aedf09ee11cede1":["a219f1dcad1700e84807666bdbd2b573e8de7021","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"c5a558d54519c651068ddb202f03befefb1514a7":["e7754464847b06ced605515bd48219280ede29e9"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","37a0f60745e53927c4c876cfe5b5a58170f0646c","55b50463286869f584cf849d1587a0fcd54d1dfa","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","c7869f64c874ebf7f317d22c00baf2b6857797a6","f2126b84bd093fa3d921582a109a0ee578c28126","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}