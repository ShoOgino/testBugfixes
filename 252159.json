{"path":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","commits":[{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":1,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Version,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      int maxThreadCount = TestUtil.nextInt(random(), 1, 4);\n      int maxMergeCount = TestUtil.nextInt(random(), maxThreadCount, maxThreadCount + 4);\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      c.setMergeScheduler(cms);\n    }\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    c.setCheckIntegrityAtMerge(r.nextBoolean());\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Version v, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(v, a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      int maxThreadCount = TestUtil.nextInt(random(), 1, 4);\n      int maxMergeCount = TestUtil.nextInt(random(), maxThreadCount, maxThreadCount + 4);\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      c.setMergeScheduler(cms);\n    }\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    c.setCheckIntegrityAtMerge(r.nextBoolean());\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4ce441f8e4ad5db9698284d95ee55efe098a4f1","date":1408563380,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      c.setMergeScheduler(cms);\n    }\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    c.setCheckIntegrityAtMerge(r.nextBoolean());\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      int maxThreadCount = TestUtil.nextInt(random(), 1, 4);\n      int maxMergeCount = TestUtil.nextInt(random(), maxThreadCount, maxThreadCount + 4);\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      c.setMergeScheduler(cms);\n    }\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    c.setCheckIntegrityAtMerge(r.nextBoolean());\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2131047ecceac64b54ba70feec3d26bbd7e483d7","date":1411862069,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      c.setMergeScheduler(cms);\n    }\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      c.setMergeScheduler(cms);\n    }\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    c.setCheckIntegrityAtMerge(r.nextBoolean());\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bb9a29a5e71a90295f175df8919802993142c9a","date":1412517673,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      c.setMergeScheduler(cms);\n    }\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      c.setMergeScheduler(cms);\n    }\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    c.setCheckIntegrityAtMerge(r.nextBoolean());\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4bb5791a757485f13c42e3d32746a440306f28c4","date":1412765145,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      c.setMergeScheduler(cms);\n    }\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      c.setMergeScheduler(cms);\n    }\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      c.setMergeScheduler(cms);\n    }\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      c.setMergeScheduler(cms);\n    }\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e13c4018a2a11854a5dc4a7661ba9e2f1132e4b","date":1416355396,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized void maybeStall() {\n            }\n          };\n      }\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      c.setMergeScheduler(cms);\n    }\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      c.setMergeScheduler(cms);\n    }\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1db7bd2068060be0b68fcca95c8270c7cb60f6c","date":1419003415,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized void maybeStall() {\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      c.setMergeScheduler(cms);\n    }\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized void maybeStall() {\n            }\n          };\n      }\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      c.setMergeScheduler(cms);\n    }\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ede814f061ec4439701275af0fa4b40b8c072ca7","date":1419018415,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized void maybeStall() {\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized void maybeStall() {\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      c.setMergeScheduler(cms);\n    }\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5faf65b6692f15cca0f87bf8666c87899afc619f","date":1420468108,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized void maybeStall(IndexWriter writer) {\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized void maybeStall() {\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","bugFix":null,"bugIntro":["c6cc2915889370c9313ee1741da315e976bdd574"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c6cc2915889370c9313ee1741da315e976bdd574","date":1422111819,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(IndexWriter writer) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized void maybeStall(IndexWriter writer) {\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","bugFix":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5592cc96e61043beee6ba728228191892f495d54","date":1434060173,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(IndexWriter writer) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(IndexWriter writer) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c02b804ab16489b95429791a2d8fb0e0728354d4","date":1436551798,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(IndexWriter writer) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(IndexWriter writer) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n    if (r.nextBoolean()) {\n      int maxNumThreadStates = rarely(r) ? TestUtil.nextInt(r, 5, 20) // crazy value\n          : TestUtil.nextInt(r, 1, 4); // reasonable value\n\n      c.setMaxThreadStates(maxNumThreadStates);\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1ea5763a93795952100d48e19c48f19777c552c","date":1512660172,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(IndexWriter writer) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    if (rarely(r)) {\n      c.setCheckPendingFlushUpdate(false);\n    }\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(IndexWriter writer) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(IndexWriter writer) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    if (rarely(r)) {\n      c.setCheckPendingFlushUpdate(false);\n    }\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(IndexWriter writer) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f","date":1579652839,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (rarely(r)) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(IndexWriter writer) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    if (rarely(r)) {\n      c.setCheckPendingFlushUpdate(false);\n    }\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (r.nextBoolean()) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(IndexWriter writer) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    if (rarely(r)) {\n      c.setCheckPendingFlushUpdate(false);\n    }\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81819c5a4a660afd353042c67106e682bb877cf1","date":1583169587,"type":3,"author":"msfroh","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (rarely(r)) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(IndexWriter writer) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    if (rarely(r)) {\n      c.setCheckPendingFlushUpdate(false);\n    }\n    c.setMaxCommitMergeWaitSeconds(atLeast(r, 1));\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (rarely(r)) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(IndexWriter writer) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    if (rarely(r)) {\n      c.setCheckPendingFlushUpdate(false);\n    }\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba192a321314de8edbe20b279eee9c471b16b48b","date":1583706474,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (rarely(r)) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(IndexWriter writer) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    if (rarely(r)) {\n      c.setCheckPendingFlushUpdate(false);\n    }\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (rarely(r)) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(IndexWriter writer) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    if (rarely(r)) {\n      c.setCheckPendingFlushUpdate(false);\n    }\n    c.setMaxCommitMergeWaitSeconds(atLeast(r, 1));\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89697e7abc9807639c384eecf5a2a6eef1080426","date":1587733375,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (rarely(r)) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(MergeSource mergeSource) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    if (rarely(r)) {\n      c.setCheckPendingFlushUpdate(false);\n    }\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (rarely(r)) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(IndexWriter writer) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    if (rarely(r)) {\n      c.setCheckPendingFlushUpdate(false);\n    }\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe39f1a106531207c028defebbc9eb5bb489ac50","date":1592513789,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (rarely(r)) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(MergeSource mergeSource) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    if (rarely(r)) {\n      c.setCheckPendingFlushUpdate(false);\n    }\n    c.setMaxCommitMergeWaitSeconds(atLeast(r, 1));\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (rarely(r)) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(MergeSource mergeSource) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    if (rarely(r)) {\n      c.setCheckPendingFlushUpdate(false);\n    }\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1182fe36fb5df768dc2da53f6d5338cbc07268ae","date":1592861749,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (rarely(r)) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(MergeSource mergeSource) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    if (rarely(r)) {\n      c.setCheckPendingFlushUpdate(false);\n    }\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (rarely(r)) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(MergeSource mergeSource) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    if (rarely(r)) {\n      c.setCheckPendingFlushUpdate(false);\n    }\n    c.setMaxCommitMergeWaitSeconds(atLeast(r, 1));\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2a23476693f2bd9a4b44cc3187c429a2e21dac2","date":1593289545,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (rarely(r)) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(MergeSource mergeSource) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    if (rarely(r)) {\n      c.setCheckPendingFlushUpdate(false);\n    }\n    c.setMaxCommitMergeWaitMillis(rarely() ?  atLeast(r, 1000) : atLeast(r, 200));\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (rarely(r)) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(MergeSource mergeSource) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    if (rarely(r)) {\n      c.setCheckPendingFlushUpdate(false);\n    }\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f354ba79a5a3e8491ec2953f14f365a02c058ac","date":1598293148,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#newIndexWriterConfig(Random,Analyzer).mjava","sourceNew":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (rarely(r)) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(MergeSource mergeSource) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    if (rarely(r)) {\n      c.setCheckPendingFlushUpdate(false);\n    }\n    c.setMaxFullFlushMergeWaitMillis(rarely() ?  atLeast(r, 1000) : atLeast(r, 200));\n    return c;\n  }\n\n","sourceOld":"  /** create a new index writer config with random defaults using the specified random */\n  public static IndexWriterConfig newIndexWriterConfig(Random r, Analyzer a) {\n    IndexWriterConfig c = new IndexWriterConfig(a);\n    c.setSimilarity(classEnvRule.similarity);\n    if (VERBOSE) {\n      // Even though TestRuleSetupAndRestoreClassEnv calls\n      // InfoStream.setDefault, we do it again here so that\n      // the PrintStreamInfoStream.messageID increments so\n      // that when there are separate instances of\n      // IndexWriter created we see \"IW 0\", \"IW 1\", \"IW 2\",\n      // ... instead of just always \"IW 0\":\n      c.setInfoStream(new TestRuleSetupAndRestoreClassEnv.ThreadNameFixingPrintStreamInfoStream(System.out));\n    }\n\n    if (rarely(r)) {\n      c.setMergeScheduler(new SerialMergeScheduler());\n    } else if (rarely(r)) {\n      ConcurrentMergeScheduler cms;\n      if (r.nextBoolean()) {\n        cms = new ConcurrentMergeScheduler();\n      } else {\n        cms = new ConcurrentMergeScheduler() {\n            @Override\n            protected synchronized boolean maybeStall(MergeSource mergeSource) {\n              return true;\n            }\n          };\n      }\n      int maxThreadCount = TestUtil.nextInt(r, 1, 4);\n      int maxMergeCount = TestUtil.nextInt(r, maxThreadCount, maxThreadCount + 4);\n      cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);\n      if (random().nextBoolean()) {\n        cms.disableAutoIOThrottle();\n        assertFalse(cms.getAutoIOThrottle());\n      }\n      cms.setForceMergeMBPerSec(10 + 10*random().nextDouble());\n      c.setMergeScheduler(cms);\n    } else {\n      // Always use consistent settings, else CMS's dynamic (SSD or not)\n      // defaults can change, hurting reproducibility:\n      ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();\n\n      // Only 1 thread can run at once (should maybe help reproducibility),\n      // with up to 3 pending merges before segment-producing threads are\n      // stalled:\n      cms.setMaxMergesAndThreads(3, 1);\n      c.setMergeScheduler(cms);\n    }\n\n    if (r.nextBoolean()) {\n      if (rarely(r)) {\n        // crazy value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 2, 15));\n      } else {\n        // reasonable value\n        c.setMaxBufferedDocs(TestUtil.nextInt(r, 16, 1000));\n      }\n    }\n\n    c.setMergePolicy(newMergePolicy(r));\n\n    avoidPathologicalMerging(c);\n\n    if (rarely(r)) {\n      c.setMergedSegmentWarmer(new SimpleMergedSegmentWarmer(c.getInfoStream()));\n    }\n    c.setUseCompoundFile(r.nextBoolean());\n    c.setReaderPooling(r.nextBoolean());\n    if (rarely(r)) {\n      c.setCheckPendingFlushUpdate(false);\n    }\n    c.setMaxCommitMergeWaitMillis(rarely() ?  atLeast(r, 1000) : atLeast(r, 200));\n    return c;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ba192a321314de8edbe20b279eee9c471b16b48b":["81819c5a4a660afd353042c67106e682bb877cf1"],"f1ea5763a93795952100d48e19c48f19777c552c":["c02b804ab16489b95429791a2d8fb0e0728354d4"],"c6cc2915889370c9313ee1741da315e976bdd574":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"f4ce441f8e4ad5db9698284d95ee55efe098a4f1":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"89697e7abc9807639c384eecf5a2a6eef1080426":["ba192a321314de8edbe20b279eee9c471b16b48b"],"9bb9a29a5e71a90295f175df8919802993142c9a":["f4ce441f8e4ad5db9698284d95ee55efe098a4f1","2131047ecceac64b54ba70feec3d26bbd7e483d7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f1db7bd2068060be0b68fcca95c8270c7cb60f6c":["7e13c4018a2a11854a5dc4a7661ba9e2f1132e4b"],"7e13c4018a2a11854a5dc4a7661ba9e2f1132e4b":["4bb5791a757485f13c42e3d32746a440306f28c4"],"81819c5a4a660afd353042c67106e682bb877cf1":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"],"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["417142ff08fda9cf0b72d5133e63097a166c6458"],"55980207f1977bd1463465de1659b821347e2fa8":["2131047ecceac64b54ba70feec3d26bbd7e483d7","4bb5791a757485f13c42e3d32746a440306f28c4"],"fe39f1a106531207c028defebbc9eb5bb489ac50":["89697e7abc9807639c384eecf5a2a6eef1080426"],"c02b804ab16489b95429791a2d8fb0e0728354d4":["5592cc96e61043beee6ba728228191892f495d54"],"4bb5791a757485f13c42e3d32746a440306f28c4":["9bb9a29a5e71a90295f175df8919802993142c9a"],"417142ff08fda9cf0b72d5133e63097a166c6458":["c02b804ab16489b95429791a2d8fb0e0728354d4","f1ea5763a93795952100d48e19c48f19777c552c"],"5592cc96e61043beee6ba728228191892f495d54":["c6cc2915889370c9313ee1741da315e976bdd574"],"c2a23476693f2bd9a4b44cc3187c429a2e21dac2":["1182fe36fb5df768dc2da53f6d5338cbc07268ae"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2131047ecceac64b54ba70feec3d26bbd7e483d7":["f4ce441f8e4ad5db9698284d95ee55efe098a4f1"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["ede814f061ec4439701275af0fa4b40b8c072ca7"],"1182fe36fb5df768dc2da53f6d5338cbc07268ae":["fe39f1a106531207c028defebbc9eb5bb489ac50"],"3f354ba79a5a3e8491ec2953f14f365a02c058ac":["c2a23476693f2bd9a4b44cc3187c429a2e21dac2"],"ede814f061ec4439701275af0fa4b40b8c072ca7":["f1db7bd2068060be0b68fcca95c8270c7cb60f6c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f354ba79a5a3e8491ec2953f14f365a02c058ac"]},"commit2Childs":{"ba192a321314de8edbe20b279eee9c471b16b48b":["89697e7abc9807639c384eecf5a2a6eef1080426"],"f1ea5763a93795952100d48e19c48f19777c552c":["417142ff08fda9cf0b72d5133e63097a166c6458"],"c6cc2915889370c9313ee1741da315e976bdd574":["5592cc96e61043beee6ba728228191892f495d54"],"f4ce441f8e4ad5db9698284d95ee55efe098a4f1":["9bb9a29a5e71a90295f175df8919802993142c9a","2131047ecceac64b54ba70feec3d26bbd7e483d7"],"89697e7abc9807639c384eecf5a2a6eef1080426":["fe39f1a106531207c028defebbc9eb5bb489ac50"],"9bb9a29a5e71a90295f175df8919802993142c9a":["4bb5791a757485f13c42e3d32746a440306f28c4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"f1db7bd2068060be0b68fcca95c8270c7cb60f6c":["ede814f061ec4439701275af0fa4b40b8c072ca7"],"7e13c4018a2a11854a5dc4a7661ba9e2f1132e4b":["f1db7bd2068060be0b68fcca95c8270c7cb60f6c"],"81819c5a4a660afd353042c67106e682bb877cf1":["ba192a321314de8edbe20b279eee9c471b16b48b"],"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["81819c5a4a660afd353042c67106e682bb877cf1"],"55980207f1977bd1463465de1659b821347e2fa8":[],"fe39f1a106531207c028defebbc9eb5bb489ac50":["1182fe36fb5df768dc2da53f6d5338cbc07268ae"],"c02b804ab16489b95429791a2d8fb0e0728354d4":["f1ea5763a93795952100d48e19c48f19777c552c","417142ff08fda9cf0b72d5133e63097a166c6458"],"4bb5791a757485f13c42e3d32746a440306f28c4":["7e13c4018a2a11854a5dc4a7661ba9e2f1132e4b","55980207f1977bd1463465de1659b821347e2fa8"],"417142ff08fda9cf0b72d5133e63097a166c6458":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"],"5592cc96e61043beee6ba728228191892f495d54":["c02b804ab16489b95429791a2d8fb0e0728354d4"],"c2a23476693f2bd9a4b44cc3187c429a2e21dac2":["3f354ba79a5a3e8491ec2953f14f365a02c058ac"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["f4ce441f8e4ad5db9698284d95ee55efe098a4f1"],"2131047ecceac64b54ba70feec3d26bbd7e483d7":["9bb9a29a5e71a90295f175df8919802993142c9a","55980207f1977bd1463465de1659b821347e2fa8"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["c6cc2915889370c9313ee1741da315e976bdd574"],"1182fe36fb5df768dc2da53f6d5338cbc07268ae":["c2a23476693f2bd9a4b44cc3187c429a2e21dac2"],"ede814f061ec4439701275af0fa4b40b8c072ca7":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"3f354ba79a5a3e8491ec2953f14f365a02c058ac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["55980207f1977bd1463465de1659b821347e2fa8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}