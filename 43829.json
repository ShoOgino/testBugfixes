{"path":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // why not return number of docs deleted?\n  // Depending on implementation, we may not be able to immediately determine the num...\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    boolean delAll=false;\n    try {\n      Query q = null;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      if (delAll) {\n        deleteAll();\n      } else {\n        indexWriterProvider.getIndexWriter().deleteDocuments(q);\n      }\n      \n      madeIt = true;\n      \n      if (commitTracker.timeUpperBound > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.timeUpperBound);\n      } else if (softCommitTracker.timeUpperBound > 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.timeUpperBound);\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // why not return number of docs deleted?\n  // Depending on implementation, we may not be able to immediately determine the num...\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    boolean delAll=false;\n    try {\n      Query q = null;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      if (delAll) {\n        deleteAll();\n      } else {\n        indexWriterProvider.getIndexWriter().deleteDocuments(q);\n      }\n      \n      madeIt = true;\n      \n      if (commitTracker.timeUpperBound > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.timeUpperBound);\n      } else if (softCommitTracker.timeUpperBound > 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.timeUpperBound);\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // why not return number of docs deleted?\n  // Depending on implementation, we may not be able to immediately determine the num...\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    boolean delAll=false;\n    try {\n      Query q = null;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      if (delAll) {\n        deleteAll();\n      } else {\n        indexWriterProvider.getIndexWriter().deleteDocuments(q);\n      }\n      \n      madeIt = true;\n      \n      if (commitTracker.timeUpperBound > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.timeUpperBound);\n      } else if (softCommitTracker.timeUpperBound > 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.timeUpperBound);\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // why not return number of docs deleted?\n  // Depending on implementation, we may not be able to immediately determine the num...\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    boolean delAll=false;\n    try {\n      Query q = null;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      if (delAll) {\n        deleteAll();\n      } else {\n        indexWriterProvider.getIndexWriter().deleteDocuments(q);\n      }\n      \n      madeIt = true;\n      \n      if (commitTracker.timeUpperBound > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.timeUpperBound);\n      } else if (softCommitTracker.timeUpperBound > 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.timeUpperBound);\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // why not return number of docs deleted?\n  // Depending on implementation, we may not be able to immediately determine the num...\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    boolean delAll=false;\n    try {\n      Query q = null;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      if (delAll) {\n        deleteAll();\n      } else {\n        indexWriterProvider.getIndexWriter().deleteDocuments(q);\n      }\n      \n      madeIt = true;\n      \n      if (commitTracker.timeUpperBound > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.timeUpperBound);\n      } else if (softCommitTracker.timeUpperBound > 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.timeUpperBound);\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // why not return number of docs deleted?\n  // Depending on implementation, we may not be able to immediately determine the num...\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    boolean delAll=false;\n    try {\n      Query q = null;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      if (delAll) {\n        deleteAll();\n      } else {\n        indexWriterProvider.getIndexWriter().deleteDocuments(q);\n      }\n      \n      madeIt = true;\n      \n      if (commitTracker.timeUpperBound > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.timeUpperBound);\n      } else if (softCommitTracker.timeUpperBound > 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.timeUpperBound);\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b09644855fe79c27cf261552509561b8ce34c4c7","date":1312056839,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      if (delAll) {\n        deleteAll();\n      } else {\n        indexWriterProvider.getIndexWriter().deleteDocuments(q);\n      }\n      \n      madeIt = true;\n      \n      if (commitTracker.timeUpperBound > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.timeUpperBound);\n      } else if (softCommitTracker.timeUpperBound > 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.timeUpperBound);\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // why not return number of docs deleted?\n  // Depending on implementation, we may not be able to immediately determine the num...\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    boolean delAll=false;\n    try {\n      Query q = null;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      if (delAll) {\n        deleteAll();\n      } else {\n        indexWriterProvider.getIndexWriter().deleteDocuments(q);\n      }\n      \n      madeIt = true;\n      \n      if (commitTracker.timeUpperBound > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.timeUpperBound);\n      } else if (softCommitTracker.timeUpperBound > 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.timeUpperBound);\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e8cb6e9df9d6fc873383924f02d9aacfffebf4e","date":1313005033,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      if (delAll) {\n        deleteAll();\n      } else {\n        indexWriterProvider.getIndexWriter(core).deleteDocuments(q);\n      }\n      \n      madeIt = true;\n      \n      if (commitTracker.timeUpperBound > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.timeUpperBound);\n      } else if (softCommitTracker.timeUpperBound > 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.timeUpperBound);\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      if (delAll) {\n        deleteAll();\n      } else {\n        indexWriterProvider.getIndexWriter().deleteDocuments(q);\n      }\n      \n      madeIt = true;\n      \n      if (commitTracker.timeUpperBound > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.timeUpperBound);\n      } else if (softCommitTracker.timeUpperBound > 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.timeUpperBound);\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c518d12136e15c9de6fa3d2c4bf5add07311a685","date":1313718511,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      if (delAll) {\n        deleteAll();\n      } else {\n        indexWriterProvider.getIndexWriter(core).deleteDocuments(q);\n      }\n      \n      madeIt = true;\n      \n      if (commitTracker.getTimeUpperBound() > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.getTimeUpperBound());\n      } else if (softCommitTracker.getTimeUpperBound()> 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.getTimeUpperBound());\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      if (delAll) {\n        deleteAll();\n      } else {\n        indexWriterProvider.getIndexWriter(core).deleteDocuments(q);\n      }\n      \n      madeIt = true;\n      \n      if (commitTracker.timeUpperBound > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.timeUpperBound);\n      } else if (softCommitTracker.timeUpperBound > 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.timeUpperBound);\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c9fe77273dc29a45ecba5acc1b217934ed3c676","date":1314217437,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      if (delAll) {\n        deleteAll();\n      } else {\n        indexWriterProvider.getIndexWriter(core).deleteDocuments(q);\n      }\n      \n      madeIt = true;\n      \n      if (commitTracker.getTimeUpperBound() > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.getTimeUpperBound());\n      } \n      \n      if (softCommitTracker.getTimeUpperBound()> 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.getTimeUpperBound());\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      if (delAll) {\n        deleteAll();\n      } else {\n        indexWriterProvider.getIndexWriter(core).deleteDocuments(q);\n      }\n      \n      madeIt = true;\n      \n      if (commitTracker.getTimeUpperBound() > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.getTimeUpperBound());\n      } else if (softCommitTracker.getTimeUpperBound()> 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.getTimeUpperBound());\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd0ef6574805f3cb9880e0983b7548a6aa933508","date":1315345052,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      if (delAll) {\n        deleteAll();\n      } else {\n        indexWriterProvider.getIndexWriter(core).deleteDocuments(q);\n      }\n\n      ulog.deleteByQuery(cmd);\n\n      madeIt = true;\n      \n      if (commitTracker.getTimeUpperBound() > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.getTimeUpperBound());\n      } \n      \n      if (softCommitTracker.getTimeUpperBound()> 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.getTimeUpperBound());\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      if (delAll) {\n        deleteAll();\n      } else {\n        indexWriterProvider.getIndexWriter(core).deleteDocuments(q);\n      }\n      \n      madeIt = true;\n      \n      if (commitTracker.getTimeUpperBound() > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.getTimeUpperBound());\n      } \n      \n      if (softCommitTracker.getTimeUpperBound()> 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.getTimeUpperBound());\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98fa1aca20a29db3d3d1a867eeed78f65448febe","date":1317919012,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      if (delAll) {\n        deleteAll();\n      } else {\n        solrCoreState.getIndexWriter(core).deleteDocuments(q);\n      }\n\n      ulog.deleteByQuery(cmd);\n\n      madeIt = true;\n      \n      if (commitTracker.getTimeUpperBound() > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.getTimeUpperBound());\n      } \n      \n      if (softCommitTracker.getTimeUpperBound()> 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.getTimeUpperBound());\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      if (delAll) {\n        deleteAll();\n      } else {\n        indexWriterProvider.getIndexWriter(core).deleteDocuments(q);\n      }\n\n      ulog.deleteByQuery(cmd);\n\n      madeIt = true;\n      \n      if (commitTracker.getTimeUpperBound() > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.getTimeUpperBound());\n      } \n      \n      if (softCommitTracker.getTimeUpperBound()> 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.getTimeUpperBound());\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"818d704eaaf0fba0561d0d2752832e1015053482","date":1327419676,"type":3,"author":"Jan HÃ¸ydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      commitTracker.deletedDocument(cmd.commitWithin);\n\n      if (delAll) {\n        deleteAll();\n      } else {\n        solrCoreState.getIndexWriter(core).deleteDocuments(q);\n      }\n\n      ulog.deleteByQuery(cmd);\n\n      madeIt = true;\n      \n      if (commitTracker.getTimeUpperBound() > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.getTimeUpperBound());\n      } \n      \n      if (softCommitTracker.getTimeUpperBound()> 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.getTimeUpperBound());\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      if (delAll) {\n        deleteAll();\n      } else {\n        solrCoreState.getIndexWriter(core).deleteDocuments(q);\n      }\n\n      ulog.deleteByQuery(cmd);\n\n      madeIt = true;\n      \n      if (commitTracker.getTimeUpperBound() > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.getTimeUpperBound());\n      } \n      \n      if (softCommitTracker.getTimeUpperBound()> 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.getTimeUpperBound());\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        // TODO: move this higher in the stack?\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n        q = QueryUtils.makeQueryable(q);\n\n        // peer-sync can cause older deleteByQueries to be executed and could\n        // delete newer documents.  We prevent this by adding a clause restricting\n        // version.\n        if ((cmd.getFlags() & UpdateCommand.PEER_SYNC) != 0) {\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(q, Occur.MUST);\n          SchemaField sf = core.getSchema().getField(VersionInfo.VERSION_FIELD);\n          ValueSource vs = sf.getType().getValueSource(sf, null);\n          ValueSourceRangeFilter filt = new ValueSourceRangeFilter(vs, null, Long.toString(Math.abs(cmd.version)), true, true);\n          FunctionRangeQuery range = new FunctionRangeQuery(filt);\n          bq.add(range, Occur.MUST);\n          q = bq;\n        }\n\n\n\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      commitTracker.deletedDocument(cmd.commitWithin);\n      \n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (this) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          solrCoreState.getIndexWriter(core).deleteDocuments(q);\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n      \n      if (commitTracker.getTimeUpperBound() > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.getTimeUpperBound());\n      } \n      \n      if (softCommitTracker.getTimeUpperBound()> 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.getTimeUpperBound());\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      commitTracker.deletedDocument(cmd.commitWithin);\n\n      if (delAll) {\n        deleteAll();\n      } else {\n        solrCoreState.getIndexWriter(core).deleteDocuments(q);\n      }\n\n      ulog.deleteByQuery(cmd);\n\n      madeIt = true;\n      \n      if (commitTracker.getTimeUpperBound() > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.getTimeUpperBound());\n      } \n      \n      if (softCommitTracker.getTimeUpperBound()> 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.getTimeUpperBound());\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["1adea4accc297f58fd9d8de3c820fd576eb0d396","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        // TODO: move this higher in the stack?\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n        q = QueryUtils.makeQueryable(q);\n\n        // peer-sync can cause older deleteByQueries to be executed and could\n        // delete newer documents.  We prevent this by adding a clause restricting\n        // version.\n        if ((cmd.getFlags() & UpdateCommand.PEER_SYNC) != 0) {\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(q, Occur.MUST);\n          SchemaField sf = core.getSchema().getField(VersionInfo.VERSION_FIELD);\n          ValueSource vs = sf.getType().getValueSource(sf, null);\n          ValueSourceRangeFilter filt = new ValueSourceRangeFilter(vs, null, Long.toString(Math.abs(cmd.version)), true, true);\n          FunctionRangeQuery range = new FunctionRangeQuery(filt);\n          bq.add(range, Occur.MUST);\n          q = bq;\n        }\n\n\n\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      commitTracker.deletedDocument(cmd.commitWithin);\n      \n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (this) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          solrCoreState.getIndexWriter(core).deleteDocuments(q);\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n      \n      if (commitTracker.getTimeUpperBound() > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.getTimeUpperBound());\n      } \n      \n      if (softCommitTracker.getTimeUpperBound()> 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.getTimeUpperBound());\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      if (delAll) {\n        deleteAll();\n      } else {\n        solrCoreState.getIndexWriter(core).deleteDocuments(q);\n      }\n\n      ulog.deleteByQuery(cmd);\n\n      madeIt = true;\n      \n      if (commitTracker.getTimeUpperBound() > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.getTimeUpperBound());\n      } \n      \n      if (softCommitTracker.getTimeUpperBound()> 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.getTimeUpperBound());\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        // TODO: move this higher in the stack?\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n        q = QueryUtils.makeQueryable(q);\n\n        // peer-sync can cause older deleteByQueries to be executed and could\n        // delete newer documents.  We prevent this by adding a clause restricting\n        // version.\n        if ((cmd.getFlags() & UpdateCommand.PEER_SYNC) != 0) {\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(q, Occur.MUST);\n          SchemaField sf = core.getSchema().getField(VersionInfo.VERSION_FIELD);\n          ValueSource vs = sf.getType().getValueSource(sf, null);\n          ValueSourceRangeFilter filt = new ValueSourceRangeFilter(vs, null, Long.toString(Math.abs(cmd.version)), true, true);\n          FunctionRangeQuery range = new FunctionRangeQuery(filt);\n          bq.add(range, Occur.MUST);\n          q = bq;\n        }\n\n\n\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      commitTracker.deletedDocument(cmd.commitWithin);\n      \n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (this) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          solrCoreState.getIndexWriter(core).deleteDocuments(q);\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n      \n      if (commitTracker.getTimeUpperBound() > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.getTimeUpperBound());\n      } \n      \n      if (softCommitTracker.getTimeUpperBound()> 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.getTimeUpperBound());\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n      \n      if (delAll) {\n        deleteAll();\n      } else {\n        solrCoreState.getIndexWriter(core).deleteDocuments(q);\n      }\n\n      ulog.deleteByQuery(cmd);\n\n      madeIt = true;\n      \n      if (commitTracker.getTimeUpperBound() > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.getTimeUpperBound());\n      } \n      \n      if (softCommitTracker.getTimeUpperBound()> 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.getTimeUpperBound());\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad31de9d3b830bc174d4c41df9f80f4cac82576","date":1328107867,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        // TODO: move this higher in the stack?\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n        q = QueryUtils.makeQueryable(q);\n\n        // peer-sync can cause older deleteByQueries to be executed and could\n        // delete newer documents.  We prevent this by adding a clause restricting\n        // version.\n        if ((cmd.getFlags() & UpdateCommand.PEER_SYNC) != 0) {\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(q, Occur.MUST);\n          SchemaField sf = core.getSchema().getField(VersionInfo.VERSION_FIELD);\n          ValueSource vs = sf.getType().getValueSource(sf, null);\n          ValueSourceRangeFilter filt = new ValueSourceRangeFilter(vs, null, Long.toString(Math.abs(cmd.version)), true, true);\n          FunctionRangeQuery range = new FunctionRangeQuery(filt);\n          bq.add(range, Occur.MUST);\n          q = bq;\n        }\n\n\n\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (this) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          solrCoreState.getIndexWriter(core).deleteDocuments(q);\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        // TODO: move this higher in the stack?\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n        q = QueryUtils.makeQueryable(q);\n\n        // peer-sync can cause older deleteByQueries to be executed and could\n        // delete newer documents.  We prevent this by adding a clause restricting\n        // version.\n        if ((cmd.getFlags() & UpdateCommand.PEER_SYNC) != 0) {\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(q, Occur.MUST);\n          SchemaField sf = core.getSchema().getField(VersionInfo.VERSION_FIELD);\n          ValueSource vs = sf.getType().getValueSource(sf, null);\n          ValueSourceRangeFilter filt = new ValueSourceRangeFilter(vs, null, Long.toString(Math.abs(cmd.version)), true, true);\n          FunctionRangeQuery range = new FunctionRangeQuery(filt);\n          bq.add(range, Occur.MUST);\n          q = bq;\n        }\n\n\n\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      commitTracker.deletedDocument(cmd.commitWithin);\n      \n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (this) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          solrCoreState.getIndexWriter(core).deleteDocuments(q);\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n      \n      if (commitTracker.getTimeUpperBound() > 0) {\n        commitTracker.scheduleCommitWithin(commitTracker.getTimeUpperBound());\n      } \n      \n      if (softCommitTracker.getTimeUpperBound()> 0) {\n        softCommitTracker.scheduleCommitWithin(softCommitTracker.getTimeUpperBound());\n      }\n      \n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb999ed3fc6e419b9104de9ebfe62ace27f31d5f","date":1341327930,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (this) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (this) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          solrCoreState.getIndexWriter(core).deleteDocuments(q);\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        // TODO: move this higher in the stack?\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n        q = QueryUtils.makeQueryable(q);\n\n        // peer-sync can cause older deleteByQueries to be executed and could\n        // delete newer documents.  We prevent this by adding a clause restricting\n        // version.\n        if ((cmd.getFlags() & UpdateCommand.PEER_SYNC) != 0) {\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(q, Occur.MUST);\n          SchemaField sf = core.getSchema().getField(VersionInfo.VERSION_FIELD);\n          ValueSource vs = sf.getType().getValueSource(sf, null);\n          ValueSourceRangeFilter filt = new ValueSourceRangeFilter(vs, null, Long.toString(Math.abs(cmd.version)), true, true);\n          FunctionRangeQuery range = new FunctionRangeQuery(filt);\n          bq.add(range, Occur.MUST);\n          q = bq;\n        }\n\n\n\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (this) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          solrCoreState.getIndexWriter(core).deleteDocuments(q);\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"08bcaef9e931052e4ca24133a89cc6aefaf61829","date":1342469326,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (this) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (this) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(q);\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (this) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (this) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          solrCoreState.getIndexWriter(core).deleteDocuments(q);\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (this) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (this) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(q);\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q;\n      try {\n        // TODO: move this higher in the stack?\n        QParser parser = QParser.getParser(cmd.query, \"lucene\", cmd.req);\n        q = parser.getQuery();\n        q = QueryUtils.makeQueryable(q);\n\n        // peer-sync can cause older deleteByQueries to be executed and could\n        // delete newer documents.  We prevent this by adding a clause restricting\n        // version.\n        if ((cmd.getFlags() & UpdateCommand.PEER_SYNC) != 0) {\n          BooleanQuery bq = new BooleanQuery();\n          bq.add(q, Occur.MUST);\n          SchemaField sf = core.getSchema().getField(VersionInfo.VERSION_FIELD);\n          ValueSource vs = sf.getType().getValueSource(sf, null);\n          ValueSourceRangeFilter filt = new ValueSourceRangeFilter(vs, null, Long.toString(Math.abs(cmd.version)), true, true);\n          FunctionRangeQuery range = new FunctionRangeQuery(filt);\n          bq.add(range, Occur.MUST);\n          q = bq;\n        }\n\n\n\n      } catch (ParseException e) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n      }\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (this) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          solrCoreState.getIndexWriter(core).deleteDocuments(q);\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9767265f21f7d1246b13dd7e73e8a4ad88b4384","date":1342986300,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (solrCoreState) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(q);\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (this) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (this) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(q);\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","fb999ed3fc6e419b9104de9ebfe62ace27f31d5f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (solrCoreState) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(q);\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (this) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (this) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(q);\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (solrCoreState) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(q);\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (this) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (this) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          solrCoreState.getIndexWriter(core).deleteDocuments(q);\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1381b91b03f7409d8d548c7070dbc615931a0f50","date":1343667369,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(q);\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (solrCoreState) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(q);\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(q);\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (solrCoreState) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(q);\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(q);\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (solrCoreState) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(q);\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7c19b4ecf30c060f4d2e29c25f027e73262713d","date":1400023065,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(q);\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(q);\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(q);\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1adea4accc297f58fd9d8de3c820fd576eb0d396","date":1441292844,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc0fbfa191179ae7a0081ee1cf7da0464bcd8078","date":1469530061,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.increment();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.increment();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.increment();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.increment();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.increment();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.increment();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.incrementAndGet();\n    deleteByQueryCommandsCumulative.incrementAndGet();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.incrementAndGet();\n        numErrorsCumulative.incrementAndGet();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.increment();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n\n        // We are reopening a searcher before applying the deletes to overcome LUCENE-7344.\n        // Once LUCENE-7344 is resolved, we can consider removing this.\n        if (ulog != null) ulog.openRealtimeSearcher();\n\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.increment();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.increment();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.increment();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.increment();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n\n        // We are reopening a searcher before applying the deletes to overcome LUCENE-7344.\n        // Once LUCENE-7344 is resolved, we can consider removing this.\n        if (ulog != null) ulog.openRealtimeSearcher();\n\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.increment();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.increment();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.increment();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e52c21eddb989aed5815d30ea4c8abf481ace8ad","date":1488795043,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.mark();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n\n        // We are reopening a searcher before applying the deletes to overcome LUCENE-7344.\n        // Once LUCENE-7344 is resolved, we can consider removing this.\n        if (ulog != null) ulog.openRealtimeSearcher();\n\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.increment();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n\n        // We are reopening a searcher before applying the deletes to overcome LUCENE-7344.\n        // Once LUCENE-7344 is resolved, we can consider removing this.\n        if (ulog != null) ulog.openRealtimeSearcher();\n\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.increment();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be320990bdc77e643388fa801e75017f19289c42","date":1489477067,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.mark();\n    boolean madeIt=false;\n    try {\n      if ( (cmd.getFlags() & UpdateCommand.IGNORE_INDEXWRITER) != 0) {\n        if (ulog != null) ulog.deleteByQuery(cmd);\n        madeIt = true;\n        return;\n      }\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n\n        // We are reopening a searcher before applying the deletes to overcome LUCENE-7344.\n        // Once LUCENE-7344 is resolved, we can consider removing this.\n        if (ulog != null) ulog.openRealtimeSearcher();\n\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.mark();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n\n        // We are reopening a searcher before applying the deletes to overcome LUCENE-7344.\n        // Once LUCENE-7344 is resolved, we can consider removing this.\n        if (ulog != null) ulog.openRealtimeSearcher();\n\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f996f8177b9204bdc92f7164460c6cefad9ac99a","date":1489482690,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.mark();\n    boolean madeIt=false;\n    try {\n      if ( (cmd.getFlags() & UpdateCommand.IGNORE_INDEXWRITER) != 0) {\n        if (ulog != null) ulog.deleteByQuery(cmd);\n        madeIt = true;\n        return;\n      }\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n\n        // We are reopening a searcher before applying the deletes to overcome LUCENE-7344.\n        // Once LUCENE-7344 is resolved, we can consider removing this.\n        if (ulog != null) ulog.openRealtimeSearcher();\n\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.mark();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n\n        // We are reopening a searcher before applying the deletes to overcome LUCENE-7344.\n        // Once LUCENE-7344 is resolved, we can consider removing this.\n        if (ulog != null) ulog.openRealtimeSearcher();\n\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.mark();\n    boolean madeIt=false;\n    try {\n      if ( (cmd.getFlags() & UpdateCommand.IGNORE_INDEXWRITER) != 0) {\n        if (ulog != null) ulog.deleteByQuery(cmd);\n        madeIt = true;\n        return;\n      }\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n\n        // We are reopening a searcher before applying the deletes to overcome LUCENE-7344.\n        // Once LUCENE-7344 is resolved, we can consider removing this.\n        if (ulog != null) ulog.openRealtimeSearcher();\n\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.mark();\n    boolean madeIt=false;\n    try {\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n\n        // We are reopening a searcher before applying the deletes to overcome LUCENE-7344.\n        // Once LUCENE-7344 is resolved, we can consider removing this.\n        if (ulog != null) ulog.openRealtimeSearcher();\n\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.mark();\n    boolean madeIt=false;\n    try {\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_INDEXWRITER) != 0) {\n        if (ulog != null) ulog.deleteByQuery(cmd);\n        madeIt = true;\n        return;\n      }\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n\n        // We are reopening a searcher before applying the deletes to overcome LUCENE-7344.\n        // Once LUCENE-7344 is resolved, we can consider removing this.\n        if (ulog != null) ulog.openRealtimeSearcher();\n\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.mark();\n    boolean madeIt=false;\n    try {\n      if ( (cmd.getFlags() & UpdateCommand.IGNORE_INDEXWRITER) != 0) {\n        if (ulog != null) ulog.deleteByQuery(cmd);\n        madeIt = true;\n        return;\n      }\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n\n        // We are reopening a searcher before applying the deletes to overcome LUCENE-7344.\n        // Once LUCENE-7344 is resolved, we can consider removing this.\n        if (ulog != null) ulog.openRealtimeSearcher();\n\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.mark();\n    boolean madeIt=false;\n    try {\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_INDEXWRITER) != 0) {\n        if (ulog != null) ulog.deleteByQuery(cmd);\n        madeIt = true;\n        return;\n      }\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n\n        // We are reopening a searcher before applying the deletes to overcome LUCENE-7344.\n        // Once LUCENE-7344 is resolved, we can consider removing this.\n        if (ulog != null) ulog.openRealtimeSearcher();\n\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.mark();\n    boolean madeIt=false;\n    try {\n      if ( (cmd.getFlags() & UpdateCommand.IGNORE_INDEXWRITER) != 0) {\n        if (ulog != null) ulog.deleteByQuery(cmd);\n        madeIt = true;\n        return;\n      }\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n\n        // We are reopening a searcher before applying the deletes to overcome LUCENE-7344.\n        // Once LUCENE-7344 is resolved, we can consider removing this.\n        if (ulog != null) ulog.openRealtimeSearcher();\n\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"482ca6c86d7073e3c19096bdc74fe0e73da4554a","date":1576010743,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    TestInjection.injectDirectUpdateLatch();\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.mark();\n    boolean madeIt=false;\n    try {\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_INDEXWRITER) != 0) {\n        if (ulog != null) ulog.deleteByQuery(cmd);\n        madeIt = true;\n        return;\n      }\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n\n        // We are reopening a searcher before applying the deletes to overcome LUCENE-7344.\n        // Once LUCENE-7344 is resolved, we can consider removing this.\n        if (ulog != null) ulog.openRealtimeSearcher();\n\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.mark();\n    boolean madeIt=false;\n    try {\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_INDEXWRITER) != 0) {\n        if (ulog != null) ulog.deleteByQuery(cmd);\n        madeIt = true;\n        return;\n      }\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n\n        // We are reopening a searcher before applying the deletes to overcome LUCENE-7344.\n        // Once LUCENE-7344 is resolved, we can consider removing this.\n        if (ulog != null) ulog.openRealtimeSearcher();\n\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a229cb50768e988c50a2106bdae3a92154f428bf","date":1576051038,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#deleteByQuery(DeleteUpdateCommand).mjava","sourceNew":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    TestInjection.injectDirectUpdateLatch();\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.mark();\n    boolean madeIt=false;\n    try {\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_INDEXWRITER) != 0) {\n        if (ulog != null) ulog.deleteByQuery(cmd);\n        madeIt = true;\n        return;\n      }\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n\n        // We are reopening a searcher before applying the deletes to overcome LUCENE-7344.\n        // Once LUCENE-7344 is resolved, we can consider removing this.\n        if (ulog != null) ulog.openRealtimeSearcher();\n\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n  }\n\n","sourceOld":"  // we don't return the number of docs deleted because it's not always possible to quickly know that info.\n  @Override\n  public void deleteByQuery(DeleteUpdateCommand cmd) throws IOException {\n    deleteByQueryCommands.increment();\n    deleteByQueryCommandsCumulative.mark();\n    boolean madeIt=false;\n    try {\n      if ((cmd.getFlags() & UpdateCommand.IGNORE_INDEXWRITER) != 0) {\n        if (ulog != null) ulog.deleteByQuery(cmd);\n        madeIt = true;\n        return;\n      }\n      Query q = getQuery(cmd);\n      \n      boolean delAll = MatchAllDocsQuery.class == q.getClass();\n\n      // currently for testing purposes.  Do a delete of complete index w/o worrying about versions, don't log, clean up most state in update log, etc\n      if (delAll && cmd.getVersion() == -Long.MAX_VALUE) {\n        synchronized (solrCoreState.getUpdateLock()) {\n          deleteAll();\n          ulog.deleteAll();\n          return;\n        }\n      }\n\n      //\n      // synchronized to prevent deleteByQuery from running during the \"open new searcher\"\n      // part of a commit.  DBQ needs to signal that a fresh reader will be needed for\n      // a realtime view of the index.  When a new searcher is opened after a DBQ, that\n      // flag can be cleared.  If those thing happen concurrently, it's not thread safe.\n      // Also, ulog.deleteByQuery clears caches and is thus not safe to be called between\n      // preSoftCommit/postSoftCommit and thus we use the updateLock to prevent this (just\n      // as we use around ulog.preCommit... also see comments in ulog.postSoftCommit)\n      //\n      synchronized (solrCoreState.getUpdateLock()) {\n\n        // We are reopening a searcher before applying the deletes to overcome LUCENE-7344.\n        // Once LUCENE-7344 is resolved, we can consider removing this.\n        if (ulog != null) ulog.openRealtimeSearcher();\n\n        if (delAll) {\n          deleteAll();\n        } else {\n          RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n          try {\n            iw.get().deleteDocuments(new DeleteByQueryWrapper(q, core.getLatestSchema()));\n          } finally {\n            iw.decref();\n          }\n        }\n\n        if (ulog != null) ulog.deleteByQuery(cmd);  // this needs to be protected by the update lock\n      }\n\n      madeIt = true;\n\n      updateDeleteTrackers(cmd);\n\n    } finally {\n      if (!madeIt) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fb999ed3fc6e419b9104de9ebfe62ace27f31d5f":["0ad31de9d3b830bc174d4c41df9f80f4cac82576"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","415bbbe7da8065dd3c477bdc3c703c6425622998"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"98fa1aca20a29db3d3d1a867eeed78f65448febe":["bd0ef6574805f3cb9880e0983b7548a6aa933508"],"818d704eaaf0fba0561d0d2752832e1015053482":["98fa1aca20a29db3d3d1a867eeed78f65448febe"],"56572ec06f1407c066d6b7399413178b33176cd8":["1381b91b03f7409d8d548c7070dbc615931a0f50","93dd449115a9247533e44bab47e8429e5dccbc6d"],"5c9fe77273dc29a45ecba5acc1b217934ed3c676":["c518d12136e15c9de6fa3d2c4bf5add07311a685"],"1adea4accc297f58fd9d8de3c820fd576eb0d396":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["ab68488225b6a6c357dda72ed11dedca9914a192","61c45e99cf6676da48f19d7511c73712ad39402b"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["98fa1aca20a29db3d3d1a867eeed78f65448febe","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a229cb50768e988c50a2106bdae3a92154f428bf":["61c45e99cf6676da48f19d7511c73712ad39402b","482ca6c86d7073e3c19096bdc74fe0e73da4554a"],"aba371508186796cc6151d8223a5b4e16d02e26e":["fb999ed3fc6e419b9104de9ebfe62ace27f31d5f","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["fe33227f6805edab2036cbb80645cc4e2d1fa424","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"c518d12136e15c9de6fa3d2c4bf5add07311a685":["0e8cb6e9df9d6fc873383924f02d9aacfffebf4e"],"be320990bdc77e643388fa801e75017f19289c42":["e52c21eddb989aed5815d30ea4c8abf481ace8ad"],"c7c19b4ecf30c060f4d2e29c25f027e73262713d":["1381b91b03f7409d8d548c7070dbc615931a0f50"],"ab68488225b6a6c357dda72ed11dedca9914a192":["e52c21eddb989aed5815d30ea4c8abf481ace8ad","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"415bbbe7da8065dd3c477bdc3c703c6425622998":["bc0fbfa191179ae7a0081ee1cf7da0464bcd8078"],"b09644855fe79c27cf261552509561b8ce34c4c7":["c26f00b574427b55127e869b935845554afde1fa"],"482ca6c86d7073e3c19096bdc74fe0e73da4554a":["61c45e99cf6676da48f19d7511c73712ad39402b"],"61c45e99cf6676da48f19d7511c73712ad39402b":["be320990bdc77e643388fa801e75017f19289c42"],"0e8cb6e9df9d6fc873383924f02d9aacfffebf4e":["b09644855fe79c27cf261552509561b8ce34c4c7"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["98fa1aca20a29db3d3d1a867eeed78f65448febe","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bc0fbfa191179ae7a0081ee1cf7da0464bcd8078":["1adea4accc297f58fd9d8de3c820fd576eb0d396"],"1381b91b03f7409d8d548c7070dbc615931a0f50":["c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["1adea4accc297f58fd9d8de3c820fd576eb0d396","bc0fbfa191179ae7a0081ee1cf7da0464bcd8078"],"bd0ef6574805f3cb9880e0983b7548a6aa933508":["5c9fe77273dc29a45ecba5acc1b217934ed3c676"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["e52c21eddb989aed5815d30ea4c8abf481ace8ad"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["1381b91b03f7409d8d548c7070dbc615931a0f50","c7c19b4ecf30c060f4d2e29c25f027e73262713d"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["0ad31de9d3b830bc174d4c41df9f80f4cac82576","08bcaef9e931052e4ca24133a89cc6aefaf61829"],"0ad31de9d3b830bc174d4c41df9f80f4cac82576":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","1381b91b03f7409d8d548c7070dbc615931a0f50"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","1381b91b03f7409d8d548c7070dbc615931a0f50"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["818d704eaaf0fba0561d0d2752832e1015053482"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e52c21eddb989aed5815d30ea4c8abf481ace8ad":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"08bcaef9e931052e4ca24133a89cc6aefaf61829":["fb999ed3fc6e419b9104de9ebfe62ace27f31d5f"],"c9767265f21f7d1246b13dd7e73e8a4ad88b4384":["08bcaef9e931052e4ca24133a89cc6aefaf61829"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["1adea4accc297f58fd9d8de3c820fd576eb0d396","bc0fbfa191179ae7a0081ee1cf7da0464bcd8078"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["482ca6c86d7073e3c19096bdc74fe0e73da4554a"]},"commit2Childs":{"fb999ed3fc6e419b9104de9ebfe62ace27f31d5f":["aba371508186796cc6151d8223a5b4e16d02e26e","08bcaef9e931052e4ca24133a89cc6aefaf61829"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"c26f00b574427b55127e869b935845554afde1fa":["b09644855fe79c27cf261552509561b8ce34c4c7"],"98fa1aca20a29db3d3d1a867eeed78f65448febe":["818d704eaaf0fba0561d0d2752832e1015053482","0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d"],"818d704eaaf0fba0561d0d2752832e1015053482":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"5c9fe77273dc29a45ecba5acc1b217934ed3c676":["bd0ef6574805f3cb9880e0983b7548a6aa933508"],"1adea4accc297f58fd9d8de3c820fd576eb0d396":["bc0fbfa191179ae7a0081ee1cf7da0464bcd8078","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"a229cb50768e988c50a2106bdae3a92154f428bf":[],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"c518d12136e15c9de6fa3d2c4bf5add07311a685":["5c9fe77273dc29a45ecba5acc1b217934ed3c676"],"ab68488225b6a6c357dda72ed11dedca9914a192":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"be320990bdc77e643388fa801e75017f19289c42":["61c45e99cf6676da48f19d7511c73712ad39402b"],"c7c19b4ecf30c060f4d2e29c25f027e73262713d":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","e52c21eddb989aed5815d30ea4c8abf481ace8ad"],"b09644855fe79c27cf261552509561b8ce34c4c7":["0e8cb6e9df9d6fc873383924f02d9aacfffebf4e"],"482ca6c86d7073e3c19096bdc74fe0e73da4554a":["a229cb50768e988c50a2106bdae3a92154f428bf","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"61c45e99cf6676da48f19d7511c73712ad39402b":["e9017cf144952056066919f1ebc7897ff9bd71b1","a229cb50768e988c50a2106bdae3a92154f428bf","482ca6c86d7073e3c19096bdc74fe0e73da4554a"],"0e8cb6e9df9d6fc873383924f02d9aacfffebf4e":["c518d12136e15c9de6fa3d2c4bf5add07311a685"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"bc0fbfa191179ae7a0081ee1cf7da0464bcd8078":["415bbbe7da8065dd3c477bdc3c703c6425622998","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"1381b91b03f7409d8d548c7070dbc615931a0f50":["56572ec06f1407c066d6b7399413178b33176cd8","c7c19b4ecf30c060f4d2e29c25f027e73262713d","93dd449115a9247533e44bab47e8429e5dccbc6d","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["598b5d23aa7c9732bf473c21a9cd309c44599394"],"bd0ef6574805f3cb9880e0983b7548a6aa933508":["98fa1aca20a29db3d3d1a867eeed78f65448febe"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["ab68488225b6a6c357dda72ed11dedca9914a192"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["56572ec06f1407c066d6b7399413178b33176cd8","1adea4accc297f58fd9d8de3c820fd576eb0d396"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"0ad31de9d3b830bc174d4c41df9f80f4cac82576":["fb999ed3fc6e419b9104de9ebfe62ace27f31d5f","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0ad31de9d3b830bc174d4c41df9f80f4cac82576"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"e52c21eddb989aed5815d30ea4c8abf481ace8ad":["be320990bdc77e643388fa801e75017f19289c42","ab68488225b6a6c357dda72ed11dedca9914a192","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"08bcaef9e931052e4ca24133a89cc6aefaf61829":["fe33227f6805edab2036cbb80645cc4e2d1fa424","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"c9767265f21f7d1246b13dd7e73e8a4ad88b4384":["aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","1381b91b03f7409d8d548c7070dbc615931a0f50"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","56572ec06f1407c066d6b7399413178b33176cd8","e9017cf144952056066919f1ebc7897ff9bd71b1","0d22ac6a4146774c1bc8400160fc0b6150294e92","a229cb50768e988c50a2106bdae3a92154f428bf","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","a258fbb26824fd104ed795e5d9033d2d040049ee","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}