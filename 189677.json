{"path":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","commits":[{"id":"448aa18a7a928a0f11c904582b22b9cd5ec63846","date":1355012177,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore).mjava","sourceNew":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core, boolean weAreReplacement) {\n    log.info(\"Checking if I should try and be the leader.\");\n    \n    if (isClosed) {\n      log.info(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (!weAreReplacement) {\n      // we are the first node starting in the shard - there is a configurable wait\n      // to make sure others participate in sync and leader election, we can be leader\n      return true;\n    }\n    \n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        .equals(ZkStateReader.ACTIVE)) {\n      log.info(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.info(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core) {\n    log.info(\"Checking if I should try and be the leader.\");\n    \n    if (isClosed) {\n      log.info(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        .equals(ZkStateReader.ACTIVE)) {\n      log.info(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.info(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","pathOld":"/dev/null","sourceNew":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core, boolean weAreReplacement) {\n    log.info(\"Checking if I should try and be the leader.\");\n    \n    if (isClosed) {\n      log.info(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (!weAreReplacement) {\n      // we are the first node starting in the shard - there is a configurable wait\n      // to make sure others participate in sync and leader election, we can be leader\n      return true;\n    }\n    \n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        .equals(ZkStateReader.ACTIVE)) {\n      log.info(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.info(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14d5815ecbef89580f5c48990bcd433f04f8563a","date":1399564106,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","sourceNew":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core, boolean weAreReplacement) {\n    log.info(\"Checking if I (\"+core.getName()+\") should try and be the leader.\");\n    \n    if (isClosed) {\n      log.info(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (!weAreReplacement) {\n      // we are the first node starting in the shard - there is a configurable wait\n      // to make sure others participate in sync and leader election, we can be leader\n      return true;\n    }\n    \n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished().equals(ZkStateReader.ACTIVE)) {\n      \n      // maybe active but if the previous leader marked us as down and\n      // we haven't recovered, then can't be leader\n      String lirState = zkController.getLeaderInitiatedRecoveryState(collection, shardId, core.getName());\n      if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERING.equals(lirState)) {\n        log.warn(\"Although my last published state is Active, the previous leader marked me \"+core.getName()\n            + \" as \" + lirState\n            + \" and I haven't recovered yet, so I shouldn't be the leader.\");\n        return false;\n      }\n      \n      log.info(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.info(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core, boolean weAreReplacement) {\n    log.info(\"Checking if I should try and be the leader.\");\n    \n    if (isClosed) {\n      log.info(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (!weAreReplacement) {\n      // we are the first node starting in the shard - there is a configurable wait\n      // to make sure others participate in sync and leader election, we can be leader\n      return true;\n    }\n    \n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        .equals(ZkStateReader.ACTIVE)) {\n      log.info(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.info(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":["b8d1bb706d514ef68ac7d45c7bb70ffbc8a16efd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"07c824e7f6927860d366e4888be45e4db8c9e03b","date":1405193679,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","sourceNew":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core, boolean weAreReplacement) {\n    log.info(\"Checking if I (core={},coreNodeName={}) should try and be the leader.\", core.getName(),\n        core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (isClosed) {\n      log.info(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (!weAreReplacement) {\n      // we are the first node starting in the shard - there is a configurable wait\n      // to make sure others participate in sync and leader election, we can be leader\n      return true;\n    }\n    \n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished().equals(ZkStateReader.ACTIVE)) {\n      \n      // maybe active but if the previous leader marked us as down and\n      // we haven't recovered, then can't be leader\n      String lirState = zkController.getLeaderInitiatedRecoveryState(collection, shardId,\n          core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n      if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERING.equals(lirState)) {\n        log.warn(\"Although my last published state is Active, the previous leader marked me \"+core.getName()\n            + \" as \" + lirState\n            + \" and I haven't recovered yet, so I shouldn't be the leader.\");\n        return false;\n      }\n      \n      log.info(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.info(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core, boolean weAreReplacement) {\n    log.info(\"Checking if I (\"+core.getName()+\") should try and be the leader.\");\n    \n    if (isClosed) {\n      log.info(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (!weAreReplacement) {\n      // we are the first node starting in the shard - there is a configurable wait\n      // to make sure others participate in sync and leader election, we can be leader\n      return true;\n    }\n    \n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished().equals(ZkStateReader.ACTIVE)) {\n      \n      // maybe active but if the previous leader marked us as down and\n      // we haven't recovered, then can't be leader\n      String lirState = zkController.getLeaderInitiatedRecoveryState(collection, shardId, core.getName());\n      if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERING.equals(lirState)) {\n        log.warn(\"Although my last published state is Active, the previous leader marked me \"+core.getName()\n            + \" as \" + lirState\n            + \" and I haven't recovered yet, so I shouldn't be the leader.\");\n        return false;\n      }\n      \n      log.info(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.info(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":["b8d1bb706d514ef68ac7d45c7bb70ffbc8a16efd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","sourceNew":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core, boolean weAreReplacement) {\n    log.info(\"Checking if I (core={},coreNodeName={}) should try and be the leader.\", core.getName(),\n        core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (isClosed) {\n      log.info(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (!weAreReplacement) {\n      // we are the first node starting in the shard - there is a configurable wait\n      // to make sure others participate in sync and leader election, we can be leader\n      return true;\n    }\n    \n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished() == Replica.State.ACTIVE) {\n      \n      // maybe active but if the previous leader marked us as down and\n      // we haven't recovered, then can't be leader\n      final Replica.State lirState = zkController.getLeaderInitiatedRecoveryState(collection, shardId,\n          core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n      if (lirState == Replica.State.DOWN || lirState == Replica.State.RECOVERING) {\n        log.warn(\"Although my last published state is Active, the previous leader marked me \"+core.getName()\n            + \" as \" + lirState.toString()\n            + \" and I haven't recovered yet, so I shouldn't be the leader.\");\n        return false;\n      }\n      \n      log.info(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.info(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core, boolean weAreReplacement) {\n    log.info(\"Checking if I (core={},coreNodeName={}) should try and be the leader.\", core.getName(),\n        core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (isClosed) {\n      log.info(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (!weAreReplacement) {\n      // we are the first node starting in the shard - there is a configurable wait\n      // to make sure others participate in sync and leader election, we can be leader\n      return true;\n    }\n    \n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished().equals(ZkStateReader.ACTIVE)) {\n      \n      // maybe active but if the previous leader marked us as down and\n      // we haven't recovered, then can't be leader\n      String lirState = zkController.getLeaderInitiatedRecoveryState(collection, shardId,\n          core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n      if (ZkStateReader.DOWN.equals(lirState) || ZkStateReader.RECOVERING.equals(lirState)) {\n        log.warn(\"Although my last published state is Active, the previous leader marked me \"+core.getName()\n            + \" as \" + lirState\n            + \" and I haven't recovered yet, so I shouldn't be the leader.\");\n        return false;\n      }\n      \n      log.info(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.info(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":["b8d1bb706d514ef68ac7d45c7bb70ffbc8a16efd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"439c63ae5d22132fca810a0029a854e97d2c1a3e","date":1432733612,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","sourceNew":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core, boolean weAreReplacement) {\n    log.info(\"Checking if I should try and be the leader.\");\n    \n    if (isClosed) {\n      log.info(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (!weAreReplacement) {\n      // we are the first node starting in the shard - there is a configurable wait\n      // to make sure others participate in sync and leader election, we can be leader\n      return true;\n    }\n    \n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished() == Replica.State.ACTIVE) {\n      \n      // maybe active but if the previous leader marked us as down and\n      // we haven't recovered, then can't be leader\n      final Replica.State lirState = zkController.getLeaderInitiatedRecoveryState(collection, shardId,\n          core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n      if (lirState == Replica.State.DOWN || lirState == Replica.State.RECOVERING) {\n        log.warn(\"Although my last published state is Active, the previous leader marked me \"+core.getName()\n            + \" as \" + lirState.toString()\n            + \" and I haven't recovered yet, so I shouldn't be the leader.\");\n        return false;\n      }\n      \n      log.info(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.info(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core, boolean weAreReplacement) {\n    log.info(\"Checking if I (core={},coreNodeName={}) should try and be the leader.\", core.getName(),\n        core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n    \n    if (isClosed) {\n      log.info(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (!weAreReplacement) {\n      // we are the first node starting in the shard - there is a configurable wait\n      // to make sure others participate in sync and leader election, we can be leader\n      return true;\n    }\n    \n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished() == Replica.State.ACTIVE) {\n      \n      // maybe active but if the previous leader marked us as down and\n      // we haven't recovered, then can't be leader\n      final Replica.State lirState = zkController.getLeaderInitiatedRecoveryState(collection, shardId,\n          core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n      if (lirState == Replica.State.DOWN || lirState == Replica.State.RECOVERING) {\n        log.warn(\"Although my last published state is Active, the previous leader marked me \"+core.getName()\n            + \" as \" + lirState.toString()\n            + \" and I haven't recovered yet, so I shouldn't be the leader.\");\n        return false;\n      }\n      \n      log.info(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.info(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b8d1bb706d514ef68ac7d45c7bb70ffbc8a16efd","date":1447422052,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","sourceNew":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core, boolean weAreReplacement) {\n    log.info(\"Checking if I should try and be the leader.\");\n    \n    if (isClosed) {\n      log.info(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (!weAreReplacement) {\n      // we are the first node starting in the shard - there is a configurable wait\n      // to make sure others participate in sync and leader election, we can be leader\n      return true;\n    }\n    \n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished() == Replica.State.ACTIVE) {\n      log.info(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.info(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core, boolean weAreReplacement) {\n    log.info(\"Checking if I should try and be the leader.\");\n    \n    if (isClosed) {\n      log.info(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (!weAreReplacement) {\n      // we are the first node starting in the shard - there is a configurable wait\n      // to make sure others participate in sync and leader election, we can be leader\n      return true;\n    }\n    \n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished() == Replica.State.ACTIVE) {\n      \n      // maybe active but if the previous leader marked us as down and\n      // we haven't recovered, then can't be leader\n      final Replica.State lirState = zkController.getLeaderInitiatedRecoveryState(collection, shardId,\n          core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName());\n      if (lirState == Replica.State.DOWN || lirState == Replica.State.RECOVERING) {\n        log.warn(\"Although my last published state is Active, the previous leader marked me \"+core.getName()\n            + \" as \" + lirState.toString()\n            + \" and I haven't recovered yet, so I shouldn't be the leader.\");\n        return false;\n      }\n      \n      log.info(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.info(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","bugFix":["07c824e7f6927860d366e4888be45e4db8c9e03b","14d5815ecbef89580f5c48990bcd433f04f8563a","a219f1dcad1700e84807666bdbd2b573e8de7021"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5d615d62cd8aff3690943d765e46942551f98b6","date":1474881754,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","sourceNew":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core, boolean weAreReplacement) {\n    log.debug(\"Checking if I should try and be the leader.\");\n    \n    if (isClosed) {\n      log.debug(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (!weAreReplacement) {\n      // we are the first node starting in the shard - there is a configurable wait\n      // to make sure others participate in sync and leader election, we can be leader\n      return true;\n    }\n    \n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished() == Replica.State.ACTIVE) {\n      log.debug(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.debug(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core, boolean weAreReplacement) {\n    log.info(\"Checking if I should try and be the leader.\");\n    \n    if (isClosed) {\n      log.info(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (!weAreReplacement) {\n      // we are the first node starting in the shard - there is a configurable wait\n      // to make sure others participate in sync and leader election, we can be leader\n      return true;\n    }\n    \n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished() == Replica.State.ACTIVE) {\n      log.info(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.info(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","sourceNew":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core, boolean weAreReplacement) {\n    log.debug(\"Checking if I should try and be the leader.\");\n    \n    if (isClosed) {\n      log.debug(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (!weAreReplacement) {\n      // we are the first node starting in the shard - there is a configurable wait\n      // to make sure others participate in sync and leader election, we can be leader\n      return true;\n    }\n    \n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished() == Replica.State.ACTIVE) {\n      log.debug(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.debug(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core, boolean weAreReplacement) {\n    log.info(\"Checking if I should try and be the leader.\");\n    \n    if (isClosed) {\n      log.info(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (!weAreReplacement) {\n      // we are the first node starting in the shard - there is a configurable wait\n      // to make sure others participate in sync and leader election, we can be leader\n      return true;\n    }\n    \n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished() == Replica.State.ACTIVE) {\n      log.info(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.info(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","sourceNew":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core, boolean weAreReplacement) {\n    log.debug(\"Checking if I should try and be the leader.\");\n    \n    if (isClosed) {\n      log.debug(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (!weAreReplacement) {\n      // we are the first node starting in the shard - there is a configurable wait\n      // to make sure others participate in sync and leader election, we can be leader\n      return true;\n    }\n    \n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished() == Replica.State.ACTIVE) {\n      log.debug(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.debug(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core, boolean weAreReplacement) {\n    log.info(\"Checking if I should try and be the leader.\");\n    \n    if (isClosed) {\n      log.info(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (!weAreReplacement) {\n      // we are the first node starting in the shard - there is a configurable wait\n      // to make sure others participate in sync and leader election, we can be leader\n      return true;\n    }\n    \n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished() == Replica.State.ACTIVE) {\n      log.info(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.info(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84f20f331d8001864545c7021812d8c6509c7593","date":1517216128,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","sourceNew":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core, boolean weAreReplacement) {\n    log.debug(\"Checking if I should try and be the leader.\");\n    \n    if (isClosed) {\n      log.debug(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (!weAreReplacement) {\n      // we are the first node starting in the shard - there is a configurable wait\n      // to make sure others participate in sync and leader election, we can be leader\n      return true;\n    }\n\n    String coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n    if (zkController.getShardTerms(collection, shardId).registered(coreNodeName)\n        && !zkController.getShardTerms(collection, shardId).canBecomeLeader(coreNodeName)) {\n      log.info(\"Can't become leader, term of replica {} less than leader\", coreNodeName);\n      return false;\n    }\n\n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished() == Replica.State.ACTIVE) {\n      log.debug(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.debug(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","sourceOld":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core, boolean weAreReplacement) {\n    log.debug(\"Checking if I should try and be the leader.\");\n    \n    if (isClosed) {\n      log.debug(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (!weAreReplacement) {\n      // we are the first node starting in the shard - there is a configurable wait\n      // to make sure others participate in sync and leader election, we can be leader\n      return true;\n    }\n    \n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished() == Replica.State.ACTIVE) {\n      log.debug(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.debug(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94","date":1520143025,"type":4,"author":"Cao Manh Dat","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#shouldIBeLeader(ZkNodeProps,SolrCore,boolean).mjava","sourceNew":null,"sourceOld":"  private boolean shouldIBeLeader(ZkNodeProps leaderProps, SolrCore core, boolean weAreReplacement) {\n    log.debug(\"Checking if I should try and be the leader.\");\n    \n    if (isClosed) {\n      log.debug(\"Bailing on leader process because we have been closed\");\n      return false;\n    }\n    \n    if (!weAreReplacement) {\n      // we are the first node starting in the shard - there is a configurable wait\n      // to make sure others participate in sync and leader election, we can be leader\n      return true;\n    }\n\n    String coreNodeName = core.getCoreDescriptor().getCloudDescriptor().getCoreNodeName();\n    if (zkController.getShardTerms(collection, shardId).registered(coreNodeName)\n        && !zkController.getShardTerms(collection, shardId).canBecomeLeader(coreNodeName)) {\n      log.info(\"Can't become leader, term of replica {} less than leader\", coreNodeName);\n      return false;\n    }\n\n    if (core.getCoreDescriptor().getCloudDescriptor().getLastPublished() == Replica.State.ACTIVE) {\n      log.debug(\"My last published State was Active, it's okay to be the leader.\");\n      return true;\n    }\n    log.debug(\"My last published State was \"\n        + core.getCoreDescriptor().getCloudDescriptor().getLastPublished()\n        + \", I won't be the leader.\");\n    // TODO: and if no one is a good candidate?\n    \n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"407687e67faf6e1f02a211ca078d8e3eed631027":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","448aa18a7a928a0f11c904582b22b9cd5ec63846"],"84f20f331d8001864545c7021812d8c6509c7593":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94":["84f20f331d8001864545c7021812d8c6509c7593"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["b8d1bb706d514ef68ac7d45c7bb70ffbc8a16efd","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["07c824e7f6927860d366e4888be45e4db8c9e03b"],"a5d615d62cd8aff3690943d765e46942551f98b6":["b8d1bb706d514ef68ac7d45c7bb70ffbc8a16efd"],"07c824e7f6927860d366e4888be45e4db8c9e03b":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["b8d1bb706d514ef68ac7d45c7bb70ffbc8a16efd","a5d615d62cd8aff3690943d765e46942551f98b6"],"14d5815ecbef89580f5c48990bcd433f04f8563a":["448aa18a7a928a0f11c904582b22b9cd5ec63846"],"448aa18a7a928a0f11c904582b22b9cd5ec63846":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b8d1bb706d514ef68ac7d45c7bb70ffbc8a16efd":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94"]},"commit2Childs":{"407687e67faf6e1f02a211ca078d8e3eed631027":[],"84f20f331d8001864545c7021812d8c6509c7593":["8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94"],"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["b8d1bb706d514ef68ac7d45c7bb70ffbc8a16efd"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"a5d615d62cd8aff3690943d765e46942551f98b6":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"07c824e7f6927860d366e4888be45e4db8c9e03b":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["407687e67faf6e1f02a211ca078d8e3eed631027","448aa18a7a928a0f11c904582b22b9cd5ec63846"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["84f20f331d8001864545c7021812d8c6509c7593","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"448aa18a7a928a0f11c904582b22b9cd5ec63846":["407687e67faf6e1f02a211ca078d8e3eed631027","14d5815ecbef89580f5c48990bcd433f04f8563a"],"14d5815ecbef89580f5c48990bcd433f04f8563a":["07c824e7f6927860d366e4888be45e4db8c9e03b"],"b8d1bb706d514ef68ac7d45c7bb70ffbc8a16efd":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a5d615d62cd8aff3690943d765e46942551f98b6","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}