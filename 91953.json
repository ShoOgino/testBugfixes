{"path":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","commits":[{"id":"0c3e228bf650e96f3002a8fb73dd0c13d55af077","date":1138253849,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","pathOld":"/dev/null","sourceNew":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        fieldTypes.put(ft.typeName,ft);\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          fields.put(f.getName(),f);\n          log.fine(\"field defined: \" + f);\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          dFields.add(new DynamicField(f));\n          log.fine(\"dynamic field defined: \" + f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields, new Comparator<DynamicField>() {\n        public int compare(DynamicField a, DynamicField b) {\n           // swap natural ordering to get biggest first.\n           // The sort is stable, so elements of the same size should\n           // be\n           if (a.regex.length() < b.regex.length()) return 1;\n           else if (a.regex.length() > b.regex.length()) return -1;\n           return 0;\n        }\n      }\n    );\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      String defName=node.getNodeValue().trim();\n      defaultSearchFieldName = getIndexedField(defName)!=null ? defName : null;\n      log.info(\"default search field is \"+defName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest = DOMUtil.getAttr(attrs,\"dest\",\"copyField definition\");\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField f = getField(source);\n        SchemaField d = getField(dest);\n        SchemaField[] destArr = copyFields.get(source);\n        if (destArr==null) {\n          destArr=new SchemaField[]{d};\n        } else {\n          destArr = (SchemaField[])append(destArr,d);\n        }\n        copyFields.put(source,destArr);\n      }\n\n\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["83fbfcaab6a6cd5daf32752c0c35f0e0c15380e0","83fbfcaab6a6cd5daf32752c0c35f0e0c15380e0","83fbfcaab6a6cd5daf32752c0c35f0e0c15380e0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9f3ac363fd9c46488a0996cc9c80b7d0bf005dbd","date":1138921307,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","sourceNew":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        fieldTypes.put(ft.typeName,ft);\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          fields.put(f.getName(),f);\n          log.fine(\"field defined: \" + f);\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          dFields.add(new DynamicField(f));\n          log.fine(\"dynamic field defined: \" + f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields, new Comparator<DynamicField>() {\n        public int compare(DynamicField a, DynamicField b) {\n           // swap natural ordering to get biggest first.\n           // The sort is stable, so elements of the same size should\n           // be\n           if (a.regex.length() < b.regex.length()) return 1;\n           else if (a.regex.length() > b.regex.length()) return -1;\n           return 0;\n        }\n      }\n    );\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      String defName=node.getNodeValue().trim();\n      defaultSearchFieldName = getIndexedField(defName)!=null ? defName : null;\n      log.info(\"default search field is \"+defName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest = DOMUtil.getAttr(attrs,\"dest\",\"copyField definition\");\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField f = getField(source);\n        SchemaField d = getField(dest);\n        SchemaField[] destArr = copyFields.get(source);\n        if (destArr==null) {\n          destArr=new SchemaField[]{d};\n        } else {\n          destArr = (SchemaField[])append(destArr,d);\n        }\n        copyFields.put(source,destArr);\n      }\n\n\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        fieldTypes.put(ft.typeName,ft);\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          fields.put(f.getName(),f);\n          log.fine(\"field defined: \" + f);\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          dFields.add(new DynamicField(f));\n          log.fine(\"dynamic field defined: \" + f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields, new Comparator<DynamicField>() {\n        public int compare(DynamicField a, DynamicField b) {\n           // swap natural ordering to get biggest first.\n           // The sort is stable, so elements of the same size should\n           // be\n           if (a.regex.length() < b.regex.length()) return 1;\n           else if (a.regex.length() > b.regex.length()) return -1;\n           return 0;\n        }\n      }\n    );\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      String defName=node.getNodeValue().trim();\n      defaultSearchFieldName = getIndexedField(defName)!=null ? defName : null;\n      log.info(\"default search field is \"+defName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest = DOMUtil.getAttr(attrs,\"dest\",\"copyField definition\");\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField f = getField(source);\n        SchemaField d = getField(dest);\n        SchemaField[] destArr = copyFields.get(source);\n        if (destArr==null) {\n          destArr=new SchemaField[]{d};\n        } else {\n          destArr = (SchemaField[])append(destArr,d);\n        }\n        copyFields.put(source,destArr);\n      }\n\n\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b451a0c4c12c9a8575a49bafc27463190c8b8833","date":1149619984,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","sourceNew":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        fieldTypes.put(ft.typeName,ft);\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          fields.put(f.getName(),f);\n          log.fine(\"field defined: \" + f);\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          dFields.add(new DynamicField(f));\n          log.fine(\"dynamic field defined: \" + f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      String defName=node.getNodeValue().trim();\n      defaultSearchFieldName = getIndexedField(defName)!=null ? defName : null;\n      log.info(\"default search field is \"+defName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n\n        String dest = DOMUtil.getAttr(attrs,\"dest\",\"copyField definition\");\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          dCopies.add(new DynamicCopy(source, d));\n        } else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        fieldTypes.put(ft.typeName,ft);\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          fields.put(f.getName(),f);\n          log.fine(\"field defined: \" + f);\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          dFields.add(new DynamicField(f));\n          log.fine(\"dynamic field defined: \" + f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields, new Comparator<DynamicField>() {\n        public int compare(DynamicField a, DynamicField b) {\n           // swap natural ordering to get biggest first.\n           // The sort is stable, so elements of the same size should\n           // be\n           if (a.regex.length() < b.regex.length()) return 1;\n           else if (a.regex.length() > b.regex.length()) return -1;\n           return 0;\n        }\n      }\n    );\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      String defName=node.getNodeValue().trim();\n      defaultSearchFieldName = getIndexedField(defName)!=null ? defName : null;\n      log.info(\"default search field is \"+defName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest = DOMUtil.getAttr(attrs,\"dest\",\"copyField definition\");\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField f = getField(source);\n        SchemaField d = getField(dest);\n        SchemaField[] destArr = copyFields.get(source);\n        if (destArr==null) {\n          destArr=new SchemaField[]{d};\n        } else {\n          destArr = (SchemaField[])append(destArr,d);\n        }\n        copyFields.put(source,destArr);\n      }\n\n\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"21400778a0bf704d187a4848279049f5d90276c8","date":1149955512,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","sourceNew":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        fieldTypes.put(ft.typeName,ft);\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          fields.put(f.getName(),f);\n          log.fine(\"field defined: \" + f);\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          dFields.add(new DynamicField(f));\n          log.fine(\"dynamic field defined: \" + f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n\n        String dest = DOMUtil.getAttr(attrs,\"dest\",\"copyField definition\");\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          dCopies.add(new DynamicCopy(source, d));\n        } else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        fieldTypes.put(ft.typeName,ft);\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          fields.put(f.getName(),f);\n          log.fine(\"field defined: \" + f);\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          dFields.add(new DynamicField(f));\n          log.fine(\"dynamic field defined: \" + f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      String defName=node.getNodeValue().trim();\n      defaultSearchFieldName = getIndexedField(defName)!=null ? defName : null;\n      log.info(\"default search field is \"+defName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n\n        String dest = DOMUtil.getAttr(attrs,\"dest\",\"copyField definition\");\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          dCopies.add(new DynamicCopy(source, d));\n        } else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6af8262271cd1db53df95496839ffa27f984a3b1","date":1153746046,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","sourceNew":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        fieldTypes.put(ft.typeName,ft);\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          fields.put(f.getName(),f);\n          log.fine(\"field defined: \" + f);\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          dFields.add(new DynamicField(f));\n          log.fine(\"dynamic field defined: \" + f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n\n        String dest = DOMUtil.getAttr(attrs,\"dest\",\"copyField definition\");\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          dCopies.add(new DynamicCopy(source, d));\n        } else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        fieldTypes.put(ft.typeName,ft);\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          fields.put(f.getName(),f);\n          log.fine(\"field defined: \" + f);\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          dFields.add(new DynamicField(f));\n          log.fine(\"dynamic field defined: \" + f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n\n        String dest = DOMUtil.getAttr(attrs,\"dest\",\"copyField definition\");\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          dCopies.add(new DynamicCopy(source, d));\n        } else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bf460de117c67053b6fb9141cc7c778e81e5ef54","date":1168027938,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","sourceNew":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        fieldTypes.put(ft.typeName,ft);\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          fields.put(f.getName(),f);\n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n        \t  fieldsWithDefaultValue.add( f );\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          dFields.add(new DynamicField(f));\n          log.fine(\"dynamic field defined: \" + f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n\n        String dest = DOMUtil.getAttr(attrs,\"dest\",\"copyField definition\");\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          dCopies.add(new DynamicCopy(source, d));\n        } else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        fieldTypes.put(ft.typeName,ft);\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          fields.put(f.getName(),f);\n          log.fine(\"field defined: \" + f);\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          dFields.add(new DynamicField(f));\n          log.fine(\"dynamic field defined: \" + f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n\n        String dest = DOMUtil.getAttr(attrs,\"dest\",\"copyField definition\");\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          dCopies.add(new DynamicCopy(source, d));\n        } else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f6131b7910c011aba5741539315107c7f04d5e11","date":1176315361,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","sourceNew":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        fieldTypes.put(ft.typeName,ft);\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          fields.put(f.getName(),f);\n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n        \t  fieldsWithDefaultValue.add( f );\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          dFields.add(new DynamicField(f));\n          log.fine(\"dynamic field defined: \" + f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n\n        String dest = DOMUtil.getAttr(attrs,\"dest\",\"copyField definition\");\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          dCopies.add(new DynamicCopy(source, d));\n        } else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        fieldTypes.put(ft.typeName,ft);\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          fields.put(f.getName(),f);\n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n        \t  fieldsWithDefaultValue.add( f );\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          dFields.add(new DynamicField(f));\n          log.fine(\"dynamic field defined: \" + f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n\n        String dest = DOMUtil.getAttr(attrs,\"dest\",\"copyField definition\");\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          dCopies.add(new DynamicCopy(source, d));\n        } else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"368c8927753a9ca6ee214a251da2746ff35aeef6","date":1177630664,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","sourceNew":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        fieldTypes.put(ft.typeName,ft);\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          fields.put(f.getName(),f);\n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n        \t  fieldsWithDefaultValue.add( f );\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          dFields.add(new DynamicField(f));\n          log.fine(\"dynamic field defined: \" + f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n\n        String dest = DOMUtil.getAttr(attrs,\"dest\",\"copyField definition\");\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          dCopies.add(new DynamicCopy(source, d));\n        } else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        fieldTypes.put(ft.typeName,ft);\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          fields.put(f.getName(),f);\n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n        \t  fieldsWithDefaultValue.add( f );\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          dFields.add(new DynamicField(f));\n          log.fine(\"dynamic field defined: \" + f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n\n        String dest = DOMUtil.getAttr(attrs,\"dest\",\"copyField definition\");\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          dCopies.add(new DynamicCopy(source, d));\n        } else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"335d5ef4d54c2861b4ebdc7244bd81278f1c1d22","date":1177887783,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","sourceNew":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        fieldTypes.put(ft.typeName,ft);\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          fields.put(f.getName(),f);\n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          dFields.add(new DynamicField(f));\n          log.fine(\"dynamic field defined: \" + f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n\n        String dest = DOMUtil.getAttr(attrs,\"dest\",\"copyField definition\");\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          dCopies.add(new DynamicCopy(source, d));\n        } else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        fieldTypes.put(ft.typeName,ft);\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          fields.put(f.getName(),f);\n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n        \t  fieldsWithDefaultValue.add( f );\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          dFields.add(new DynamicField(f));\n          log.fine(\"dynamic field defined: \" + f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n\n        String dest = DOMUtil.getAttr(attrs,\"dest\",\"copyField definition\");\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          dCopies.add(new DynamicCopy(source, d));\n        } else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aceda38d9d3f703668f1a4569473f90880ed3f1e","date":1178744011,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","sourceNew":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        FieldType old = fieldTypes.put(ft.typeName,ft);\n        if( old != null ) {\n          String msg = \"[schema.xml] Duplicate fieldType definition for '\"\n            + ft.typeName + \"' ignoring: \"+old.toString();\n          \n          Throwable t = new SolrException( 500, msg );\n          SolrException.logOnce(log,null,t);\n          SolrConfig.severeErrors.add( t );\n        }\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( 500, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( 500, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n\n        String dest = DOMUtil.getAttr(attrs,\"dest\",\"copyField definition\");\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          dCopies.add(new DynamicCopy(source, d));\n        } else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        fieldTypes.put(ft.typeName,ft);\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          fields.put(f.getName(),f);\n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          dFields.add(new DynamicField(f));\n          log.fine(\"dynamic field defined: \" + f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n\n        String dest = DOMUtil.getAttr(attrs,\"dest\",\"copyField definition\");\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          dCopies.add(new DynamicCopy(source, d));\n        } else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":["0aea57ab530d174e645bf6e14d04db1e243e13d7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80da508d266be0277931540f4d8f7905b54e7432","date":1178761952,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","sourceNew":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        FieldType old = fieldTypes.put(ft.typeName,ft);\n        if( old != null ) {\n          String msg = \"[schema.xml] Duplicate fieldType definition for '\"\n            + ft.typeName + \"' ignoring: \"+old.toString();\n          \n          Throwable t = new SolrException( 500, msg );\n          SolrException.logOnce(log,null,t);\n          SolrConfig.severeErrors.add( t );\n        }\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( 500, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( 500, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( 500, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( 500, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        FieldType old = fieldTypes.put(ft.typeName,ft);\n        if( old != null ) {\n          String msg = \"[schema.xml] Duplicate fieldType definition for '\"\n            + ft.typeName + \"' ignoring: \"+old.toString();\n          \n          Throwable t = new SolrException( 500, msg );\n          SolrException.logOnce(log,null,t);\n          SolrConfig.severeErrors.add( t );\n        }\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( 500, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( 500, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n\n        String dest = DOMUtil.getAttr(attrs,\"dest\",\"copyField definition\");\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          dCopies.add(new DynamicCopy(source, d));\n        } else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ffa55a3112f6a9ed19ca7e20579dff40c1f493b2","date":1180428723,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","sourceNew":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        FieldType old = fieldTypes.put(ft.typeName,ft);\n        if( old != null ) {\n          String msg = \"[schema.xml] Duplicate fieldType definition for '\"\n            + ft.typeName + \"' ignoring: \"+old.toString();\n          \n          Throwable t = new SolrException( 500, msg );\n          SolrException.logOnce(log,null,t);\n          SolrConfig.severeErrors.add( t );\n        }\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( 500, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( 500, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( 500, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( 500, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException(500,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        FieldType old = fieldTypes.put(ft.typeName,ft);\n        if( old != null ) {\n          String msg = \"[schema.xml] Duplicate fieldType definition for '\"\n            + ft.typeName + \"' ignoring: \"+old.toString();\n          \n          Throwable t = new SolrException( 500, msg );\n          SolrException.logOnce(log,null,t);\n          SolrConfig.severeErrors.add( t );\n        }\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( 500, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( 500, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( 500, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( 500, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException(1,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996","date":1180477701,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","sourceNew":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        FieldType old = fieldTypes.put(ft.typeName,ft);\n        if( old != null ) {\n          String msg = \"[schema.xml] Duplicate fieldType definition for '\"\n            + ft.typeName + \"' ignoring: \"+old.toString();\n          \n          Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n          SolrException.logOnce(log,null,t);\n          SolrConfig.severeErrors.add( t );\n        }\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        FieldType old = fieldTypes.put(ft.typeName,ft);\n        if( old != null ) {\n          String msg = \"[schema.xml] Duplicate fieldType definition for '\"\n            + ft.typeName + \"' ignoring: \"+old.toString();\n          \n          Throwable t = new SolrException( 500, msg );\n          SolrException.logOnce(log,null,t);\n          SolrConfig.severeErrors.add( t );\n        }\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException(400,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( 500, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( 500, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( 500, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( 500, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException(500,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":["cf718fc7210fb8e7744d4b69704a4c9f732d1e92","cf718fc7210fb8e7744d4b69704a4c9f732d1e92","cf718fc7210fb8e7744d4b69704a4c9f732d1e92","0aea57ab530d174e645bf6e14d04db1e243e13d7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0902cc3e4d3f7e4fe37a1474010f51523cafbbef","date":1181874468,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","sourceNew":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        FieldType old = fieldTypes.put(ft.typeName,ft);\n        if( old != null ) {\n          String msg = \"[schema.xml] Duplicate fieldType definition for '\"\n            + ft.typeName + \"' ignoring: \"+old.toString();\n          \n          Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n          SolrException.logOnce(log,null,t);\n          SolrConfig.severeErrors.add( t );\n        }\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        FieldType old = fieldTypes.put(ft.typeName,ft);\n        if( old != null ) {\n          String msg = \"[schema.xml] Duplicate fieldType definition for '\"\n            + ft.typeName + \"' ignoring: \"+old.toString();\n          \n          Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n          SolrException.logOnce(log,null,t);\n          SolrConfig.severeErrors.add( t );\n        }\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a4cc0532e82274748c1910318b92089c5604e48a","date":1183443010,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","sourceNew":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      final XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\" ) {\n\n        @Override\n        protected FieldType create( String name, String className, Map<String,String> params, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)Config.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Map<String, String> params, Node node) throws Exception {\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"fieldtype error\");\n        log.finest(\"reading fieldtype \"+name);\n        String clsName = DOMUtil.getAttr(attrs,\"class\", \"fieldtype error\");\n        FieldType ft = (FieldType)Config.newInstance(clsName);\n        ft.setTypeName(name);\n\n        expression = \"./analyzer[@type='query']\";\n        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer queryAnalyzer = readAnalyzer(anode);\n\n        // An analyzer without a type specified, or with type=\"index\"\n        expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n        Analyzer analyzer = readAnalyzer(anode);\n\n        if (queryAnalyzer==null) queryAnalyzer=analyzer;\n        if (analyzer==null) analyzer=queryAnalyzer;\n        if (analyzer!=null) {\n          ft.setAnalyzer(analyzer);\n          ft.setQueryAnalyzer(queryAnalyzer);\n        }\n\n\n        ft.setArgs(this, DOMUtil.toMapExcept(attrs,\"name\",\"class\"));\n        FieldType old = fieldTypes.put(ft.typeName,ft);\n        if( old != null ) {\n          String msg = \"[schema.xml] Duplicate fieldType definition for '\"\n            + ft.typeName + \"' ignoring: \"+old.toString();\n          \n          Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n          SolrException.logOnce(log,null,t);\n          SolrConfig.severeErrors.add( t );\n        }\n        log.finest(\"fieldtype defined: \" + ft);\n      }\n\n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29633c90dc51f05e4bbfe2e9f1991cdeee08b2d1","date":1183450581,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","sourceNew":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      final XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\" ) {\n\n        @Override\n        protected FieldType create( String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)Config.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      final XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\" ) {\n\n        @Override\n        protected FieldType create( String name, String className, Map<String,String> params, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)Config.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Map<String, String> params, Node node) throws Exception {\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6d6338c87060be5f66757a94945975f3bbd377a9","date":1189278234,"type":5,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/schema/IndexSchema#readSchema(SolrConfig).mjava","pathOld":"src/java/org/apache/solr/schema/IndexSchema#readConfig().mjava","sourceNew":"  private void readSchema(SolrConfig solrConfig) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config schemaConf = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\" ) {\n\n        @Override\n        protected FieldType create( SolrCore core, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)Config.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)solrConfig.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","sourceOld":"  private void readConfig() {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      /***\n      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      Document document = builder.parse(getInputStream());\n      ***/\n\n      Config config = new Config(\"schema\", getInputStream(), \"/schema/\");\n      Document document = config.getDocument();\n      final XPath xpath = config.getXPath();\n\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warning(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = config.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> loader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\" ) {\n\n        @Override\n        protected FieldType create( String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)Config.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.finest(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      loader.load( nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.finest(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n        String val;\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"'\",false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' ignoring: \"+old.toString();\n            \n            Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n          }\n          \n          log.fine(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.fine(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.fine(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          boolean dup = false;\n          for( DynamicField df : dFields ) {\n            if( df.regex.equals( f.name ) ) {\n              String msg = \"[schema.xml] Duplicate DynamicField definition for '\"\n                + f.getName() + \"' ignoring: \"+f.toString();\n              \n              Throwable t = new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n              SolrException.logOnce(log,null,t);\n              SolrConfig.severeErrors.add( t );\n              dup = true;\n              break;\n            }\n          }\n          if( !dup ) {\n            dFields.add(new DynamicField(f));\n            log.fine(\"dynamic field defined: \" + f);\n          }\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.finest(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity/@class\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarity = new DefaultSimilarity();\n      log.fine(\"using default similarity\");\n    } else {\n      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());\n      log.fine(\"using similarity \" + similarity.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) getIndexedField(defaultSearchFieldName);\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.fine(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warning(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n\n    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();\n\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n\n        boolean sourceIsPattern = isWildCard(source);\n        boolean destIsPattern   = isWildCard(dest);\n\n        log.fine(\"copyField source='\"+source+\"' dest='\"+dest+\"'\");\n        SchemaField d = getField(dest);\n\n        if(sourceIsPattern) {\n          if( destIsPattern ) {\n            DynamicField df = null;\n            for( DynamicField dd : dynamicFields ) {\n              if( dd.regex.equals( dest ) ) {\n                df = dd;\n                break;\n              }\n            }\n            if( df == null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \"copyField dynamic destination must match a dynamicField.\" );\n            }\n            dCopies.add(new DynamicDestCopy(source, df ));\n          }\n          else {\n            dCopies.add(new DynamicCopy(source, d));\n          }\n        } \n        else if( destIsPattern ) {\n          String msg =  \"copyField only supports a dynamic destination if the source is also dynamic\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n        else {\n          // retrieve the field to force an exception if it doesn't exist\n          SchemaField f = getField(source);\n\n          SchemaField[] destArr = copyFields.get(source);\n          if (destArr==null) {\n            destArr=new SchemaField[]{d};\n          } else {\n            destArr = (SchemaField[])append(destArr,d);\n          }\n          copyFields.put(source,destArr);\n          copyFieldTarget.add( d );\n        }\n     }\n\n      log.finest(\"Dynamic Copied Fields:\" + dCopies);\n\n      // stuff it in a normal array for faster access\n      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);\n\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n     analyzer = new SolrIndexAnalyzer();\n     queryAnalyzer = new SolrQueryAnalyzer();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"aceda38d9d3f703668f1a4569473f90880ed3f1e":["335d5ef4d54c2861b4ebdc7244bd81278f1c1d22"],"6d6338c87060be5f66757a94945975f3bbd377a9":["29633c90dc51f05e4bbfe2e9f1991cdeee08b2d1"],"f6131b7910c011aba5741539315107c7f04d5e11":["bf460de117c67053b6fb9141cc7c778e81e5ef54"],"368c8927753a9ca6ee214a251da2746ff35aeef6":["f6131b7910c011aba5741539315107c7f04d5e11"],"21400778a0bf704d187a4848279049f5d90276c8":["b451a0c4c12c9a8575a49bafc27463190c8b8833"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"80da508d266be0277931540f4d8f7905b54e7432":["aceda38d9d3f703668f1a4569473f90880ed3f1e"],"6af8262271cd1db53df95496839ffa27f984a3b1":["21400778a0bf704d187a4848279049f5d90276c8"],"335d5ef4d54c2861b4ebdc7244bd81278f1c1d22":["368c8927753a9ca6ee214a251da2746ff35aeef6"],"b451a0c4c12c9a8575a49bafc27463190c8b8833":["9f3ac363fd9c46488a0996cc9c80b7d0bf005dbd"],"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996":["ffa55a3112f6a9ed19ca7e20579dff40c1f493b2"],"9f3ac363fd9c46488a0996cc9c80b7d0bf005dbd":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"29633c90dc51f05e4bbfe2e9f1991cdeee08b2d1":["a4cc0532e82274748c1910318b92089c5604e48a"],"a4cc0532e82274748c1910318b92089c5604e48a":["0902cc3e4d3f7e4fe37a1474010f51523cafbbef"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0902cc3e4d3f7e4fe37a1474010f51523cafbbef":["c4abe53aaee39b5f2f41dd9a0b905c1ddf880996"],"ffa55a3112f6a9ed19ca7e20579dff40c1f493b2":["80da508d266be0277931540f4d8f7905b54e7432"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bf460de117c67053b6fb9141cc7c778e81e5ef54":["6af8262271cd1db53df95496839ffa27f984a3b1"]},"commit2Childs":{"aceda38d9d3f703668f1a4569473f90880ed3f1e":["80da508d266be0277931540f4d8f7905b54e7432"],"6d6338c87060be5f66757a94945975f3bbd377a9":[],"f6131b7910c011aba5741539315107c7f04d5e11":["368c8927753a9ca6ee214a251da2746ff35aeef6"],"368c8927753a9ca6ee214a251da2746ff35aeef6":["335d5ef4d54c2861b4ebdc7244bd81278f1c1d22"],"21400778a0bf704d187a4848279049f5d90276c8":["6af8262271cd1db53df95496839ffa27f984a3b1"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"80da508d266be0277931540f4d8f7905b54e7432":["ffa55a3112f6a9ed19ca7e20579dff40c1f493b2"],"6af8262271cd1db53df95496839ffa27f984a3b1":["bf460de117c67053b6fb9141cc7c778e81e5ef54"],"335d5ef4d54c2861b4ebdc7244bd81278f1c1d22":["aceda38d9d3f703668f1a4569473f90880ed3f1e"],"b451a0c4c12c9a8575a49bafc27463190c8b8833":["21400778a0bf704d187a4848279049f5d90276c8"],"c4abe53aaee39b5f2f41dd9a0b905c1ddf880996":["0902cc3e4d3f7e4fe37a1474010f51523cafbbef"],"9f3ac363fd9c46488a0996cc9c80b7d0bf005dbd":["b451a0c4c12c9a8575a49bafc27463190c8b8833"],"29633c90dc51f05e4bbfe2e9f1991cdeee08b2d1":["6d6338c87060be5f66757a94945975f3bbd377a9"],"a4cc0532e82274748c1910318b92089c5604e48a":["29633c90dc51f05e4bbfe2e9f1991cdeee08b2d1"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["9f3ac363fd9c46488a0996cc9c80b7d0bf005dbd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0902cc3e4d3f7e4fe37a1474010f51523cafbbef":["a4cc0532e82274748c1910318b92089c5604e48a"],"ffa55a3112f6a9ed19ca7e20579dff40c1f493b2":["c4abe53aaee39b5f2f41dd9a0b905c1ddf880996"],"bf460de117c67053b6fb9141cc7c778e81e5ef54":["f6131b7910c011aba5741539315107c7f04d5e11"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["6d6338c87060be5f66757a94945975f3bbd377a9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}