{"path":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long,boolean).mjava","commits":[{"id":"f09dfe4eae83c6f3ce87c6267cb774e4da0a2d73","date":1504185139,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","sourceNew":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   * @param omitCommitted if a tlog is already committed then don't read it\n   */\n  public void copyOverOldUpdates(long commitVersion, boolean omitCommitted) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (omitCommitted && oldTlog.endsWithCommit()) return;\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","sourceOld":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) {\n        return;\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":1,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","sourceNew":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   * @param omitCommitted if a tlog is already committed then don't read it\n   */\n  public void copyOverOldUpdates(long commitVersion, boolean omitCommitted) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (omitCommitted && oldTlog.endsWithCommit()) return;\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","sourceOld":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) {\n        return;\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","date":1504848000,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","sourceNew":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   * @param omitCommitted if a tlog is already committed then don't read it\n   */\n  public void copyOverOldUpdates(long commitVersion, boolean omitCommitted) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (omitCommitted && oldTlog.endsWithCommit()) return;\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","sourceOld":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) {\n        return;\n      }\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04ecf884544ff74add5faa452748f160c4af904b","date":1506527215,"type":5,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long,boolean).mjava","sourceNew":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) return;\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n    copyOverOldUpdatesMeter.mark();\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","sourceOld":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   * @param omitCommitted if a tlog is already committed then don't read it\n   */\n  public void copyOverOldUpdates(long commitVersion, boolean omitCommitted) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (omitCommitted && oldTlog.endsWithCommit()) return;\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/UpdateLog#copyOverOldUpdates(long,boolean).mjava","sourceNew":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   */\n  public void copyOverOldUpdates(long commitVersion) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (oldTlog.endsWithCommit()) return;\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n    copyOverOldUpdatesMeter.mark();\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","sourceOld":"  /**\n   * Copy over updates from prevTlog or last tlog (in tlog folder) to a new tlog\n   * @param commitVersion any updates that have version larger than the commitVersion will be copied over\n   * @param omitCommitted if a tlog is already committed then don't read it\n   */\n  public void copyOverOldUpdates(long commitVersion, boolean omitCommitted) {\n    TransactionLog oldTlog = prevTlog;\n    if (oldTlog == null && !logs.isEmpty()) {\n      oldTlog = logs.getFirst();\n    }\n    if (oldTlog == null || oldTlog.refcount.get() == 0) {\n      return;\n    }\n\n    try {\n      if (omitCommitted && oldTlog.endsWithCommit()) return;\n    } catch (IOException e) {\n      log.warn(\"Exception reading log\", e);\n      return;\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core,\n        new ModifiableSolrParams());\n    TransactionLog.LogReader logReader = oldTlog.getReader(0);\n    Object o = null;\n    try {\n      while ( (o = logReader.next()) != null ) {\n        try {\n          List entry = (List)o;\n          int operationAndFlags = (Integer) entry.get(0);\n          int oper = operationAndFlags & OPERATION_MASK;\n          long version = (Long) entry.get(1);\n          if (Math.abs(version) > commitVersion) {\n            switch (oper) {\n              case UpdateLog.UPDATE_INPLACE:\n              case UpdateLog.ADD: {\n                AddUpdateCommand cmd = convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                add(cmd);\n                break;\n              }\n              case UpdateLog.DELETE: {\n                byte[] idBytes = (byte[]) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.setIndexedId(new BytesRef(idBytes));\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                delete(cmd);\n                break;\n              }\n\n              case UpdateLog.DELETE_BY_QUERY: {\n                String query = (String) entry.get(2);\n                DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n                cmd.query = query;\n                cmd.setVersion(version);\n                cmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);\n                deleteByQuery(cmd);\n                break;\n              }\n\n              default:\n                throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unknown Operation! \" + oper);\n            }\n          }\n        } catch (ClassCastException e) {\n          log.warn(\"Unexpected log entry or corrupt log.  Entry=\" + o, e);\n        }\n      }\n      // Prev tlog will be closed, so nullify prevMap\n      if (prevTlog == oldTlog) {\n        prevMap = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Exception reading versions from log\",e);\n    } catch (InterruptedException e) {\n      log.warn(\"Exception reading log\", e);\n    } finally {\n      if (logReader != null) logReader.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"04ecf884544ff74add5faa452748f160c4af904b":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f09dfe4eae83c6f3ce87c6267cb774e4da0a2d73"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f09dfe4eae83c6f3ce87c6267cb774e4da0a2d73"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","04ecf884544ff74add5faa452748f160c4af904b"],"f09dfe4eae83c6f3ce87c6267cb774e4da0a2d73":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["04ecf884544ff74add5faa452748f160c4af904b"]},"commit2Childs":{"04ecf884544ff74add5faa452748f160c4af904b":["6240b74b884c5587f2a4062dd27d6c32bf228889","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"104a3f62ee393d48b5596de76ed4d9a4e0ea6de7":["04ecf884544ff74add5faa452748f160c4af904b"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["6240b74b884c5587f2a4062dd27d6c32bf228889"],"6240b74b884c5587f2a4062dd27d6c32bf228889":[],"f09dfe4eae83c6f3ce87c6267cb774e4da0a2d73":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["104a3f62ee393d48b5596de76ed4d9a4e0ea6de7","3a7809d1d753b67f48b1a706e17034bf8b624ea3","f09dfe4eae83c6f3ce87c6267cb774e4da0a2d73"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["6240b74b884c5587f2a4062dd27d6c32bf228889","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}