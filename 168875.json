{"path":"lucene/facet/src/test/org/apache/lucene/facet/TestLongValueFacetCounts#testRandom().mjava","commits":[{"id":"4513731041236fcf659e5bfc43d8862e1721a310","date":1504022253,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestLongValueFacetCounts#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int valueCount = atLeast(1000);\n    double missingChance = random().nextDouble();\n    long maxValue;\n    if (random().nextBoolean()) {\n      maxValue = random().nextLong() & Long.MAX_VALUE;\n    } else {\n      maxValue = random().nextInt(1000);\n    }\n    if (VERBOSE) {\n      System.out.println(\"TEST: valueCount=\" + valueCount + \" valueRange=-\" + maxValue +\n                         \"-\" + maxValue + \" missingChance=\" + missingChance);\n    }\n    Long[] values = new Long[valueCount];\n    int missingCount = 0;\n    for (int i = 0; i < valueCount; i++) {\n      Document doc = new Document();\n      doc.add(new IntPoint(\"id\", i));\n      if (random().nextDouble() > missingChance) {\n        long value = TestUtil.nextLong(random(), -maxValue, maxValue);\n        doc.add(new NumericDocValuesField(\"field\", value));\n        values[i] = value;\n      } else {\n        missingCount++;\n      }\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(100);\n    for (int iter = 0; iter < iters; iter++) {\n      FacetsCollector fc = new FacetsCollector();\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter);\n        System.out.println(\"  test all docs\");\n      }\n\n      // all docs\n      Map<Long, Integer> expected = new HashMap<>();\n      int expectedChildCount = 0;\n      for (int i = 0; i < valueCount; i++) {\n        if (values[i] != null) {\n          Integer curCount = expected.get(values[i]);\n          if (curCount == null) {\n            curCount = 0;\n            expectedChildCount++;\n          }\n          expected.put(values[i], curCount + 1);\n        }\n      }\n\n      List<Map.Entry<Long, Integer>> expectedCounts = new ArrayList<>(expected.entrySet());\n\n      // sort by value\n      Collections.sort(expectedCounts,\n                       (a, b) -> (Long.compare(a.getKey(), b.getKey())));\n\n      LongValueFacetCounts facetCounts;\n      if (random().nextBoolean()) {\n        s.search(new MatchAllDocsQuery(), fc);\n        if (random().nextBoolean()) {\n          if (VERBOSE) {\n            System.out.println(\"  use value source\");\n          }\n          facetCounts = new LongValueFacetCounts(\"field\", LongValuesSource.fromLongField(\"field\"), fc);\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  use doc values\");\n          }\n          facetCounts = new LongValueFacetCounts(\"field\", fc, false);\n        }\n      } else {\n        // optimized count all:\n        if (random().nextBoolean()) {\n          if (VERBOSE) {\n            System.out.println(\"  count all value source\");\n          }\n          facetCounts = new LongValueFacetCounts(\"field\", LongValuesSource.fromLongField(\"field\"), r);\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  count all doc values\");\n          }\n          facetCounts = new LongValueFacetCounts(\"field\", r, false);\n        }          \n      }\n\n      FacetResult actual = facetCounts.getAllChildrenSortByValue();\n      assertSame(\"all docs, sort facets by value\", expectedCounts, expectedChildCount,\n                 valueCount - missingCount, actual, Integer.MAX_VALUE);\n\n      // sort by count\n      Collections.sort(expectedCounts,\n                       (a, b) -> {\n                         int cmp = -Integer.compare(a.getValue(), b.getValue());\n                         if (cmp == 0) {\n                           // tie break by value\n                           cmp = Long.compare(a.getKey(), b.getKey());\n                         }\n                         return cmp;\n                       });\n      int topN;\n      if (random().nextBoolean()) {\n        topN = valueCount;\n      } else {\n        topN = random().nextInt(valueCount);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  topN=\" + topN);\n      }\n      actual = facetCounts.getTopChildrenSortByCount(topN);\n      assertSame(\"all docs, sort facets by count\", expectedCounts, expectedChildCount, valueCount - missingCount, actual, topN);\n\n      // subset of docs\n      int minId = random().nextInt(valueCount);\n      int maxId = random().nextInt(valueCount);\n      if (minId > maxId) {\n        int tmp = minId;\n        minId = maxId;\n        maxId = tmp;\n      }\n      if (VERBOSE) {\n        System.out.println(\"  test id range \" + minId + \"-\" + maxId);\n      }\n\n      fc = new FacetsCollector();\n      s.search(IntPoint.newRangeQuery(\"id\", minId, maxId), fc);\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"  use doc values\");\n        }\n        facetCounts = new LongValueFacetCounts(\"field\", fc, false);\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  use value source\");\n        }\n        facetCounts = new LongValueFacetCounts(\"field\", LongValuesSource.fromLongField(\"field\"), fc);\n      }\n\n      expected = new HashMap<>();\n      expectedChildCount = 0;\n      int totCount = 0;\n      for (int i = minId; i <= maxId; i++) {\n        if (values[i] != null) {\n          totCount++;\n          Integer curCount = expected.get(values[i]);\n          if (curCount == null) {\n            expectedChildCount++;\n            curCount = 0;\n          }\n          expected.put(values[i], curCount + 1);\n        }\n      }\n      expectedCounts = new ArrayList<>(expected.entrySet());\n\n      // sort by value\n      Collections.sort(expectedCounts,\n                       (a, b) -> (Long.compare(a.getKey(), b.getKey())));\n      actual = facetCounts.getAllChildrenSortByValue();\n      assertSame(\"id \" + minId + \"-\" + maxId + \", sort facets by value\", expectedCounts,\n                 expectedChildCount, totCount, actual, Integer.MAX_VALUE);\n\n      // sort by count\n      Collections.sort(expectedCounts,\n                       (a, b) -> {\n                         int cmp = -Integer.compare(a.getValue(), b.getValue());\n                         if (cmp == 0) {\n                           // tie break by value\n                           cmp = Long.compare(a.getKey(), b.getKey());\n                         }\n                         return cmp;\n                       });\n      if (random().nextBoolean()) {\n        topN = valueCount;\n      } else {\n        topN = random().nextInt(valueCount);\n      }\n      actual = facetCounts.getTopChildrenSortByCount(topN);\n      assertSame(\"id \" + minId + \"-\" + maxId + \", sort facets by count\", expectedCounts, expectedChildCount, totCount, actual, topN);\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6028626aa0f7c266ef725110257eed11e5b3d1d7","date":1504104056,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestLongValueFacetCounts#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int valueCount = atLeast(1000);\n    double missingChance = random().nextDouble();\n    long maxValue;\n    if (random().nextBoolean()) {\n      maxValue = random().nextLong() & Long.MAX_VALUE;\n    } else {\n      maxValue = random().nextInt(1000);\n    }\n    if (VERBOSE) {\n      System.out.println(\"TEST: valueCount=\" + valueCount + \" valueRange=-\" + maxValue +\n                         \"-\" + maxValue + \" missingChance=\" + missingChance);\n    }\n    Long[] values = new Long[valueCount];\n    int missingCount = 0;\n    for (int i = 0; i < valueCount; i++) {\n      Document doc = new Document();\n      doc.add(new IntPoint(\"id\", i));\n      if (random().nextDouble() > missingChance) {\n        long value = TestUtil.nextLong(random(), -maxValue, maxValue);\n        doc.add(new NumericDocValuesField(\"field\", value));\n        values[i] = value;\n      } else {\n        missingCount++;\n      }\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(100);\n    for (int iter = 0; iter < iters; iter++) {\n      FacetsCollector fc = new FacetsCollector();\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter);\n        System.out.println(\"  test all docs\");\n      }\n\n      // all docs\n      Map<Long, Integer> expected = new HashMap<>();\n      int expectedChildCount = 0;\n      for (int i = 0; i < valueCount; i++) {\n        if (values[i] != null) {\n          Integer curCount = expected.get(values[i]);\n          if (curCount == null) {\n            curCount = 0;\n            expectedChildCount++;\n          }\n          expected.put(values[i], curCount + 1);\n        }\n      }\n\n      List<Map.Entry<Long, Integer>> expectedCounts = new ArrayList<>(expected.entrySet());\n\n      // sort by value\n      Collections.sort(expectedCounts,\n                       (a, b) -> (Long.compare(a.getKey(), b.getKey())));\n\n      LongValueFacetCounts facetCounts;\n      if (random().nextBoolean()) {\n        s.search(new MatchAllDocsQuery(), fc);\n        if (random().nextBoolean()) {\n          if (VERBOSE) {\n            System.out.println(\"  use value source\");\n          }\n          facetCounts = new LongValueFacetCounts(\"field\", LongValuesSource.fromLongField(\"field\"), fc);\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  use doc values\");\n          }\n          facetCounts = new LongValueFacetCounts(\"field\", fc, false);\n        }\n      } else {\n        // optimized count all:\n        if (random().nextBoolean()) {\n          if (VERBOSE) {\n            System.out.println(\"  count all value source\");\n          }\n          facetCounts = new LongValueFacetCounts(\"field\", LongValuesSource.fromLongField(\"field\"), r);\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  count all doc values\");\n          }\n          facetCounts = new LongValueFacetCounts(\"field\", r, false);\n        }          \n      }\n\n      FacetResult actual = facetCounts.getAllChildrenSortByValue();\n      assertSame(\"all docs, sort facets by value\", expectedCounts, expectedChildCount,\n                 valueCount - missingCount, actual, Integer.MAX_VALUE);\n\n      // sort by count\n      Collections.sort(expectedCounts,\n                       (a, b) -> {\n                         int cmp = -Integer.compare(a.getValue(), b.getValue());\n                         if (cmp == 0) {\n                           // tie break by value\n                           cmp = Long.compare(a.getKey(), b.getKey());\n                         }\n                         return cmp;\n                       });\n      int topN;\n      if (random().nextBoolean()) {\n        topN = valueCount;\n      } else {\n        topN = random().nextInt(valueCount);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  topN=\" + topN);\n      }\n      actual = facetCounts.getTopChildrenSortByCount(topN);\n      assertSame(\"all docs, sort facets by count\", expectedCounts, expectedChildCount, valueCount - missingCount, actual, topN);\n\n      // subset of docs\n      int minId = random().nextInt(valueCount);\n      int maxId = random().nextInt(valueCount);\n      if (minId > maxId) {\n        int tmp = minId;\n        minId = maxId;\n        maxId = tmp;\n      }\n      if (VERBOSE) {\n        System.out.println(\"  test id range \" + minId + \"-\" + maxId);\n      }\n\n      fc = new FacetsCollector();\n      s.search(IntPoint.newRangeQuery(\"id\", minId, maxId), fc);\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"  use doc values\");\n        }\n        facetCounts = new LongValueFacetCounts(\"field\", fc, false);\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  use value source\");\n        }\n        facetCounts = new LongValueFacetCounts(\"field\", LongValuesSource.fromLongField(\"field\"), fc);\n      }\n\n      expected = new HashMap<>();\n      expectedChildCount = 0;\n      int totCount = 0;\n      for (int i = minId; i <= maxId; i++) {\n        if (values[i] != null) {\n          totCount++;\n          Integer curCount = expected.get(values[i]);\n          if (curCount == null) {\n            expectedChildCount++;\n            curCount = 0;\n          }\n          expected.put(values[i], curCount + 1);\n        }\n      }\n      expectedCounts = new ArrayList<>(expected.entrySet());\n\n      // sort by value\n      Collections.sort(expectedCounts,\n                       (a, b) -> (Long.compare(a.getKey(), b.getKey())));\n      actual = facetCounts.getAllChildrenSortByValue();\n      assertSame(\"id \" + minId + \"-\" + maxId + \", sort facets by value\", expectedCounts,\n                 expectedChildCount, totCount, actual, Integer.MAX_VALUE);\n\n      // sort by count\n      Collections.sort(expectedCounts,\n                       (a, b) -> {\n                         int cmp = -Integer.compare(a.getValue(), b.getValue());\n                         if (cmp == 0) {\n                           // tie break by value\n                           cmp = Long.compare(a.getKey(), b.getKey());\n                         }\n                         return cmp;\n                       });\n      if (random().nextBoolean()) {\n        topN = valueCount;\n      } else {\n        topN = random().nextInt(valueCount);\n      }\n      actual = facetCounts.getTopChildrenSortByCount(topN);\n      assertSame(\"id \" + minId + \"-\" + maxId + \", sort facets by count\", expectedCounts, expectedChildCount, totCount, actual, topN);\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a7809d1d753b67f48b1a706e17034bf8b624ea3","date":1504366927,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/TestLongValueFacetCounts#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n\n    int valueCount = atLeast(1000);\n    double missingChance = random().nextDouble();\n    long maxValue;\n    if (random().nextBoolean()) {\n      maxValue = random().nextLong() & Long.MAX_VALUE;\n    } else {\n      maxValue = random().nextInt(1000);\n    }\n    if (VERBOSE) {\n      System.out.println(\"TEST: valueCount=\" + valueCount + \" valueRange=-\" + maxValue +\n                         \"-\" + maxValue + \" missingChance=\" + missingChance);\n    }\n    Long[] values = new Long[valueCount];\n    int missingCount = 0;\n    for (int i = 0; i < valueCount; i++) {\n      Document doc = new Document();\n      doc.add(new IntPoint(\"id\", i));\n      if (random().nextDouble() > missingChance) {\n        long value = TestUtil.nextLong(random(), -maxValue, maxValue);\n        doc.add(new NumericDocValuesField(\"field\", value));\n        values[i] = value;\n      } else {\n        missingCount++;\n      }\n      w.addDocument(doc);\n    }\n\n    IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int iters = atLeast(100);\n    for (int iter = 0; iter < iters; iter++) {\n      FacetsCollector fc = new FacetsCollector();\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter);\n        System.out.println(\"  test all docs\");\n      }\n\n      // all docs\n      Map<Long, Integer> expected = new HashMap<>();\n      int expectedChildCount = 0;\n      for (int i = 0; i < valueCount; i++) {\n        if (values[i] != null) {\n          Integer curCount = expected.get(values[i]);\n          if (curCount == null) {\n            curCount = 0;\n            expectedChildCount++;\n          }\n          expected.put(values[i], curCount + 1);\n        }\n      }\n\n      List<Map.Entry<Long, Integer>> expectedCounts = new ArrayList<>(expected.entrySet());\n\n      // sort by value\n      Collections.sort(expectedCounts,\n                       (a, b) -> (Long.compare(a.getKey(), b.getKey())));\n\n      LongValueFacetCounts facetCounts;\n      if (random().nextBoolean()) {\n        s.search(new MatchAllDocsQuery(), fc);\n        if (random().nextBoolean()) {\n          if (VERBOSE) {\n            System.out.println(\"  use value source\");\n          }\n          facetCounts = new LongValueFacetCounts(\"field\", LongValuesSource.fromLongField(\"field\"), fc);\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  use doc values\");\n          }\n          facetCounts = new LongValueFacetCounts(\"field\", fc, false);\n        }\n      } else {\n        // optimized count all:\n        if (random().nextBoolean()) {\n          if (VERBOSE) {\n            System.out.println(\"  count all value source\");\n          }\n          facetCounts = new LongValueFacetCounts(\"field\", LongValuesSource.fromLongField(\"field\"), r);\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  count all doc values\");\n          }\n          facetCounts = new LongValueFacetCounts(\"field\", r, false);\n        }          \n      }\n\n      FacetResult actual = facetCounts.getAllChildrenSortByValue();\n      assertSame(\"all docs, sort facets by value\", expectedCounts, expectedChildCount,\n                 valueCount - missingCount, actual, Integer.MAX_VALUE);\n\n      // sort by count\n      Collections.sort(expectedCounts,\n                       (a, b) -> {\n                         int cmp = -Integer.compare(a.getValue(), b.getValue());\n                         if (cmp == 0) {\n                           // tie break by value\n                           cmp = Long.compare(a.getKey(), b.getKey());\n                         }\n                         return cmp;\n                       });\n      int topN;\n      if (random().nextBoolean()) {\n        topN = valueCount;\n      } else {\n        topN = random().nextInt(valueCount);\n      }\n      if (VERBOSE) {\n        System.out.println(\"  topN=\" + topN);\n      }\n      actual = facetCounts.getTopChildrenSortByCount(topN);\n      assertSame(\"all docs, sort facets by count\", expectedCounts, expectedChildCount, valueCount - missingCount, actual, topN);\n\n      // subset of docs\n      int minId = random().nextInt(valueCount);\n      int maxId = random().nextInt(valueCount);\n      if (minId > maxId) {\n        int tmp = minId;\n        minId = maxId;\n        maxId = tmp;\n      }\n      if (VERBOSE) {\n        System.out.println(\"  test id range \" + minId + \"-\" + maxId);\n      }\n\n      fc = new FacetsCollector();\n      s.search(IntPoint.newRangeQuery(\"id\", minId, maxId), fc);\n      if (random().nextBoolean()) {\n        if (VERBOSE) {\n          System.out.println(\"  use doc values\");\n        }\n        facetCounts = new LongValueFacetCounts(\"field\", fc, false);\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  use value source\");\n        }\n        facetCounts = new LongValueFacetCounts(\"field\", LongValuesSource.fromLongField(\"field\"), fc);\n      }\n\n      expected = new HashMap<>();\n      expectedChildCount = 0;\n      int totCount = 0;\n      for (int i = minId; i <= maxId; i++) {\n        if (values[i] != null) {\n          totCount++;\n          Integer curCount = expected.get(values[i]);\n          if (curCount == null) {\n            expectedChildCount++;\n            curCount = 0;\n          }\n          expected.put(values[i], curCount + 1);\n        }\n      }\n      expectedCounts = new ArrayList<>(expected.entrySet());\n\n      // sort by value\n      Collections.sort(expectedCounts,\n                       (a, b) -> (Long.compare(a.getKey(), b.getKey())));\n      actual = facetCounts.getAllChildrenSortByValue();\n      assertSame(\"id \" + minId + \"-\" + maxId + \", sort facets by value\", expectedCounts,\n                 expectedChildCount, totCount, actual, Integer.MAX_VALUE);\n\n      // sort by count\n      Collections.sort(expectedCounts,\n                       (a, b) -> {\n                         int cmp = -Integer.compare(a.getValue(), b.getValue());\n                         if (cmp == 0) {\n                           // tie break by value\n                           cmp = Long.compare(a.getKey(), b.getKey());\n                         }\n                         return cmp;\n                       });\n      if (random().nextBoolean()) {\n        topN = valueCount;\n      } else {\n        topN = random().nextInt(valueCount);\n      }\n      actual = facetCounts.getTopChildrenSortByCount(topN);\n      assertSame(\"id \" + minId + \"-\" + maxId + \", sort facets by count\", expectedCounts, expectedChildCount, totCount, actual, topN);\n    }\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6028626aa0f7c266ef725110257eed11e5b3d1d7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4513731041236fcf659e5bfc43d8862e1721a310"],"4513731041236fcf659e5bfc43d8862e1721a310":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6028626aa0f7c266ef725110257eed11e5b3d1d7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6028626aa0f7c266ef725110257eed11e5b3d1d7"]},"commit2Childs":{"6028626aa0f7c266ef725110257eed11e5b3d1d7":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4513731041236fcf659e5bfc43d8862e1721a310":["6028626aa0f7c266ef725110257eed11e5b3d1d7"],"3a7809d1d753b67f48b1a706e17034bf8b624ea3":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6028626aa0f7c266ef725110257eed11e5b3d1d7","4513731041236fcf659e5bfc43d8862e1721a310","3a7809d1d753b67f48b1a706e17034bf8b624ea3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3a7809d1d753b67f48b1a706e17034bf8b624ea3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}