{"path":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#promoteReplica().mjava","commits":[{"id":"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","date":1453892412,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#promoteReplica().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestNRTReplication#promoteReplica().mjava","sourceNew":"  /** Picks a replica and promotes it as new primary. */\n  private void promoteReplica() throws IOException {\n    message(\"top: primary crashed; now pick replica to promote\");\n    long maxSearchingVersion = -1;\n    NodeProcess replicaToPromote = null;\n\n    // We must promote the most current replica, because otherwise file name reuse can cause a replication to fail when it needs to copy\n    // over a file currently held open for searching.  This also minimizes recovery work since the most current replica means less xlog\n    // replay to catch up:\n    for (NodeProcess node : nodes) {\n      if (node != null) {\n        message(\"ask \" + node + \" for its current searching version\");\n        long searchingVersion = node.getSearchingVersion();\n        message(node + \" has searchingVersion=\" + searchingVersion);\n        if (searchingVersion > maxSearchingVersion) {\n          maxSearchingVersion = searchingVersion;\n          replicaToPromote = node;\n        }\n      }\n    }\n\n    if (replicaToPromote == null) {\n      message(\"top: no replicas running; skipping primary promotion\");\n      return;\n    }\n\n    message(\"top: promote \" + replicaToPromote + \" version=\" + maxSearchingVersion + \"; now commit\");\n    if (replicaToPromote.commit() == false) {\n      message(\"top: commit failed; skipping primary promotion\");\n      return;\n    }\n\n    message(\"top: now shutdown \" + replicaToPromote);\n    if (replicaToPromote.shutdown() == false) {\n      message(\"top: shutdown failed for R\" + replicaToPromote.id + \"; skipping primary promotion\");\n      return;\n    }\n\n    int id = replicaToPromote.id;\n    message(\"top: now startPrimary \" + replicaToPromote);\n    startPrimary(replicaToPromote.id);\n  }\n\n","sourceOld":"  /** Picks a replica and promotes it as new primary. */\n  private void promoteReplica() throws IOException {\n    message(\"top: primary crashed; now pick replica to promote\");\n    long maxSearchingVersion = -1;\n    NodeProcess replicaToPromote = null;\n\n    // We must promote the most current replica, because otherwise file name reuse can cause a replication to fail when it needs to copy\n    // over a file currently held open for searching.  This also minimizes recovery work since the most current replica means less xlog\n    // replay to catch up:\n    for (NodeProcess node : nodes) {\n      if (node != null) {\n        message(\"ask \" + node + \" for its current searching version\");\n        long searchingVersion = node.getSearchingVersion();\n        message(node + \" has searchingVersion=\" + searchingVersion);\n        if (searchingVersion > maxSearchingVersion) {\n          maxSearchingVersion = searchingVersion;\n          replicaToPromote = node;\n        }\n      }\n    }\n\n    if (replicaToPromote == null) {\n      message(\"top: no replicas running; skipping primary promotion\");\n      return;\n    }\n\n    message(\"top: promote \" + replicaToPromote + \" version=\" + maxSearchingVersion + \"; now commit\");\n    if (replicaToPromote.commit() == false) {\n      message(\"top: commit failed; skipping primary promotion\");\n      return;\n    }\n\n    message(\"top: now shutdown \" + replicaToPromote);\n    if (replicaToPromote.shutdown() == false) {\n      message(\"top: shutdown failed for R\" + replicaToPromote.id + \"; skipping primary promotion\");\n      return;\n    }\n\n    int id = replicaToPromote.id;\n    message(\"top: now startPrimary \" + replicaToPromote);\n    startPrimary(replicaToPromote.id);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"13ea66b549e25413e4e3057bf3492ab828899110","date":1454958424,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#promoteReplica().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#promoteReplica().mjava","sourceNew":"  /** Picks a replica and promotes it as new primary. */\n  private void promoteReplica() throws IOException {\n    message(\"top: primary crashed; now pick replica to promote\");\n    long maxSearchingVersion = -1;\n    NodeProcess replicaToPromote = null;\n\n    // We must promote the most current replica, because otherwise file name reuse can cause a replication to fail when it needs to copy\n    // over a file currently held open for searching.  This also minimizes recovery work since the most current replica means less xlog\n    // replay to catch up:\n    for (NodeProcess node : nodes) {\n      if (node != null) {\n        message(\"ask \" + node + \" for its current searching version\");\n        long searchingVersion;\n        try {\n          searchingVersion = node.getSearchingVersion();\n        } catch (Throwable t) {\n          message(\"top: hit SocketException during getSearchingVersion with R\" + node.id + \"; skipping\");\n          t.printStackTrace(System.out);\n          continue;\n        }\n        message(node + \" has searchingVersion=\" + searchingVersion);\n        if (searchingVersion > maxSearchingVersion) {\n          maxSearchingVersion = searchingVersion;\n          replicaToPromote = node;\n        }\n      }\n    }\n\n    if (replicaToPromote == null) {\n      message(\"top: no replicas running; skipping primary promotion\");\n      return;\n    }\n\n    message(\"top: promote \" + replicaToPromote + \" version=\" + maxSearchingVersion + \"; now commit\");\n    try {\n      replicaToPromote.commit();\n    } catch (Throwable t) {\n      // Something wrong with this replica; skip it:\n      message(\"top: hit exception during commit with R\" + replicaToPromote.id + \"; skipping\");\n      t.printStackTrace(System.out);\n      return;\n    }\n\n    message(\"top: now shutdown \" + replicaToPromote);\n    if (replicaToPromote.shutdown() == false) {\n      message(\"top: shutdown failed for R\" + replicaToPromote.id + \"; skipping primary promotion\");\n      return;\n    }\n\n    int id = replicaToPromote.id;\n    message(\"top: now startPrimary \" + replicaToPromote);\n    startPrimary(replicaToPromote.id);\n  }\n\n","sourceOld":"  /** Picks a replica and promotes it as new primary. */\n  private void promoteReplica() throws IOException {\n    message(\"top: primary crashed; now pick replica to promote\");\n    long maxSearchingVersion = -1;\n    NodeProcess replicaToPromote = null;\n\n    // We must promote the most current replica, because otherwise file name reuse can cause a replication to fail when it needs to copy\n    // over a file currently held open for searching.  This also minimizes recovery work since the most current replica means less xlog\n    // replay to catch up:\n    for (NodeProcess node : nodes) {\n      if (node != null) {\n        message(\"ask \" + node + \" for its current searching version\");\n        long searchingVersion = node.getSearchingVersion();\n        message(node + \" has searchingVersion=\" + searchingVersion);\n        if (searchingVersion > maxSearchingVersion) {\n          maxSearchingVersion = searchingVersion;\n          replicaToPromote = node;\n        }\n      }\n    }\n\n    if (replicaToPromote == null) {\n      message(\"top: no replicas running; skipping primary promotion\");\n      return;\n    }\n\n    message(\"top: promote \" + replicaToPromote + \" version=\" + maxSearchingVersion + \"; now commit\");\n    if (replicaToPromote.commit() == false) {\n      message(\"top: commit failed; skipping primary promotion\");\n      return;\n    }\n\n    message(\"top: now shutdown \" + replicaToPromote);\n    if (replicaToPromote.shutdown() == false) {\n      message(\"top: shutdown failed for R\" + replicaToPromote.id + \"; skipping primary promotion\");\n      return;\n    }\n\n    int id = replicaToPromote.id;\n    message(\"top: now startPrimary \" + replicaToPromote);\n    startPrimary(replicaToPromote.id);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1b0febf62c2d9baeee7db38998d9197700ccbab9","date":1454958476,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#promoteReplica().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#promoteReplica().mjava","sourceNew":"  /** Picks a replica and promotes it as new primary. */\n  private void promoteReplica() throws IOException {\n    message(\"top: primary crashed; now pick replica to promote\");\n    long maxSearchingVersion = -1;\n    NodeProcess replicaToPromote = null;\n\n    // We must promote the most current replica, because otherwise file name reuse can cause a replication to fail when it needs to copy\n    // over a file currently held open for searching.  This also minimizes recovery work since the most current replica means less xlog\n    // replay to catch up:\n    for (NodeProcess node : nodes) {\n      if (node != null) {\n        message(\"ask \" + node + \" for its current searching version\");\n        long searchingVersion;\n        try {\n          searchingVersion = node.getSearchingVersion();\n        } catch (Throwable t) {\n          message(\"top: hit SocketException during getSearchingVersion with R\" + node.id + \"; skipping\");\n          t.printStackTrace(System.out);\n          continue;\n        }\n        message(node + \" has searchingVersion=\" + searchingVersion);\n        if (searchingVersion > maxSearchingVersion) {\n          maxSearchingVersion = searchingVersion;\n          replicaToPromote = node;\n        }\n      }\n    }\n\n    if (replicaToPromote == null) {\n      message(\"top: no replicas running; skipping primary promotion\");\n      return;\n    }\n\n    message(\"top: promote \" + replicaToPromote + \" version=\" + maxSearchingVersion + \"; now commit\");\n    try {\n      replicaToPromote.commit();\n    } catch (Throwable t) {\n      // Something wrong with this replica; skip it:\n      message(\"top: hit exception during commit with R\" + replicaToPromote.id + \"; skipping\");\n      t.printStackTrace(System.out);\n      return;\n    }\n\n    message(\"top: now shutdown \" + replicaToPromote);\n    if (replicaToPromote.shutdown() == false) {\n      message(\"top: shutdown failed for R\" + replicaToPromote.id + \"; skipping primary promotion\");\n      return;\n    }\n\n    int id = replicaToPromote.id;\n    message(\"top: now startPrimary \" + replicaToPromote);\n    startPrimary(replicaToPromote.id);\n  }\n\n","sourceOld":"  /** Picks a replica and promotes it as new primary. */\n  private void promoteReplica() throws IOException {\n    message(\"top: primary crashed; now pick replica to promote\");\n    long maxSearchingVersion = -1;\n    NodeProcess replicaToPromote = null;\n\n    // We must promote the most current replica, because otherwise file name reuse can cause a replication to fail when it needs to copy\n    // over a file currently held open for searching.  This also minimizes recovery work since the most current replica means less xlog\n    // replay to catch up:\n    for (NodeProcess node : nodes) {\n      if (node != null) {\n        message(\"ask \" + node + \" for its current searching version\");\n        long searchingVersion = node.getSearchingVersion();\n        message(node + \" has searchingVersion=\" + searchingVersion);\n        if (searchingVersion > maxSearchingVersion) {\n          maxSearchingVersion = searchingVersion;\n          replicaToPromote = node;\n        }\n      }\n    }\n\n    if (replicaToPromote == null) {\n      message(\"top: no replicas running; skipping primary promotion\");\n      return;\n    }\n\n    message(\"top: promote \" + replicaToPromote + \" version=\" + maxSearchingVersion + \"; now commit\");\n    if (replicaToPromote.commit() == false) {\n      message(\"top: commit failed; skipping primary promotion\");\n      return;\n    }\n\n    message(\"top: now shutdown \" + replicaToPromote);\n    if (replicaToPromote.shutdown() == false) {\n      message(\"top: shutdown failed for R\" + replicaToPromote.id + \"; skipping primary promotion\");\n      return;\n    }\n\n    int id = replicaToPromote.id;\n    message(\"top: now startPrimary \" + replicaToPromote);\n    startPrimary(replicaToPromote.id);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/TestStressNRTReplication#promoteReplica().mjava","pathOld":"/dev/null","sourceNew":"  /** Picks a replica and promotes it as new primary. */\n  private void promoteReplica() throws IOException {\n    message(\"top: primary crashed; now pick replica to promote\");\n    long maxSearchingVersion = -1;\n    NodeProcess replicaToPromote = null;\n\n    // We must promote the most current replica, because otherwise file name reuse can cause a replication to fail when it needs to copy\n    // over a file currently held open for searching.  This also minimizes recovery work since the most current replica means less xlog\n    // replay to catch up:\n    for (NodeProcess node : nodes) {\n      if (node != null) {\n        message(\"ask \" + node + \" for its current searching version\");\n        long searchingVersion;\n        try {\n          searchingVersion = node.getSearchingVersion();\n        } catch (Throwable t) {\n          message(\"top: hit SocketException during getSearchingVersion with R\" + node.id + \"; skipping\");\n          t.printStackTrace(System.out);\n          continue;\n        }\n        message(node + \" has searchingVersion=\" + searchingVersion);\n        if (searchingVersion > maxSearchingVersion) {\n          maxSearchingVersion = searchingVersion;\n          replicaToPromote = node;\n        }\n      }\n    }\n\n    if (replicaToPromote == null) {\n      message(\"top: no replicas running; skipping primary promotion\");\n      return;\n    }\n\n    message(\"top: promote \" + replicaToPromote + \" version=\" + maxSearchingVersion + \"; now commit\");\n    try {\n      replicaToPromote.commit();\n    } catch (Throwable t) {\n      // Something wrong with this replica; skip it:\n      message(\"top: hit exception during commit with R\" + replicaToPromote.id + \"; skipping\");\n      t.printStackTrace(System.out);\n      return;\n    }\n\n    message(\"top: now shutdown \" + replicaToPromote);\n    if (replicaToPromote.shutdown() == false) {\n      message(\"top: shutdown failed for R\" + replicaToPromote.id + \"; skipping primary promotion\");\n      return;\n    }\n\n    int id = replicaToPromote.id;\n    message(\"top: now startPrimary \" + replicaToPromote);\n    startPrimary(replicaToPromote.id);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1b0febf62c2d9baeee7db38998d9197700ccbab9":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","13ea66b549e25413e4e3057bf3492ab828899110"],"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","13ea66b549e25413e4e3057bf3492ab828899110"],"13ea66b549e25413e4e3057bf3492ab828899110":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["68496c2200e559fb7802f7575427b7a482659afb"]},"commit2Childs":{"1b0febf62c2d9baeee7db38998d9197700ccbab9":[],"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["1b0febf62c2d9baeee7db38998d9197700ccbab9","13ea66b549e25413e4e3057bf3492ab828899110"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","68496c2200e559fb7802f7575427b7a482659afb"],"68496c2200e559fb7802f7575427b7a482659afb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"13ea66b549e25413e4e3057bf3492ab828899110":["1b0febf62c2d9baeee7db38998d9197700ccbab9","68496c2200e559fb7802f7575427b7a482659afb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1b0febf62c2d9baeee7db38998d9197700ccbab9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}