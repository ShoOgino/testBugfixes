{"path":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,FieldDoc,int,Sort,boolean,boolean,boolean).mjava","commits":[{"id":"fb02351ae2b114dd41585916d1e35fb2cff98fb0","date":1337171337,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,FieldDoc,int,Sort,boolean,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,int,Sort,boolean).mjava","sourceNew":"  /**\n   * Just like {@link #search(Weight, int, Sort, boolean, boolean)}, but you choose\n   * whether or not the fields in the returned {@link FieldDoc} instances should\n   * be set by specifying fillFields.\n   *\n   * <p>NOTE: this does not compute scores by default.  If you\n   * need scores, create a {@link TopFieldCollector}\n   * instance by calling {@link TopFieldCollector#create} and\n   * then pass that to {@link #search(AtomicReaderContext[], Weight,\n   * Collector)}.</p>\n   */\n  protected TopFieldDocs search(Weight weight, FieldDoc after, int nDocs,\n                                Sort sort, boolean fillFields,\n                                boolean doDocScores, boolean doMaxScore)\n      throws IOException {\n\n    if (sort == null) throw new NullPointerException();\n    \n    if (executor == null) {\n      // use all leaves here!\n      return search(leafContexts, weight, after, nDocs, sort, fillFields, doDocScores, doMaxScore);\n    } else {\n      final TopFieldCollector topCollector = TopFieldCollector.create(sort, nDocs,\n                                                                      after,\n                                                                      fillFields,\n                                                                      doDocScores,\n                                                                      doMaxScore,\n                                                                      false);\n\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopFieldDocs> runner = new ExecutionHelper<TopFieldDocs>(executor);\n      for (int i = 0; i < leafSlices.length; i++) { // search each leaf slice\n        runner.submit(\n                      new SearcherCallableWithSort(lock, this, leafSlices[i], weight, after, nDocs, topCollector, sort, doDocScores, doMaxScore));\n      }\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopFieldDocs topFieldDocs : runner) {\n        if (topFieldDocs.totalHits != 0) {\n          totalHits += topFieldDocs.totalHits;\n          maxScore = Math.max(maxScore, topFieldDocs.getMaxScore());\n        }\n      }\n\n      final TopFieldDocs topDocs = (TopFieldDocs) topCollector.topDocs();\n\n      return new TopFieldDocs(totalHits, topDocs.scoreDocs, topDocs.fields, topDocs.getMaxScore());\n    }\n  }\n\n","sourceOld":"  /**\n   * Just like {@link #search(Weight, int, Sort)}, but you choose\n   * whether or not the fields in the returned {@link FieldDoc} instances should\n   * be set by specifying fillFields.\n   *\n   * <p>NOTE: this does not compute scores by default.  If you\n   * need scores, create a {@link TopFieldCollector}\n   * instance by calling {@link TopFieldCollector#create} and\n   * then pass that to {@link #search(AtomicReaderContext[], Weight,\n   * Collector)}.</p>\n   */\n  protected TopFieldDocs search(Weight weight, int nDocs,\n                                Sort sort, boolean fillFields)\n      throws IOException {\n\n    if (sort == null) throw new NullPointerException();\n    \n    if (executor == null) {\n      // use all leaves here!\n      return search (leafContexts, weight, nDocs, sort, fillFields);\n    } else {\n      final TopFieldCollector topCollector = TopFieldCollector.create(sort, nDocs,\n                                                                      fillFields,\n                                                                      fieldSortDoTrackScores,\n                                                                      fieldSortDoMaxScore,\n                                                                      false);\n\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopFieldDocs> runner = new ExecutionHelper<TopFieldDocs>(executor);\n      for (int i = 0; i < leafSlices.length; i++) { // search each leaf slice\n        runner.submit(\n                      new SearcherCallableWithSort(lock, this, leafSlices[i], weight, nDocs, topCollector, sort));\n      }\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopFieldDocs topFieldDocs : runner) {\n        if (topFieldDocs.totalHits != 0) {\n          totalHits += topFieldDocs.totalHits;\n          maxScore = Math.max(maxScore, topFieldDocs.getMaxScore());\n        }\n      }\n\n      final TopFieldDocs topDocs = (TopFieldDocs) topCollector.topDocs();\n\n      return new TopFieldDocs(totalHits, topDocs.scoreDocs, topDocs.fields, topDocs.getMaxScore());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ef0d8a69209261514c5739c770bba706c2308450","date":1337607597,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,FieldDoc,int,Sort,boolean,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,int,Sort,boolean).mjava","sourceNew":"  /**\n   * Just like {@link #search(Weight, int, Sort, boolean, boolean)}, but you choose\n   * whether or not the fields in the returned {@link FieldDoc} instances should\n   * be set by specifying fillFields.\n   *\n   * <p>NOTE: this does not compute scores by default.  If you\n   * need scores, create a {@link TopFieldCollector}\n   * instance by calling {@link TopFieldCollector#create} and\n   * then pass that to {@link #search(AtomicReaderContext[], Weight,\n   * Collector)}.</p>\n   */\n  protected TopFieldDocs search(Weight weight, FieldDoc after, int nDocs,\n                                Sort sort, boolean fillFields,\n                                boolean doDocScores, boolean doMaxScore)\n      throws IOException {\n\n    if (sort == null) throw new NullPointerException();\n    \n    if (executor == null) {\n      // use all leaves here!\n      return search(leafContexts, weight, after, nDocs, sort, fillFields, doDocScores, doMaxScore);\n    } else {\n      final TopFieldCollector topCollector = TopFieldCollector.create(sort, nDocs,\n                                                                      after,\n                                                                      fillFields,\n                                                                      doDocScores,\n                                                                      doMaxScore,\n                                                                      false);\n\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopFieldDocs> runner = new ExecutionHelper<TopFieldDocs>(executor);\n      for (int i = 0; i < leafSlices.length; i++) { // search each leaf slice\n        runner.submit(\n                      new SearcherCallableWithSort(lock, this, leafSlices[i], weight, after, nDocs, topCollector, sort, doDocScores, doMaxScore));\n      }\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopFieldDocs topFieldDocs : runner) {\n        if (topFieldDocs.totalHits != 0) {\n          totalHits += topFieldDocs.totalHits;\n          maxScore = Math.max(maxScore, topFieldDocs.getMaxScore());\n        }\n      }\n\n      final TopFieldDocs topDocs = (TopFieldDocs) topCollector.topDocs();\n\n      return new TopFieldDocs(totalHits, topDocs.scoreDocs, topDocs.fields, topDocs.getMaxScore());\n    }\n  }\n\n","sourceOld":"  /**\n   * Just like {@link #search(Weight, int, Sort)}, but you choose\n   * whether or not the fields in the returned {@link FieldDoc} instances should\n   * be set by specifying fillFields.\n   *\n   * <p>NOTE: this does not compute scores by default.  If you\n   * need scores, create a {@link TopFieldCollector}\n   * instance by calling {@link TopFieldCollector#create} and\n   * then pass that to {@link #search(AtomicReaderContext[], Weight,\n   * Collector)}.</p>\n   */\n  protected TopFieldDocs search(Weight weight, int nDocs,\n                                Sort sort, boolean fillFields)\n      throws IOException {\n\n    if (sort == null) throw new NullPointerException();\n    \n    if (executor == null) {\n      // use all leaves here!\n      return search (leafContexts, weight, nDocs, sort, fillFields);\n    } else {\n      final TopFieldCollector topCollector = TopFieldCollector.create(sort, nDocs,\n                                                                      fillFields,\n                                                                      fieldSortDoTrackScores,\n                                                                      fieldSortDoMaxScore,\n                                                                      false);\n\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopFieldDocs> runner = new ExecutionHelper<TopFieldDocs>(executor);\n      for (int i = 0; i < leafSlices.length; i++) { // search each leaf slice\n        runner.submit(\n                      new SearcherCallableWithSort(lock, this, leafSlices[i], weight, nDocs, topCollector, sort));\n      }\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopFieldDocs topFieldDocs : runner) {\n        if (topFieldDocs.totalHits != 0) {\n          totalHits += topFieldDocs.totalHits;\n          maxScore = Math.max(maxScore, topFieldDocs.getMaxScore());\n        }\n      }\n\n      final TopFieldDocs topDocs = (TopFieldDocs) topCollector.topDocs();\n\n      return new TopFieldDocs(totalHits, topDocs.scoreDocs, topDocs.fields, topDocs.getMaxScore());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","date":1340090669,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,FieldDoc,int,Sort,boolean,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,FieldDoc,int,Sort,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Just like {@link #search(Weight, int, Sort, boolean, boolean)}, but you choose\n   * whether or not the fields in the returned {@link FieldDoc} instances should\n   * be set by specifying fillFields.\n   *\n   * <p>NOTE: this does not compute scores by default.  If you\n   * need scores, create a {@link TopFieldCollector}\n   * instance by calling {@link TopFieldCollector#create} and\n   * then pass that to {@link #search(List, Weight,\n   * Collector)}.</p>\n   */\n  protected TopFieldDocs search(Weight weight, FieldDoc after, int nDocs,\n                                Sort sort, boolean fillFields,\n                                boolean doDocScores, boolean doMaxScore)\n      throws IOException {\n\n    if (sort == null) throw new NullPointerException();\n    \n    if (executor == null) {\n      // use all leaves here!\n      return search(leafContexts, weight, after, nDocs, sort, fillFields, doDocScores, doMaxScore);\n    } else {\n      final TopFieldCollector topCollector = TopFieldCollector.create(sort, nDocs,\n                                                                      after,\n                                                                      fillFields,\n                                                                      doDocScores,\n                                                                      doMaxScore,\n                                                                      false);\n\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopFieldDocs> runner = new ExecutionHelper<TopFieldDocs>(executor);\n      for (int i = 0; i < leafSlices.length; i++) { // search each leaf slice\n        runner.submit(\n                      new SearcherCallableWithSort(lock, this, leafSlices[i], weight, after, nDocs, topCollector, sort, doDocScores, doMaxScore));\n      }\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopFieldDocs topFieldDocs : runner) {\n        if (topFieldDocs.totalHits != 0) {\n          totalHits += topFieldDocs.totalHits;\n          maxScore = Math.max(maxScore, topFieldDocs.getMaxScore());\n        }\n      }\n\n      final TopFieldDocs topDocs = (TopFieldDocs) topCollector.topDocs();\n\n      return new TopFieldDocs(totalHits, topDocs.scoreDocs, topDocs.fields, topDocs.getMaxScore());\n    }\n  }\n\n","sourceOld":"  /**\n   * Just like {@link #search(Weight, int, Sort, boolean, boolean)}, but you choose\n   * whether or not the fields in the returned {@link FieldDoc} instances should\n   * be set by specifying fillFields.\n   *\n   * <p>NOTE: this does not compute scores by default.  If you\n   * need scores, create a {@link TopFieldCollector}\n   * instance by calling {@link TopFieldCollector#create} and\n   * then pass that to {@link #search(AtomicReaderContext[], Weight,\n   * Collector)}.</p>\n   */\n  protected TopFieldDocs search(Weight weight, FieldDoc after, int nDocs,\n                                Sort sort, boolean fillFields,\n                                boolean doDocScores, boolean doMaxScore)\n      throws IOException {\n\n    if (sort == null) throw new NullPointerException();\n    \n    if (executor == null) {\n      // use all leaves here!\n      return search(leafContexts, weight, after, nDocs, sort, fillFields, doDocScores, doMaxScore);\n    } else {\n      final TopFieldCollector topCollector = TopFieldCollector.create(sort, nDocs,\n                                                                      after,\n                                                                      fillFields,\n                                                                      doDocScores,\n                                                                      doMaxScore,\n                                                                      false);\n\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopFieldDocs> runner = new ExecutionHelper<TopFieldDocs>(executor);\n      for (int i = 0; i < leafSlices.length; i++) { // search each leaf slice\n        runner.submit(\n                      new SearcherCallableWithSort(lock, this, leafSlices[i], weight, after, nDocs, topCollector, sort, doDocScores, doMaxScore));\n      }\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopFieldDocs topFieldDocs : runner) {\n        if (topFieldDocs.totalHits != 0) {\n          totalHits += topFieldDocs.totalHits;\n          maxScore = Math.max(maxScore, topFieldDocs.getMaxScore());\n        }\n      }\n\n      final TopFieldDocs topDocs = (TopFieldDocs) topCollector.topDocs();\n\n      return new TopFieldDocs(totalHits, topDocs.scoreDocs, topDocs.fields, topDocs.getMaxScore());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"79d6e3f06f0471669e08486b9e47ebe477819dea","date":1351891294,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,FieldDoc,int,Sort,boolean,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,FieldDoc,int,Sort,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Just like {@link #search(Weight, int, Sort, boolean, boolean)}, but you choose\n   * whether or not the fields in the returned {@link FieldDoc} instances should\n   * be set by specifying fillFields.\n   *\n   * <p>NOTE: this does not compute scores by default.  If you\n   * need scores, create a {@link TopFieldCollector}\n   * instance by calling {@link TopFieldCollector#create} and\n   * then pass that to {@link #search(List, Weight,\n   * Collector)}.</p>\n   */\n  protected TopFieldDocs search(Weight weight, FieldDoc after, int nDocs,\n                                Sort sort, boolean fillFields,\n                                boolean doDocScores, boolean doMaxScore)\n      throws IOException {\n\n    if (sort == null) throw new NullPointerException(\"Sort must not be null\");\n    \n    if (executor == null) {\n      // use all leaves here!\n      return search(leafContexts, weight, after, nDocs, sort, fillFields, doDocScores, doMaxScore);\n    } else {\n      final TopFieldCollector topCollector = TopFieldCollector.create(sort, nDocs,\n                                                                      after,\n                                                                      fillFields,\n                                                                      doDocScores,\n                                                                      doMaxScore,\n                                                                      false);\n\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopFieldDocs> runner = new ExecutionHelper<TopFieldDocs>(executor);\n      for (int i = 0; i < leafSlices.length; i++) { // search each leaf slice\n        runner.submit(\n                      new SearcherCallableWithSort(lock, this, leafSlices[i], weight, after, nDocs, topCollector, sort, doDocScores, doMaxScore));\n      }\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopFieldDocs topFieldDocs : runner) {\n        if (topFieldDocs.totalHits != 0) {\n          totalHits += topFieldDocs.totalHits;\n          maxScore = Math.max(maxScore, topFieldDocs.getMaxScore());\n        }\n      }\n\n      final TopFieldDocs topDocs = (TopFieldDocs) topCollector.topDocs();\n\n      return new TopFieldDocs(totalHits, topDocs.scoreDocs, topDocs.fields, topDocs.getMaxScore());\n    }\n  }\n\n","sourceOld":"  /**\n   * Just like {@link #search(Weight, int, Sort, boolean, boolean)}, but you choose\n   * whether or not the fields in the returned {@link FieldDoc} instances should\n   * be set by specifying fillFields.\n   *\n   * <p>NOTE: this does not compute scores by default.  If you\n   * need scores, create a {@link TopFieldCollector}\n   * instance by calling {@link TopFieldCollector#create} and\n   * then pass that to {@link #search(List, Weight,\n   * Collector)}.</p>\n   */\n  protected TopFieldDocs search(Weight weight, FieldDoc after, int nDocs,\n                                Sort sort, boolean fillFields,\n                                boolean doDocScores, boolean doMaxScore)\n      throws IOException {\n\n    if (sort == null) throw new NullPointerException();\n    \n    if (executor == null) {\n      // use all leaves here!\n      return search(leafContexts, weight, after, nDocs, sort, fillFields, doDocScores, doMaxScore);\n    } else {\n      final TopFieldCollector topCollector = TopFieldCollector.create(sort, nDocs,\n                                                                      after,\n                                                                      fillFields,\n                                                                      doDocScores,\n                                                                      doMaxScore,\n                                                                      false);\n\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopFieldDocs> runner = new ExecutionHelper<TopFieldDocs>(executor);\n      for (int i = 0; i < leafSlices.length; i++) { // search each leaf slice\n        runner.submit(\n                      new SearcherCallableWithSort(lock, this, leafSlices[i], weight, after, nDocs, topCollector, sort, doDocScores, doMaxScore));\n      }\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopFieldDocs topFieldDocs : runner) {\n        if (topFieldDocs.totalHits != 0) {\n          totalHits += topFieldDocs.totalHits;\n          maxScore = Math.max(maxScore, topFieldDocs.getMaxScore());\n        }\n      }\n\n      final TopFieldDocs topDocs = (TopFieldDocs) topCollector.topDocs();\n\n      return new TopFieldDocs(totalHits, topDocs.scoreDocs, topDocs.fields, topDocs.getMaxScore());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"450d0bc37c59f2de7743066469a444243907fd75","date":1366384804,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,FieldDoc,int,Sort,boolean,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,FieldDoc,int,Sort,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Just like {@link #search(Weight, int, Sort, boolean, boolean)}, but you choose\n   * whether or not the fields in the returned {@link FieldDoc} instances should\n   * be set by specifying fillFields.\n   *\n   * <p>NOTE: this does not compute scores by default.  If you\n   * need scores, create a {@link TopFieldCollector}\n   * instance by calling {@link TopFieldCollector#create} and\n   * then pass that to {@link #search(List, Weight,\n   * Collector)}.</p>\n   */\n  protected TopFieldDocs search(Weight weight, FieldDoc after, int nDocs,\n                                Sort sort, boolean fillFields,\n                                boolean doDocScores, boolean doMaxScore)\n      throws IOException {\n\n    if (sort == null) throw new NullPointerException(\"Sort must not be null\");\n    \n    int limit = reader.maxDoc();\n    if (limit == 0) {\n      limit = 1;\n    }\n    nDocs = Math.min(nDocs, limit);\n\n    if (executor == null) {\n      // use all leaves here!\n      return search(leafContexts, weight, after, nDocs, sort, fillFields, doDocScores, doMaxScore);\n    } else {\n      final TopFieldCollector topCollector = TopFieldCollector.create(sort, nDocs,\n                                                                      after,\n                                                                      fillFields,\n                                                                      doDocScores,\n                                                                      doMaxScore,\n                                                                      false);\n\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopFieldDocs> runner = new ExecutionHelper<TopFieldDocs>(executor);\n      for (int i = 0; i < leafSlices.length; i++) { // search each leaf slice\n        runner.submit(\n                      new SearcherCallableWithSort(lock, this, leafSlices[i], weight, after, nDocs, topCollector, sort, doDocScores, doMaxScore));\n      }\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopFieldDocs topFieldDocs : runner) {\n        if (topFieldDocs.totalHits != 0) {\n          totalHits += topFieldDocs.totalHits;\n          maxScore = Math.max(maxScore, topFieldDocs.getMaxScore());\n        }\n      }\n\n      final TopFieldDocs topDocs = (TopFieldDocs) topCollector.topDocs();\n\n      return new TopFieldDocs(totalHits, topDocs.scoreDocs, topDocs.fields, topDocs.getMaxScore());\n    }\n  }\n\n","sourceOld":"  /**\n   * Just like {@link #search(Weight, int, Sort, boolean, boolean)}, but you choose\n   * whether or not the fields in the returned {@link FieldDoc} instances should\n   * be set by specifying fillFields.\n   *\n   * <p>NOTE: this does not compute scores by default.  If you\n   * need scores, create a {@link TopFieldCollector}\n   * instance by calling {@link TopFieldCollector#create} and\n   * then pass that to {@link #search(List, Weight,\n   * Collector)}.</p>\n   */\n  protected TopFieldDocs search(Weight weight, FieldDoc after, int nDocs,\n                                Sort sort, boolean fillFields,\n                                boolean doDocScores, boolean doMaxScore)\n      throws IOException {\n\n    if (sort == null) throw new NullPointerException(\"Sort must not be null\");\n    \n    if (executor == null) {\n      // use all leaves here!\n      return search(leafContexts, weight, after, nDocs, sort, fillFields, doDocScores, doMaxScore);\n    } else {\n      final TopFieldCollector topCollector = TopFieldCollector.create(sort, nDocs,\n                                                                      after,\n                                                                      fillFields,\n                                                                      doDocScores,\n                                                                      doMaxScore,\n                                                                      false);\n\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopFieldDocs> runner = new ExecutionHelper<TopFieldDocs>(executor);\n      for (int i = 0; i < leafSlices.length; i++) { // search each leaf slice\n        runner.submit(\n                      new SearcherCallableWithSort(lock, this, leafSlices[i], weight, after, nDocs, topCollector, sort, doDocScores, doMaxScore));\n      }\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopFieldDocs topFieldDocs : runner) {\n        if (topFieldDocs.totalHits != 0) {\n          totalHits += topFieldDocs.totalHits;\n          maxScore = Math.max(maxScore, topFieldDocs.getMaxScore());\n        }\n      }\n\n      final TopFieldDocs topDocs = (TopFieldDocs) topCollector.topDocs();\n\n      return new TopFieldDocs(totalHits, topDocs.scoreDocs, topDocs.fields, topDocs.getMaxScore());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d952588315decd1eff4d2aed77830e4180a958b0","date":1379698319,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,FieldDoc,int,Sort,boolean,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,FieldDoc,int,Sort,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Just like {@link #search(Weight, int, Sort, boolean, boolean)}, but you choose\n   * whether or not the fields in the returned {@link FieldDoc} instances should\n   * be set by specifying fillFields.\n   */\n  protected TopFieldDocs search(Weight weight, FieldDoc after, int nDocs,\n                                Sort sort, boolean fillFields,\n                                boolean doDocScores, boolean doMaxScore)\n      throws IOException {\n\n    if (sort == null) throw new NullPointerException(\"Sort must not be null\");\n    \n    int limit = reader.maxDoc();\n    if (limit == 0) {\n      limit = 1;\n    }\n    nDocs = Math.min(nDocs, limit);\n\n    if (executor == null) {\n      // use all leaves here!\n      return search(leafContexts, weight, after, nDocs, sort, fillFields, doDocScores, doMaxScore);\n    } else {\n      final TopFieldCollector topCollector = TopFieldCollector.create(sort, nDocs,\n                                                                      after,\n                                                                      fillFields,\n                                                                      doDocScores,\n                                                                      doMaxScore,\n                                                                      false);\n\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopFieldDocs> runner = new ExecutionHelper<TopFieldDocs>(executor);\n      for (int i = 0; i < leafSlices.length; i++) { // search each leaf slice\n        runner.submit(\n                      new SearcherCallableWithSort(lock, this, leafSlices[i], weight, after, nDocs, topCollector, sort, doDocScores, doMaxScore));\n      }\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopFieldDocs topFieldDocs : runner) {\n        if (topFieldDocs.totalHits != 0) {\n          totalHits += topFieldDocs.totalHits;\n          maxScore = Math.max(maxScore, topFieldDocs.getMaxScore());\n        }\n      }\n\n      final TopFieldDocs topDocs = (TopFieldDocs) topCollector.topDocs();\n\n      return new TopFieldDocs(totalHits, topDocs.scoreDocs, topDocs.fields, topDocs.getMaxScore());\n    }\n  }\n\n","sourceOld":"  /**\n   * Just like {@link #search(Weight, int, Sort, boolean, boolean)}, but you choose\n   * whether or not the fields in the returned {@link FieldDoc} instances should\n   * be set by specifying fillFields.\n   *\n   * <p>NOTE: this does not compute scores by default.  If you\n   * need scores, create a {@link TopFieldCollector}\n   * instance by calling {@link TopFieldCollector#create} and\n   * then pass that to {@link #search(List, Weight,\n   * Collector)}.</p>\n   */\n  protected TopFieldDocs search(Weight weight, FieldDoc after, int nDocs,\n                                Sort sort, boolean fillFields,\n                                boolean doDocScores, boolean doMaxScore)\n      throws IOException {\n\n    if (sort == null) throw new NullPointerException(\"Sort must not be null\");\n    \n    int limit = reader.maxDoc();\n    if (limit == 0) {\n      limit = 1;\n    }\n    nDocs = Math.min(nDocs, limit);\n\n    if (executor == null) {\n      // use all leaves here!\n      return search(leafContexts, weight, after, nDocs, sort, fillFields, doDocScores, doMaxScore);\n    } else {\n      final TopFieldCollector topCollector = TopFieldCollector.create(sort, nDocs,\n                                                                      after,\n                                                                      fillFields,\n                                                                      doDocScores,\n                                                                      doMaxScore,\n                                                                      false);\n\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopFieldDocs> runner = new ExecutionHelper<TopFieldDocs>(executor);\n      for (int i = 0; i < leafSlices.length; i++) { // search each leaf slice\n        runner.submit(\n                      new SearcherCallableWithSort(lock, this, leafSlices[i], weight, after, nDocs, topCollector, sort, doDocScores, doMaxScore));\n      }\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopFieldDocs topFieldDocs : runner) {\n        if (topFieldDocs.totalHits != 0) {\n          totalHits += topFieldDocs.totalHits;\n          maxScore = Math.max(maxScore, topFieldDocs.getMaxScore());\n        }\n      }\n\n      final TopFieldDocs topDocs = (TopFieldDocs) topCollector.topDocs();\n\n      return new TopFieldDocs(totalHits, topDocs.scoreDocs, topDocs.fields, topDocs.getMaxScore());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,FieldDoc,int,Sort,boolean,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,FieldDoc,int,Sort,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Just like {@link #search(Weight, int, Sort, boolean, boolean)}, but you choose\n   * whether or not the fields in the returned {@link FieldDoc} instances should\n   * be set by specifying fillFields.\n   */\n  protected TopFieldDocs search(Weight weight, FieldDoc after, int nDocs,\n                                Sort sort, boolean fillFields,\n                                boolean doDocScores, boolean doMaxScore)\n      throws IOException {\n\n    if (sort == null) throw new NullPointerException(\"Sort must not be null\");\n    \n    int limit = reader.maxDoc();\n    if (limit == 0) {\n      limit = 1;\n    }\n    nDocs = Math.min(nDocs, limit);\n\n    if (executor == null) {\n      // use all leaves here!\n      return search(leafContexts, weight, after, nDocs, sort, fillFields, doDocScores, doMaxScore);\n    } else {\n      final TopFieldCollector topCollector = TopFieldCollector.create(sort, nDocs,\n                                                                      after,\n                                                                      fillFields,\n                                                                      doDocScores,\n                                                                      doMaxScore,\n                                                                      false);\n\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopFieldDocs> runner = new ExecutionHelper<>(executor);\n      for (int i = 0; i < leafSlices.length; i++) { // search each leaf slice\n        runner.submit(\n                      new SearcherCallableWithSort(lock, this, leafSlices[i], weight, after, nDocs, topCollector, sort, doDocScores, doMaxScore));\n      }\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopFieldDocs topFieldDocs : runner) {\n        if (topFieldDocs.totalHits != 0) {\n          totalHits += topFieldDocs.totalHits;\n          maxScore = Math.max(maxScore, topFieldDocs.getMaxScore());\n        }\n      }\n\n      final TopFieldDocs topDocs = (TopFieldDocs) topCollector.topDocs();\n\n      return new TopFieldDocs(totalHits, topDocs.scoreDocs, topDocs.fields, topDocs.getMaxScore());\n    }\n  }\n\n","sourceOld":"  /**\n   * Just like {@link #search(Weight, int, Sort, boolean, boolean)}, but you choose\n   * whether or not the fields in the returned {@link FieldDoc} instances should\n   * be set by specifying fillFields.\n   */\n  protected TopFieldDocs search(Weight weight, FieldDoc after, int nDocs,\n                                Sort sort, boolean fillFields,\n                                boolean doDocScores, boolean doMaxScore)\n      throws IOException {\n\n    if (sort == null) throw new NullPointerException(\"Sort must not be null\");\n    \n    int limit = reader.maxDoc();\n    if (limit == 0) {\n      limit = 1;\n    }\n    nDocs = Math.min(nDocs, limit);\n\n    if (executor == null) {\n      // use all leaves here!\n      return search(leafContexts, weight, after, nDocs, sort, fillFields, doDocScores, doMaxScore);\n    } else {\n      final TopFieldCollector topCollector = TopFieldCollector.create(sort, nDocs,\n                                                                      after,\n                                                                      fillFields,\n                                                                      doDocScores,\n                                                                      doMaxScore,\n                                                                      false);\n\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopFieldDocs> runner = new ExecutionHelper<TopFieldDocs>(executor);\n      for (int i = 0; i < leafSlices.length; i++) { // search each leaf slice\n        runner.submit(\n                      new SearcherCallableWithSort(lock, this, leafSlices[i], weight, after, nDocs, topCollector, sort, doDocScores, doMaxScore));\n      }\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopFieldDocs topFieldDocs : runner) {\n        if (topFieldDocs.totalHits != 0) {\n          totalHits += topFieldDocs.totalHits;\n          maxScore = Math.max(maxScore, topFieldDocs.getMaxScore());\n        }\n      }\n\n      final TopFieldDocs topDocs = (TopFieldDocs) topCollector.topDocs();\n\n      return new TopFieldDocs(totalHits, topDocs.scoreDocs, topDocs.fields, topDocs.getMaxScore());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","date":1421314520,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,FieldDoc,int,Sort,boolean,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,FieldDoc,int,Sort,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Just like {@link #search(Weight, int, Sort, boolean, boolean)}, but you choose\n   * whether or not the fields in the returned {@link FieldDoc} instances should\n   * be set by specifying fillFields.\n   */\n  protected TopFieldDocs search(Weight weight, FieldDoc after, int nDocs,\n                                Sort sort, boolean fillFields,\n                                boolean doDocScores, boolean doMaxScore)\n      throws IOException {\n\n    if (sort == null) throw new NullPointerException(\"Sort must not be null\");\n    \n    int limit = reader.maxDoc();\n    if (limit == 0) {\n      limit = 1;\n    }\n    nDocs = Math.min(nDocs, limit);\n\n    if (executor == null) {\n      // use all leaves here!\n      return search(leafContexts, weight, after, nDocs, sort, fillFields, doDocScores, doMaxScore);\n    } else {\n      final TopFieldCollector topCollector = TopFieldCollector.create(sort, nDocs,\n                                                                      after,\n                                                                      fillFields,\n                                                                      doDocScores,\n                                                                      doMaxScore);\n\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopFieldDocs> runner = new ExecutionHelper<>(executor);\n      for (int i = 0; i < leafSlices.length; i++) { // search each leaf slice\n        runner.submit(\n                      new SearcherCallableWithSort(lock, this, leafSlices[i], weight, after, nDocs, topCollector, sort, doDocScores, doMaxScore));\n      }\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopFieldDocs topFieldDocs : runner) {\n        if (topFieldDocs.totalHits != 0) {\n          totalHits += topFieldDocs.totalHits;\n          maxScore = Math.max(maxScore, topFieldDocs.getMaxScore());\n        }\n      }\n\n      final TopFieldDocs topDocs = (TopFieldDocs) topCollector.topDocs();\n\n      return new TopFieldDocs(totalHits, topDocs.scoreDocs, topDocs.fields, topDocs.getMaxScore());\n    }\n  }\n\n","sourceOld":"  /**\n   * Just like {@link #search(Weight, int, Sort, boolean, boolean)}, but you choose\n   * whether or not the fields in the returned {@link FieldDoc} instances should\n   * be set by specifying fillFields.\n   */\n  protected TopFieldDocs search(Weight weight, FieldDoc after, int nDocs,\n                                Sort sort, boolean fillFields,\n                                boolean doDocScores, boolean doMaxScore)\n      throws IOException {\n\n    if (sort == null) throw new NullPointerException(\"Sort must not be null\");\n    \n    int limit = reader.maxDoc();\n    if (limit == 0) {\n      limit = 1;\n    }\n    nDocs = Math.min(nDocs, limit);\n\n    if (executor == null) {\n      // use all leaves here!\n      return search(leafContexts, weight, after, nDocs, sort, fillFields, doDocScores, doMaxScore);\n    } else {\n      final TopFieldCollector topCollector = TopFieldCollector.create(sort, nDocs,\n                                                                      after,\n                                                                      fillFields,\n                                                                      doDocScores,\n                                                                      doMaxScore,\n                                                                      false);\n\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopFieldDocs> runner = new ExecutionHelper<>(executor);\n      for (int i = 0; i < leafSlices.length; i++) { // search each leaf slice\n        runner.submit(\n                      new SearcherCallableWithSort(lock, this, leafSlices[i], weight, after, nDocs, topCollector, sort, doDocScores, doMaxScore));\n      }\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopFieldDocs topFieldDocs : runner) {\n        if (topFieldDocs.totalHits != 0) {\n          totalHits += topFieldDocs.totalHits;\n          maxScore = Math.max(maxScore, topFieldDocs.getMaxScore());\n        }\n      }\n\n      final TopFieldDocs topDocs = (TopFieldDocs) topCollector.topDocs();\n\n      return new TopFieldDocs(totalHits, topDocs.scoreDocs, topDocs.fields, topDocs.getMaxScore());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"023aa7229ae194442d2c4f36a9aaea1588760416","date":1421349700,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,FieldDoc,int,Sort,boolean,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,FieldDoc,int,Sort,boolean,boolean,boolean).mjava","sourceNew":"  /**\n   * Just like {@link #search(Weight, int, Sort, boolean, boolean)}, but you choose\n   * whether or not the fields in the returned {@link FieldDoc} instances should\n   * be set by specifying fillFields.\n   */\n  protected TopFieldDocs search(Weight weight, FieldDoc after, int nDocs,\n                                Sort sort, boolean fillFields,\n                                boolean doDocScores, boolean doMaxScore)\n      throws IOException {\n\n    if (sort == null) throw new NullPointerException(\"Sort must not be null\");\n    \n    int limit = reader.maxDoc();\n    if (limit == 0) {\n      limit = 1;\n    }\n    nDocs = Math.min(nDocs, limit);\n\n    if (executor == null) {\n      // use all leaves here!\n      return search(leafContexts, weight, after, nDocs, sort, fillFields, doDocScores, doMaxScore);\n    } else {\n      final List<Future<TopFieldDocs>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; i++) { // search each leaf slice\n        topDocsFutures.add(executor.submit(new SearcherCallableWithSort(this, leafSlices[i], weight, after, nDocs, sort, doDocScores, doMaxScore)));\n      }\n      final TopFieldDocs[] topDocs = new TopFieldDocs[leafSlices.length];\n      for (int i = 0; i < leafSlices.length; i++) {\n        try {\n          topDocs[i] = topDocsFutures.get(i).get();\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return (TopFieldDocs) TopDocs.merge(sort, nDocs, topDocs);\n    }\n  }\n\n","sourceOld":"  /**\n   * Just like {@link #search(Weight, int, Sort, boolean, boolean)}, but you choose\n   * whether or not the fields in the returned {@link FieldDoc} instances should\n   * be set by specifying fillFields.\n   */\n  protected TopFieldDocs search(Weight weight, FieldDoc after, int nDocs,\n                                Sort sort, boolean fillFields,\n                                boolean doDocScores, boolean doMaxScore)\n      throws IOException {\n\n    if (sort == null) throw new NullPointerException(\"Sort must not be null\");\n    \n    int limit = reader.maxDoc();\n    if (limit == 0) {\n      limit = 1;\n    }\n    nDocs = Math.min(nDocs, limit);\n\n    if (executor == null) {\n      // use all leaves here!\n      return search(leafContexts, weight, after, nDocs, sort, fillFields, doDocScores, doMaxScore);\n    } else {\n      final TopFieldCollector topCollector = TopFieldCollector.create(sort, nDocs,\n                                                                      after,\n                                                                      fillFields,\n                                                                      doDocScores,\n                                                                      doMaxScore);\n\n      final Lock lock = new ReentrantLock();\n      final ExecutionHelper<TopFieldDocs> runner = new ExecutionHelper<>(executor);\n      for (int i = 0; i < leafSlices.length; i++) { // search each leaf slice\n        runner.submit(\n                      new SearcherCallableWithSort(lock, this, leafSlices[i], weight, after, nDocs, topCollector, sort, doDocScores, doMaxScore));\n      }\n      int totalHits = 0;\n      float maxScore = Float.NEGATIVE_INFINITY;\n      for (final TopFieldDocs topFieldDocs : runner) {\n        if (topFieldDocs.totalHits != 0) {\n          totalHits += topFieldDocs.totalHits;\n          maxScore = Math.max(maxScore, topFieldDocs.getMaxScore());\n        }\n      }\n\n      final TopFieldDocs topDocs = (TopFieldDocs) topCollector.topDocs();\n\n      return new TopFieldDocs(totalHits, topDocs.scoreDocs, topDocs.fields, topDocs.getMaxScore());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb17639909a369c1e64866842e5c213440acc17e","date":1423238093,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#search(Weight,FieldDoc,int,Sort,boolean,boolean,boolean).mjava","sourceNew":null,"sourceOld":"  /**\n   * Just like {@link #search(Weight, int, Sort, boolean, boolean)}, but you choose\n   * whether or not the fields in the returned {@link FieldDoc} instances should\n   * be set by specifying fillFields.\n   */\n  protected TopFieldDocs search(Weight weight, FieldDoc after, int nDocs,\n                                Sort sort, boolean fillFields,\n                                boolean doDocScores, boolean doMaxScore)\n      throws IOException {\n\n    if (sort == null) throw new NullPointerException(\"Sort must not be null\");\n    \n    int limit = reader.maxDoc();\n    if (limit == 0) {\n      limit = 1;\n    }\n    nDocs = Math.min(nDocs, limit);\n\n    if (executor == null) {\n      // use all leaves here!\n      return search(leafContexts, weight, after, nDocs, sort, fillFields, doDocScores, doMaxScore);\n    } else {\n      final List<Future<TopFieldDocs>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; i++) { // search each leaf slice\n        topDocsFutures.add(executor.submit(new SearcherCallableWithSort(this, leafSlices[i], weight, after, nDocs, sort, doDocScores, doMaxScore)));\n      }\n      final TopFieldDocs[] topDocs = new TopFieldDocs[leafSlices.length];\n      for (int i = 0; i < leafSlices.length; i++) {\n        try {\n          topDocs[i] = topDocsFutures.get(i).get();\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return (TopFieldDocs) TopDocs.merge(sort, nDocs, topDocs);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fb02351ae2b114dd41585916d1e35fb2cff98fb0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fb17639909a369c1e64866842e5c213440acc17e":["023aa7229ae194442d2c4f36a9aaea1588760416"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["d952588315decd1eff4d2aed77830e4180a958b0"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["fb02351ae2b114dd41585916d1e35fb2cff98fb0"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"79d6e3f06f0471669e08486b9e47ebe477819dea":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"d952588315decd1eff4d2aed77830e4180a958b0":["450d0bc37c59f2de7743066469a444243907fd75"],"023aa7229ae194442d2c4f36a9aaea1588760416":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"450d0bc37c59f2de7743066469a444243907fd75":["79d6e3f06f0471669e08486b9e47ebe477819dea"],"ef0d8a69209261514c5739c770bba706c2308450":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","fb02351ae2b114dd41585916d1e35fb2cff98fb0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fb17639909a369c1e64866842e5c213440acc17e"]},"commit2Childs":{"fb02351ae2b114dd41585916d1e35fb2cff98fb0":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","ef0d8a69209261514c5739c770bba706c2308450"],"fb17639909a369c1e64866842e5c213440acc17e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["79d6e3f06f0471669e08486b9e47ebe477819dea"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["023aa7229ae194442d2c4f36a9aaea1588760416"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fb02351ae2b114dd41585916d1e35fb2cff98fb0","ef0d8a69209261514c5739c770bba706c2308450"],"79d6e3f06f0471669e08486b9e47ebe477819dea":["450d0bc37c59f2de7743066469a444243907fd75"],"d952588315decd1eff4d2aed77830e4180a958b0":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"023aa7229ae194442d2c4f36a9aaea1588760416":["fb17639909a369c1e64866842e5c213440acc17e"],"450d0bc37c59f2de7743066469a444243907fd75":["d952588315decd1eff4d2aed77830e4180a958b0"],"ef0d8a69209261514c5739c770bba706c2308450":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ef0d8a69209261514c5739c770bba706c2308450","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}