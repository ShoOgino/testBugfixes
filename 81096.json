{"path":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxDocs().mjava","commits":[{"id":"9a8ccb9d7a971a53ccd8bc3d8230590bca107c51","date":1431446228,"type":0,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxDocs().mjava","pathOld":"/dev/null","sourceNew":"  public void testMinMaxDocs() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    int minChildDocsPerParent = 2;\n    int maxChildDocsPerParent = 16;\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    int[] childDocsPerParent = new int[numParents];\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent);\n      childDocsPerParent[p] = numChildren;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        iw.addDocument(childDoc);\n      }\n    }\n    iw.close();\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    Query fromQuery = new TermQuery(new Term(\"type\", \"from\"));\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n\n    int iters = RandomInts.randomIntBetween(random(), 3, 9);\n    for (int i = 1; i <= iters; i++) {\n      final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      int min = RandomInts.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent - 1);\n      int max = RandomInts.randomIntBetween(random(), min, maxChildDocsPerParent);\n      if (VERBOSE) {\n        System.out.println(\"iter=\" + i);\n        System.out.println(\"scoreMode=\" + scoreMode);\n        System.out.println(\"min=\" + min);\n        System.out.println(\"max=\" + max);\n      }\n      Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery, toQuery, searcher, scoreMode, ordinalMap, min, max);\n      TotalHitCountCollector collector = new TotalHitCountCollector();\n      searcher.search(joinQuery, collector);\n      int expectedCount = 0;\n      for (int numChildDocs : childDocsPerParent) {\n        if (numChildDocs >= min && numChildDocs <= max) {\n          expectedCount++;\n        }\n      }\n      assertEquals(expectedCount, collector.getTotalHits());\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6448f67be45147de82a85cd903fec34e8930da75","date":1477041277,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxDocs().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxDocs().mjava","sourceNew":"  public void testMinMaxDocs() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    int minChildDocsPerParent = 2;\n    int maxChildDocsPerParent = 16;\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    int[] childDocsPerParent = new int[numParents];\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent);\n      childDocsPerParent[p] = numChildren;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        iw.addDocument(childDoc);\n      }\n    }\n    iw.close();\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    Query fromQuery = new TermQuery(new Term(\"type\", \"from\"));\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n\n    int iters = RandomNumbers.randomIntBetween(random(), 3, 9);\n    for (int i = 1; i <= iters; i++) {\n      final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      int min = RandomNumbers.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent - 1);\n      int max = RandomNumbers.randomIntBetween(random(), min, maxChildDocsPerParent);\n      if (VERBOSE) {\n        System.out.println(\"iter=\" + i);\n        System.out.println(\"scoreMode=\" + scoreMode);\n        System.out.println(\"min=\" + min);\n        System.out.println(\"max=\" + max);\n      }\n      Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery, toQuery, searcher, scoreMode, ordinalMap, min, max);\n      TotalHitCountCollector collector = new TotalHitCountCollector();\n      searcher.search(joinQuery, collector);\n      int expectedCount = 0;\n      for (int numChildDocs : childDocsPerParent) {\n        if (numChildDocs >= min && numChildDocs <= max) {\n          expectedCount++;\n        }\n      }\n      assertEquals(expectedCount, collector.getTotalHits());\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxDocs() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    int minChildDocsPerParent = 2;\n    int maxChildDocsPerParent = 16;\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    int[] childDocsPerParent = new int[numParents];\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent);\n      childDocsPerParent[p] = numChildren;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        iw.addDocument(childDoc);\n      }\n    }\n    iw.close();\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    Query fromQuery = new TermQuery(new Term(\"type\", \"from\"));\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n\n    int iters = RandomInts.randomIntBetween(random(), 3, 9);\n    for (int i = 1; i <= iters; i++) {\n      final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      int min = RandomInts.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent - 1);\n      int max = RandomInts.randomIntBetween(random(), min, maxChildDocsPerParent);\n      if (VERBOSE) {\n        System.out.println(\"iter=\" + i);\n        System.out.println(\"scoreMode=\" + scoreMode);\n        System.out.println(\"min=\" + min);\n        System.out.println(\"max=\" + max);\n      }\n      Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery, toQuery, searcher, scoreMode, ordinalMap, min, max);\n      TotalHitCountCollector collector = new TotalHitCountCollector();\n      searcher.search(joinQuery, collector);\n      int expectedCount = 0;\n      for (int numChildDocs : childDocsPerParent) {\n        if (numChildDocs >= min && numChildDocs <= max) {\n          expectedCount++;\n        }\n      }\n      assertEquals(expectedCount, collector.getTotalHits());\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxDocs().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxDocs().mjava","sourceNew":"  public void testMinMaxDocs() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    int minChildDocsPerParent = 2;\n    int maxChildDocsPerParent = 16;\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    int[] childDocsPerParent = new int[numParents];\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent);\n      childDocsPerParent[p] = numChildren;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        iw.addDocument(childDoc);\n      }\n    }\n    iw.close();\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    Query fromQuery = new TermQuery(new Term(\"type\", \"from\"));\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n\n    int iters = RandomNumbers.randomIntBetween(random(), 3, 9);\n    for (int i = 1; i <= iters; i++) {\n      final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      int min = RandomNumbers.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent - 1);\n      int max = RandomNumbers.randomIntBetween(random(), min, maxChildDocsPerParent);\n      if (VERBOSE) {\n        System.out.println(\"iter=\" + i);\n        System.out.println(\"scoreMode=\" + scoreMode);\n        System.out.println(\"min=\" + min);\n        System.out.println(\"max=\" + max);\n      }\n      Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery, toQuery, searcher, scoreMode, ordinalMap, min, max);\n      TotalHitCountCollector collector = new TotalHitCountCollector();\n      searcher.search(joinQuery, collector);\n      int expectedCount = 0;\n      for (int numChildDocs : childDocsPerParent) {\n        if (numChildDocs >= min && numChildDocs <= max) {\n          expectedCount++;\n        }\n      }\n      assertEquals(expectedCount, collector.getTotalHits());\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxDocs() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    int minChildDocsPerParent = 2;\n    int maxChildDocsPerParent = 16;\n    int numParents = RandomInts.randomIntBetween(random(), 16, 64);\n    int[] childDocsPerParent = new int[numParents];\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomInts.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent);\n      childDocsPerParent[p] = numChildren;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        iw.addDocument(childDoc);\n      }\n    }\n    iw.close();\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    Query fromQuery = new TermQuery(new Term(\"type\", \"from\"));\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n\n    int iters = RandomInts.randomIntBetween(random(), 3, 9);\n    for (int i = 1; i <= iters; i++) {\n      final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      int min = RandomInts.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent - 1);\n      int max = RandomInts.randomIntBetween(random(), min, maxChildDocsPerParent);\n      if (VERBOSE) {\n        System.out.println(\"iter=\" + i);\n        System.out.println(\"scoreMode=\" + scoreMode);\n        System.out.println(\"min=\" + min);\n        System.out.println(\"max=\" + max);\n      }\n      Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery, toQuery, searcher, scoreMode, ordinalMap, min, max);\n      TotalHitCountCollector collector = new TotalHitCountCollector();\n      searcher.search(joinQuery, collector);\n      int expectedCount = 0;\n      for (int numChildDocs : childDocsPerParent) {\n        if (numChildDocs >= min && numChildDocs <= max) {\n          expectedCount++;\n        }\n      }\n      assertEquals(expectedCount, collector.getTotalHits());\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d211216c83f01894810543d1c107160a9ae3650b","date":1488289605,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxDocs().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxDocs().mjava","sourceNew":"  public void testMinMaxDocs() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    int minChildDocsPerParent = 2;\n    int maxChildDocsPerParent = 16;\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    int[] childDocsPerParent = new int[numParents];\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent);\n      childDocsPerParent[p] = numChildren;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        iw.addDocument(childDoc);\n      }\n    }\n    iw.close();\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        null, values, PackedInts.DEFAULT\n    );\n    Query fromQuery = new TermQuery(new Term(\"type\", \"from\"));\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n\n    int iters = RandomNumbers.randomIntBetween(random(), 3, 9);\n    for (int i = 1; i <= iters; i++) {\n      final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      int min = RandomNumbers.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent - 1);\n      int max = RandomNumbers.randomIntBetween(random(), min, maxChildDocsPerParent);\n      if (VERBOSE) {\n        System.out.println(\"iter=\" + i);\n        System.out.println(\"scoreMode=\" + scoreMode);\n        System.out.println(\"min=\" + min);\n        System.out.println(\"max=\" + max);\n      }\n      Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery, toQuery, searcher, scoreMode, ordinalMap, min, max);\n      TotalHitCountCollector collector = new TotalHitCountCollector();\n      searcher.search(joinQuery, collector);\n      int expectedCount = 0;\n      for (int numChildDocs : childDocsPerParent) {\n        if (numChildDocs >= min && numChildDocs <= max) {\n          expectedCount++;\n        }\n      }\n      assertEquals(expectedCount, collector.getTotalHits());\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxDocs() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    int minChildDocsPerParent = 2;\n    int maxChildDocsPerParent = 16;\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    int[] childDocsPerParent = new int[numParents];\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent);\n      childDocsPerParent[p] = numChildren;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        iw.addDocument(childDoc);\n      }\n    }\n    iw.close();\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT\n    );\n    Query fromQuery = new TermQuery(new Term(\"type\", \"from\"));\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n\n    int iters = RandomNumbers.randomIntBetween(random(), 3, 9);\n    for (int i = 1; i <= iters; i++) {\n      final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      int min = RandomNumbers.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent - 1);\n      int max = RandomNumbers.randomIntBetween(random(), min, maxChildDocsPerParent);\n      if (VERBOSE) {\n        System.out.println(\"iter=\" + i);\n        System.out.println(\"scoreMode=\" + scoreMode);\n        System.out.println(\"min=\" + min);\n        System.out.println(\"max=\" + max);\n      }\n      Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery, toQuery, searcher, scoreMode, ordinalMap, min, max);\n      TotalHitCountCollector collector = new TotalHitCountCollector();\n      searcher.search(joinQuery, collector);\n      int expectedCount = 0;\n      for (int numChildDocs : childDocsPerParent) {\n        if (numChildDocs >= min && numChildDocs <= max) {\n          expectedCount++;\n        }\n      }\n      assertEquals(expectedCount, collector.getTotalHits());\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"957c610636f393a85a38f1af670540028db13e6b","date":1500044517,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxDocs().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxDocs().mjava","sourceNew":"  public void testMinMaxDocs() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    int minChildDocsPerParent = 2;\n    int maxChildDocsPerParent = 16;\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    int[] childDocsPerParent = new int[numParents];\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent);\n      childDocsPerParent[p] = numChildren;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        iw.addDocument(childDoc);\n      }\n    }\n    iw.close();\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    OrdinalMap ordinalMap = OrdinalMap.build(\n        null, values, PackedInts.DEFAULT\n    );\n    Query fromQuery = new TermQuery(new Term(\"type\", \"from\"));\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n\n    int iters = RandomNumbers.randomIntBetween(random(), 3, 9);\n    for (int i = 1; i <= iters; i++) {\n      final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      int min = RandomNumbers.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent - 1);\n      int max = RandomNumbers.randomIntBetween(random(), min, maxChildDocsPerParent);\n      if (VERBOSE) {\n        System.out.println(\"iter=\" + i);\n        System.out.println(\"scoreMode=\" + scoreMode);\n        System.out.println(\"min=\" + min);\n        System.out.println(\"max=\" + max);\n      }\n      Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery, toQuery, searcher, scoreMode, ordinalMap, min, max);\n      TotalHitCountCollector collector = new TotalHitCountCollector();\n      searcher.search(joinQuery, collector);\n      int expectedCount = 0;\n      for (int numChildDocs : childDocsPerParent) {\n        if (numChildDocs >= min && numChildDocs <= max) {\n          expectedCount++;\n        }\n      }\n      assertEquals(expectedCount, collector.getTotalHits());\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxDocs() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    int minChildDocsPerParent = 2;\n    int maxChildDocsPerParent = 16;\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    int[] childDocsPerParent = new int[numParents];\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent);\n      childDocsPerParent[p] = numChildren;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        iw.addDocument(childDoc);\n      }\n    }\n    iw.close();\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        null, values, PackedInts.DEFAULT\n    );\n    Query fromQuery = new TermQuery(new Term(\"type\", \"from\"));\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n\n    int iters = RandomNumbers.randomIntBetween(random(), 3, 9);\n    for (int i = 1; i <= iters; i++) {\n      final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      int min = RandomNumbers.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent - 1);\n      int max = RandomNumbers.randomIntBetween(random(), min, maxChildDocsPerParent);\n      if (VERBOSE) {\n        System.out.println(\"iter=\" + i);\n        System.out.println(\"scoreMode=\" + scoreMode);\n        System.out.println(\"min=\" + min);\n        System.out.println(\"max=\" + max);\n      }\n      Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery, toQuery, searcher, scoreMode, ordinalMap, min, max);\n      TotalHitCountCollector collector = new TotalHitCountCollector();\n      searcher.search(joinQuery, collector);\n      int expectedCount = 0;\n      for (int numChildDocs : childDocsPerParent) {\n        if (numChildDocs >= min && numChildDocs <= max) {\n          expectedCount++;\n        }\n      }\n      assertEquals(expectedCount, collector.getTotalHits());\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aaf90fc29510e72665ac7934f34c3d1c25efad64","date":1500354819,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxDocs().mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#testMinMaxDocs().mjava","sourceNew":"  public void testMinMaxDocs() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    int minChildDocsPerParent = 2;\n    int maxChildDocsPerParent = 16;\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    int[] childDocsPerParent = new int[numParents];\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent);\n      childDocsPerParent[p] = numChildren;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        iw.addDocument(childDoc);\n      }\n    }\n    iw.close();\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    OrdinalMap ordinalMap = OrdinalMap.build(\n        null, values, PackedInts.DEFAULT\n    );\n    Query fromQuery = new TermQuery(new Term(\"type\", \"from\"));\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n\n    int iters = RandomNumbers.randomIntBetween(random(), 3, 9);\n    for (int i = 1; i <= iters; i++) {\n      final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      int min = RandomNumbers.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent - 1);\n      int max = RandomNumbers.randomIntBetween(random(), min, maxChildDocsPerParent);\n      if (VERBOSE) {\n        System.out.println(\"iter=\" + i);\n        System.out.println(\"scoreMode=\" + scoreMode);\n        System.out.println(\"min=\" + min);\n        System.out.println(\"max=\" + max);\n      }\n      Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery, toQuery, searcher, scoreMode, ordinalMap, min, max);\n      TotalHitCountCollector collector = new TotalHitCountCollector();\n      searcher.search(joinQuery, collector);\n      int expectedCount = 0;\n      for (int numChildDocs : childDocsPerParent) {\n        if (numChildDocs >= min && numChildDocs <= max) {\n          expectedCount++;\n        }\n      }\n      assertEquals(expectedCount, collector.getTotalHits());\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMinMaxDocs() throws Exception {\n    Directory dir = newDirectory();\n    RandomIndexWriter iw = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    int minChildDocsPerParent = 2;\n    int maxChildDocsPerParent = 16;\n    int numParents = RandomNumbers.randomIntBetween(random(), 16, 64);\n    int[] childDocsPerParent = new int[numParents];\n    for (int p = 0; p < numParents; p++) {\n      String parentId = Integer.toString(p);\n      Document parentDoc = new Document();\n      parentDoc.add(new StringField(\"id\", parentId, Field.Store.YES));\n      parentDoc.add(new StringField(\"type\", \"to\", Field.Store.NO));\n      parentDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n      iw.addDocument(parentDoc);\n      int numChildren = RandomNumbers.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent);\n      childDocsPerParent[p] = numChildren;\n      for (int c = 0; c < numChildren; c++) {\n        String childId = Integer.toString(p + c);\n        Document childDoc = new Document();\n        childDoc.add(new StringField(\"id\", childId, Field.Store.YES));\n        childDoc.add(new StringField(\"type\", \"from\", Field.Store.NO));\n        childDoc.add(new SortedDocValuesField(\"join_field\", new BytesRef(parentId)));\n        iw.addDocument(childDoc);\n      }\n    }\n    iw.close();\n\n    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));\n    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];\n    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {\n      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n    }\n    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(\n        null, values, PackedInts.DEFAULT\n    );\n    Query fromQuery = new TermQuery(new Term(\"type\", \"from\"));\n    Query toQuery = new TermQuery(new Term(\"type\", \"to\"));\n\n    int iters = RandomNumbers.randomIntBetween(random(), 3, 9);\n    for (int i = 1; i <= iters; i++) {\n      final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n      int min = RandomNumbers.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent - 1);\n      int max = RandomNumbers.randomIntBetween(random(), min, maxChildDocsPerParent);\n      if (VERBOSE) {\n        System.out.println(\"iter=\" + i);\n        System.out.println(\"scoreMode=\" + scoreMode);\n        System.out.println(\"min=\" + min);\n        System.out.println(\"max=\" + max);\n      }\n      Query joinQuery = JoinUtil.createJoinQuery(\"join_field\", fromQuery, toQuery, searcher, scoreMode, ordinalMap, min, max);\n      TotalHitCountCollector collector = new TotalHitCountCollector();\n      searcher.search(joinQuery, collector);\n      int expectedCount = 0;\n      for (int numChildDocs : childDocsPerParent) {\n        if (numChildDocs >= min && numChildDocs <= max) {\n          expectedCount++;\n        }\n      }\n      assertEquals(expectedCount, collector.getTotalHits());\n    }\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"957c610636f393a85a38f1af670540028db13e6b":["d211216c83f01894810543d1c107160a9ae3650b"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":["d211216c83f01894810543d1c107160a9ae3650b","957c610636f393a85a38f1af670540028db13e6b"],"d211216c83f01894810543d1c107160a9ae3650b":["6448f67be45147de82a85cd903fec34e8930da75"],"6448f67be45147de82a85cd903fec34e8930da75":["9a8ccb9d7a971a53ccd8bc3d8230590bca107c51"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["9a8ccb9d7a971a53ccd8bc3d8230590bca107c51","6448f67be45147de82a85cd903fec34e8930da75"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["957c610636f393a85a38f1af670540028db13e6b"],"9a8ccb9d7a971a53ccd8bc3d8230590bca107c51":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"957c610636f393a85a38f1af670540028db13e6b":["aaf90fc29510e72665ac7934f34c3d1c25efad64","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":[],"d211216c83f01894810543d1c107160a9ae3650b":["957c610636f393a85a38f1af670540028db13e6b","aaf90fc29510e72665ac7934f34c3d1c25efad64"],"6448f67be45147de82a85cd903fec34e8930da75":["d211216c83f01894810543d1c107160a9ae3650b","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9a8ccb9d7a971a53ccd8bc3d8230590bca107c51"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":[],"9a8ccb9d7a971a53ccd8bc3d8230590bca107c51":["6448f67be45147de82a85cd903fec34e8930da75","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aaf90fc29510e72665ac7934f34c3d1c25efad64","80d0e6d59ae23f4a6f30eaf40bfb40742300287f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}