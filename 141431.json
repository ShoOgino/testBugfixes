{"path":"lucene/core/src/java/org/apache/lucene/util/fst/FST#writeNodeForDirectAddressing(FSTCompiler[T],FSTCompiler.UnCompiledNode[T],long,int,int).mjava","commits":[{"id":"0f5661e6a04d3172e262ad741b717924f2f1b6a5","date":1576244274,"type":1,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#writeNodeForDirectAddressing(FSTCompiler[T],FSTCompiler.UnCompiledNode[T],long,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#writeNodeForDirectAddressing(Builder[T],Builder.UnCompiledNode[T],long,int,int).mjava","sourceNew":"  private void writeNodeForDirectAddressing(FSTCompiler<T> fstCompiler, FSTCompiler.UnCompiledNode<T> nodeIn, long startAddress, int maxBytesPerArcWithoutLabel, int labelRange) {\n    // Expand the arcs backwards in a buffer because we remove the labels.\n    // So the obtained arcs might occupy less space. This is the reason why this\n    // whole method is more complex.\n    // Drop the label bytes since we can infer the label based on the arc index,\n    // the presence bits, and the first label. Keep the first label.\n    int headerMaxLen = 11;\n    int numPresenceBytes = getNumPresenceBytes(labelRange);\n    long srcPos = fstCompiler.bytes.getPosition();\n    int totalArcBytes = fstCompiler.numLabelBytesPerArc[0] + nodeIn.numArcs * maxBytesPerArcWithoutLabel;\n    int bufferOffset = headerMaxLen + numPresenceBytes + totalArcBytes;\n    byte[] buffer = fstCompiler.fixedLengthArcsBuffer.ensureCapacity(bufferOffset).getBytes();\n    // Copy the arcs to the buffer, dropping all labels except first one.\n    for (int arcIdx = nodeIn.numArcs - 1; arcIdx >= 0; arcIdx--) {\n      bufferOffset -= maxBytesPerArcWithoutLabel;\n      int srcArcLen = fstCompiler.numBytesPerArc[arcIdx];\n      srcPos -= srcArcLen;\n      int labelLen = fstCompiler.numLabelBytesPerArc[arcIdx];\n      // Copy the flags.\n      fstCompiler.bytes.copyBytes(srcPos, buffer, bufferOffset, 1);\n      // Skip the label, copy the remaining.\n      int remainingArcLen = srcArcLen - 1 - labelLen;\n      if (remainingArcLen != 0) {\n        fstCompiler.bytes.copyBytes(srcPos + 1 + labelLen, buffer, bufferOffset + 1, remainingArcLen);\n      }\n      if (arcIdx == 0) {\n        // Copy the label of the first arc only.\n        bufferOffset -= labelLen;\n        fstCompiler.bytes.copyBytes(srcPos + 1, buffer, bufferOffset, labelLen);\n      }\n    }\n    assert bufferOffset == headerMaxLen + numPresenceBytes;\n\n    // Build the header in the buffer.\n    // It is a false/special arc which is in fact a node header with node flags followed by node metadata.\n    fstCompiler.fixedLengthArcsBuffer\n        .resetPosition()\n        .writeByte(ARCS_FOR_DIRECT_ADDRESSING)\n        .writeVInt(labelRange) // labelRange instead of numArcs.\n        .writeVInt(maxBytesPerArcWithoutLabel); // maxBytesPerArcWithoutLabel instead of maxBytesPerArc.\n    int headerLen = fstCompiler.fixedLengthArcsBuffer.getPosition();\n\n    // Prepare the builder byte store. Enlarge or truncate if needed.\n    long nodeEnd = startAddress + headerLen + numPresenceBytes + totalArcBytes;\n    long currentPosition = fstCompiler.bytes.getPosition();\n    if (nodeEnd >= currentPosition) {\n      fstCompiler.bytes.skipBytes((int) (nodeEnd - currentPosition));\n    } else {\n      fstCompiler.bytes.truncate(nodeEnd);\n    }\n    assert fstCompiler.bytes.getPosition() == nodeEnd;\n\n    // Write the header.\n    long writeOffset = startAddress;\n    fstCompiler.bytes.writeBytes(writeOffset, fstCompiler.fixedLengthArcsBuffer.getBytes(), 0, headerLen);\n    writeOffset += headerLen;\n\n    // Write the presence bits\n    writePresenceBits(fstCompiler, nodeIn, writeOffset, numPresenceBytes);\n    writeOffset += numPresenceBytes;\n\n    // Write the first label and the arcs.\n    fstCompiler.bytes.writeBytes(writeOffset, fstCompiler.fixedLengthArcsBuffer.getBytes(), bufferOffset, totalArcBytes);\n  }\n\n","sourceOld":"  private void writeNodeForDirectAddressing(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn, long startAddress, int maxBytesPerArcWithoutLabel, int labelRange) {\n    // Expand the arcs backwards in a buffer because we remove the labels.\n    // So the obtained arcs might occupy less space. This is the reason why this\n    // whole method is more complex.\n    // Drop the label bytes since we can infer the label based on the arc index,\n    // the presence bits, and the first label. Keep the first label.\n    int headerMaxLen = 11;\n    int numPresenceBytes = getNumPresenceBytes(labelRange);\n    long srcPos = builder.bytes.getPosition();\n    int totalArcBytes = builder.numLabelBytesPerArc[0] + nodeIn.numArcs * maxBytesPerArcWithoutLabel;\n    int bufferOffset = headerMaxLen + numPresenceBytes + totalArcBytes;\n    byte[] buffer = builder.fixedLengthArcsBuffer.ensureCapacity(bufferOffset).getBytes();\n    // Copy the arcs to the buffer, dropping all labels except first one.\n    for (int arcIdx = nodeIn.numArcs - 1; arcIdx >= 0; arcIdx--) {\n      bufferOffset -= maxBytesPerArcWithoutLabel;\n      int srcArcLen = builder.numBytesPerArc[arcIdx];\n      srcPos -= srcArcLen;\n      int labelLen = builder.numLabelBytesPerArc[arcIdx];\n      // Copy the flags.\n      builder.bytes.copyBytes(srcPos, buffer, bufferOffset, 1);\n      // Skip the label, copy the remaining.\n      int remainingArcLen = srcArcLen - 1 - labelLen;\n      if (remainingArcLen != 0) {\n        builder.bytes.copyBytes(srcPos + 1 + labelLen, buffer, bufferOffset + 1, remainingArcLen);\n      }\n      if (arcIdx == 0) {\n        // Copy the label of the first arc only.\n        bufferOffset -= labelLen;\n        builder.bytes.copyBytes(srcPos + 1, buffer, bufferOffset, labelLen);\n      }\n    }\n    assert bufferOffset == headerMaxLen + numPresenceBytes;\n\n    // Build the header in the buffer.\n    // It is a false/special arc which is in fact a node header with node flags followed by node metadata.\n    builder.fixedLengthArcsBuffer\n        .resetPosition()\n        .writeByte(ARCS_FOR_DIRECT_ADDRESSING)\n        .writeVInt(labelRange) // labelRange instead of numArcs.\n        .writeVInt(maxBytesPerArcWithoutLabel); // maxBytesPerArcWithoutLabel instead of maxBytesPerArc.\n    int headerLen = builder.fixedLengthArcsBuffer.getPosition();\n\n    // Prepare the builder byte store. Enlarge or truncate if needed.\n    long nodeEnd = startAddress + headerLen + numPresenceBytes + totalArcBytes;\n    long currentPosition = builder.bytes.getPosition();\n    if (nodeEnd >= currentPosition) {\n      builder.bytes.skipBytes((int) (nodeEnd - currentPosition));\n    } else {\n      builder.bytes.truncate(nodeEnd);\n    }\n    assert builder.bytes.getPosition() == nodeEnd;\n\n    // Write the header.\n    long writeOffset = startAddress;\n    builder.bytes.writeBytes(writeOffset, builder.fixedLengthArcsBuffer.getBytes(), 0, headerLen);\n    writeOffset += headerLen;\n\n    // Write the presence bits\n    writePresenceBits(builder, nodeIn, writeOffset, numPresenceBytes);\n    writeOffset += numPresenceBytes;\n\n    // Write the first label and the arcs.\n    builder.bytes.writeBytes(writeOffset, builder.fixedLengthArcsBuffer.getBytes(), bufferOffset, totalArcBytes);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","date":1576247714,"type":1,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#writeNodeForDirectAddressing(FSTCompiler[T],FSTCompiler.UnCompiledNode[T],long,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#writeNodeForDirectAddressing(Builder[T],Builder.UnCompiledNode[T],long,int,int).mjava","sourceNew":"  private void writeNodeForDirectAddressing(FSTCompiler<T> fstCompiler, FSTCompiler.UnCompiledNode<T> nodeIn, long startAddress, int maxBytesPerArcWithoutLabel, int labelRange) {\n    // Expand the arcs backwards in a buffer because we remove the labels.\n    // So the obtained arcs might occupy less space. This is the reason why this\n    // whole method is more complex.\n    // Drop the label bytes since we can infer the label based on the arc index,\n    // the presence bits, and the first label. Keep the first label.\n    int headerMaxLen = 11;\n    int numPresenceBytes = getNumPresenceBytes(labelRange);\n    long srcPos = fstCompiler.bytes.getPosition();\n    int totalArcBytes = fstCompiler.numLabelBytesPerArc[0] + nodeIn.numArcs * maxBytesPerArcWithoutLabel;\n    int bufferOffset = headerMaxLen + numPresenceBytes + totalArcBytes;\n    byte[] buffer = fstCompiler.fixedLengthArcsBuffer.ensureCapacity(bufferOffset).getBytes();\n    // Copy the arcs to the buffer, dropping all labels except first one.\n    for (int arcIdx = nodeIn.numArcs - 1; arcIdx >= 0; arcIdx--) {\n      bufferOffset -= maxBytesPerArcWithoutLabel;\n      int srcArcLen = fstCompiler.numBytesPerArc[arcIdx];\n      srcPos -= srcArcLen;\n      int labelLen = fstCompiler.numLabelBytesPerArc[arcIdx];\n      // Copy the flags.\n      fstCompiler.bytes.copyBytes(srcPos, buffer, bufferOffset, 1);\n      // Skip the label, copy the remaining.\n      int remainingArcLen = srcArcLen - 1 - labelLen;\n      if (remainingArcLen != 0) {\n        fstCompiler.bytes.copyBytes(srcPos + 1 + labelLen, buffer, bufferOffset + 1, remainingArcLen);\n      }\n      if (arcIdx == 0) {\n        // Copy the label of the first arc only.\n        bufferOffset -= labelLen;\n        fstCompiler.bytes.copyBytes(srcPos + 1, buffer, bufferOffset, labelLen);\n      }\n    }\n    assert bufferOffset == headerMaxLen + numPresenceBytes;\n\n    // Build the header in the buffer.\n    // It is a false/special arc which is in fact a node header with node flags followed by node metadata.\n    fstCompiler.fixedLengthArcsBuffer\n        .resetPosition()\n        .writeByte(ARCS_FOR_DIRECT_ADDRESSING)\n        .writeVInt(labelRange) // labelRange instead of numArcs.\n        .writeVInt(maxBytesPerArcWithoutLabel); // maxBytesPerArcWithoutLabel instead of maxBytesPerArc.\n    int headerLen = fstCompiler.fixedLengthArcsBuffer.getPosition();\n\n    // Prepare the builder byte store. Enlarge or truncate if needed.\n    long nodeEnd = startAddress + headerLen + numPresenceBytes + totalArcBytes;\n    long currentPosition = fstCompiler.bytes.getPosition();\n    if (nodeEnd >= currentPosition) {\n      fstCompiler.bytes.skipBytes((int) (nodeEnd - currentPosition));\n    } else {\n      fstCompiler.bytes.truncate(nodeEnd);\n    }\n    assert fstCompiler.bytes.getPosition() == nodeEnd;\n\n    // Write the header.\n    long writeOffset = startAddress;\n    fstCompiler.bytes.writeBytes(writeOffset, fstCompiler.fixedLengthArcsBuffer.getBytes(), 0, headerLen);\n    writeOffset += headerLen;\n\n    // Write the presence bits\n    writePresenceBits(fstCompiler, nodeIn, writeOffset, numPresenceBytes);\n    writeOffset += numPresenceBytes;\n\n    // Write the first label and the arcs.\n    fstCompiler.bytes.writeBytes(writeOffset, fstCompiler.fixedLengthArcsBuffer.getBytes(), bufferOffset, totalArcBytes);\n  }\n\n","sourceOld":"  private void writeNodeForDirectAddressing(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn, long startAddress, int maxBytesPerArcWithoutLabel, int labelRange) {\n    // Expand the arcs backwards in a buffer because we remove the labels.\n    // So the obtained arcs might occupy less space. This is the reason why this\n    // whole method is more complex.\n    // Drop the label bytes since we can infer the label based on the arc index,\n    // the presence bits, and the first label. Keep the first label.\n    int headerMaxLen = 11;\n    int numPresenceBytes = getNumPresenceBytes(labelRange);\n    long srcPos = builder.bytes.getPosition();\n    int totalArcBytes = builder.numLabelBytesPerArc[0] + nodeIn.numArcs * maxBytesPerArcWithoutLabel;\n    int bufferOffset = headerMaxLen + numPresenceBytes + totalArcBytes;\n    byte[] buffer = builder.fixedLengthArcsBuffer.ensureCapacity(bufferOffset).getBytes();\n    // Copy the arcs to the buffer, dropping all labels except first one.\n    for (int arcIdx = nodeIn.numArcs - 1; arcIdx >= 0; arcIdx--) {\n      bufferOffset -= maxBytesPerArcWithoutLabel;\n      int srcArcLen = builder.numBytesPerArc[arcIdx];\n      srcPos -= srcArcLen;\n      int labelLen = builder.numLabelBytesPerArc[arcIdx];\n      // Copy the flags.\n      builder.bytes.copyBytes(srcPos, buffer, bufferOffset, 1);\n      // Skip the label, copy the remaining.\n      int remainingArcLen = srcArcLen - 1 - labelLen;\n      if (remainingArcLen != 0) {\n        builder.bytes.copyBytes(srcPos + 1 + labelLen, buffer, bufferOffset + 1, remainingArcLen);\n      }\n      if (arcIdx == 0) {\n        // Copy the label of the first arc only.\n        bufferOffset -= labelLen;\n        builder.bytes.copyBytes(srcPos + 1, buffer, bufferOffset, labelLen);\n      }\n    }\n    assert bufferOffset == headerMaxLen + numPresenceBytes;\n\n    // Build the header in the buffer.\n    // It is a false/special arc which is in fact a node header with node flags followed by node metadata.\n    builder.fixedLengthArcsBuffer\n        .resetPosition()\n        .writeByte(ARCS_FOR_DIRECT_ADDRESSING)\n        .writeVInt(labelRange) // labelRange instead of numArcs.\n        .writeVInt(maxBytesPerArcWithoutLabel); // maxBytesPerArcWithoutLabel instead of maxBytesPerArc.\n    int headerLen = builder.fixedLengthArcsBuffer.getPosition();\n\n    // Prepare the builder byte store. Enlarge or truncate if needed.\n    long nodeEnd = startAddress + headerLen + numPresenceBytes + totalArcBytes;\n    long currentPosition = builder.bytes.getPosition();\n    if (nodeEnd >= currentPosition) {\n      builder.bytes.skipBytes((int) (nodeEnd - currentPosition));\n    } else {\n      builder.bytes.truncate(nodeEnd);\n    }\n    assert builder.bytes.getPosition() == nodeEnd;\n\n    // Write the header.\n    long writeOffset = startAddress;\n    builder.bytes.writeBytes(writeOffset, builder.fixedLengthArcsBuffer.getBytes(), 0, headerLen);\n    writeOffset += headerLen;\n\n    // Write the presence bits\n    writePresenceBits(builder, nodeIn, writeOffset, numPresenceBytes);\n    writeOffset += numPresenceBytes;\n\n    // Write the first label and the arcs.\n    builder.bytes.writeBytes(writeOffset, builder.fixedLengthArcsBuffer.getBytes(), bufferOffset, totalArcBytes);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f5661e6a04d3172e262ad741b717924f2f1b6a5"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":[],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}