{"path":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessor#finish().mjava","commits":[{"id":"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef","date":1458928975,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessor#finish().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void finish() throws IOException {\n\n    // even if processAdd threw an error, this.finish() is still called and we might have additional\n    // errors from other remote leaders that we need to check for from the finish method of downstream processors\n    // (like DUP)\n    \n    try {\n      super.finish();\n    } catch (DistributedUpdateProcessor.DistributedUpdatesAsyncException duae) {\n      firstErrTracker.caught(duae);\n\n      \n      // adjust our stats based on each of the distributed errors\n      for (Error error : duae.errors) {\n        // we can't trust the req info from the Error, because multiple original requests might have been\n        // lumped together\n        //\n        // instead we trust the metadata that the TolerantUpdateProcessor running on the remote node added\n        // to the exception when it failed.\n        if ( ! (error.e instanceof SolrException) ) {\n          log.error(\"async update exception is not SolrException, no metadata to process\", error.e);\n          continue;\n        }\n        SolrException remoteErr = (SolrException) error.e;\n        NamedList<String> remoteErrMetadata = remoteErr.getMetadata();\n\n        if (null == remoteErrMetadata) {\n          log.warn(\"remote error has no metadata to aggregate: \" + remoteErr.getMessage(), remoteErr);\n          continue;\n        }\n\n        for (int i = 0; i < remoteErrMetadata.size(); i++) {\n          ToleratedUpdateError err =\n            ToleratedUpdateError.parseMetadataIfToleratedUpdateError(remoteErrMetadata.getName(i),\n                                                                     remoteErrMetadata.getVal(i));\n          if (null == err) {\n            // some metadata unrelated to this update processor\n            continue;\n          }\n\n          if (CmdType.DELQ.equals(err.getType())) {\n            if (knownDBQErrors.contains(err)) {\n              // we've already seen this identical error, probably a dup from another shard\n              continue;\n            } else {\n              knownDBQErrors.add(err);\n            }\n          }\n          \n          knownErrors.add(err);\n        }\n      }\n    }\n\n    header.add(\"errors\", ToleratedUpdateError.formatForResponseHeader(knownErrors));\n    // include in response so client knows what effective value was (may have been server side config)\n    header.add(\"maxErrors\", ToleratedUpdateError.getUserFriendlyMaxErrors(maxErrors));\n\n    // annotate any error that might be thrown (or was already thrown)\n    firstErrTracker.annotate(knownErrors);\n\n    // decide if we have hit a situation where we know an error needs to be thrown.\n    \n    if ((DistribPhase.TOLEADER.equals(distribPhase) ? 0 : maxErrors) < knownErrors.size()) {\n      // NOTE: even if maxErrors wasn't exceeeded, we need to throw an error when we have any errors if we're\n      // a leader that was forwarded to by another node so that the forwarding node knows we encountered some\n      // problems and can aggregate the results\n\n      firstErrTracker.throwFirst();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0158ced21948b6626f733c1c42c1e18d94449789","date":1462994341,"type":3,"author":"Bartosz KrasiÅ„ski","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessor#finish().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessor#finish().mjava","sourceNew":"  @Override\n  public void finish() throws IOException {\n\n    // even if processAdd threw an error, this.finish() is still called and we might have additional\n    // errors from other remote leaders that we need to check for from the finish method of downstream processors\n    // (like DUP)\n    \n    try {\n      super.finish();\n    } catch (DistributedUpdateProcessor.DistributedUpdatesAsyncException duae) {\n      firstErrTracker.caught(duae);\n\n      \n      // adjust our stats based on each of the distributed errors\n      for (Error error : duae.errors) {\n        // we can't trust the req info from the Error, because multiple original requests might have been\n        // lumped together\n        //\n        // instead we trust the metadata that the TolerantUpdateProcessor running on the remote node added\n        // to the exception when it failed.\n        if ( ! (error.e instanceof SolrException) ) {\n          log.error(\"async update exception is not SolrException, no metadata to process\", error.e);\n          continue;\n        }\n        SolrException remoteErr = (SolrException) error.e;\n        NamedList<String> remoteErrMetadata = remoteErr.getMetadata();\n\n        if (null == remoteErrMetadata) {\n          log.warn(\"remote error has no metadata to aggregate: \" + remoteErr.getMessage(), remoteErr);\n          continue;\n        }\n\n        for (int i = 0; i < remoteErrMetadata.size(); i++) {\n          ToleratedUpdateError err =\n            ToleratedUpdateError.parseMetadataIfToleratedUpdateError(remoteErrMetadata.getName(i),\n                                                                     remoteErrMetadata.getVal(i));\n          if (null == err) {\n            // some metadata unrelated to this update processor\n            continue;\n          }\n\n          if (CmdType.DELQ.equals(err.getType())) {\n            if (knownDBQErrors.contains(err)) {\n              // we've already seen this identical error, probably a dup from another shard\n              continue;\n            } else {\n              knownDBQErrors.add(err);\n            }\n          }\n          \n          knownErrors.add(err);\n        }\n      }\n    }\n\n    header.add(\"errors\", ToleratedUpdateError.formatForResponseHeader(knownErrors));\n    // include in response so client knows what effective value was (may have been server side config)\n    header.add(\"maxErrors\", ToleratedUpdateError.getUserFriendlyMaxErrors(maxErrors));\n\n    // annotate any error that might be thrown (or was already thrown)\n    firstErrTracker.annotate(knownErrors);\n\n    // decide if we have hit a situation where we know an error needs to be thrown.\n    \n    if ((DistribPhase.TOLEADER.equals(distribPhase) ? 0 : maxErrors) < knownErrors.size()) {\n      // NOTE: even if maxErrors wasn't exceeded, we need to throw an error when we have any errors if we're\n      // a leader that was forwarded to by another node so that the forwarding node knows we encountered some\n      // problems and can aggregate the results\n\n      firstErrTracker.throwFirst();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void finish() throws IOException {\n\n    // even if processAdd threw an error, this.finish() is still called and we might have additional\n    // errors from other remote leaders that we need to check for from the finish method of downstream processors\n    // (like DUP)\n    \n    try {\n      super.finish();\n    } catch (DistributedUpdateProcessor.DistributedUpdatesAsyncException duae) {\n      firstErrTracker.caught(duae);\n\n      \n      // adjust our stats based on each of the distributed errors\n      for (Error error : duae.errors) {\n        // we can't trust the req info from the Error, because multiple original requests might have been\n        // lumped together\n        //\n        // instead we trust the metadata that the TolerantUpdateProcessor running on the remote node added\n        // to the exception when it failed.\n        if ( ! (error.e instanceof SolrException) ) {\n          log.error(\"async update exception is not SolrException, no metadata to process\", error.e);\n          continue;\n        }\n        SolrException remoteErr = (SolrException) error.e;\n        NamedList<String> remoteErrMetadata = remoteErr.getMetadata();\n\n        if (null == remoteErrMetadata) {\n          log.warn(\"remote error has no metadata to aggregate: \" + remoteErr.getMessage(), remoteErr);\n          continue;\n        }\n\n        for (int i = 0; i < remoteErrMetadata.size(); i++) {\n          ToleratedUpdateError err =\n            ToleratedUpdateError.parseMetadataIfToleratedUpdateError(remoteErrMetadata.getName(i),\n                                                                     remoteErrMetadata.getVal(i));\n          if (null == err) {\n            // some metadata unrelated to this update processor\n            continue;\n          }\n\n          if (CmdType.DELQ.equals(err.getType())) {\n            if (knownDBQErrors.contains(err)) {\n              // we've already seen this identical error, probably a dup from another shard\n              continue;\n            } else {\n              knownDBQErrors.add(err);\n            }\n          }\n          \n          knownErrors.add(err);\n        }\n      }\n    }\n\n    header.add(\"errors\", ToleratedUpdateError.formatForResponseHeader(knownErrors));\n    // include in response so client knows what effective value was (may have been server side config)\n    header.add(\"maxErrors\", ToleratedUpdateError.getUserFriendlyMaxErrors(maxErrors));\n\n    // annotate any error that might be thrown (or was already thrown)\n    firstErrTracker.annotate(knownErrors);\n\n    // decide if we have hit a situation where we know an error needs to be thrown.\n    \n    if ((DistribPhase.TOLEADER.equals(distribPhase) ? 0 : maxErrors) < knownErrors.size()) {\n      // NOTE: even if maxErrors wasn't exceeeded, we need to throw an error when we have any errors if we're\n      // a leader that was forwarded to by another node so that the forwarding node knows we encountered some\n      // problems and can aggregate the results\n\n      firstErrTracker.throwFirst();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessor#finish().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessor#finish().mjava","sourceNew":"  @Override\n  public void finish() throws IOException {\n\n    // even if processAdd threw an error, this.finish() is still called and we might have additional\n    // errors from other remote leaders that we need to check for from the finish method of downstream processors\n    // (like DUP)\n    \n    try {\n      super.finish();\n    } catch (DistributedUpdateProcessor.DistributedUpdatesAsyncException duae) {\n      firstErrTracker.caught(duae);\n\n      \n      // adjust our stats based on each of the distributed errors\n      for (Error error : duae.errors) {\n        // we can't trust the req info from the Error, because multiple original requests might have been\n        // lumped together\n        //\n        // instead we trust the metadata that the TolerantUpdateProcessor running on the remote node added\n        // to the exception when it failed.\n        if ( ! (error.e instanceof SolrException) ) {\n          log.error(\"async update exception is not SolrException, no metadata to process\", error.e);\n          continue;\n        }\n        SolrException remoteErr = (SolrException) error.e;\n        NamedList<String> remoteErrMetadata = remoteErr.getMetadata();\n\n        if (null == remoteErrMetadata) {\n          log.warn(\"remote error has no metadata to aggregate: \" + remoteErr.getMessage(), remoteErr);\n          continue;\n        }\n\n        for (int i = 0; i < remoteErrMetadata.size(); i++) {\n          ToleratedUpdateError err =\n            ToleratedUpdateError.parseMetadataIfToleratedUpdateError(remoteErrMetadata.getName(i),\n                                                                     remoteErrMetadata.getVal(i));\n          if (null == err) {\n            // some metadata unrelated to this update processor\n            continue;\n          }\n\n          if (CmdType.DELQ.equals(err.getType())) {\n            if (knownDBQErrors.contains(err)) {\n              // we've already seen this identical error, probably a dup from another shard\n              continue;\n            } else {\n              knownDBQErrors.add(err);\n            }\n          }\n          \n          knownErrors.add(err);\n        }\n      }\n    }\n\n    header.add(\"errors\", ToleratedUpdateError.formatForResponseHeader(knownErrors));\n    // include in response so client knows what effective value was (may have been server side config)\n    header.add(\"maxErrors\", ToleratedUpdateError.getUserFriendlyMaxErrors(maxErrors));\n\n    // annotate any error that might be thrown (or was already thrown)\n    firstErrTracker.annotate(knownErrors);\n\n    // decide if we have hit a situation where we know an error needs to be thrown.\n    \n    if ((DistribPhase.TOLEADER.equals(distribPhase) ? 0 : maxErrors) < knownErrors.size()) {\n      // NOTE: even if maxErrors wasn't exceeded, we need to throw an error when we have any errors if we're\n      // a leader that was forwarded to by another node so that the forwarding node knows we encountered some\n      // problems and can aggregate the results\n\n      firstErrTracker.throwFirst();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void finish() throws IOException {\n\n    // even if processAdd threw an error, this.finish() is still called and we might have additional\n    // errors from other remote leaders that we need to check for from the finish method of downstream processors\n    // (like DUP)\n    \n    try {\n      super.finish();\n    } catch (DistributedUpdateProcessor.DistributedUpdatesAsyncException duae) {\n      firstErrTracker.caught(duae);\n\n      \n      // adjust our stats based on each of the distributed errors\n      for (Error error : duae.errors) {\n        // we can't trust the req info from the Error, because multiple original requests might have been\n        // lumped together\n        //\n        // instead we trust the metadata that the TolerantUpdateProcessor running on the remote node added\n        // to the exception when it failed.\n        if ( ! (error.e instanceof SolrException) ) {\n          log.error(\"async update exception is not SolrException, no metadata to process\", error.e);\n          continue;\n        }\n        SolrException remoteErr = (SolrException) error.e;\n        NamedList<String> remoteErrMetadata = remoteErr.getMetadata();\n\n        if (null == remoteErrMetadata) {\n          log.warn(\"remote error has no metadata to aggregate: \" + remoteErr.getMessage(), remoteErr);\n          continue;\n        }\n\n        for (int i = 0; i < remoteErrMetadata.size(); i++) {\n          ToleratedUpdateError err =\n            ToleratedUpdateError.parseMetadataIfToleratedUpdateError(remoteErrMetadata.getName(i),\n                                                                     remoteErrMetadata.getVal(i));\n          if (null == err) {\n            // some metadata unrelated to this update processor\n            continue;\n          }\n\n          if (CmdType.DELQ.equals(err.getType())) {\n            if (knownDBQErrors.contains(err)) {\n              // we've already seen this identical error, probably a dup from another shard\n              continue;\n            } else {\n              knownDBQErrors.add(err);\n            }\n          }\n          \n          knownErrors.add(err);\n        }\n      }\n    }\n\n    header.add(\"errors\", ToleratedUpdateError.formatForResponseHeader(knownErrors));\n    // include in response so client knows what effective value was (may have been server side config)\n    header.add(\"maxErrors\", ToleratedUpdateError.getUserFriendlyMaxErrors(maxErrors));\n\n    // annotate any error that might be thrown (or was already thrown)\n    firstErrTracker.annotate(knownErrors);\n\n    // decide if we have hit a situation where we know an error needs to be thrown.\n    \n    if ((DistribPhase.TOLEADER.equals(distribPhase) ? 0 : maxErrors) < knownErrors.size()) {\n      // NOTE: even if maxErrors wasn't exceeeded, we need to throw an error when we have any errors if we're\n      // a leader that was forwarded to by another node so that the forwarding node knows we encountered some\n      // problems and can aggregate the results\n\n      firstErrTracker.throwFirst();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessor#finish().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessor#finish().mjava","sourceNew":"  @Override\n  public void finish() throws IOException {\n\n    // even if processAdd threw an error, this.finish() is still called and we might have additional\n    // errors from other remote leaders that we need to check for from the finish method of downstream processors\n    // (like DUP)\n    \n    try {\n      super.finish();\n    } catch (DistributedUpdateProcessor.DistributedUpdatesAsyncException duae) {\n      firstErrTracker.caught(duae);\n\n      \n      // adjust our stats based on each of the distributed errors\n      for (Error error : duae.errors) {\n        // we can't trust the req info from the Error, because multiple original requests might have been\n        // lumped together\n        //\n        // instead we trust the metadata that the TolerantUpdateProcessor running on the remote node added\n        // to the exception when it failed.\n        if ( ! (error.e instanceof SolrException) ) {\n          log.error(\"async update exception is not SolrException, no metadata to process\", error.e);\n          continue;\n        }\n        SolrException remoteErr = (SolrException) error.e;\n        NamedList<String> remoteErrMetadata = remoteErr.getMetadata();\n\n        if (null == remoteErrMetadata) {\n          log.warn(\"remote error has no metadata to aggregate: \" + remoteErr.getMessage(), remoteErr);\n          continue;\n        }\n\n        for (int i = 0; i < remoteErrMetadata.size(); i++) {\n          ToleratedUpdateError err =\n            ToleratedUpdateError.parseMetadataIfToleratedUpdateError(remoteErrMetadata.getName(i),\n                                                                     remoteErrMetadata.getVal(i));\n          if (null == err) {\n            // some metadata unrelated to this update processor\n            continue;\n          }\n\n          if (CmdType.DELQ.equals(err.getType())) {\n            if (knownDBQErrors.contains(err)) {\n              // we've already seen this identical error, probably a dup from another shard\n              continue;\n            } else {\n              knownDBQErrors.add(err);\n            }\n          }\n          \n          knownErrors.add(err);\n        }\n      }\n    }\n\n    header.add(\"errors\", ToleratedUpdateError.formatForResponseHeader(knownErrors));\n    // include in response so client knows what effective value was (may have been server side config)\n    header.add(\"maxErrors\", ToleratedUpdateError.getUserFriendlyMaxErrors(maxErrors));\n\n    // annotate any error that might be thrown (or was already thrown)\n    firstErrTracker.annotate(knownErrors);\n\n    // decide if we have hit a situation where we know an error needs to be thrown.\n    \n    if ((DistribPhase.TOLEADER.equals(distribPhase) ? 0 : maxErrors) < knownErrors.size()) {\n      // NOTE: even if maxErrors wasn't exceeded, we need to throw an error when we have any errors if we're\n      // a leader that was forwarded to by another node so that the forwarding node knows we encountered some\n      // problems and can aggregate the results\n\n      firstErrTracker.throwFirst();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void finish() throws IOException {\n\n    // even if processAdd threw an error, this.finish() is still called and we might have additional\n    // errors from other remote leaders that we need to check for from the finish method of downstream processors\n    // (like DUP)\n    \n    try {\n      super.finish();\n    } catch (DistributedUpdateProcessor.DistributedUpdatesAsyncException duae) {\n      firstErrTracker.caught(duae);\n\n      \n      // adjust our stats based on each of the distributed errors\n      for (Error error : duae.errors) {\n        // we can't trust the req info from the Error, because multiple original requests might have been\n        // lumped together\n        //\n        // instead we trust the metadata that the TolerantUpdateProcessor running on the remote node added\n        // to the exception when it failed.\n        if ( ! (error.e instanceof SolrException) ) {\n          log.error(\"async update exception is not SolrException, no metadata to process\", error.e);\n          continue;\n        }\n        SolrException remoteErr = (SolrException) error.e;\n        NamedList<String> remoteErrMetadata = remoteErr.getMetadata();\n\n        if (null == remoteErrMetadata) {\n          log.warn(\"remote error has no metadata to aggregate: \" + remoteErr.getMessage(), remoteErr);\n          continue;\n        }\n\n        for (int i = 0; i < remoteErrMetadata.size(); i++) {\n          ToleratedUpdateError err =\n            ToleratedUpdateError.parseMetadataIfToleratedUpdateError(remoteErrMetadata.getName(i),\n                                                                     remoteErrMetadata.getVal(i));\n          if (null == err) {\n            // some metadata unrelated to this update processor\n            continue;\n          }\n\n          if (CmdType.DELQ.equals(err.getType())) {\n            if (knownDBQErrors.contains(err)) {\n              // we've already seen this identical error, probably a dup from another shard\n              continue;\n            } else {\n              knownDBQErrors.add(err);\n            }\n          }\n          \n          knownErrors.add(err);\n        }\n      }\n    }\n\n    header.add(\"errors\", ToleratedUpdateError.formatForResponseHeader(knownErrors));\n    // include in response so client knows what effective value was (may have been server side config)\n    header.add(\"maxErrors\", ToleratedUpdateError.getUserFriendlyMaxErrors(maxErrors));\n\n    // annotate any error that might be thrown (or was already thrown)\n    firstErrTracker.annotate(knownErrors);\n\n    // decide if we have hit a situation where we know an error needs to be thrown.\n    \n    if ((DistribPhase.TOLEADER.equals(distribPhase) ? 0 : maxErrors) < knownErrors.size()) {\n      // NOTE: even if maxErrors wasn't exceeeded, we need to throw an error when we have any errors if we're\n      // a leader that was forwarded to by another node so that the forwarding node knows we encountered some\n      // problems and can aggregate the results\n\n      firstErrTracker.throwFirst();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1a77e5e21cbd575a8240b0e3926164f15295f4e8","date":1544979500,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessor#finish().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessor#finish().mjava","sourceNew":"  @Override\n  public void finish() throws IOException {\n\n    // even if processAdd threw an error, this.finish() is still called and we might have additional\n    // errors from other remote leaders that we need to check for from the finish method of downstream processors\n    // (like DUP)\n\n    try {\n      super.finish();\n    } catch (DistributedUpdateProcessor.DistributedUpdatesAsyncException duae) {\n      firstErrTracker.caught(duae);\n\n\n      // adjust our stats based on each of the distributed errors\n      for (Error error : duae.errors) {\n        // we can't trust the req info from the Error, because multiple original requests might have been\n        // lumped together\n        //\n        // instead we trust the metadata that the TolerantUpdateProcessor running on the remote node added\n        // to the exception when it failed.\n        if ( ! (error.e instanceof SolrException) ) {\n          log.error(\"async update exception is not SolrException, no metadata to process\", error.e);\n          continue;\n        }\n        SolrException remoteErr = (SolrException) error.e;\n        NamedList<String> remoteErrMetadata = remoteErr.getMetadata();\n\n        if (null == remoteErrMetadata) {\n          log.warn(\"remote error has no metadata to aggregate: \" + remoteErr.getMessage(), remoteErr);\n          continue;\n        }\n\n        for (int i = 0; i < remoteErrMetadata.size(); i++) {\n          ToleratedUpdateError err =\n            ToleratedUpdateError.parseMetadataIfToleratedUpdateError(remoteErrMetadata.getName(i),\n                                                                     remoteErrMetadata.getVal(i));\n          if (null == err) {\n            // some metadata unrelated to this update processor\n            continue;\n          }\n\n          if (CmdType.DELQ.equals(err.getType())) {\n            if (knownDBQErrors.contains(err)) {\n              // we've already seen this identical error, probably a dup from another shard\n              continue;\n            } else {\n              knownDBQErrors.add(err);\n            }\n          }\n\n          knownErrors.add(err);\n        }\n      }\n    }\n\n    header.add(\"errors\", ToleratedUpdateError.formatForResponseHeader(knownErrors));\n    // include in response so client knows what effective value was (may have been server side config)\n    header.add(\"maxErrors\", ToleratedUpdateError.getUserFriendlyMaxErrors(maxErrors));\n\n    // annotate any error that might be thrown (or was already thrown)\n    firstErrTracker.annotate(knownErrors);\n\n    // decide if we have hit a situation where we know an error needs to be thrown.\n\n    if ((DistribPhase.TOLEADER.equals(distribPhase) ? 0 : maxErrors) < knownErrors.size()) {\n      // NOTE: even if maxErrors wasn't exceeded, we need to throw an error when we have any errors if we're\n      // a leader that was forwarded to by another node so that the forwarding node knows we encountered some\n      // problems and can aggregate the results\n\n      firstErrTracker.throwFirst();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void finish() throws IOException {\n\n    // even if processAdd threw an error, this.finish() is still called and we might have additional\n    // errors from other remote leaders that we need to check for from the finish method of downstream processors\n    // (like DUP)\n    \n    try {\n      super.finish();\n    } catch (DistributedUpdateProcessor.DistributedUpdatesAsyncException duae) {\n      firstErrTracker.caught(duae);\n\n      \n      // adjust our stats based on each of the distributed errors\n      for (Error error : duae.errors) {\n        // we can't trust the req info from the Error, because multiple original requests might have been\n        // lumped together\n        //\n        // instead we trust the metadata that the TolerantUpdateProcessor running on the remote node added\n        // to the exception when it failed.\n        if ( ! (error.e instanceof SolrException) ) {\n          log.error(\"async update exception is not SolrException, no metadata to process\", error.e);\n          continue;\n        }\n        SolrException remoteErr = (SolrException) error.e;\n        NamedList<String> remoteErrMetadata = remoteErr.getMetadata();\n\n        if (null == remoteErrMetadata) {\n          log.warn(\"remote error has no metadata to aggregate: \" + remoteErr.getMessage(), remoteErr);\n          continue;\n        }\n\n        for (int i = 0; i < remoteErrMetadata.size(); i++) {\n          ToleratedUpdateError err =\n            ToleratedUpdateError.parseMetadataIfToleratedUpdateError(remoteErrMetadata.getName(i),\n                                                                     remoteErrMetadata.getVal(i));\n          if (null == err) {\n            // some metadata unrelated to this update processor\n            continue;\n          }\n\n          if (CmdType.DELQ.equals(err.getType())) {\n            if (knownDBQErrors.contains(err)) {\n              // we've already seen this identical error, probably a dup from another shard\n              continue;\n            } else {\n              knownDBQErrors.add(err);\n            }\n          }\n          \n          knownErrors.add(err);\n        }\n      }\n    }\n\n    header.add(\"errors\", ToleratedUpdateError.formatForResponseHeader(knownErrors));\n    // include in response so client knows what effective value was (may have been server side config)\n    header.add(\"maxErrors\", ToleratedUpdateError.getUserFriendlyMaxErrors(maxErrors));\n\n    // annotate any error that might be thrown (or was already thrown)\n    firstErrTracker.annotate(knownErrors);\n\n    // decide if we have hit a situation where we know an error needs to be thrown.\n    \n    if ((DistribPhase.TOLEADER.equals(distribPhase) ? 0 : maxErrors) < knownErrors.size()) {\n      // NOTE: even if maxErrors wasn't exceeded, we need to throw an error when we have any errors if we're\n      // a leader that was forwarded to by another node so that the forwarding node knows we encountered some\n      // problems and can aggregate the results\n\n      firstErrTracker.throwFirst();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessor#finish().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessor#finish().mjava","sourceNew":"  @Override\n  public void finish() throws IOException {\n\n    // even if processAdd threw an error, this.finish() is still called and we might have additional\n    // errors from other remote leaders that we need to check for from the finish method of downstream processors\n    // (like DUP)\n\n    try {\n      super.finish();\n    } catch (DistributedUpdateProcessor.DistributedUpdatesAsyncException duae) {\n      firstErrTracker.caught(duae);\n\n\n      // adjust our stats based on each of the distributed errors\n      for (Error error : duae.errors) {\n        // we can't trust the req info from the Error, because multiple original requests might have been\n        // lumped together\n        //\n        // instead we trust the metadata that the TolerantUpdateProcessor running on the remote node added\n        // to the exception when it failed.\n        if ( ! (error.e instanceof SolrException) ) {\n          log.error(\"async update exception is not SolrException, no metadata to process\", error.e);\n          continue;\n        }\n        SolrException remoteErr = (SolrException) error.e;\n        NamedList<String> remoteErrMetadata = remoteErr.getMetadata();\n\n        if (null == remoteErrMetadata) {\n          if (log.isWarnEnabled()) {\n            log.warn(\"remote error has no metadata to aggregate: {} {}\", remoteErr.getMessage(), remoteErr);\n          }\n          continue;\n        }\n\n        for (int i = 0; i < remoteErrMetadata.size(); i++) {\n          ToleratedUpdateError err =\n            ToleratedUpdateError.parseMetadataIfToleratedUpdateError(remoteErrMetadata.getName(i),\n                                                                     remoteErrMetadata.getVal(i));\n          if (null == err) {\n            // some metadata unrelated to this update processor\n            continue;\n          }\n\n          if (CmdType.DELQ.equals(err.getType())) {\n            if (knownDBQErrors.contains(err)) {\n              // we've already seen this identical error, probably a dup from another shard\n              continue;\n            } else {\n              knownDBQErrors.add(err);\n            }\n          }\n\n          knownErrors.add(err);\n        }\n      }\n    }\n\n    header.add(\"errors\", ToleratedUpdateError.formatForResponseHeader(knownErrors));\n    // include in response so client knows what effective value was (may have been server side config)\n    header.add(\"maxErrors\", ToleratedUpdateError.getUserFriendlyMaxErrors(maxErrors));\n\n    // annotate any error that might be thrown (or was already thrown)\n    firstErrTracker.annotate(knownErrors);\n\n    // decide if we have hit a situation where we know an error needs to be thrown.\n\n    if ((DistribPhase.TOLEADER.equals(distribPhase) ? 0 : maxErrors) < knownErrors.size()) {\n      // NOTE: even if maxErrors wasn't exceeded, we need to throw an error when we have any errors if we're\n      // a leader that was forwarded to by another node so that the forwarding node knows we encountered some\n      // problems and can aggregate the results\n\n      firstErrTracker.throwFirst();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void finish() throws IOException {\n\n    // even if processAdd threw an error, this.finish() is still called and we might have additional\n    // errors from other remote leaders that we need to check for from the finish method of downstream processors\n    // (like DUP)\n\n    try {\n      super.finish();\n    } catch (DistributedUpdateProcessor.DistributedUpdatesAsyncException duae) {\n      firstErrTracker.caught(duae);\n\n\n      // adjust our stats based on each of the distributed errors\n      for (Error error : duae.errors) {\n        // we can't trust the req info from the Error, because multiple original requests might have been\n        // lumped together\n        //\n        // instead we trust the metadata that the TolerantUpdateProcessor running on the remote node added\n        // to the exception when it failed.\n        if ( ! (error.e instanceof SolrException) ) {\n          log.error(\"async update exception is not SolrException, no metadata to process\", error.e);\n          continue;\n        }\n        SolrException remoteErr = (SolrException) error.e;\n        NamedList<String> remoteErrMetadata = remoteErr.getMetadata();\n\n        if (null == remoteErrMetadata) {\n          log.warn(\"remote error has no metadata to aggregate: \" + remoteErr.getMessage(), remoteErr);\n          continue;\n        }\n\n        for (int i = 0; i < remoteErrMetadata.size(); i++) {\n          ToleratedUpdateError err =\n            ToleratedUpdateError.parseMetadataIfToleratedUpdateError(remoteErrMetadata.getName(i),\n                                                                     remoteErrMetadata.getVal(i));\n          if (null == err) {\n            // some metadata unrelated to this update processor\n            continue;\n          }\n\n          if (CmdType.DELQ.equals(err.getType())) {\n            if (knownDBQErrors.contains(err)) {\n              // we've already seen this identical error, probably a dup from another shard\n              continue;\n            } else {\n              knownDBQErrors.add(err);\n            }\n          }\n\n          knownErrors.add(err);\n        }\n      }\n    }\n\n    header.add(\"errors\", ToleratedUpdateError.formatForResponseHeader(knownErrors));\n    // include in response so client knows what effective value was (may have been server side config)\n    header.add(\"maxErrors\", ToleratedUpdateError.getUserFriendlyMaxErrors(maxErrors));\n\n    // annotate any error that might be thrown (or was already thrown)\n    firstErrTracker.annotate(knownErrors);\n\n    // decide if we have hit a situation where we know an error needs to be thrown.\n\n    if ((DistribPhase.TOLEADER.equals(distribPhase) ? 0 : maxErrors) < knownErrors.size()) {\n      // NOTE: even if maxErrors wasn't exceeded, we need to throw an error when we have any errors if we're\n      // a leader that was forwarded to by another node so that the forwarding node knows we encountered some\n      // problems and can aggregate the results\n\n      firstErrTracker.throwFirst();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessor#finish().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessor#finish().mjava","sourceNew":"  @Override\n  public void finish() throws IOException {\n\n    // even if processAdd threw an error, this.finish() is still called and we might have additional\n    // errors from other remote leaders that we need to check for from the finish method of downstream processors\n    // (like DUP)\n\n    try {\n      super.finish();\n    } catch (DistributedUpdateProcessor.DistributedUpdatesAsyncException duae) {\n      firstErrTracker.caught(duae);\n\n\n      // adjust our stats based on each of the distributed errors\n      for (Error error : duae.errors) {\n        // we can't trust the req info from the Error, because multiple original requests might have been\n        // lumped together\n        //\n        // instead we trust the metadata that the TolerantUpdateProcessor running on the remote node added\n        // to the exception when it failed.\n        if ( ! (error.e instanceof SolrException) ) {\n          log.error(\"async update exception is not SolrException, no metadata to process\", error.e);\n          continue;\n        }\n        SolrException remoteErr = (SolrException) error.e;\n        NamedList<String> remoteErrMetadata = remoteErr.getMetadata();\n\n        if (null == remoteErrMetadata) {\n          log.warn(\"remote error has no metadata to aggregate: {} {}\", remoteErr.getMessage(), remoteErr);\n          continue;\n        }\n\n        for (int i = 0; i < remoteErrMetadata.size(); i++) {\n          ToleratedUpdateError err =\n            ToleratedUpdateError.parseMetadataIfToleratedUpdateError(remoteErrMetadata.getName(i),\n                                                                     remoteErrMetadata.getVal(i));\n          if (null == err) {\n            // some metadata unrelated to this update processor\n            continue;\n          }\n\n          if (CmdType.DELQ.equals(err.getType())) {\n            if (knownDBQErrors.contains(err)) {\n              // we've already seen this identical error, probably a dup from another shard\n              continue;\n            } else {\n              knownDBQErrors.add(err);\n            }\n          }\n\n          knownErrors.add(err);\n        }\n      }\n    }\n\n    header.add(\"errors\", ToleratedUpdateError.formatForResponseHeader(knownErrors));\n    // include in response so client knows what effective value was (may have been server side config)\n    header.add(\"maxErrors\", ToleratedUpdateError.getUserFriendlyMaxErrors(maxErrors));\n\n    // annotate any error that might be thrown (or was already thrown)\n    firstErrTracker.annotate(knownErrors);\n\n    // decide if we have hit a situation where we know an error needs to be thrown.\n\n    if ((DistribPhase.TOLEADER.equals(distribPhase) ? 0 : maxErrors) < knownErrors.size()) {\n      // NOTE: even if maxErrors wasn't exceeded, we need to throw an error when we have any errors if we're\n      // a leader that was forwarded to by another node so that the forwarding node knows we encountered some\n      // problems and can aggregate the results\n\n      firstErrTracker.throwFirst();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void finish() throws IOException {\n\n    // even if processAdd threw an error, this.finish() is still called and we might have additional\n    // errors from other remote leaders that we need to check for from the finish method of downstream processors\n    // (like DUP)\n\n    try {\n      super.finish();\n    } catch (DistributedUpdateProcessor.DistributedUpdatesAsyncException duae) {\n      firstErrTracker.caught(duae);\n\n\n      // adjust our stats based on each of the distributed errors\n      for (Error error : duae.errors) {\n        // we can't trust the req info from the Error, because multiple original requests might have been\n        // lumped together\n        //\n        // instead we trust the metadata that the TolerantUpdateProcessor running on the remote node added\n        // to the exception when it failed.\n        if ( ! (error.e instanceof SolrException) ) {\n          log.error(\"async update exception is not SolrException, no metadata to process\", error.e);\n          continue;\n        }\n        SolrException remoteErr = (SolrException) error.e;\n        NamedList<String> remoteErrMetadata = remoteErr.getMetadata();\n\n        if (null == remoteErrMetadata) {\n          if (log.isWarnEnabled()) {\n            log.warn(\"remote error has no metadata to aggregate: {} {}\", remoteErr.getMessage(), remoteErr);\n          }\n          continue;\n        }\n\n        for (int i = 0; i < remoteErrMetadata.size(); i++) {\n          ToleratedUpdateError err =\n            ToleratedUpdateError.parseMetadataIfToleratedUpdateError(remoteErrMetadata.getName(i),\n                                                                     remoteErrMetadata.getVal(i));\n          if (null == err) {\n            // some metadata unrelated to this update processor\n            continue;\n          }\n\n          if (CmdType.DELQ.equals(err.getType())) {\n            if (knownDBQErrors.contains(err)) {\n              // we've already seen this identical error, probably a dup from another shard\n              continue;\n            } else {\n              knownDBQErrors.add(err);\n            }\n          }\n\n          knownErrors.add(err);\n        }\n      }\n    }\n\n    header.add(\"errors\", ToleratedUpdateError.formatForResponseHeader(knownErrors));\n    // include in response so client knows what effective value was (may have been server side config)\n    header.add(\"maxErrors\", ToleratedUpdateError.getUserFriendlyMaxErrors(maxErrors));\n\n    // annotate any error that might be thrown (or was already thrown)\n    firstErrTracker.annotate(knownErrors);\n\n    // decide if we have hit a situation where we know an error needs to be thrown.\n\n    if ((DistribPhase.TOLEADER.equals(distribPhase) ? 0 : maxErrors) < knownErrors.size()) {\n      // NOTE: even if maxErrors wasn't exceeded, we need to throw an error when we have any errors if we're\n      // a leader that was forwarded to by another node so that the forwarding node knows we encountered some\n      // problems and can aggregate the results\n\n      firstErrTracker.throwFirst();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57c238f5fb83803b49b37b3a1a12224a64d47542","date":1593655679,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessor#finish().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/TolerantUpdateProcessor#finish().mjava","sourceNew":"  @Override\n  public void finish() throws IOException {\n\n    // even if processAdd threw an error, this.finish() is still called and we might have additional\n    // errors from other remote leaders that we need to check for from the finish method of downstream processors\n    // (like DUP)\n\n    try {\n      super.finish();\n    } catch (DistributedUpdateProcessor.DistributedUpdatesAsyncException duae) {\n      firstErrTracker.caught(duae);\n\n\n      // adjust our stats based on each of the distributed errors\n      for (Error error : duae.errors) {\n        // we can't trust the req info from the Error, because multiple original requests might have been\n        // lumped together\n        //\n        // instead we trust the metadata that the TolerantUpdateProcessor running on the remote node added\n        // to the exception when it failed.\n        if ( ! (error.e instanceof SolrException) ) {\n          log.error(\"async update exception is not SolrException, no metadata to process\", error.e);\n          continue;\n        }\n        SolrException remoteErr = (SolrException) error.e;\n        NamedList<String> remoteErrMetadata = remoteErr.getMetadata();\n\n        if (null == remoteErrMetadata) {\n          log.warn(\"remote error has no metadata to aggregate: \", remoteErr);\n          continue;\n        }\n\n        for (int i = 0; i < remoteErrMetadata.size(); i++) {\n          ToleratedUpdateError err =\n            ToleratedUpdateError.parseMetadataIfToleratedUpdateError(remoteErrMetadata.getName(i),\n                                                                     remoteErrMetadata.getVal(i));\n          if (null == err) {\n            // some metadata unrelated to this update processor\n            continue;\n          }\n\n          if (CmdType.DELQ.equals(err.getType())) {\n            if (knownDBQErrors.contains(err)) {\n              // we've already seen this identical error, probably a dup from another shard\n              continue;\n            } else {\n              knownDBQErrors.add(err);\n            }\n          }\n\n          knownErrors.add(err);\n        }\n      }\n    }\n\n    header.add(\"errors\", ToleratedUpdateError.formatForResponseHeader(knownErrors));\n    // include in response so client knows what effective value was (may have been server side config)\n    header.add(\"maxErrors\", ToleratedUpdateError.getUserFriendlyMaxErrors(maxErrors));\n\n    // annotate any error that might be thrown (or was already thrown)\n    firstErrTracker.annotate(knownErrors);\n\n    // decide if we have hit a situation where we know an error needs to be thrown.\n\n    if ((DistribPhase.TOLEADER.equals(distribPhase) ? 0 : maxErrors) < knownErrors.size()) {\n      // NOTE: even if maxErrors wasn't exceeded, we need to throw an error when we have any errors if we're\n      // a leader that was forwarded to by another node so that the forwarding node knows we encountered some\n      // problems and can aggregate the results\n\n      firstErrTracker.throwFirst();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void finish() throws IOException {\n\n    // even if processAdd threw an error, this.finish() is still called and we might have additional\n    // errors from other remote leaders that we need to check for from the finish method of downstream processors\n    // (like DUP)\n\n    try {\n      super.finish();\n    } catch (DistributedUpdateProcessor.DistributedUpdatesAsyncException duae) {\n      firstErrTracker.caught(duae);\n\n\n      // adjust our stats based on each of the distributed errors\n      for (Error error : duae.errors) {\n        // we can't trust the req info from the Error, because multiple original requests might have been\n        // lumped together\n        //\n        // instead we trust the metadata that the TolerantUpdateProcessor running on the remote node added\n        // to the exception when it failed.\n        if ( ! (error.e instanceof SolrException) ) {\n          log.error(\"async update exception is not SolrException, no metadata to process\", error.e);\n          continue;\n        }\n        SolrException remoteErr = (SolrException) error.e;\n        NamedList<String> remoteErrMetadata = remoteErr.getMetadata();\n\n        if (null == remoteErrMetadata) {\n          log.warn(\"remote error has no metadata to aggregate: {} {}\", remoteErr.getMessage(), remoteErr);\n          continue;\n        }\n\n        for (int i = 0; i < remoteErrMetadata.size(); i++) {\n          ToleratedUpdateError err =\n            ToleratedUpdateError.parseMetadataIfToleratedUpdateError(remoteErrMetadata.getName(i),\n                                                                     remoteErrMetadata.getVal(i));\n          if (null == err) {\n            // some metadata unrelated to this update processor\n            continue;\n          }\n\n          if (CmdType.DELQ.equals(err.getType())) {\n            if (knownDBQErrors.contains(err)) {\n              // we've already seen this identical error, probably a dup from another shard\n              continue;\n            } else {\n              knownDBQErrors.add(err);\n            }\n          }\n\n          knownErrors.add(err);\n        }\n      }\n    }\n\n    header.add(\"errors\", ToleratedUpdateError.formatForResponseHeader(knownErrors));\n    // include in response so client knows what effective value was (may have been server side config)\n    header.add(\"maxErrors\", ToleratedUpdateError.getUserFriendlyMaxErrors(maxErrors));\n\n    // annotate any error that might be thrown (or was already thrown)\n    firstErrTracker.annotate(knownErrors);\n\n    // decide if we have hit a situation where we know an error needs to be thrown.\n\n    if ((DistribPhase.TOLEADER.equals(distribPhase) ? 0 : maxErrors) < knownErrors.size()) {\n      // NOTE: even if maxErrors wasn't exceeded, we need to throw an error when we have any errors if we're\n      // a leader that was forwarded to by another node so that the forwarding node knows we encountered some\n      // problems and can aggregate the results\n\n      firstErrTracker.throwFirst();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"740d649f013f07efbeb73ca854f106c60166e7c0":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"57c238f5fb83803b49b37b3a1a12224a64d47542":["575e66bd4b2349209027f6801184da7fc3cba13f"],"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"575e66bd4b2349209027f6801184da7fc3cba13f":["740d649f013f07efbeb73ca854f106c60166e7c0"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef","d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef","0158ced21948b6626f733c1c42c1e18d94449789"],"0158ced21948b6626f733c1c42c1e18d94449789":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef"]},"commit2Childs":{"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["740d649f013f07efbeb73ca854f106c60166e7c0"],"740d649f013f07efbeb73ca854f106c60166e7c0":["575e66bd4b2349209027f6801184da7fc3cba13f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef"],"57c238f5fb83803b49b37b3a1a12224a64d47542":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f57cf082c4d2ee975c6a2034fcf3c13f9514e6ef":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","0158ced21948b6626f733c1c42c1e18d94449789"],"575e66bd4b2349209027f6801184da7fc3cba13f":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["1a77e5e21cbd575a8240b0e3926164f15295f4e8","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"0158ced21948b6626f733c1c42c1e18d94449789":["d470c8182e92b264680e34081b75e70a9f2b3c89"]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}