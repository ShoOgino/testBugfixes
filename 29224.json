{"path":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#doAfterDocument(DocumentsWriterPerThread,boolean).mjava","commits":[{"id":"264935965977b4a9e2f3920420647072c9c49176","date":1586600626,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#doAfterDocument(DocumentsWriterPerThread,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#doAfterDocument(ThreadState,boolean).mjava","sourceNew":"  synchronized DocumentsWriterPerThread doAfterDocument(DocumentsWriterPerThread perThread, boolean isUpdate) {\n    try {\n      commitPerThreadBytes(perThread);\n      if (!perThread.isFlushPending()) {\n        if (isUpdate) {\n          flushPolicy.onUpdate(this, perThread);\n        } else {\n          flushPolicy.onInsert(this, perThread);\n        }\n        if (!perThread.isFlushPending() && perThread.bytesUsed() > hardMaxBytesPerDWPT) {\n          // Safety check to prevent a single DWPT exceeding its RAM limit. This\n          // is super important since we can not address more than 2048 MB per DWPT\n          setFlushPending(perThread);\n        }\n      }\n      return checkout(perThread, false);\n    } finally {\n      boolean stalled = updateStallState();\n      assert assertNumDocsSinceStalled(stalled) && assertMemory();\n    }\n  }\n\n","sourceOld":"  synchronized DocumentsWriterPerThread doAfterDocument(ThreadState perThread, boolean isUpdate) {\n    try {\n      commitPerThreadBytes(perThread);\n      if (!perThread.flushPending) {\n        if (isUpdate) {\n          flushPolicy.onUpdate(this, perThread);\n        } else {\n          flushPolicy.onInsert(this, perThread);\n        }\n        if (!perThread.flushPending && perThread.bytesUsed > hardMaxBytesPerDWPT) {\n          // Safety check to prevent a single DWPT exceeding its RAM limit. This\n          // is super important since we can not address more than 2048 MB per DWPT\n          setFlushPending(perThread);\n        }\n      }\n      return checkout(perThread, false);\n    } finally {\n      boolean stalled = updateStallState();\n      assert assertNumDocsSinceStalled(stalled) && assertMemory();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6926606ec5e0dd8d4ec79166d39a3b4ddb862bf4","date":1599581893,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#doAfterDocument(DocumentsWriterPerThread,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#doAfterDocument(DocumentsWriterPerThread,boolean).mjava","sourceNew":"  synchronized DocumentsWriterPerThread doAfterDocument(DocumentsWriterPerThread perThread, boolean isUpdate) {\n    try {\n      commitPerThreadBytes(perThread);\n      if (!perThread.isFlushPending()) {\n        if (isUpdate) {\n          flushPolicy.onUpdate(this, perThread);\n        } else {\n          flushPolicy.onInsert(this, perThread);\n        }\n        if (!perThread.isFlushPending() && perThread.ramBytesUsed() > hardMaxBytesPerDWPT) {\n          // Safety check to prevent a single DWPT exceeding its RAM limit. This\n          // is super important since we can not address more than 2048 MB per DWPT\n          setFlushPending(perThread);\n        }\n      }\n      return checkout(perThread, false);\n    } finally {\n      boolean stalled = updateStallState();\n      assert assertNumDocsSinceStalled(stalled) && assertMemory();\n    }\n  }\n\n","sourceOld":"  synchronized DocumentsWriterPerThread doAfterDocument(DocumentsWriterPerThread perThread, boolean isUpdate) {\n    try {\n      commitPerThreadBytes(perThread);\n      if (!perThread.isFlushPending()) {\n        if (isUpdate) {\n          flushPolicy.onUpdate(this, perThread);\n        } else {\n          flushPolicy.onInsert(this, perThread);\n        }\n        if (!perThread.isFlushPending() && perThread.bytesUsed() > hardMaxBytesPerDWPT) {\n          // Safety check to prevent a single DWPT exceeding its RAM limit. This\n          // is super important since we can not address more than 2048 MB per DWPT\n          setFlushPending(perThread);\n        }\n      }\n      return checkout(perThread, false);\n    } finally {\n      boolean stalled = updateStallState();\n      assert assertNumDocsSinceStalled(stalled) && assertMemory();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0fb8f59fecc02c4b9a6970b8968a3f4eca60b2d","date":1600933173,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#doAfterDocument(DocumentsWriterPerThread,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl#doAfterDocument(DocumentsWriterPerThread,boolean).mjava","sourceNew":"  DocumentsWriterPerThread doAfterDocument(DocumentsWriterPerThread perThread, boolean isUpdate) {\n    final long delta = perThread.getCommitLastBytesUsedDelta();\n    synchronized (this) {\n      // we need to commit this under lock but calculate it outside of the lock to minimize the time this lock is held\n      // per document. The reason we update this under lock is that we mark DWPTs as pending without acquiring it's\n      // lock in #setFlushPending and this also reads the committed bytes and modifies the flush/activeBytes.\n      // In the future we can clean this up to be more intuitive.\n      perThread.commitLastBytesUsed(delta);\n      try {\n        /*\n         * We need to differentiate here if we are pending since setFlushPending\n         * moves the perThread memory to the flushBytes and we could be set to\n         * pending during a delete\n         */\n        if (perThread.isFlushPending()) {\n          flushBytes += delta;\n          assert updatePeaks(delta);\n        } else {\n          activeBytes += delta;\n          assert updatePeaks(delta);\n          if (isUpdate) {\n            flushPolicy.onUpdate(this, perThread);\n          } else {\n            flushPolicy.onInsert(this, perThread);\n          }\n          if (!perThread.isFlushPending() && perThread.ramBytesUsed() > hardMaxBytesPerDWPT) {\n            // Safety check to prevent a single DWPT exceeding its RAM limit. This\n            // is super important since we can not address more than 2048 MB per DWPT\n            setFlushPending(perThread);\n          }\n        }\n        return checkout(perThread, false);\n      } finally {\n        boolean stalled = updateStallState();\n        assert assertNumDocsSinceStalled(stalled) && assertMemory();\n      }\n    }\n  }\n\n","sourceOld":"  synchronized DocumentsWriterPerThread doAfterDocument(DocumentsWriterPerThread perThread, boolean isUpdate) {\n    try {\n      commitPerThreadBytes(perThread);\n      if (!perThread.isFlushPending()) {\n        if (isUpdate) {\n          flushPolicy.onUpdate(this, perThread);\n        } else {\n          flushPolicy.onInsert(this, perThread);\n        }\n        if (!perThread.isFlushPending() && perThread.ramBytesUsed() > hardMaxBytesPerDWPT) {\n          // Safety check to prevent a single DWPT exceeding its RAM limit. This\n          // is super important since we can not address more than 2048 MB per DWPT\n          setFlushPending(perThread);\n        }\n      }\n      return checkout(perThread, false);\n    } finally {\n      boolean stalled = updateStallState();\n      assert assertNumDocsSinceStalled(stalled) && assertMemory();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6926606ec5e0dd8d4ec79166d39a3b4ddb862bf4":["264935965977b4a9e2f3920420647072c9c49176"],"264935965977b4a9e2f3920420647072c9c49176":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0fb8f59fecc02c4b9a6970b8968a3f4eca60b2d":["6926606ec5e0dd8d4ec79166d39a3b4ddb862bf4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0fb8f59fecc02c4b9a6970b8968a3f4eca60b2d"]},"commit2Childs":{"6926606ec5e0dd8d4ec79166d39a3b4ddb862bf4":["a0fb8f59fecc02c4b9a6970b8968a3f4eca60b2d"],"264935965977b4a9e2f3920420647072c9c49176":["6926606ec5e0dd8d4ec79166d39a3b4ddb862bf4"],"a0fb8f59fecc02c4b9a6970b8968a3f4eca60b2d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["264935965977b4a9e2f3920420647072c9c49176"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}