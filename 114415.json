{"path":"solr/core/src/test/org/apache/solr/schema/TestCloudManagedSchemaConcurrent#verifyWaitForSchemaUpdateToPropagate().mjava","commits":[{"id":"106069d345c14ee5c76f0ea76397b02a656f883c","date":1411998064,"type":0,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestCloudManagedSchemaConcurrent#verifyWaitForSchemaUpdateToPropagate().mjava","pathOld":"/dev/null","sourceNew":"  private void verifyWaitForSchemaUpdateToPropagate() throws Exception {\n    String testCollectionName = \"collection1\";\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Replica shard1Leader = clusterState.getLeader(testCollectionName, \"shard1\");\n    final String coreUrl = (new ZkCoreNodeProps(shard1Leader)).getCoreUrl();\n    assertNotNull(coreUrl);\n\n    RestTestHarness harness = new RestTestHarness(new RESTfulServerProvider() {\n      public String getBaseURL() {\n        return coreUrl.endsWith(\"/\") ? coreUrl.substring(0, coreUrl.length()-1) : coreUrl;\n      }\n    });\n\n    addFieldTypePut(harness, \"fooInt\", 15);\n\n    // go into ZK to get the version of the managed schema after the update\n    SolrZkClient zkClient = cloudClient.getZkStateReader().getZkClient();\n    Stat stat = new Stat();\n    zkClient.getData(\"/configs/conf1/managed-schema\", null, stat, false);\n    final int schemaZkVersion = stat.getVersion();\n\n    // now loop over all replicas and verify each has the same schema version\n    for (Slice slice : clusterState.getActiveSlices(testCollectionName)) {\n      for (Replica replica : slice.getReplicas()) {\n        final String replicaUrl = (new ZkCoreNodeProps(replica)).getCoreUrl();\n        RestTestHarness testHarness = new RestTestHarness(new RESTfulServerProvider() {\n          public String getBaseURL() {\n            return replicaUrl.endsWith(\"/\") ? replicaUrl.substring(0, replicaUrl.length()-1) : replicaUrl;\n          }\n        });\n        testHarness.validateQuery(\"/schema/zkversion?wt=xml\", \"//zkversion=\"+schemaZkVersion);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1596015c8bad249c0b9a52182de1d47e1d56fdde","date":1412350121,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestCloudManagedSchemaConcurrent#verifyWaitForSchemaUpdateToPropagate().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/TestCloudManagedSchemaConcurrent#verifyWaitForSchemaUpdateToPropagate().mjava","sourceNew":"  private void verifyWaitForSchemaUpdateToPropagate() throws Exception {\n    String testCollectionName = \"collection1\";\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Replica shard1Leader = clusterState.getLeader(testCollectionName, \"shard1\");\n    final String coreUrl = (new ZkCoreNodeProps(shard1Leader)).getCoreUrl();\n    assertNotNull(coreUrl);\n\n    RestTestHarness harness = new RestTestHarness(new RESTfulServerProvider() {\n      public String getBaseURL() {\n        return coreUrl.endsWith(\"/\") ? coreUrl.substring(0, coreUrl.length()-1) : coreUrl;\n      }\n    });\n\n    addFieldTypePut(harness, \"fooInt\", 15);\n\n    // go into ZK to get the version of the managed schema after the update\n    SolrZkClient zkClient = cloudClient.getZkStateReader().getZkClient();\n    Stat stat = new Stat();\n    String znodePath = \"/configs/conf1/managed-schema\";\n    byte[] managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int schemaZkVersion = stat.getVersion();\n\n    // now loop over all replicas and verify each has the same schema version\n    Replica randomReplicaNotLeader = null;\n    for (Slice slice : clusterState.getActiveSlices(testCollectionName)) {\n      for (Replica replica : slice.getReplicas()) {\n        validateZkVersion(replica, schemaZkVersion, 0, false);\n\n        // save a random replica to test zk watcher behavior\n        if (randomReplicaNotLeader == null && !replica.getName().equals(shard1Leader.getName()))\n          randomReplicaNotLeader = replica;\n      }\n    }\n    assertNotNull(randomReplicaNotLeader);\n\n    // now update the data and then verify the znode watcher fires correctly\n    // before an after a zk session expiration (see SOLR-6249)\n    zkClient.setData(znodePath, managedSchemaBytes, schemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int updatedSchemaZkVersion = stat.getVersion();\n    assertTrue(updatedSchemaZkVersion > schemaZkVersion);\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 2, true);\n\n    // ok - looks like the watcher fired correctly on the replica\n    // now, expire that replica's zk session and then verify the watcher fires again (after reconnect)\n    JettySolrRunner randomReplicaJetty =\n        getJettyOnPort(getReplicaPort(randomReplicaNotLeader));\n    assertNotNull(randomReplicaJetty);\n    chaosMonkey.expireSession(randomReplicaJetty);\n\n    // update the data again to cause watchers to fire\n    zkClient.setData(znodePath, managedSchemaBytes, updatedSchemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    updatedSchemaZkVersion = stat.getVersion();\n    // give up to 10 secs for the replica to recover after zk session loss and see the update\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 10, true);\n  }\n\n","sourceOld":"  private void verifyWaitForSchemaUpdateToPropagate() throws Exception {\n    String testCollectionName = \"collection1\";\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Replica shard1Leader = clusterState.getLeader(testCollectionName, \"shard1\");\n    final String coreUrl = (new ZkCoreNodeProps(shard1Leader)).getCoreUrl();\n    assertNotNull(coreUrl);\n\n    RestTestHarness harness = new RestTestHarness(new RESTfulServerProvider() {\n      public String getBaseURL() {\n        return coreUrl.endsWith(\"/\") ? coreUrl.substring(0, coreUrl.length()-1) : coreUrl;\n      }\n    });\n\n    addFieldTypePut(harness, \"fooInt\", 15);\n\n    // go into ZK to get the version of the managed schema after the update\n    SolrZkClient zkClient = cloudClient.getZkStateReader().getZkClient();\n    Stat stat = new Stat();\n    zkClient.getData(\"/configs/conf1/managed-schema\", null, stat, false);\n    final int schemaZkVersion = stat.getVersion();\n\n    // now loop over all replicas and verify each has the same schema version\n    for (Slice slice : clusterState.getActiveSlices(testCollectionName)) {\n      for (Replica replica : slice.getReplicas()) {\n        final String replicaUrl = (new ZkCoreNodeProps(replica)).getCoreUrl();\n        RestTestHarness testHarness = new RestTestHarness(new RESTfulServerProvider() {\n          public String getBaseURL() {\n            return replicaUrl.endsWith(\"/\") ? replicaUrl.substring(0, replicaUrl.length()-1) : replicaUrl;\n          }\n        });\n        testHarness.validateQuery(\"/schema/zkversion?wt=xml\", \"//zkversion=\"+schemaZkVersion);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d9a47902d6207303f5ed3e7aaca62ca33433af66","date":1412435312,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestCloudManagedSchemaConcurrent#verifyWaitForSchemaUpdateToPropagate().mjava","pathOld":"/dev/null","sourceNew":"  private void verifyWaitForSchemaUpdateToPropagate() throws Exception {\n    String testCollectionName = \"collection1\";\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Replica shard1Leader = clusterState.getLeader(testCollectionName, \"shard1\");\n    final String coreUrl = (new ZkCoreNodeProps(shard1Leader)).getCoreUrl();\n    assertNotNull(coreUrl);\n\n    RestTestHarness harness = new RestTestHarness(new RESTfulServerProvider() {\n      public String getBaseURL() {\n        return coreUrl.endsWith(\"/\") ? coreUrl.substring(0, coreUrl.length()-1) : coreUrl;\n      }\n    });\n\n    addFieldTypePut(harness, \"fooInt\", 15);\n\n    // go into ZK to get the version of the managed schema after the update\n    SolrZkClient zkClient = cloudClient.getZkStateReader().getZkClient();\n    Stat stat = new Stat();\n    String znodePath = \"/configs/conf1/managed-schema\";\n    byte[] managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int schemaZkVersion = stat.getVersion();\n\n    // now loop over all replicas and verify each has the same schema version\n    Replica randomReplicaNotLeader = null;\n    for (Slice slice : clusterState.getActiveSlices(testCollectionName)) {\n      for (Replica replica : slice.getReplicas()) {\n        validateZkVersion(replica, schemaZkVersion, 0, false);\n\n        // save a random replica to test zk watcher behavior\n        if (randomReplicaNotLeader == null && !replica.getName().equals(shard1Leader.getName()))\n          randomReplicaNotLeader = replica;\n      }\n    }\n    assertNotNull(randomReplicaNotLeader);\n\n    // now update the data and then verify the znode watcher fires correctly\n    // before an after a zk session expiration (see SOLR-6249)\n    zkClient.setData(znodePath, managedSchemaBytes, schemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int updatedSchemaZkVersion = stat.getVersion();\n    assertTrue(updatedSchemaZkVersion > schemaZkVersion);\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 2, true);\n\n    // ok - looks like the watcher fired correctly on the replica\n    // now, expire that replica's zk session and then verify the watcher fires again (after reconnect)\n    JettySolrRunner randomReplicaJetty =\n        getJettyOnPort(getReplicaPort(randomReplicaNotLeader));\n    assertNotNull(randomReplicaJetty);\n    chaosMonkey.expireSession(randomReplicaJetty);\n\n    // update the data again to cause watchers to fire\n    zkClient.setData(znodePath, managedSchemaBytes, updatedSchemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    updatedSchemaZkVersion = stat.getVersion();\n    // give up to 10 secs for the replica to recover after zk session loss and see the update\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 10, true);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6784d0cc613dc1ee97030eaaa5e0754edc22d164","date":1420824784,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestCloudManagedSchemaConcurrent#verifyWaitForSchemaUpdateToPropagate().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/TestCloudManagedSchemaConcurrent#verifyWaitForSchemaUpdateToPropagate().mjava","sourceNew":"  private void verifyWaitForSchemaUpdateToPropagate() throws Exception {\n    String testCollectionName = \"collection1\";\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Replica shard1Leader = clusterState.getLeader(testCollectionName, \"shard1\");\n    final String coreUrl = (new ZkCoreNodeProps(shard1Leader)).getCoreUrl();\n    assertNotNull(coreUrl);\n\n    RestTestHarness harness = new RestTestHarness(new RESTfulServerProvider() {\n      public String getBaseURL() {\n        return coreUrl.endsWith(\"/\") ? coreUrl.substring(0, coreUrl.length()-1) : coreUrl;\n      }\n    });\n    try {\n      addFieldTypePut(harness, \"fooInt\", 15);\n    } finally {\n      harness.close();\n    }\n\n    // go into ZK to get the version of the managed schema after the update\n    SolrZkClient zkClient = cloudClient.getZkStateReader().getZkClient();\n    Stat stat = new Stat();\n    String znodePath = \"/configs/conf1/managed-schema\";\n    byte[] managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int schemaZkVersion = stat.getVersion();\n\n    // now loop over all replicas and verify each has the same schema version\n    Replica randomReplicaNotLeader = null;\n    for (Slice slice : clusterState.getActiveSlices(testCollectionName)) {\n      for (Replica replica : slice.getReplicas()) {\n        validateZkVersion(replica, schemaZkVersion, 0, false);\n\n        // save a random replica to test zk watcher behavior\n        if (randomReplicaNotLeader == null && !replica.getName().equals(shard1Leader.getName()))\n          randomReplicaNotLeader = replica;\n      }\n    }\n    assertNotNull(randomReplicaNotLeader);\n\n    // now update the data and then verify the znode watcher fires correctly\n    // before an after a zk session expiration (see SOLR-6249)\n    zkClient.setData(znodePath, managedSchemaBytes, schemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int updatedSchemaZkVersion = stat.getVersion();\n    assertTrue(updatedSchemaZkVersion > schemaZkVersion);\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 2, true);\n\n    // ok - looks like the watcher fired correctly on the replica\n    // now, expire that replica's zk session and then verify the watcher fires again (after reconnect)\n    JettySolrRunner randomReplicaJetty =\n        getJettyOnPort(getReplicaPort(randomReplicaNotLeader));\n    assertNotNull(randomReplicaJetty);\n    chaosMonkey.expireSession(randomReplicaJetty);\n\n    // update the data again to cause watchers to fire\n    zkClient.setData(znodePath, managedSchemaBytes, updatedSchemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    updatedSchemaZkVersion = stat.getVersion();\n    // give up to 10 secs for the replica to recover after zk session loss and see the update\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 10, true);\n  }\n\n","sourceOld":"  private void verifyWaitForSchemaUpdateToPropagate() throws Exception {\n    String testCollectionName = \"collection1\";\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Replica shard1Leader = clusterState.getLeader(testCollectionName, \"shard1\");\n    final String coreUrl = (new ZkCoreNodeProps(shard1Leader)).getCoreUrl();\n    assertNotNull(coreUrl);\n\n    RestTestHarness harness = new RestTestHarness(new RESTfulServerProvider() {\n      public String getBaseURL() {\n        return coreUrl.endsWith(\"/\") ? coreUrl.substring(0, coreUrl.length()-1) : coreUrl;\n      }\n    });\n\n    addFieldTypePut(harness, \"fooInt\", 15);\n\n    // go into ZK to get the version of the managed schema after the update\n    SolrZkClient zkClient = cloudClient.getZkStateReader().getZkClient();\n    Stat stat = new Stat();\n    String znodePath = \"/configs/conf1/managed-schema\";\n    byte[] managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int schemaZkVersion = stat.getVersion();\n\n    // now loop over all replicas and verify each has the same schema version\n    Replica randomReplicaNotLeader = null;\n    for (Slice slice : clusterState.getActiveSlices(testCollectionName)) {\n      for (Replica replica : slice.getReplicas()) {\n        validateZkVersion(replica, schemaZkVersion, 0, false);\n\n        // save a random replica to test zk watcher behavior\n        if (randomReplicaNotLeader == null && !replica.getName().equals(shard1Leader.getName()))\n          randomReplicaNotLeader = replica;\n      }\n    }\n    assertNotNull(randomReplicaNotLeader);\n\n    // now update the data and then verify the znode watcher fires correctly\n    // before an after a zk session expiration (see SOLR-6249)\n    zkClient.setData(znodePath, managedSchemaBytes, schemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int updatedSchemaZkVersion = stat.getVersion();\n    assertTrue(updatedSchemaZkVersion > schemaZkVersion);\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 2, true);\n\n    // ok - looks like the watcher fired correctly on the replica\n    // now, expire that replica's zk session and then verify the watcher fires again (after reconnect)\n    JettySolrRunner randomReplicaJetty =\n        getJettyOnPort(getReplicaPort(randomReplicaNotLeader));\n    assertNotNull(randomReplicaJetty);\n    chaosMonkey.expireSession(randomReplicaJetty);\n\n    // update the data again to cause watchers to fire\n    zkClient.setData(znodePath, managedSchemaBytes, updatedSchemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    updatedSchemaZkVersion = stat.getVersion();\n    // give up to 10 secs for the replica to recover after zk session loss and see the update\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 10, true);\n  }\n\n","bugFix":["106069d345c14ee5c76f0ea76397b02a656f883c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b04972a589b63fe694313d3868815a20546c4907","date":1460726888,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestCloudManagedSchemaConcurrent#verifyWaitForSchemaUpdateToPropagate().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/TestCloudManagedSchemaConcurrent#verifyWaitForSchemaUpdateToPropagate().mjava","sourceNew":"  private void verifyWaitForSchemaUpdateToPropagate() throws Exception {\n    String testCollectionName = \"collection1\";\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Replica shard1Leader = clusterState.getLeader(testCollectionName, \"shard1\");\n    final String coreUrl = (new ZkCoreNodeProps(shard1Leader)).getCoreUrl();\n    assertNotNull(coreUrl);\n\n    RestTestHarness harness = new RestTestHarness(() -> coreUrl.endsWith(\"/\") ? coreUrl.substring(0, coreUrl.length()-1) : coreUrl);\n    try {\n      addFieldTypePut(harness, \"fooInt\", 15);\n    } finally {\n      harness.close();\n    }\n\n    // go into ZK to get the version of the managed schema after the update\n    SolrZkClient zkClient = cloudClient.getZkStateReader().getZkClient();\n    Stat stat = new Stat();\n    String znodePath = \"/configs/conf1/managed-schema\";\n    byte[] managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int schemaZkVersion = stat.getVersion();\n\n    // now loop over all replicas and verify each has the same schema version\n    Replica randomReplicaNotLeader = null;\n    for (Slice slice : clusterState.getActiveSlices(testCollectionName)) {\n      for (Replica replica : slice.getReplicas()) {\n        validateZkVersion(replica, schemaZkVersion, 0, false);\n\n        // save a random replica to test zk watcher behavior\n        if (randomReplicaNotLeader == null && !replica.getName().equals(shard1Leader.getName()))\n          randomReplicaNotLeader = replica;\n      }\n    }\n    assertNotNull(randomReplicaNotLeader);\n\n    // now update the data and then verify the znode watcher fires correctly\n    // before an after a zk session expiration (see SOLR-6249)\n    zkClient.setData(znodePath, managedSchemaBytes, schemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int updatedSchemaZkVersion = stat.getVersion();\n    assertTrue(updatedSchemaZkVersion > schemaZkVersion);\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 2, true);\n\n    // ok - looks like the watcher fired correctly on the replica\n    // now, expire that replica's zk session and then verify the watcher fires again (after reconnect)\n    JettySolrRunner randomReplicaJetty =\n        getJettyOnPort(getReplicaPort(randomReplicaNotLeader));\n    assertNotNull(randomReplicaJetty);\n    chaosMonkey.expireSession(randomReplicaJetty);\n\n    // update the data again to cause watchers to fire\n    zkClient.setData(znodePath, managedSchemaBytes, updatedSchemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    updatedSchemaZkVersion = stat.getVersion();\n    // give up to 10 secs for the replica to recover after zk session loss and see the update\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 10, true);\n  }\n\n","sourceOld":"  private void verifyWaitForSchemaUpdateToPropagate() throws Exception {\n    String testCollectionName = \"collection1\";\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Replica shard1Leader = clusterState.getLeader(testCollectionName, \"shard1\");\n    final String coreUrl = (new ZkCoreNodeProps(shard1Leader)).getCoreUrl();\n    assertNotNull(coreUrl);\n\n    RestTestHarness harness = new RestTestHarness(new RESTfulServerProvider() {\n      public String getBaseURL() {\n        return coreUrl.endsWith(\"/\") ? coreUrl.substring(0, coreUrl.length()-1) : coreUrl;\n      }\n    });\n    try {\n      addFieldTypePut(harness, \"fooInt\", 15);\n    } finally {\n      harness.close();\n    }\n\n    // go into ZK to get the version of the managed schema after the update\n    SolrZkClient zkClient = cloudClient.getZkStateReader().getZkClient();\n    Stat stat = new Stat();\n    String znodePath = \"/configs/conf1/managed-schema\";\n    byte[] managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int schemaZkVersion = stat.getVersion();\n\n    // now loop over all replicas and verify each has the same schema version\n    Replica randomReplicaNotLeader = null;\n    for (Slice slice : clusterState.getActiveSlices(testCollectionName)) {\n      for (Replica replica : slice.getReplicas()) {\n        validateZkVersion(replica, schemaZkVersion, 0, false);\n\n        // save a random replica to test zk watcher behavior\n        if (randomReplicaNotLeader == null && !replica.getName().equals(shard1Leader.getName()))\n          randomReplicaNotLeader = replica;\n      }\n    }\n    assertNotNull(randomReplicaNotLeader);\n\n    // now update the data and then verify the znode watcher fires correctly\n    // before an after a zk session expiration (see SOLR-6249)\n    zkClient.setData(znodePath, managedSchemaBytes, schemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int updatedSchemaZkVersion = stat.getVersion();\n    assertTrue(updatedSchemaZkVersion > schemaZkVersion);\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 2, true);\n\n    // ok - looks like the watcher fired correctly on the replica\n    // now, expire that replica's zk session and then verify the watcher fires again (after reconnect)\n    JettySolrRunner randomReplicaJetty =\n        getJettyOnPort(getReplicaPort(randomReplicaNotLeader));\n    assertNotNull(randomReplicaJetty);\n    chaosMonkey.expireSession(randomReplicaJetty);\n\n    // update the data again to cause watchers to fire\n    zkClient.setData(znodePath, managedSchemaBytes, updatedSchemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    updatedSchemaZkVersion = stat.getVersion();\n    // give up to 10 secs for the replica to recover after zk session loss and see the update\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 10, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73457c9372b4f2f962ca916788a5fe9e1f644a9f","date":1460794059,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestCloudManagedSchemaConcurrent#verifyWaitForSchemaUpdateToPropagate().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/TestCloudManagedSchemaConcurrent#verifyWaitForSchemaUpdateToPropagate().mjava","sourceNew":"  private void verifyWaitForSchemaUpdateToPropagate() throws Exception {\n    String testCollectionName = \"collection1\";\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Replica shard1Leader = clusterState.getLeader(testCollectionName, \"shard1\");\n    final String coreUrl = (new ZkCoreNodeProps(shard1Leader)).getCoreUrl();\n    assertNotNull(coreUrl);\n\n    RestTestHarness harness = new RestTestHarness(() -> coreUrl.endsWith(\"/\") ? coreUrl.substring(0, coreUrl.length()-1) : coreUrl);\n    try {\n      addFieldTypePut(harness, \"fooInt\", 15);\n    } finally {\n      harness.close();\n    }\n\n    // go into ZK to get the version of the managed schema after the update\n    SolrZkClient zkClient = cloudClient.getZkStateReader().getZkClient();\n    Stat stat = new Stat();\n    String znodePath = \"/configs/conf1/managed-schema\";\n    byte[] managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int schemaZkVersion = stat.getVersion();\n\n    // now loop over all replicas and verify each has the same schema version\n    Replica randomReplicaNotLeader = null;\n    for (Slice slice : clusterState.getActiveSlices(testCollectionName)) {\n      for (Replica replica : slice.getReplicas()) {\n        validateZkVersion(replica, schemaZkVersion, 0, false);\n\n        // save a random replica to test zk watcher behavior\n        if (randomReplicaNotLeader == null && !replica.getName().equals(shard1Leader.getName()))\n          randomReplicaNotLeader = replica;\n      }\n    }\n    assertNotNull(randomReplicaNotLeader);\n\n    // now update the data and then verify the znode watcher fires correctly\n    // before an after a zk session expiration (see SOLR-6249)\n    zkClient.setData(znodePath, managedSchemaBytes, schemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int updatedSchemaZkVersion = stat.getVersion();\n    assertTrue(updatedSchemaZkVersion > schemaZkVersion);\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 2, true);\n\n    // ok - looks like the watcher fired correctly on the replica\n    // now, expire that replica's zk session and then verify the watcher fires again (after reconnect)\n    JettySolrRunner randomReplicaJetty =\n        getJettyOnPort(getReplicaPort(randomReplicaNotLeader));\n    assertNotNull(randomReplicaJetty);\n    chaosMonkey.expireSession(randomReplicaJetty);\n\n    // update the data again to cause watchers to fire\n    zkClient.setData(znodePath, managedSchemaBytes, updatedSchemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    updatedSchemaZkVersion = stat.getVersion();\n    // give up to 10 secs for the replica to recover after zk session loss and see the update\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 10, true);\n  }\n\n","sourceOld":"  private void verifyWaitForSchemaUpdateToPropagate() throws Exception {\n    String testCollectionName = \"collection1\";\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Replica shard1Leader = clusterState.getLeader(testCollectionName, \"shard1\");\n    final String coreUrl = (new ZkCoreNodeProps(shard1Leader)).getCoreUrl();\n    assertNotNull(coreUrl);\n\n    RestTestHarness harness = new RestTestHarness(new RESTfulServerProvider() {\n      public String getBaseURL() {\n        return coreUrl.endsWith(\"/\") ? coreUrl.substring(0, coreUrl.length()-1) : coreUrl;\n      }\n    });\n    try {\n      addFieldTypePut(harness, \"fooInt\", 15);\n    } finally {\n      harness.close();\n    }\n\n    // go into ZK to get the version of the managed schema after the update\n    SolrZkClient zkClient = cloudClient.getZkStateReader().getZkClient();\n    Stat stat = new Stat();\n    String znodePath = \"/configs/conf1/managed-schema\";\n    byte[] managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int schemaZkVersion = stat.getVersion();\n\n    // now loop over all replicas and verify each has the same schema version\n    Replica randomReplicaNotLeader = null;\n    for (Slice slice : clusterState.getActiveSlices(testCollectionName)) {\n      for (Replica replica : slice.getReplicas()) {\n        validateZkVersion(replica, schemaZkVersion, 0, false);\n\n        // save a random replica to test zk watcher behavior\n        if (randomReplicaNotLeader == null && !replica.getName().equals(shard1Leader.getName()))\n          randomReplicaNotLeader = replica;\n      }\n    }\n    assertNotNull(randomReplicaNotLeader);\n\n    // now update the data and then verify the znode watcher fires correctly\n    // before an after a zk session expiration (see SOLR-6249)\n    zkClient.setData(znodePath, managedSchemaBytes, schemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int updatedSchemaZkVersion = stat.getVersion();\n    assertTrue(updatedSchemaZkVersion > schemaZkVersion);\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 2, true);\n\n    // ok - looks like the watcher fired correctly on the replica\n    // now, expire that replica's zk session and then verify the watcher fires again (after reconnect)\n    JettySolrRunner randomReplicaJetty =\n        getJettyOnPort(getReplicaPort(randomReplicaNotLeader));\n    assertNotNull(randomReplicaJetty);\n    chaosMonkey.expireSession(randomReplicaJetty);\n\n    // update the data again to cause watchers to fire\n    zkClient.setData(znodePath, managedSchemaBytes, updatedSchemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    updatedSchemaZkVersion = stat.getVersion();\n    // give up to 10 secs for the replica to recover after zk session loss and see the update\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 10, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c3a8c645ec119d18a65174f4cbb1c927792ff814","date":1500897120,"type":4,"author":"Noble Paul","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/schema/TestCloudManagedSchemaConcurrent#verifyWaitForSchemaUpdateToPropagate().mjava","sourceNew":null,"sourceOld":"  private void verifyWaitForSchemaUpdateToPropagate() throws Exception {\n    String testCollectionName = \"collection1\";\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Replica shard1Leader = clusterState.getLeader(testCollectionName, \"shard1\");\n    final String coreUrl = (new ZkCoreNodeProps(shard1Leader)).getCoreUrl();\n    assertNotNull(coreUrl);\n\n    RestTestHarness harness = new RestTestHarness(() -> coreUrl.endsWith(\"/\") ? coreUrl.substring(0, coreUrl.length()-1) : coreUrl);\n    try {\n      addFieldTypePut(harness, \"fooInt\", 15);\n    } finally {\n      harness.close();\n    }\n\n    // go into ZK to get the version of the managed schema after the update\n    SolrZkClient zkClient = cloudClient.getZkStateReader().getZkClient();\n    Stat stat = new Stat();\n    String znodePath = \"/configs/conf1/managed-schema\";\n    byte[] managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int schemaZkVersion = stat.getVersion();\n\n    // now loop over all replicas and verify each has the same schema version\n    Replica randomReplicaNotLeader = null;\n    for (Slice slice : clusterState.getActiveSlices(testCollectionName)) {\n      for (Replica replica : slice.getReplicas()) {\n        validateZkVersion(replica, schemaZkVersion, 0, false);\n\n        // save a random replica to test zk watcher behavior\n        if (randomReplicaNotLeader == null && !replica.getName().equals(shard1Leader.getName()))\n          randomReplicaNotLeader = replica;\n      }\n    }\n    assertNotNull(randomReplicaNotLeader);\n\n    // now update the data and then verify the znode watcher fires correctly\n    // before an after a zk session expiration (see SOLR-6249)\n    zkClient.setData(znodePath, managedSchemaBytes, schemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int updatedSchemaZkVersion = stat.getVersion();\n    assertTrue(updatedSchemaZkVersion > schemaZkVersion);\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 2, true);\n\n    // ok - looks like the watcher fired correctly on the replica\n    // now, expire that replica's zk session and then verify the watcher fires again (after reconnect)\n    JettySolrRunner randomReplicaJetty =\n        getJettyOnPort(getReplicaPort(randomReplicaNotLeader));\n    assertNotNull(randomReplicaJetty);\n    chaosMonkey.expireSession(randomReplicaJetty);\n\n    // update the data again to cause watchers to fire\n    zkClient.setData(znodePath, managedSchemaBytes, updatedSchemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    updatedSchemaZkVersion = stat.getVersion();\n    // give up to 10 secs for the replica to recover after zk session loss and see the update\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 10, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"936cdd5882761db3b844afd6f84ab81cbb011a75","date":1500973524,"type":4,"author":"Cao Manh Dat","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/schema/TestCloudManagedSchemaConcurrent#verifyWaitForSchemaUpdateToPropagate().mjava","sourceNew":null,"sourceOld":"  private void verifyWaitForSchemaUpdateToPropagate() throws Exception {\n    String testCollectionName = \"collection1\";\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Replica shard1Leader = clusterState.getLeader(testCollectionName, \"shard1\");\n    final String coreUrl = (new ZkCoreNodeProps(shard1Leader)).getCoreUrl();\n    assertNotNull(coreUrl);\n\n    RestTestHarness harness = new RestTestHarness(() -> coreUrl.endsWith(\"/\") ? coreUrl.substring(0, coreUrl.length()-1) : coreUrl);\n    try {\n      addFieldTypePut(harness, \"fooInt\", 15);\n    } finally {\n      harness.close();\n    }\n\n    // go into ZK to get the version of the managed schema after the update\n    SolrZkClient zkClient = cloudClient.getZkStateReader().getZkClient();\n    Stat stat = new Stat();\n    String znodePath = \"/configs/conf1/managed-schema\";\n    byte[] managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int schemaZkVersion = stat.getVersion();\n\n    // now loop over all replicas and verify each has the same schema version\n    Replica randomReplicaNotLeader = null;\n    for (Slice slice : clusterState.getActiveSlices(testCollectionName)) {\n      for (Replica replica : slice.getReplicas()) {\n        validateZkVersion(replica, schemaZkVersion, 0, false);\n\n        // save a random replica to test zk watcher behavior\n        if (randomReplicaNotLeader == null && !replica.getName().equals(shard1Leader.getName()))\n          randomReplicaNotLeader = replica;\n      }\n    }\n    assertNotNull(randomReplicaNotLeader);\n\n    // now update the data and then verify the znode watcher fires correctly\n    // before an after a zk session expiration (see SOLR-6249)\n    zkClient.setData(znodePath, managedSchemaBytes, schemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int updatedSchemaZkVersion = stat.getVersion();\n    assertTrue(updatedSchemaZkVersion > schemaZkVersion);\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 2, true);\n\n    // ok - looks like the watcher fired correctly on the replica\n    // now, expire that replica's zk session and then verify the watcher fires again (after reconnect)\n    JettySolrRunner randomReplicaJetty =\n        getJettyOnPort(getReplicaPort(randomReplicaNotLeader));\n    assertNotNull(randomReplicaJetty);\n    chaosMonkey.expireSession(randomReplicaJetty);\n\n    // update the data again to cause watchers to fire\n    zkClient.setData(znodePath, managedSchemaBytes, updatedSchemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    updatedSchemaZkVersion = stat.getVersion();\n    // give up to 10 secs for the replica to recover after zk session loss and see the update\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 10, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a52341299179de5479672f7cf518bf4b173f34b3","date":1501079746,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/schema/TestCloudManagedSchemaConcurrent#verifyWaitForSchemaUpdateToPropagate().mjava","sourceNew":null,"sourceOld":"  private void verifyWaitForSchemaUpdateToPropagate() throws Exception {\n    String testCollectionName = \"collection1\";\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Replica shard1Leader = clusterState.getLeader(testCollectionName, \"shard1\");\n    final String coreUrl = (new ZkCoreNodeProps(shard1Leader)).getCoreUrl();\n    assertNotNull(coreUrl);\n\n    RestTestHarness harness = new RestTestHarness(() -> coreUrl.endsWith(\"/\") ? coreUrl.substring(0, coreUrl.length()-1) : coreUrl);\n    try {\n      addFieldTypePut(harness, \"fooInt\", 15);\n    } finally {\n      harness.close();\n    }\n\n    // go into ZK to get the version of the managed schema after the update\n    SolrZkClient zkClient = cloudClient.getZkStateReader().getZkClient();\n    Stat stat = new Stat();\n    String znodePath = \"/configs/conf1/managed-schema\";\n    byte[] managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int schemaZkVersion = stat.getVersion();\n\n    // now loop over all replicas and verify each has the same schema version\n    Replica randomReplicaNotLeader = null;\n    for (Slice slice : clusterState.getActiveSlices(testCollectionName)) {\n      for (Replica replica : slice.getReplicas()) {\n        validateZkVersion(replica, schemaZkVersion, 0, false);\n\n        // save a random replica to test zk watcher behavior\n        if (randomReplicaNotLeader == null && !replica.getName().equals(shard1Leader.getName()))\n          randomReplicaNotLeader = replica;\n      }\n    }\n    assertNotNull(randomReplicaNotLeader);\n\n    // now update the data and then verify the znode watcher fires correctly\n    // before an after a zk session expiration (see SOLR-6249)\n    zkClient.setData(znodePath, managedSchemaBytes, schemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int updatedSchemaZkVersion = stat.getVersion();\n    assertTrue(updatedSchemaZkVersion > schemaZkVersion);\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 2, true);\n\n    // ok - looks like the watcher fired correctly on the replica\n    // now, expire that replica's zk session and then verify the watcher fires again (after reconnect)\n    JettySolrRunner randomReplicaJetty =\n        getJettyOnPort(getReplicaPort(randomReplicaNotLeader));\n    assertNotNull(randomReplicaJetty);\n    chaosMonkey.expireSession(randomReplicaJetty);\n\n    // update the data again to cause watchers to fire\n    zkClient.setData(znodePath, managedSchemaBytes, updatedSchemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    updatedSchemaZkVersion = stat.getVersion();\n    // give up to 10 secs for the replica to recover after zk session loss and see the update\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 10, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"344b0840364d990b29b97467bfcc766ff8325d11","date":1501574100,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestCloudManagedSchemaConcurrent#verifyWaitForSchemaUpdateToPropagate().mjava","pathOld":"/dev/null","sourceNew":"  private void verifyWaitForSchemaUpdateToPropagate() throws Exception {\n    String testCollectionName = \"collection1\";\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Replica shard1Leader = clusterState.getCollection(testCollectionName).getLeader(\"shard1\");\n    final String coreUrl = (new ZkCoreNodeProps(shard1Leader)).getCoreUrl();\n    assertNotNull(coreUrl);\n\n    RestTestHarness harness = new RestTestHarness(() -> coreUrl.endsWith(\"/\") ? coreUrl.substring(0, coreUrl.length()-1) : coreUrl);\n    try {\n      addFieldTypePut(harness, \"fooInt\", 15);\n    } finally {\n      harness.close();\n    }\n\n    // go into ZK to get the version of the managed schema after the update\n    SolrZkClient zkClient = cloudClient.getZkStateReader().getZkClient();\n    Stat stat = new Stat();\n    String znodePath = \"/configs/conf1/managed-schema\";\n    byte[] managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int schemaZkVersion = stat.getVersion();\n\n    // now loop over all replicas and verify each has the same schema version\n    Replica randomReplicaNotLeader = null;\n    for (Slice slice : clusterState.getCollection(testCollectionName).getActiveSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        validateZkVersion(replica, schemaZkVersion, 0, false);\n\n        // save a random replica to test zk watcher behavior\n        if (randomReplicaNotLeader == null && !replica.getName().equals(shard1Leader.getName()))\n          randomReplicaNotLeader = replica;\n      }\n    }\n    assertNotNull(randomReplicaNotLeader);\n\n    // now update the data and then verify the znode watcher fires correctly\n    // before an after a zk session expiration (see SOLR-6249)\n    zkClient.setData(znodePath, managedSchemaBytes, schemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int updatedSchemaZkVersion = stat.getVersion();\n    assertTrue(updatedSchemaZkVersion > schemaZkVersion);\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 2, true);\n\n    // ok - looks like the watcher fired correctly on the replica\n    // now, expire that replica's zk session and then verify the watcher fires again (after reconnect)\n    JettySolrRunner randomReplicaJetty =\n        getJettyOnPort(getReplicaPort(randomReplicaNotLeader));\n    assertNotNull(randomReplicaJetty);\n    chaosMonkey.expireSession(randomReplicaJetty);\n\n    // update the data again to cause watchers to fire\n    zkClient.setData(znodePath, managedSchemaBytes, updatedSchemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    updatedSchemaZkVersion = stat.getVersion();\n    // give up to 10 secs for the replica to recover after zk session loss and see the update\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 10, true);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c717efc76ccf2ea435c52fa36a4774056fe8b4d4","date":1501575440,"type":4,"author":"Cao Manh Dat","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/schema/TestCloudManagedSchemaConcurrent#verifyWaitForSchemaUpdateToPropagate().mjava","sourceNew":null,"sourceOld":"  private void verifyWaitForSchemaUpdateToPropagate() throws Exception {\n    String testCollectionName = \"collection1\";\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Replica shard1Leader = clusterState.getCollection(testCollectionName).getLeader(\"shard1\");\n    final String coreUrl = (new ZkCoreNodeProps(shard1Leader)).getCoreUrl();\n    assertNotNull(coreUrl);\n\n    RestTestHarness harness = new RestTestHarness(() -> coreUrl.endsWith(\"/\") ? coreUrl.substring(0, coreUrl.length()-1) : coreUrl);\n    try {\n      addFieldTypePut(harness, \"fooInt\", 15);\n    } finally {\n      harness.close();\n    }\n\n    // go into ZK to get the version of the managed schema after the update\n    SolrZkClient zkClient = cloudClient.getZkStateReader().getZkClient();\n    Stat stat = new Stat();\n    String znodePath = \"/configs/conf1/managed-schema\";\n    byte[] managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int schemaZkVersion = stat.getVersion();\n\n    // now loop over all replicas and verify each has the same schema version\n    Replica randomReplicaNotLeader = null;\n    for (Slice slice : clusterState.getCollection(testCollectionName).getActiveSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        validateZkVersion(replica, schemaZkVersion, 0, false);\n\n        // save a random replica to test zk watcher behavior\n        if (randomReplicaNotLeader == null && !replica.getName().equals(shard1Leader.getName()))\n          randomReplicaNotLeader = replica;\n      }\n    }\n    assertNotNull(randomReplicaNotLeader);\n\n    // now update the data and then verify the znode watcher fires correctly\n    // before an after a zk session expiration (see SOLR-6249)\n    zkClient.setData(znodePath, managedSchemaBytes, schemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    int updatedSchemaZkVersion = stat.getVersion();\n    assertTrue(updatedSchemaZkVersion > schemaZkVersion);\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 2, true);\n\n    // ok - looks like the watcher fired correctly on the replica\n    // now, expire that replica's zk session and then verify the watcher fires again (after reconnect)\n    JettySolrRunner randomReplicaJetty =\n        getJettyOnPort(getReplicaPort(randomReplicaNotLeader));\n    assertNotNull(randomReplicaJetty);\n    chaosMonkey.expireSession(randomReplicaJetty);\n\n    // update the data again to cause watchers to fire\n    zkClient.setData(znodePath, managedSchemaBytes, updatedSchemaZkVersion, false);\n    stat = new Stat();\n    managedSchemaBytes = zkClient.getData(znodePath, null, stat, false);\n    updatedSchemaZkVersion = stat.getVersion();\n    // give up to 10 secs for the replica to recover after zk session loss and see the update\n    validateZkVersion(randomReplicaNotLeader, updatedSchemaZkVersion, 10, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b04972a589b63fe694313d3868815a20546c4907":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"c717efc76ccf2ea435c52fa36a4774056fe8b4d4":["344b0840364d990b29b97467bfcc766ff8325d11"],"344b0840364d990b29b97467bfcc766ff8325d11":["a52341299179de5479672f7cf518bf4b173f34b3"],"936cdd5882761db3b844afd6f84ab81cbb011a75":["73457c9372b4f2f962ca916788a5fe9e1f644a9f","c3a8c645ec119d18a65174f4cbb1c927792ff814"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1596015c8bad249c0b9a52182de1d47e1d56fdde"],"a52341299179de5479672f7cf518bf4b173f34b3":["73457c9372b4f2f962ca916788a5fe9e1f644a9f","c3a8c645ec119d18a65174f4cbb1c927792ff814"],"1596015c8bad249c0b9a52182de1d47e1d56fdde":["106069d345c14ee5c76f0ea76397b02a656f883c"],"c3a8c645ec119d18a65174f4cbb1c927792ff814":["73457c9372b4f2f962ca916788a5fe9e1f644a9f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"106069d345c14ee5c76f0ea76397b02a656f883c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6784d0cc613dc1ee97030eaaa5e0754edc22d164":["1596015c8bad249c0b9a52182de1d47e1d56fdde"],"73457c9372b4f2f962ca916788a5fe9e1f644a9f":["6784d0cc613dc1ee97030eaaa5e0754edc22d164","b04972a589b63fe694313d3868815a20546c4907"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c717efc76ccf2ea435c52fa36a4774056fe8b4d4"]},"commit2Childs":{"b04972a589b63fe694313d3868815a20546c4907":["73457c9372b4f2f962ca916788a5fe9e1f644a9f"],"c717efc76ccf2ea435c52fa36a4774056fe8b4d4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"344b0840364d990b29b97467bfcc766ff8325d11":["c717efc76ccf2ea435c52fa36a4774056fe8b4d4"],"936cdd5882761db3b844afd6f84ab81cbb011a75":[],"d9a47902d6207303f5ed3e7aaca62ca33433af66":[],"a52341299179de5479672f7cf518bf4b173f34b3":["344b0840364d990b29b97467bfcc766ff8325d11"],"1596015c8bad249c0b9a52182de1d47e1d56fdde":["d9a47902d6207303f5ed3e7aaca62ca33433af66","6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"c3a8c645ec119d18a65174f4cbb1c927792ff814":["936cdd5882761db3b844afd6f84ab81cbb011a75","a52341299179de5479672f7cf518bf4b173f34b3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d9a47902d6207303f5ed3e7aaca62ca33433af66","106069d345c14ee5c76f0ea76397b02a656f883c"],"106069d345c14ee5c76f0ea76397b02a656f883c":["1596015c8bad249c0b9a52182de1d47e1d56fdde"],"6784d0cc613dc1ee97030eaaa5e0754edc22d164":["b04972a589b63fe694313d3868815a20546c4907","73457c9372b4f2f962ca916788a5fe9e1f644a9f"],"73457c9372b4f2f962ca916788a5fe9e1f644a9f":["936cdd5882761db3b844afd6f84ab81cbb011a75","a52341299179de5479672f7cf518bf4b173f34b3","c3a8c645ec119d18a65174f4cbb1c927792ff814"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["936cdd5882761db3b844afd6f84ab81cbb011a75","d9a47902d6207303f5ed3e7aaca62ca33433af66","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}