{"path":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","commits":[{"id":"b64a4420c88dd81303e7f7959057baf9f3b45f94","date":1346077333,"type":1,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private FieldCache.DocTerms terms;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            BytesRef joinValue = terms.getTerm(doc, spare);\n            if (joinValue == null) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, 0);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private DocTermOrds docTermOrds;\n            private TermsEnum docTermsEnum;\n            private DocTermOrds.TermOrdsIterator reuse;\n            private int docBase;\n\n            public void collect(int doc) throws IOException {\n              if (docTermOrds.isEmpty()) {\n                return;\n              }\n\n              reuse = docTermOrds.lookup(doc, reuse);\n              int[] buffer = new int[5];\n\n              int chunk;\n              do {\n                chunk = reuse.read(buffer);\n                if (chunk == 0) {\n                  return;\n                }\n\n                for (int idx = 0; idx < chunk; idx++) {\n                  int key = buffer[idx];\n                  docTermsEnum.seekExact((long) key);\n                  JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                  if (joinScore == null) {\n                    continue;\n                  }\n                  Integer basedDoc = docBase + doc;\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(basedDoc)) {\n                    docToJoinScore.put(basedDoc, joinScore);\n                  }\n                }\n              } while (chunk >= buffer.length);\n            }\n\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n              docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n              reuse = null;\n            }\n\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private FieldCache.DocTerms terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) {\n            JoinScore joinScore = joinValueToJoinScores.get(terms.getTerm(doc, spare));\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private FieldCache.DocTerms terms;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            BytesRef joinValue = terms.getTerm(doc, spare);\n            if (joinValue == null) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n          private int docBase;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) {}\n        });\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private FieldCache.DocTerms terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) {\n            JoinScore joinScore = joinValueToJoinScores.get(terms.getTerm(doc, spare));\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private FieldCache.DocTerms terms;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            BytesRef joinValue = terms.getTerm(doc, spare);\n            if (joinValue == null) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, 0);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private DocTermOrds docTermOrds;\n            private TermsEnum docTermsEnum;\n            private DocTermOrds.TermOrdsIterator reuse;\n            private int docBase;\n\n            public void collect(int doc) throws IOException {\n              if (docTermOrds.isEmpty()) {\n                return;\n              }\n\n              reuse = docTermOrds.lookup(doc, reuse);\n              int[] buffer = new int[5];\n\n              int chunk;\n              do {\n                chunk = reuse.read(buffer);\n                if (chunk == 0) {\n                  return;\n                }\n\n                for (int idx = 0; idx < chunk; idx++) {\n                  int key = buffer[idx];\n                  docTermsEnum.seekExact((long) key);\n                  JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                  if (joinScore == null) {\n                    continue;\n                  }\n                  Integer basedDoc = docBase + doc;\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(basedDoc)) {\n                    docToJoinScore.put(basedDoc, joinScore);\n                  }\n                }\n              } while (chunk >= buffer.length);\n            }\n\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n              docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n              reuse = null;\n            }\n\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private FieldCache.DocTerms terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) {\n            JoinScore joinScore = joinValueToJoinScores.get(terms.getTerm(doc, spare));\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2dd9934a49477c83301120ba51827d91eb3606d5","date":1353767072,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.bytes == BinaryDocValues.MISSING) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, 0);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private DocTermOrds docTermOrds;\n            private TermsEnum docTermsEnum;\n            private DocTermOrds.TermOrdsIterator reuse;\n            private int docBase;\n\n            public void collect(int doc) throws IOException {\n              if (docTermOrds.isEmpty()) {\n                return;\n              }\n\n              reuse = docTermOrds.lookup(doc, reuse);\n              int[] buffer = new int[5];\n\n              int chunk;\n              do {\n                chunk = reuse.read(buffer);\n                if (chunk == 0) {\n                  return;\n                }\n\n                for (int idx = 0; idx < chunk; idx++) {\n                  int key = buffer[idx];\n                  docTermsEnum.seekExact((long) key);\n                  JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                  if (joinScore == null) {\n                    continue;\n                  }\n                  Integer basedDoc = docBase + doc;\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(basedDoc)) {\n                    docToJoinScore.put(basedDoc, joinScore);\n                  }\n                }\n              } while (chunk >= buffer.length);\n            }\n\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n              docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n              reuse = null;\n            }\n\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private FieldCache.DocTerms terms;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            BytesRef joinValue = terms.getTerm(doc, spare);\n            if (joinValue == null) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, 0);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private DocTermOrds docTermOrds;\n            private TermsEnum docTermsEnum;\n            private DocTermOrds.TermOrdsIterator reuse;\n            private int docBase;\n\n            public void collect(int doc) throws IOException {\n              if (docTermOrds.isEmpty()) {\n                return;\n              }\n\n              reuse = docTermOrds.lookup(doc, reuse);\n              int[] buffer = new int[5];\n\n              int chunk;\n              do {\n                chunk = reuse.read(buffer);\n                if (chunk == 0) {\n                  return;\n                }\n\n                for (int idx = 0; idx < chunk; idx++) {\n                  int key = buffer[idx];\n                  docTermsEnum.seekExact((long) key);\n                  JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                  if (joinScore == null) {\n                    continue;\n                  }\n                  Integer basedDoc = docBase + doc;\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(basedDoc)) {\n                    docToJoinScore.put(basedDoc, joinScore);\n                  }\n                }\n              } while (chunk >= buffer.length);\n            }\n\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n              docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n              reuse = null;\n            }\n\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private FieldCache.DocTerms terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) {\n            JoinScore joinScore = joinValueToJoinScores.get(terms.getTerm(doc, spare));\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":["87d6f9603307ae2ad642fb01deedf031320fd0c3","87d6f9603307ae2ad642fb01deedf031320fd0c3","87d6f9603307ae2ad642fb01deedf031320fd0c3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15250ca94ba8ab3bcdd476daf6bf3f3febb92640","date":1355200097,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private FieldCache.DocTerms terms;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            BytesRef joinValue = terms.getTerm(doc, spare);\n            if (joinValue == null) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private DocTermOrds docTermOrds;\n            private TermsEnum docTermsEnum;\n            private DocTermOrds.TermOrdsIterator reuse;\n            private int docBase;\n\n            public void collect(int doc) throws IOException {\n              if (docTermOrds.isEmpty()) {\n                return;\n              }\n\n              reuse = docTermOrds.lookup(doc, reuse);\n              int[] buffer = new int[5];\n\n              int chunk;\n              do {\n                chunk = reuse.read(buffer);\n                if (chunk == 0) {\n                  return;\n                }\n\n                for (int idx = 0; idx < chunk; idx++) {\n                  int key = buffer[idx];\n                  docTermsEnum.seekExact((long) key);\n                  JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                  if (joinScore == null) {\n                    continue;\n                  }\n                  Integer basedDoc = docBase + doc;\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(basedDoc)) {\n                    docToJoinScore.put(basedDoc, joinScore);\n                  }\n                }\n              } while (chunk >= buffer.length);\n            }\n\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n              docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n              reuse = null;\n            }\n\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private FieldCache.DocTerms terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) {\n            JoinScore joinScore = joinValueToJoinScores.get(terms.getTerm(doc, spare));\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private FieldCache.DocTerms terms;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            BytesRef joinValue = terms.getTerm(doc, spare);\n            if (joinValue == null) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, 0);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private DocTermOrds docTermOrds;\n            private TermsEnum docTermsEnum;\n            private DocTermOrds.TermOrdsIterator reuse;\n            private int docBase;\n\n            public void collect(int doc) throws IOException {\n              if (docTermOrds.isEmpty()) {\n                return;\n              }\n\n              reuse = docTermOrds.lookup(doc, reuse);\n              int[] buffer = new int[5];\n\n              int chunk;\n              do {\n                chunk = reuse.read(buffer);\n                if (chunk == 0) {\n                  return;\n                }\n\n                for (int idx = 0; idx < chunk; idx++) {\n                  int key = buffer[idx];\n                  docTermsEnum.seekExact((long) key);\n                  JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                  if (joinScore == null) {\n                    continue;\n                  }\n                  Integer basedDoc = docBase + doc;\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(basedDoc)) {\n                    docToJoinScore.put(basedDoc, joinScore);\n                  }\n                }\n              } while (chunk >= buffer.length);\n            }\n\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n              docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n              reuse = null;\n            }\n\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private FieldCache.DocTerms terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) {\n            JoinScore joinScore = joinValueToJoinScores.get(terms.getTerm(doc, spare));\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private FieldCache.DocTerms terms;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            BytesRef joinValue = terms.getTerm(doc, spare);\n            if (joinValue == null) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private DocTermOrds docTermOrds;\n            private TermsEnum docTermsEnum;\n            private DocTermOrds.TermOrdsIterator reuse;\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              if (docTermOrds.isEmpty()) {\n                return;\n              }\n\n              reuse = docTermOrds.lookup(doc, reuse);\n              int[] buffer = new int[5];\n\n              int chunk;\n              do {\n                chunk = reuse.read(buffer);\n                if (chunk == 0) {\n                  return;\n                }\n\n                for (int idx = 0; idx < chunk; idx++) {\n                  int key = buffer[idx];\n                  docTermsEnum.seekExact((long) key);\n                  JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                  if (joinScore == null) {\n                    continue;\n                  }\n                  Integer basedDoc = docBase + doc;\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(basedDoc)) {\n                    docToJoinScore.put(basedDoc, joinScore);\n                  }\n                }\n              } while (chunk >= buffer.length);\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n              docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n              reuse = null;\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private FieldCache.DocTerms terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            JoinScore joinScore = joinValueToJoinScores.get(terms.getTerm(doc, spare));\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private FieldCache.DocTerms terms;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            BytesRef joinValue = terms.getTerm(doc, spare);\n            if (joinValue == null) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private DocTermOrds docTermOrds;\n            private TermsEnum docTermsEnum;\n            private DocTermOrds.TermOrdsIterator reuse;\n            private int docBase;\n\n            public void collect(int doc) throws IOException {\n              if (docTermOrds.isEmpty()) {\n                return;\n              }\n\n              reuse = docTermOrds.lookup(doc, reuse);\n              int[] buffer = new int[5];\n\n              int chunk;\n              do {\n                chunk = reuse.read(buffer);\n                if (chunk == 0) {\n                  return;\n                }\n\n                for (int idx = 0; idx < chunk; idx++) {\n                  int key = buffer[idx];\n                  docTermsEnum.seekExact((long) key);\n                  JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                  if (joinScore == null) {\n                    continue;\n                  }\n                  Integer basedDoc = docBase + doc;\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(basedDoc)) {\n                    docToJoinScore.put(basedDoc, joinScore);\n                  }\n                }\n              } while (chunk >= buffer.length);\n            }\n\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n              docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n              reuse = null;\n            }\n\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private FieldCache.DocTerms terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) {\n            JoinScore joinScore = joinValueToJoinScores.get(terms.getTerm(doc, spare));\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.bytes == BinaryDocValues.MISSING) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private DocTermOrds docTermOrds;\n            private TermsEnum docTermsEnum;\n            private DocTermOrds.TermOrdsIterator reuse;\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              if (docTermOrds.isEmpty()) {\n                return;\n              }\n\n              reuse = docTermOrds.lookup(doc, reuse);\n              int[] buffer = new int[5];\n\n              int chunk;\n              do {\n                chunk = reuse.read(buffer);\n                if (chunk == 0) {\n                  return;\n                }\n\n                for (int idx = 0; idx < chunk; idx++) {\n                  int key = buffer[idx];\n                  docTermsEnum.seekExact((long) key);\n                  JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                  if (joinScore == null) {\n                    continue;\n                  }\n                  Integer basedDoc = docBase + doc;\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(basedDoc)) {\n                    docToJoinScore.put(basedDoc, joinScore);\n                  }\n                }\n              } while (chunk >= buffer.length);\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n              docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n              reuse = null;\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.bytes == BinaryDocValues.MISSING) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, 0);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private DocTermOrds docTermOrds;\n            private TermsEnum docTermsEnum;\n            private DocTermOrds.TermOrdsIterator reuse;\n            private int docBase;\n\n            public void collect(int doc) throws IOException {\n              if (docTermOrds.isEmpty()) {\n                return;\n              }\n\n              reuse = docTermOrds.lookup(doc, reuse);\n              int[] buffer = new int[5];\n\n              int chunk;\n              do {\n                chunk = reuse.read(buffer);\n                if (chunk == 0) {\n                  return;\n                }\n\n                for (int idx = 0; idx < chunk; idx++) {\n                  int key = buffer[idx];\n                  docTermsEnum.seekExact((long) key);\n                  JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                  if (joinScore == null) {\n                    continue;\n                  }\n                  Integer basedDoc = docBase + doc;\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(basedDoc)) {\n                    docToJoinScore.put(basedDoc, joinScore);\n                  }\n                }\n              } while (chunk >= buffer.length);\n            }\n\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n              docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n              reuse = null;\n            }\n\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.bytes == BinaryDocValues.MISSING) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private DocTermOrds docTermOrds;\n            private TermsEnum docTermsEnum;\n            private DocTermOrds.TermOrdsIterator reuse;\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              if (docTermOrds.isEmpty()) {\n                return;\n              }\n\n              reuse = docTermOrds.lookup(doc, reuse);\n              int[] buffer = new int[5];\n\n              int chunk;\n              do {\n                chunk = reuse.read(buffer);\n                if (chunk == 0) {\n                  return;\n                }\n\n                for (int idx = 0; idx < chunk; idx++) {\n                  int key = buffer[idx];\n                  docTermsEnum.seekExact((long) key);\n                  JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                  if (joinScore == null) {\n                    continue;\n                  }\n                  Integer basedDoc = docBase + doc;\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(basedDoc)) {\n                    docToJoinScore.put(basedDoc, joinScore);\n                  }\n                }\n              } while (chunk >= buffer.length);\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n              docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n              reuse = null;\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private FieldCache.DocTerms terms;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            BytesRef joinValue = terms.getTerm(doc, spare);\n            if (joinValue == null) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private DocTermOrds docTermOrds;\n            private TermsEnum docTermsEnum;\n            private DocTermOrds.TermOrdsIterator reuse;\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              if (docTermOrds.isEmpty()) {\n                return;\n              }\n\n              reuse = docTermOrds.lookup(doc, reuse);\n              int[] buffer = new int[5];\n\n              int chunk;\n              do {\n                chunk = reuse.read(buffer);\n                if (chunk == 0) {\n                  return;\n                }\n\n                for (int idx = 0; idx < chunk; idx++) {\n                  int key = buffer[idx];\n                  docTermsEnum.seekExact((long) key);\n                  JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                  if (joinScore == null) {\n                    continue;\n                  }\n                  Integer basedDoc = docBase + doc;\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(basedDoc)) {\n                    docToJoinScore.put(basedDoc, joinScore);\n                  }\n                }\n              } while (chunk >= buffer.length);\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n              docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n              reuse = null;\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private FieldCache.DocTerms terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            JoinScore joinScore = joinValueToJoinScores.get(terms.getTerm(doc, spare));\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":["77855215e331ce146763531cb9b0c050726f6ae5"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f438915b81b54f1fdff40443da8c4fb15c61c777","date":1360597404,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // nocommit: cut over\n            DocTermOrds.Iterator iterator = (DocTermOrds.Iterator) FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermOrds = iterator.getParent();\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.bytes == BinaryDocValues.MISSING) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private DocTermOrds docTermOrds;\n            private TermsEnum docTermsEnum;\n            private DocTermOrds.TermOrdsIterator reuse;\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              if (docTermOrds.isEmpty()) {\n                return;\n              }\n\n              reuse = docTermOrds.lookup(doc, reuse);\n              int[] buffer = new int[5];\n\n              int chunk;\n              do {\n                chunk = reuse.read(buffer);\n                if (chunk == 0) {\n                  return;\n                }\n\n                for (int idx = 0; idx < chunk; idx++) {\n                  int key = buffer[idx];\n                  docTermsEnum.seekExact((long) key);\n                  JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                  if (joinScore == null) {\n                    continue;\n                  }\n                  Integer basedDoc = docBase + doc;\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(basedDoc)) {\n                    docToJoinScore.put(basedDoc, joinScore);\n                  }\n                }\n              } while (chunk >= buffer.length);\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              DocTermOrds.Iterator iterator = (DocTermOrds.Iterator) FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n              docTermOrds = iterator.getParent();\n              docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n              reuse = null;\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.bytes == BinaryDocValues.MISSING) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private DocTermOrds docTermOrds;\n            private TermsEnum docTermsEnum;\n            private DocTermOrds.TermOrdsIterator reuse;\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              if (docTermOrds.isEmpty()) {\n                return;\n              }\n\n              reuse = docTermOrds.lookup(doc, reuse);\n              int[] buffer = new int[5];\n\n              int chunk;\n              do {\n                chunk = reuse.read(buffer);\n                if (chunk == 0) {\n                  return;\n                }\n\n                for (int idx = 0; idx < chunk; idx++) {\n                  int key = buffer[idx];\n                  docTermsEnum.seekExact((long) key);\n                  JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                  if (joinScore == null) {\n                    continue;\n                  }\n                  Integer basedDoc = docBase + doc;\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(basedDoc)) {\n                    docToJoinScore.put(basedDoc, joinScore);\n                  }\n                }\n              } while (chunk >= buffer.length);\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n              docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n              reuse = null;\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c141f828bd623b6f0e984f8336590b0f582415bf","date":1360603468,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.bytes == BinaryDocValues.MISSING) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private DocTermOrds docTermOrds;\n            private TermsEnum docTermsEnum;\n            private DocTermOrds.TermOrdsIterator reuse;\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              if (docTermOrds.isEmpty()) {\n                return;\n              }\n\n              reuse = docTermOrds.lookup(doc, reuse);\n              int[] buffer = new int[5];\n\n              int chunk;\n              do {\n                chunk = reuse.read(buffer);\n                if (chunk == 0) {\n                  return;\n                }\n\n                for (int idx = 0; idx < chunk; idx++) {\n                  int key = buffer[idx];\n                  docTermsEnum.seekExact((long) key);\n                  JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                  if (joinScore == null) {\n                    continue;\n                  }\n                  Integer basedDoc = docBase + doc;\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(basedDoc)) {\n                    docToJoinScore.put(basedDoc, joinScore);\n                  }\n                }\n              } while (chunk >= buffer.length);\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              DocTermOrds.Iterator iterator = (DocTermOrds.Iterator) FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n              docTermOrds = iterator.getParent();\n              docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n              reuse = null;\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // nocommit: cut over\n            DocTermOrds.Iterator iterator = (DocTermOrds.Iterator) FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermOrds = iterator.getParent();\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.bytes == BinaryDocValues.MISSING) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private DocTermOrds docTermOrds;\n            private TermsEnum docTermsEnum;\n            private DocTermOrds.TermOrdsIterator reuse;\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              if (docTermOrds.isEmpty()) {\n                return;\n              }\n\n              reuse = docTermOrds.lookup(doc, reuse);\n              int[] buffer = new int[5];\n\n              int chunk;\n              do {\n                chunk = reuse.read(buffer);\n                if (chunk == 0) {\n                  return;\n                }\n\n                for (int idx = 0; idx < chunk; idx++) {\n                  int key = buffer[idx];\n                  docTermsEnum.seekExact((long) key);\n                  JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                  if (joinScore == null) {\n                    continue;\n                  }\n                  Integer basedDoc = docBase + doc;\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(basedDoc)) {\n                    docToJoinScore.put(basedDoc, joinScore);\n                  }\n                }\n              } while (chunk >= buffer.length);\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              DocTermOrds.Iterator iterator = (DocTermOrds.Iterator) FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n              docTermOrds = iterator.getParent();\n              docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n              reuse = null;\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a75b0a3b1c51de153947d37e403a0cc7d899040b","date":1360626385,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.bytes == BinaryDocValues.MISSING) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.bytes == BinaryDocValues.MISSING) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private DocTermOrds docTermOrds;\n            private TermsEnum docTermsEnum;\n            private DocTermOrds.TermOrdsIterator reuse;\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              if (docTermOrds.isEmpty()) {\n                return;\n              }\n\n              reuse = docTermOrds.lookup(doc, reuse);\n              int[] buffer = new int[5];\n\n              int chunk;\n              do {\n                chunk = reuse.read(buffer);\n                if (chunk == 0) {\n                  return;\n                }\n\n                for (int idx = 0; idx < chunk; idx++) {\n                  int key = buffer[idx];\n                  docTermsEnum.seekExact((long) key);\n                  JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                  if (joinScore == null) {\n                    continue;\n                  }\n                  Integer basedDoc = docBase + doc;\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(basedDoc)) {\n                    docToJoinScore.put(basedDoc, joinScore);\n                  }\n                }\n              } while (chunk >= buffer.length);\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              DocTermOrds.Iterator iterator = (DocTermOrds.Iterator) FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n              docTermOrds = iterator.getParent();\n              docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n              reuse = null;\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ddbb72a33557d2b5bc22ee95daf3281c43560502","date":1361334582,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.bytes == BinaryDocValues.MISSING) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.bytes == BinaryDocValues.MISSING) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private DocTermOrds docTermOrds;\n            private TermsEnum docTermsEnum;\n            private DocTermOrds.TermOrdsIterator reuse;\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              if (docTermOrds.isEmpty()) {\n                return;\n              }\n\n              reuse = docTermOrds.lookup(doc, reuse);\n              int[] buffer = new int[5];\n\n              int chunk;\n              do {\n                chunk = reuse.read(buffer);\n                if (chunk == 0) {\n                  return;\n                }\n\n                for (int idx = 0; idx < chunk; idx++) {\n                  int key = buffer[idx];\n                  docTermsEnum.seekExact((long) key);\n                  JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                  if (joinScore == null) {\n                    continue;\n                  }\n                  Integer basedDoc = docBase + doc;\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(basedDoc)) {\n                    docToJoinScore.put(basedDoc, joinScore);\n                  }\n                }\n              } while (chunk >= buffer.length);\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n              docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n              reuse = null;\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19f400d1b6b61e87efe596bd64726f080f9a29f0","date":1366027276,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.bytes == BinaryDocValues.MISSING) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.bytes == BinaryDocValues.MISSING) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8","date":1373996650,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.bytes == BinaryDocValues.MISSING) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.bytes == BinaryDocValues.MISSING) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.bytes == BinaryDocValues.MISSING) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.bytes == BinaryDocValues.MISSING) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"87d6f9603307ae2ad642fb01deedf031320fd0c3","date":1377877563,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField, true);\n            docsWithField = FieldCache.DEFAULT.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField, false);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.bytes == BinaryDocValues.MISSING) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":["2dd9934a49477c83301120ba51827d91eb3606d5","77855215e331ce146763531cb9b0c050726f6ae5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField, true);\n            docsWithField = FieldCache.DEFAULT.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField, false);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField, true);\n            docsWithField = FieldCache.DEFAULT.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField, false);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae73da626f97850c922c42736f808d0378e165f0","date":1396625460,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField, true);\n            docsWithField = FieldCache.DEFAULT.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField, false);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField, true);\n            docsWithField = FieldCache.DEFAULT.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField, false);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField, true);\n            docsWithField = FieldCache.DEFAULT.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField, false);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField, true);\n            docsWithField = FieldCache.DEFAULT.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField, false);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","date":1399816179,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = DocValues.getSortedSet(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField, true);\n            docsWithField = FieldCache.DEFAULT.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField, false);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = DocValues.getSortedSet(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField, true);\n            docsWithField = FieldCache.DEFAULT.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField, false);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = DocValues.getSortedSet(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField, true);\n            docsWithField = FieldCache.DEFAULT.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField, false);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf","date":1401983689,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n            private SortedSetDocValues docTermOrds;\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = DocValues.getSortedSet(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n          final BytesRef joinValue = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              docTermOrds.lookupOrd(ord, joinValue);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) throws IOException {\n            terms.get(doc, spare);\n            BytesRef joinValue = spare;\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n            private SortedSetDocValues docTermOrds;\n            private final BytesRef scratch = new BytesRef();\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                docTermOrds.lookupOrd(ord, scratch);\n                JoinScore joinScore = joinValueToJoinScores.get(scratch);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = DocValues.getSortedSet(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          @Override\n          public void collect(int doc) {\n            terms.get(doc, spare);\n            JoinScore joinScore = joinValueToJoinScores.get(spare);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n            private SortedSetDocValues docTermOrds;\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            protected void doSetNextReader(LeafReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = DocValues.getSortedSet(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n            private SortedSetDocValues docTermOrds;\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = DocValues.getSortedSet(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","date":1421314520,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          DocsEnum docsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n            private SortedSetDocValues docTermOrds;\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            protected void doSetNextReader(LeafReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = DocValues.getSortedSet(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9359ad4a5596673c3154ffa1133458f00e124234","date":1428012026,"type":1,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n//        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n        uniqueRandomValue = TestUtil.randomSimpleString(random());\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(slowCompositeReader.getLiveDocs(), postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {}\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(slowCompositeReader.getLiveDocs(), postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {}\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","date":1428091986,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n//        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n        uniqueRandomValue = TestUtil.randomSimpleString(random());\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(slowCompositeReader.getLiveDocs(), postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {}\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(slowCompositeReader.getLiveDocs(), postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {}\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7065b7a1004439fcad981283f1fa7632142a5f47","date":1428399440,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random(), 2, 10);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n//        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n        uniqueRandomValue = TestUtil.randomSimpleString(random());\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.YES));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random().nextBoolean()) {\n      fromWriter.forceMerge(1);\n      toWriter.forceMerge(1);\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(slowCompositeReader.getLiveDocs(), postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {}\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n//        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n        uniqueRandomValue = TestUtil.randomSimpleString(random());\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(slowCompositeReader.getLiveDocs(), postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {}\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c8376c8b9c659015b6e2a23a8c7275ea203eeef3","date":1428508284,"type":5,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(\n        random(),\n        dir,\n        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))\n    );\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random(), 2, 10);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n//        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n        uniqueRandomValue = TestUtil.randomSimpleString(random());\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.YES));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    w.close();\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    DirectoryReader topLevelReader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(topLevelReader);\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        searcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(topLevelReader);\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(slowCompositeReader.getLiveDocs(), postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        searcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    if (globalOrdinalJoin) {\n      SortedDocValues[] values = new SortedDocValues[topLevelReader.leaves().size()];\n      for (LeafReaderContext leadContext : topLevelReader.leaves()) {\n        values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), \"join_field\");\n      }\n      context.ordinalMap = MultiDocValues.OrdinalMap.build(\n          topLevelReader.getCoreCacheKey(), values, PackedInts.DEFAULT\n      );\n    }\n\n    context.searcher = searcher;\n    context.dir = dir;\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / RandomInts.randomIntBetween(random(), 2, 10);\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n//        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n        uniqueRandomValue = TestUtil.randomSimpleString(random());\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.YES));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    if (random().nextBoolean()) {\n      fromWriter.forceMerge(1);\n      toWriter.forceMerge(1);\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(slowCompositeReader.getLiveDocs(), postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {}\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["2dd9934a49477c83301120ba51827d91eb3606d5","7530de27b87b961b51f01bd1299b7004d46e8823"],"9359ad4a5596673c3154ffa1133458f00e124234":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"2dd9934a49477c83301120ba51827d91eb3606d5":["b64a4420c88dd81303e7f7959057baf9f3b45f94"],"a75b0a3b1c51de153947d37e403a0cc7d899040b":["c141f828bd623b6f0e984f8336590b0f582415bf"],"ddbb72a33557d2b5bc22ee95daf3281c43560502":["d4d69c535930b5cce125cff868d40f6373dc27d4","a75b0a3b1c51de153947d37e403a0cc7d899040b"],"56572ec06f1407c066d6b7399413178b33176cd8":["ae73da626f97850c922c42736f808d0378e165f0","93dd449115a9247533e44bab47e8429e5dccbc6d"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf"],"19f400d1b6b61e87efe596bd64726f080f9a29f0":["ddbb72a33557d2b5bc22ee95daf3281c43560502"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["6613659748fe4411a7dcf85266e55db1f95f7315","ae73da626f97850c922c42736f808d0378e165f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","9359ad4a5596673c3154ffa1133458f00e124234"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["19f400d1b6b61e87efe596bd64726f080f9a29f0"],"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"6613659748fe4411a7dcf85266e55db1f95f7315":["87d6f9603307ae2ad642fb01deedf031320fd0c3"],"f438915b81b54f1fdff40443da8c4fb15c61c777":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["ae73da626f97850c922c42736f808d0378e165f0"],"87d6f9603307ae2ad642fb01deedf031320fd0c3":["eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b64a4420c88dd81303e7f7959057baf9f3b45f94"],"c8376c8b9c659015b6e2a23a8c7275ea203eeef3":["7065b7a1004439fcad981283f1fa7632142a5f47"],"b64a4420c88dd81303e7f7959057baf9f3b45f94":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c141f828bd623b6f0e984f8336590b0f582415bf":["f438915b81b54f1fdff40443da8c4fb15c61c777"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["7530de27b87b961b51f01bd1299b7004d46e8823","d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"15250ca94ba8ab3bcdd476daf6bf3f3febb92640":["b64a4420c88dd81303e7f7959057baf9f3b45f94"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["ae73da626f97850c922c42736f808d0378e165f0","b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"ae73da626f97850c922c42736f808d0378e165f0":["6613659748fe4411a7dcf85266e55db1f95f7315"],"7065b7a1004439fcad981283f1fa7632142a5f47":["9359ad4a5596673c3154ffa1133458f00e124234"],"7530de27b87b961b51f01bd1299b7004d46e8823":["15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["19f400d1b6b61e87efe596bd64726f080f9a29f0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c8376c8b9c659015b6e2a23a8c7275ea203eeef3"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"9359ad4a5596673c3154ffa1133458f00e124234":["6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","7065b7a1004439fcad981283f1fa7632142a5f47"],"2dd9934a49477c83301120ba51827d91eb3606d5":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"a75b0a3b1c51de153947d37e403a0cc7d899040b":["ddbb72a33557d2b5bc22ee95daf3281c43560502"],"ddbb72a33557d2b5bc22ee95daf3281c43560502":["19f400d1b6b61e87efe596bd64726f080f9a29f0"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"19f400d1b6b61e87efe596bd64726f080f9a29f0":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["05a14b2611ead08655a2b2bdc61632eb31316e57","b64a4420c88dd81303e7f7959057baf9f3b45f94"],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"6613659748fe4411a7dcf85266e55db1f95f7315":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","ae73da626f97850c922c42736f808d0378e165f0"],"f438915b81b54f1fdff40443da8c4fb15c61c777":["c141f828bd623b6f0e984f8336590b0f582415bf"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"87d6f9603307ae2ad642fb01deedf031320fd0c3":["6613659748fe4411a7dcf85266e55db1f95f7315"],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"b64a4420c88dd81303e7f7959057baf9f3b45f94":["2dd9934a49477c83301120ba51827d91eb3606d5","05a14b2611ead08655a2b2bdc61632eb31316e57","15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"c8376c8b9c659015b6e2a23a8c7275ea203eeef3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c141f828bd623b6f0e984f8336590b0f582415bf":["a75b0a3b1c51de153947d37e403a0cc7d899040b"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["ddbb72a33557d2b5bc22ee95daf3281c43560502","f438915b81b54f1fdff40443da8c4fb15c61c777"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["56572ec06f1407c066d6b7399413178b33176cd8","53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf"],"15250ca94ba8ab3bcdd476daf6bf3f3febb92640":["7530de27b87b961b51f01bd1299b7004d46e8823"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["9359ad4a5596673c3154ffa1133458f00e124234","6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c"],"ae73da626f97850c922c42736f808d0378e165f0":["56572ec06f1407c066d6b7399413178b33176cd8","15e323346eac5e4685c0a9f2df85eb96b4239bbb","b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","93dd449115a9247533e44bab47e8429e5dccbc6d"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","d4d69c535930b5cce125cff868d40f6373dc27d4"],"7065b7a1004439fcad981283f1fa7632142a5f47":["c8376c8b9c659015b6e2a23a8c7275ea203eeef3"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["87d6f9603307ae2ad642fb01deedf031320fd0c3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["56572ec06f1407c066d6b7399413178b33176cd8","15e323346eac5e4685c0a9f2df85eb96b4239bbb","6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","05a14b2611ead08655a2b2bdc61632eb31316e57","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}