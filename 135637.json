{"path":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#stateVersionParamTest().mjava","commits":[{"id":"a6f693ed86f289b2e42b46684409b3997f2c264a","date":1404319832,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#stateVersionParamTest().mjava","pathOld":"/dev/null","sourceNew":"  private void stateVersionParamTest() throws Exception {\n    CloudSolrServer client = createCloudClient(null);\n    try {\n      String collectionName = \"checkStateVerCol\";\n      createCollection(collectionName, client, 2, 2);\n      waitForRecoveriesToFinish(collectionName, false);\n      DocCollection coll = client.getZkStateReader().getClusterState().getCollection(collectionName);\n      Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n      HttpSolrServer httpSolrServer = new HttpSolrServer(r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\"+collectionName);\n\n\n      SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n\n      log.info(\"should work query, result {}\", httpSolrServer.query(q));\n      //no problem\n      q.setParam(CloudSolrServer.STATE_VERSION, collectionName+\":\"+coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", httpSolrServer.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrServer.STATE_VERSION, collectionName+\":\"+ (coll.getZNodeVersion() -1)); //an older version expect error\n\n      HttpSolrServer.RemoteSolrException sse = null;\n      try {\n        httpSolrServer.query(q);\n        log.info(\"expected query error\");\n      } catch (HttpSolrServer.RemoteSolrException e) {\n        sse = e;\n      }\n      httpSolrServer.shutdown();\n      assertNotNull(sse);\n      assertEquals(\" Error code should be \",  sse.code() , SolrException.ErrorCode.INVALID_STATE.code);\n\n      //now send the request to another node that does n ot serve the collection\n\n      Set<String> allNodesOfColl = new HashSet<>();\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n        }\n      }\n      String theNode = null;\n      for (String s : client.getZkStateReader().getClusterState().getLiveNodes()) {\n        String n = client.getZkStateReader().getBaseUrlForNodeName(s);\n        if(!allNodesOfColl.contains(s)){\n          theNode = n;\n          break;\n        }\n      }\n      log.info(\"thenode which does not serve this collection{} \",theNode);\n      assertNotNull(theNode);\n      httpSolrServer = new HttpSolrServer(theNode + \"/\"+collectionName);\n\n      q.setParam(CloudSolrServer.STATE_VERSION, collectionName+\":\"+coll.getZNodeVersion());\n\n      try {\n        httpSolrServer.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrServer.RemoteSolrException e) {\n        sse = e;\n      }\n      httpSolrServer.shutdown();\n      assertNotNull(sse);\n      assertEquals(\" Error code should be \",  sse.code() , SolrException.ErrorCode.INVALID_STATE.code);\n    } finally {\n      client.shutdown();\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4c07fa58a256dccf8b95364855fd5e9ad4d1401","date":1404386015,"type":4,"author":"Noble Paul","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#stateVersionParamTest().mjava","sourceNew":null,"sourceOld":"  private void stateVersionParamTest() throws Exception {\n    CloudSolrServer client = createCloudClient(null);\n    try {\n      String collectionName = \"checkStateVerCol\";\n      createCollection(collectionName, client, 2, 2);\n      waitForRecoveriesToFinish(collectionName, false);\n      DocCollection coll = client.getZkStateReader().getClusterState().getCollection(collectionName);\n      Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n      HttpSolrServer httpSolrServer = new HttpSolrServer(r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\"+collectionName);\n\n\n      SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n\n      log.info(\"should work query, result {}\", httpSolrServer.query(q));\n      //no problem\n      q.setParam(CloudSolrServer.STATE_VERSION, collectionName+\":\"+coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", httpSolrServer.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrServer.STATE_VERSION, collectionName+\":\"+ (coll.getZNodeVersion() -1)); //an older version expect error\n\n      HttpSolrServer.RemoteSolrException sse = null;\n      try {\n        httpSolrServer.query(q);\n        log.info(\"expected query error\");\n      } catch (HttpSolrServer.RemoteSolrException e) {\n        sse = e;\n      }\n      httpSolrServer.shutdown();\n      assertNotNull(sse);\n      assertEquals(\" Error code should be \",  sse.code() , SolrException.ErrorCode.INVALID_STATE.code);\n\n      //now send the request to another node that does n ot serve the collection\n\n      Set<String> allNodesOfColl = new HashSet<>();\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n        }\n      }\n      String theNode = null;\n      for (String s : client.getZkStateReader().getClusterState().getLiveNodes()) {\n        String n = client.getZkStateReader().getBaseUrlForNodeName(s);\n        if(!allNodesOfColl.contains(s)){\n          theNode = n;\n          break;\n        }\n      }\n      log.info(\"thenode which does not serve this collection{} \",theNode);\n      assertNotNull(theNode);\n      httpSolrServer = new HttpSolrServer(theNode + \"/\"+collectionName);\n\n      q.setParam(CloudSolrServer.STATE_VERSION, collectionName+\":\"+coll.getZNodeVersion());\n\n      try {\n        httpSolrServer.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrServer.RemoteSolrException e) {\n        sse = e;\n      }\n      httpSolrServer.shutdown();\n      assertNotNull(sse);\n      assertEquals(\" Error code should be \",  sse.code() , SolrException.ErrorCode.INVALID_STATE.code);\n    } finally {\n      client.shutdown();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9279b175e5e66258442d2123a50f052219a9cc1b","date":1410531077,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#stateVersionParamTest().mjava","pathOld":"/dev/null","sourceNew":"  private void stateVersionParamTest() throws Exception {\n    CloudSolrServer client = createCloudClient(null);\n    try {\n      String collectionName = \"checkStateVerCol\";\n      createCollection(collectionName, client, 2, 2);\n      waitForRecoveriesToFinish(collectionName, false);\n      DocCollection coll = client.getZkStateReader().getClusterState().getCollection(collectionName);\n      Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n      HttpSolrServer httpSolrServer = new HttpSolrServer(r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\"+collectionName);\n\n\n      SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n\n      log.info(\"should work query, result {}\", httpSolrServer.query(q));\n      //no problem\n      q.setParam(CloudSolrServer.STATE_VERSION, collectionName+\":\"+coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", httpSolrServer.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrServer.STATE_VERSION, collectionName+\":\"+ (coll.getZNodeVersion() -1)); //an older version expect error\n\n      HttpSolrServer.RemoteSolrException sse = null;\n      try {\n        httpSolrServer.query(q);\n        log.info(\"expected query error\");\n      } catch (HttpSolrServer.RemoteSolrException e) {\n        sse = e;\n      }\n      httpSolrServer.shutdown();\n      assertNotNull(sse);\n      assertEquals(\" Error code should be \",  sse.code() , SolrException.ErrorCode.INVALID_STATE.code);\n\n      //now send the request to another node that does n ot serve the collection\n\n      Set<String> allNodesOfColl = new HashSet<>();\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n        }\n      }\n      String theNode = null;\n      for (String s : client.getZkStateReader().getClusterState().getLiveNodes()) {\n        String n = client.getZkStateReader().getBaseUrlForNodeName(s);\n        if(!allNodesOfColl.contains(s)){\n          theNode = n;\n          break;\n        }\n      }\n      log.info(\"thenode which does not serve this collection{} \",theNode);\n      assertNotNull(theNode);\n      httpSolrServer = new HttpSolrServer(theNode + \"/\"+collectionName);\n\n      q.setParam(CloudSolrServer.STATE_VERSION, collectionName+\":\"+coll.getZNodeVersion());\n\n      try {\n        httpSolrServer.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrServer.RemoteSolrException e) {\n        sse = e;\n      }\n      httpSolrServer.shutdown();\n      assertNotNull(sse);\n      assertEquals(\" Error code should be \",  sse.code() , SolrException.ErrorCode.INVALID_STATE.code);\n    } finally {\n      client.shutdown();\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#stateVersionParamTest().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#stateVersionParamTest().mjava","sourceNew":"  private void stateVersionParamTest() throws Exception {\n    CloudSolrClient client = createCloudClient(null);\n    try {\n      String collectionName = \"checkStateVerCol\";\n      createCollection(collectionName, client, 2, 2);\n      waitForRecoveriesToFinish(collectionName, false);\n      DocCollection coll = client.getZkStateReader().getClusterState().getCollection(collectionName);\n      Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n      HttpSolrClient solrClient = new HttpSolrClient(r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\"+collectionName);\n\n\n      SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n\n      log.info(\"should work query, result {}\", solrClient.query(q));\n      //no problem\n      q.setParam(CloudSolrClient.STATE_VERSION, collectionName + \":\" + coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", solrClient.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrClient.STATE_VERSION, collectionName+\":\"+ (coll.getZNodeVersion() -1)); //an older version expect error\n\n      HttpSolrClient.RemoteSolrException sse = null;\n      try {\n        solrClient.query(q);\n        log.info(\"expected query error\");\n      } catch (HttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      solrClient.shutdown();\n      assertNotNull(sse);\n      assertEquals(\" Error code should be \", sse.code(), SolrException.ErrorCode.INVALID_STATE.code);\n\n      //now send the request to another node that does n ot serve the collection\n\n      Set<String> allNodesOfColl = new HashSet<>();\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n        }\n      }\n      String theNode = null;\n      for (String s : client.getZkStateReader().getClusterState().getLiveNodes()) {\n        String n = client.getZkStateReader().getBaseUrlForNodeName(s);\n        if(!allNodesOfColl.contains(s)){\n          theNode = n;\n          break;\n        }\n      }\n      log.info(\"thenode which does not serve this collection{} \",theNode);\n      assertNotNull(theNode);\n      solrClient = new HttpSolrClient(theNode + \"/\"+collectionName);\n\n      q.setParam(CloudSolrClient.STATE_VERSION, collectionName+\":\"+coll.getZNodeVersion());\n\n      try {\n        solrClient.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrClient.RemoteSolrException e) {\n        sse = e;\n      }\n      solrClient.shutdown();\n      assertNotNull(sse);\n      assertEquals(\" Error code should be \",  sse.code() , SolrException.ErrorCode.INVALID_STATE.code);\n    } finally {\n      client.shutdown();\n    }\n\n  }\n\n","sourceOld":"  private void stateVersionParamTest() throws Exception {\n    CloudSolrServer client = createCloudClient(null);\n    try {\n      String collectionName = \"checkStateVerCol\";\n      createCollection(collectionName, client, 2, 2);\n      waitForRecoveriesToFinish(collectionName, false);\n      DocCollection coll = client.getZkStateReader().getClusterState().getCollection(collectionName);\n      Replica r = coll.getSlices().iterator().next().getReplicas().iterator().next();\n\n      HttpSolrServer httpSolrServer = new HttpSolrServer(r.getStr(ZkStateReader.BASE_URL_PROP) + \"/\"+collectionName);\n\n\n      SolrQuery q = new SolrQuery().setQuery(\"*:*\");\n\n      log.info(\"should work query, result {}\", httpSolrServer.query(q));\n      //no problem\n      q.setParam(CloudSolrServer.STATE_VERSION, collectionName+\":\"+coll.getZNodeVersion());\n      log.info(\"2nd query , result {}\", httpSolrServer.query(q));\n      //no error yet good\n\n      q.setParam(CloudSolrServer.STATE_VERSION, collectionName+\":\"+ (coll.getZNodeVersion() -1)); //an older version expect error\n\n      HttpSolrServer.RemoteSolrException sse = null;\n      try {\n        httpSolrServer.query(q);\n        log.info(\"expected query error\");\n      } catch (HttpSolrServer.RemoteSolrException e) {\n        sse = e;\n      }\n      httpSolrServer.shutdown();\n      assertNotNull(sse);\n      assertEquals(\" Error code should be \",  sse.code() , SolrException.ErrorCode.INVALID_STATE.code);\n\n      //now send the request to another node that does n ot serve the collection\n\n      Set<String> allNodesOfColl = new HashSet<>();\n      for (Slice slice : coll.getSlices()) {\n        for (Replica replica : slice.getReplicas()) {\n          allNodesOfColl.add(replica.getStr(ZkStateReader.BASE_URL_PROP));\n        }\n      }\n      String theNode = null;\n      for (String s : client.getZkStateReader().getClusterState().getLiveNodes()) {\n        String n = client.getZkStateReader().getBaseUrlForNodeName(s);\n        if(!allNodesOfColl.contains(s)){\n          theNode = n;\n          break;\n        }\n      }\n      log.info(\"thenode which does not serve this collection{} \",theNode);\n      assertNotNull(theNode);\n      httpSolrServer = new HttpSolrServer(theNode + \"/\"+collectionName);\n\n      q.setParam(CloudSolrServer.STATE_VERSION, collectionName+\":\"+coll.getZNodeVersion());\n\n      try {\n        httpSolrServer.query(q);\n        log.info(\"error was expected\");\n      } catch (HttpSolrServer.RemoteSolrException e) {\n        sse = e;\n      }\n      httpSolrServer.shutdown();\n      assertNotNull(sse);\n      assertEquals(\" Error code should be \",  sse.code() , SolrException.ErrorCode.INVALID_STATE.code);\n    } finally {\n      client.shutdown();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a6f693ed86f289b2e42b46684409b3997f2c264a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bafca15d8e408346a67f4282ad1143b88023893b":["9279b175e5e66258442d2123a50f052219a9cc1b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bafca15d8e408346a67f4282ad1143b88023893b"],"9279b175e5e66258442d2123a50f052219a9cc1b":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"]},"commit2Childs":{"a6f693ed86f289b2e42b46684409b3997f2c264a":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["9279b175e5e66258442d2123a50f052219a9cc1b"],"bafca15d8e408346a67f4282ad1143b88023893b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9279b175e5e66258442d2123a50f052219a9cc1b":["bafca15d8e408346a67f4282ad1143b88023893b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}