{"path":"lucene/facet/src/test/org/apache/lucene/facet/search/FacetResultTest#searchIndex(TaxonomyReader,IndexSearcher,boolean,String[],String[][],int[]).mjava","commits":[{"id":"ff6a0dc6ca67172f353dbc6b826e324f84d378ef","date":1369831625,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/FacetResultTest#searchIndex(TaxonomyReader,IndexSearcher,boolean,String[],String[][],int[]).mjava","pathOld":"/dev/null","sourceNew":"  private void searchIndex(TaxonomyReader taxoReader, IndexSearcher searcher, boolean fillMissingCounts, String[] exp,\n      String[][] drillDowns, int[] numResults) throws IOException {\n    CategoryPath[][] cps = new CategoryPath[drillDowns.length][];\n    for (int i = 0; i < cps.length; i++) {\n      cps[i] = new CategoryPath[drillDowns[i].length];\n      for (int j = 0; j < cps[i].length; j++) {\n        cps[i][j] = new CategoryPath(drillDowns[i][j], '/');\n      }\n    }\n    DrillDownQuery ddq = new DrillDownQuery(FacetIndexingParams.DEFAULT, new MatchAllDocsQuery());\n    for (CategoryPath[] cats : cps) {\n      ddq.add(cats);\n    }\n    \n    List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n    for (CategoryPath[] cats : cps) {\n      for (int i = 0; i < cats.length; i++) {\n        CategoryPath cp = cats[i];\n        int numres = numResults == null ? 2 : numResults[i];\n        // for each drill-down, add itself as well as its parent as requests, so\n        // we get the drill-sideways\n        facetRequests.add(new CountFacetRequest(cp, numres));\n        CountFacetRequest parent = new CountFacetRequest(cp.subpath(cp.length - 1), numres);\n        if (!facetRequests.contains(parent) && parent.categoryPath.length > 0) {\n          facetRequests.add(parent);\n        }\n      }\n    }\n    \n    FacetSearchParams fsp = new FacetSearchParams(facetRequests);\n    final DrillSideways ds;\n    final Map<String,FacetArrays> dimArrays;\n    if (fillMissingCounts) {\n      dimArrays = new HashMap<String,FacetArrays>();\n      ds = new DrillSideways(searcher, taxoReader) {\n        @Override\n        protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n          FacetsAccumulator fa = super.getDrillSidewaysAccumulator(dim, fsp);\n          dimArrays.put(dim, fa.facetArrays);\n          return fa;\n        }\n      };\n    } else {\n      ds = new DrillSideways(searcher, taxoReader);\n      dimArrays = null;\n    }\n    \n    final DrillSidewaysResult sidewaysRes = ds.search(null, ddq, 5, fsp);\n    List<FacetResult> facetResults = FacetResult.mergeHierarchies(sidewaysRes.facetResults, taxoReader, dimArrays);\n    CollectionUtil.introSort(facetResults, new Comparator<FacetResult>() {\n      @Override\n      public int compare(FacetResult o1, FacetResult o2) {\n        return o1.getFacetRequest().categoryPath.compareTo(o2.getFacetRequest().categoryPath);\n      }\n    });\n    assertEquals(exp.length, facetResults.size()); // A + single one for date\n    for (int i = 0; i < facetResults.size(); i++) {\n      assertEquals(exp[i], FacetTestUtils.toSimpleString(facetResults.get(i)));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49","date":1375103250,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/FacetResultTest#searchIndex(TaxonomyReader,IndexSearcher,boolean,String[],String[][],int[]).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/FacetResultTest#searchIndex(TaxonomyReader,IndexSearcher,boolean,String[],String[][],int[]).mjava","sourceNew":"  private void searchIndex(TaxonomyReader taxoReader, IndexSearcher searcher, boolean fillMissingCounts, String[] exp,\n      String[][] drillDowns, int[] numResults) throws IOException {\n    CategoryPath[][] cps = new CategoryPath[drillDowns.length][];\n    for (int i = 0; i < cps.length; i++) {\n      cps[i] = new CategoryPath[drillDowns[i].length];\n      for (int j = 0; j < cps[i].length; j++) {\n        cps[i][j] = new CategoryPath(drillDowns[i][j], '/');\n      }\n    }\n    DrillDownQuery ddq = new DrillDownQuery(FacetIndexingParams.DEFAULT, new MatchAllDocsQuery());\n    for (CategoryPath[] cats : cps) {\n      ddq.add(cats);\n    }\n    \n    List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n    for (CategoryPath[] cats : cps) {\n      for (int i = 0; i < cats.length; i++) {\n        CategoryPath cp = cats[i];\n        int numres = numResults == null ? 2 : numResults[i];\n        // for each drill-down, add itself as well as its parent as requests, so\n        // we get the drill-sideways\n        facetRequests.add(new CountFacetRequest(cp, numres));\n        CountFacetRequest parent = new CountFacetRequest(cp.subpath(cp.length - 1), numres);\n        if (!facetRequests.contains(parent) && parent.categoryPath.length > 0) {\n          facetRequests.add(parent);\n        }\n      }\n    }\n    \n    FacetSearchParams fsp = new FacetSearchParams(facetRequests);\n    final DrillSideways ds;\n    final Map<String,FacetArrays> dimArrays;\n    if (fillMissingCounts) {\n      dimArrays = new HashMap<String,FacetArrays>();\n      ds = new DrillSideways(searcher, taxoReader) {\n        @Override\n        protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n          FacetsAccumulator fa = super.getDrillSidewaysAccumulator(dim, fsp);\n          dimArrays.put(dim, ((TaxonomyFacetsAccumulator) fa).facetArrays);\n          return fa;\n        }\n      };\n    } else {\n      ds = new DrillSideways(searcher, taxoReader);\n      dimArrays = null;\n    }\n    \n    final DrillSidewaysResult sidewaysRes = ds.search(null, ddq, 5, fsp);\n    List<FacetResult> facetResults = FacetResult.mergeHierarchies(sidewaysRes.facetResults, taxoReader, dimArrays);\n    CollectionUtil.introSort(facetResults, new Comparator<FacetResult>() {\n      @Override\n      public int compare(FacetResult o1, FacetResult o2) {\n        return o1.getFacetRequest().categoryPath.compareTo(o2.getFacetRequest().categoryPath);\n      }\n    });\n    assertEquals(exp.length, facetResults.size()); // A + single one for date\n    for (int i = 0; i < facetResults.size(); i++) {\n      assertEquals(exp[i], FacetTestUtils.toSimpleString(facetResults.get(i)));\n    }\n  }\n\n","sourceOld":"  private void searchIndex(TaxonomyReader taxoReader, IndexSearcher searcher, boolean fillMissingCounts, String[] exp,\n      String[][] drillDowns, int[] numResults) throws IOException {\n    CategoryPath[][] cps = new CategoryPath[drillDowns.length][];\n    for (int i = 0; i < cps.length; i++) {\n      cps[i] = new CategoryPath[drillDowns[i].length];\n      for (int j = 0; j < cps[i].length; j++) {\n        cps[i][j] = new CategoryPath(drillDowns[i][j], '/');\n      }\n    }\n    DrillDownQuery ddq = new DrillDownQuery(FacetIndexingParams.DEFAULT, new MatchAllDocsQuery());\n    for (CategoryPath[] cats : cps) {\n      ddq.add(cats);\n    }\n    \n    List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n    for (CategoryPath[] cats : cps) {\n      for (int i = 0; i < cats.length; i++) {\n        CategoryPath cp = cats[i];\n        int numres = numResults == null ? 2 : numResults[i];\n        // for each drill-down, add itself as well as its parent as requests, so\n        // we get the drill-sideways\n        facetRequests.add(new CountFacetRequest(cp, numres));\n        CountFacetRequest parent = new CountFacetRequest(cp.subpath(cp.length - 1), numres);\n        if (!facetRequests.contains(parent) && parent.categoryPath.length > 0) {\n          facetRequests.add(parent);\n        }\n      }\n    }\n    \n    FacetSearchParams fsp = new FacetSearchParams(facetRequests);\n    final DrillSideways ds;\n    final Map<String,FacetArrays> dimArrays;\n    if (fillMissingCounts) {\n      dimArrays = new HashMap<String,FacetArrays>();\n      ds = new DrillSideways(searcher, taxoReader) {\n        @Override\n        protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n          FacetsAccumulator fa = super.getDrillSidewaysAccumulator(dim, fsp);\n          dimArrays.put(dim, fa.facetArrays);\n          return fa;\n        }\n      };\n    } else {\n      ds = new DrillSideways(searcher, taxoReader);\n      dimArrays = null;\n    }\n    \n    final DrillSidewaysResult sidewaysRes = ds.search(null, ddq, 5, fsp);\n    List<FacetResult> facetResults = FacetResult.mergeHierarchies(sidewaysRes.facetResults, taxoReader, dimArrays);\n    CollectionUtil.introSort(facetResults, new Comparator<FacetResult>() {\n      @Override\n      public int compare(FacetResult o1, FacetResult o2) {\n        return o1.getFacetRequest().categoryPath.compareTo(o2.getFacetRequest().categoryPath);\n      }\n    });\n    assertEquals(exp.length, facetResults.size()); // A + single one for date\n    for (int i = 0; i < facetResults.size(); i++) {\n      assertEquals(exp[i], FacetTestUtils.toSimpleString(facetResults.get(i)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/FacetResultTest#searchIndex(TaxonomyReader,IndexSearcher,boolean,String[],String[][],int[]).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/FacetResultTest#searchIndex(TaxonomyReader,IndexSearcher,boolean,String[],String[][],int[]).mjava","sourceNew":"  private void searchIndex(TaxonomyReader taxoReader, IndexSearcher searcher, boolean fillMissingCounts, String[] exp,\n      String[][] drillDowns, int[] numResults) throws IOException {\n    CategoryPath[][] cps = new CategoryPath[drillDowns.length][];\n    for (int i = 0; i < cps.length; i++) {\n      cps[i] = new CategoryPath[drillDowns[i].length];\n      for (int j = 0; j < cps[i].length; j++) {\n        cps[i][j] = new CategoryPath(drillDowns[i][j], '/');\n      }\n    }\n    DrillDownQuery ddq = new DrillDownQuery(FacetIndexingParams.DEFAULT, new MatchAllDocsQuery());\n    for (CategoryPath[] cats : cps) {\n      ddq.add(cats);\n    }\n    \n    List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n    for (CategoryPath[] cats : cps) {\n      for (int i = 0; i < cats.length; i++) {\n        CategoryPath cp = cats[i];\n        int numres = numResults == null ? 2 : numResults[i];\n        // for each drill-down, add itself as well as its parent as requests, so\n        // we get the drill-sideways\n        facetRequests.add(new CountFacetRequest(cp, numres));\n        CountFacetRequest parent = new CountFacetRequest(cp.subpath(cp.length - 1), numres);\n        if (!facetRequests.contains(parent) && parent.categoryPath.length > 0) {\n          facetRequests.add(parent);\n        }\n      }\n    }\n    \n    FacetSearchParams fsp = new FacetSearchParams(facetRequests);\n    final DrillSideways ds;\n    final Map<String,FacetArrays> dimArrays;\n    if (fillMissingCounts) {\n      dimArrays = new HashMap<String,FacetArrays>();\n      ds = new DrillSideways(searcher, taxoReader) {\n        @Override\n        protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n          FacetsAccumulator fa = super.getDrillSidewaysAccumulator(dim, fsp);\n          dimArrays.put(dim, ((TaxonomyFacetsAccumulator) fa).facetArrays);\n          return fa;\n        }\n      };\n    } else {\n      ds = new DrillSideways(searcher, taxoReader);\n      dimArrays = null;\n    }\n    \n    final DrillSidewaysResult sidewaysRes = ds.search(null, ddq, 5, fsp);\n    List<FacetResult> facetResults = FacetResult.mergeHierarchies(sidewaysRes.facetResults, taxoReader, dimArrays);\n    CollectionUtil.introSort(facetResults, new Comparator<FacetResult>() {\n      @Override\n      public int compare(FacetResult o1, FacetResult o2) {\n        return o1.getFacetRequest().categoryPath.compareTo(o2.getFacetRequest().categoryPath);\n      }\n    });\n    assertEquals(exp.length, facetResults.size()); // A + single one for date\n    for (int i = 0; i < facetResults.size(); i++) {\n      assertEquals(exp[i], FacetTestUtils.toSimpleString(facetResults.get(i)));\n    }\n  }\n\n","sourceOld":"  private void searchIndex(TaxonomyReader taxoReader, IndexSearcher searcher, boolean fillMissingCounts, String[] exp,\n      String[][] drillDowns, int[] numResults) throws IOException {\n    CategoryPath[][] cps = new CategoryPath[drillDowns.length][];\n    for (int i = 0; i < cps.length; i++) {\n      cps[i] = new CategoryPath[drillDowns[i].length];\n      for (int j = 0; j < cps[i].length; j++) {\n        cps[i][j] = new CategoryPath(drillDowns[i][j], '/');\n      }\n    }\n    DrillDownQuery ddq = new DrillDownQuery(FacetIndexingParams.DEFAULT, new MatchAllDocsQuery());\n    for (CategoryPath[] cats : cps) {\n      ddq.add(cats);\n    }\n    \n    List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n    for (CategoryPath[] cats : cps) {\n      for (int i = 0; i < cats.length; i++) {\n        CategoryPath cp = cats[i];\n        int numres = numResults == null ? 2 : numResults[i];\n        // for each drill-down, add itself as well as its parent as requests, so\n        // we get the drill-sideways\n        facetRequests.add(new CountFacetRequest(cp, numres));\n        CountFacetRequest parent = new CountFacetRequest(cp.subpath(cp.length - 1), numres);\n        if (!facetRequests.contains(parent) && parent.categoryPath.length > 0) {\n          facetRequests.add(parent);\n        }\n      }\n    }\n    \n    FacetSearchParams fsp = new FacetSearchParams(facetRequests);\n    final DrillSideways ds;\n    final Map<String,FacetArrays> dimArrays;\n    if (fillMissingCounts) {\n      dimArrays = new HashMap<String,FacetArrays>();\n      ds = new DrillSideways(searcher, taxoReader) {\n        @Override\n        protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n          FacetsAccumulator fa = super.getDrillSidewaysAccumulator(dim, fsp);\n          dimArrays.put(dim, fa.facetArrays);\n          return fa;\n        }\n      };\n    } else {\n      ds = new DrillSideways(searcher, taxoReader);\n      dimArrays = null;\n    }\n    \n    final DrillSidewaysResult sidewaysRes = ds.search(null, ddq, 5, fsp);\n    List<FacetResult> facetResults = FacetResult.mergeHierarchies(sidewaysRes.facetResults, taxoReader, dimArrays);\n    CollectionUtil.introSort(facetResults, new Comparator<FacetResult>() {\n      @Override\n      public int compare(FacetResult o1, FacetResult o2) {\n        return o1.getFacetRequest().categoryPath.compareTo(o2.getFacetRequest().categoryPath);\n      }\n    });\n    assertEquals(exp.length, facetResults.size()); // A + single one for date\n    for (int i = 0; i < facetResults.size(); i++) {\n      assertEquals(exp[i], FacetTestUtils.toSimpleString(facetResults.get(i)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c190847801a50f4dd20fd639bdc29b54ea3b288b","date":1384461522,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/FacetResultTest#searchIndex(TaxonomyReader,IndexSearcher,boolean,String[],String[][],int[]).mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/FacetResultTest#searchIndex(TaxonomyReader,IndexSearcher,boolean,String[],String[][],int[]).mjava","sourceNew":"  private void searchIndex(TaxonomyReader taxoReader, IndexSearcher searcher, boolean fillMissingCounts, String[] exp,\n      String[][] drillDowns, int[] numResults) throws IOException {\n    FacetLabel[][] cps = new FacetLabel[drillDowns.length][];\n    for (int i = 0; i < cps.length; i++) {\n      cps[i] = new FacetLabel[drillDowns[i].length];\n      for (int j = 0; j < cps[i].length; j++) {\n        cps[i][j] = new FacetLabel(drillDowns[i][j], '/');\n      }\n    }\n    DrillDownQuery ddq = new DrillDownQuery(FacetIndexingParams.DEFAULT, new MatchAllDocsQuery());\n    for (FacetLabel[] cats : cps) {\n      ddq.add(cats);\n    }\n    \n    List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n    for (FacetLabel[] cats : cps) {\n      for (int i = 0; i < cats.length; i++) {\n        FacetLabel cp = cats[i];\n        int numres = numResults == null ? 2 : numResults[i];\n        // for each drill-down, add itself as well as its parent as requests, so\n        // we get the drill-sideways\n        facetRequests.add(new CountFacetRequest(cp, numres));\n        CountFacetRequest parent = new CountFacetRequest(cp.subpath(cp.length - 1), numres);\n        if (!facetRequests.contains(parent) && parent.categoryPath.length > 0) {\n          facetRequests.add(parent);\n        }\n      }\n    }\n    \n    FacetSearchParams fsp = new FacetSearchParams(facetRequests);\n    final DrillSideways ds;\n    final Map<String,FacetArrays> dimArrays;\n    if (fillMissingCounts) {\n      dimArrays = new HashMap<String,FacetArrays>();\n      ds = new DrillSideways(searcher, taxoReader) {\n        @Override\n        protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n          FacetsAccumulator fa = super.getDrillSidewaysAccumulator(dim, fsp);\n          dimArrays.put(dim, ((TaxonomyFacetsAccumulator) fa).facetArrays);\n          return fa;\n        }\n      };\n    } else {\n      ds = new DrillSideways(searcher, taxoReader);\n      dimArrays = null;\n    }\n    \n    final DrillSidewaysResult sidewaysRes = ds.search(null, ddq, 5, fsp);\n    List<FacetResult> facetResults = FacetResult.mergeHierarchies(sidewaysRes.facetResults, taxoReader, dimArrays);\n    CollectionUtil.introSort(facetResults, new Comparator<FacetResult>() {\n      @Override\n      public int compare(FacetResult o1, FacetResult o2) {\n        return o1.getFacetRequest().categoryPath.compareTo(o2.getFacetRequest().categoryPath);\n      }\n    });\n    assertEquals(exp.length, facetResults.size()); // A + single one for date\n    for (int i = 0; i < facetResults.size(); i++) {\n      assertEquals(exp[i], FacetTestUtils.toSimpleString(facetResults.get(i)));\n    }\n  }\n\n","sourceOld":"  private void searchIndex(TaxonomyReader taxoReader, IndexSearcher searcher, boolean fillMissingCounts, String[] exp,\n      String[][] drillDowns, int[] numResults) throws IOException {\n    CategoryPath[][] cps = new CategoryPath[drillDowns.length][];\n    for (int i = 0; i < cps.length; i++) {\n      cps[i] = new CategoryPath[drillDowns[i].length];\n      for (int j = 0; j < cps[i].length; j++) {\n        cps[i][j] = new CategoryPath(drillDowns[i][j], '/');\n      }\n    }\n    DrillDownQuery ddq = new DrillDownQuery(FacetIndexingParams.DEFAULT, new MatchAllDocsQuery());\n    for (CategoryPath[] cats : cps) {\n      ddq.add(cats);\n    }\n    \n    List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n    for (CategoryPath[] cats : cps) {\n      for (int i = 0; i < cats.length; i++) {\n        CategoryPath cp = cats[i];\n        int numres = numResults == null ? 2 : numResults[i];\n        // for each drill-down, add itself as well as its parent as requests, so\n        // we get the drill-sideways\n        facetRequests.add(new CountFacetRequest(cp, numres));\n        CountFacetRequest parent = new CountFacetRequest(cp.subpath(cp.length - 1), numres);\n        if (!facetRequests.contains(parent) && parent.categoryPath.length > 0) {\n          facetRequests.add(parent);\n        }\n      }\n    }\n    \n    FacetSearchParams fsp = new FacetSearchParams(facetRequests);\n    final DrillSideways ds;\n    final Map<String,FacetArrays> dimArrays;\n    if (fillMissingCounts) {\n      dimArrays = new HashMap<String,FacetArrays>();\n      ds = new DrillSideways(searcher, taxoReader) {\n        @Override\n        protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n          FacetsAccumulator fa = super.getDrillSidewaysAccumulator(dim, fsp);\n          dimArrays.put(dim, ((TaxonomyFacetsAccumulator) fa).facetArrays);\n          return fa;\n        }\n      };\n    } else {\n      ds = new DrillSideways(searcher, taxoReader);\n      dimArrays = null;\n    }\n    \n    final DrillSidewaysResult sidewaysRes = ds.search(null, ddq, 5, fsp);\n    List<FacetResult> facetResults = FacetResult.mergeHierarchies(sidewaysRes.facetResults, taxoReader, dimArrays);\n    CollectionUtil.introSort(facetResults, new Comparator<FacetResult>() {\n      @Override\n      public int compare(FacetResult o1, FacetResult o2) {\n        return o1.getFacetRequest().categoryPath.compareTo(o2.getFacetRequest().categoryPath);\n      }\n    });\n    assertEquals(exp.length, facetResults.size()); // A + single one for date\n    for (int i = 0; i < facetResults.size(); i++) {\n      assertEquals(exp[i], FacetTestUtils.toSimpleString(facetResults.get(i)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca39562b2d7687143fdb601d5de1b8f7b778f1db","date":1385299806,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/FacetResultTest#searchIndex(TaxonomyReader,IndexSearcher,boolean,String[],String[][],int[]).mjava","sourceNew":null,"sourceOld":"  private void searchIndex(TaxonomyReader taxoReader, IndexSearcher searcher, boolean fillMissingCounts, String[] exp,\n      String[][] drillDowns, int[] numResults) throws IOException {\n    FacetLabel[][] cps = new FacetLabel[drillDowns.length][];\n    for (int i = 0; i < cps.length; i++) {\n      cps[i] = new FacetLabel[drillDowns[i].length];\n      for (int j = 0; j < cps[i].length; j++) {\n        cps[i][j] = new FacetLabel(drillDowns[i][j], '/');\n      }\n    }\n    DrillDownQuery ddq = new DrillDownQuery(FacetIndexingParams.DEFAULT, new MatchAllDocsQuery());\n    for (FacetLabel[] cats : cps) {\n      ddq.add(cats);\n    }\n    \n    List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n    for (FacetLabel[] cats : cps) {\n      for (int i = 0; i < cats.length; i++) {\n        FacetLabel cp = cats[i];\n        int numres = numResults == null ? 2 : numResults[i];\n        // for each drill-down, add itself as well as its parent as requests, so\n        // we get the drill-sideways\n        facetRequests.add(new CountFacetRequest(cp, numres));\n        CountFacetRequest parent = new CountFacetRequest(cp.subpath(cp.length - 1), numres);\n        if (!facetRequests.contains(parent) && parent.categoryPath.length > 0) {\n          facetRequests.add(parent);\n        }\n      }\n    }\n    \n    FacetSearchParams fsp = new FacetSearchParams(facetRequests);\n    final DrillSideways ds;\n    final Map<String,FacetArrays> dimArrays;\n    if (fillMissingCounts) {\n      dimArrays = new HashMap<String,FacetArrays>();\n      ds = new DrillSideways(searcher, taxoReader) {\n        @Override\n        protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n          FacetsAccumulator fa = super.getDrillSidewaysAccumulator(dim, fsp);\n          dimArrays.put(dim, ((TaxonomyFacetsAccumulator) fa).facetArrays);\n          return fa;\n        }\n      };\n    } else {\n      ds = new DrillSideways(searcher, taxoReader);\n      dimArrays = null;\n    }\n    \n    final DrillSidewaysResult sidewaysRes = ds.search(null, ddq, 5, fsp);\n    List<FacetResult> facetResults = FacetResult.mergeHierarchies(sidewaysRes.facetResults, taxoReader, dimArrays);\n    CollectionUtil.introSort(facetResults, new Comparator<FacetResult>() {\n      @Override\n      public int compare(FacetResult o1, FacetResult o2) {\n        return o1.getFacetRequest().categoryPath.compareTo(o2.getFacetRequest().categoryPath);\n      }\n    });\n    assertEquals(exp.length, facetResults.size()); // A + single one for date\n    for (int i = 0; i < facetResults.size(); i++) {\n      assertEquals(exp[i], FacetTestUtils.toSimpleString(facetResults.get(i)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/FacetResultTest#searchIndex(TaxonomyReader,IndexSearcher,boolean,String[],String[][],int[]).mjava","sourceNew":null,"sourceOld":"  private void searchIndex(TaxonomyReader taxoReader, IndexSearcher searcher, boolean fillMissingCounts, String[] exp,\n      String[][] drillDowns, int[] numResults) throws IOException {\n    CategoryPath[][] cps = new CategoryPath[drillDowns.length][];\n    for (int i = 0; i < cps.length; i++) {\n      cps[i] = new CategoryPath[drillDowns[i].length];\n      for (int j = 0; j < cps[i].length; j++) {\n        cps[i][j] = new CategoryPath(drillDowns[i][j], '/');\n      }\n    }\n    DrillDownQuery ddq = new DrillDownQuery(FacetIndexingParams.DEFAULT, new MatchAllDocsQuery());\n    for (CategoryPath[] cats : cps) {\n      ddq.add(cats);\n    }\n    \n    List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();\n    for (CategoryPath[] cats : cps) {\n      for (int i = 0; i < cats.length; i++) {\n        CategoryPath cp = cats[i];\n        int numres = numResults == null ? 2 : numResults[i];\n        // for each drill-down, add itself as well as its parent as requests, so\n        // we get the drill-sideways\n        facetRequests.add(new CountFacetRequest(cp, numres));\n        CountFacetRequest parent = new CountFacetRequest(cp.subpath(cp.length - 1), numres);\n        if (!facetRequests.contains(parent) && parent.categoryPath.length > 0) {\n          facetRequests.add(parent);\n        }\n      }\n    }\n    \n    FacetSearchParams fsp = new FacetSearchParams(facetRequests);\n    final DrillSideways ds;\n    final Map<String,FacetArrays> dimArrays;\n    if (fillMissingCounts) {\n      dimArrays = new HashMap<String,FacetArrays>();\n      ds = new DrillSideways(searcher, taxoReader) {\n        @Override\n        protected FacetsAccumulator getDrillSidewaysAccumulator(String dim, FacetSearchParams fsp) throws IOException {\n          FacetsAccumulator fa = super.getDrillSidewaysAccumulator(dim, fsp);\n          dimArrays.put(dim, ((TaxonomyFacetsAccumulator) fa).facetArrays);\n          return fa;\n        }\n      };\n    } else {\n      ds = new DrillSideways(searcher, taxoReader);\n      dimArrays = null;\n    }\n    \n    final DrillSidewaysResult sidewaysRes = ds.search(null, ddq, 5, fsp);\n    List<FacetResult> facetResults = FacetResult.mergeHierarchies(sidewaysRes.facetResults, taxoReader, dimArrays);\n    CollectionUtil.introSort(facetResults, new Comparator<FacetResult>() {\n      @Override\n      public int compare(FacetResult o1, FacetResult o2) {\n        return o1.getFacetRequest().categoryPath.compareTo(o2.getFacetRequest().categoryPath);\n      }\n    });\n    assertEquals(exp.length, facetResults.size()); // A + single one for date\n    for (int i = 0; i < facetResults.size(); i++) {\n      assertEquals(exp[i], FacetTestUtils.toSimpleString(facetResults.get(i)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ff6a0dc6ca67172f353dbc6b826e324f84d378ef":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["ff6a0dc6ca67172f353dbc6b826e324f84d378ef"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49","ca39562b2d7687143fdb601d5de1b8f7b778f1db"],"6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49":["ff6a0dc6ca67172f353dbc6b826e324f84d378ef"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"ca39562b2d7687143fdb601d5de1b8f7b778f1db":["c190847801a50f4dd20fd639bdc29b54ea3b288b"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49"]},"commit2Childs":{"ff6a0dc6ca67172f353dbc6b826e324f84d378ef":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ff6a0dc6ca67172f353dbc6b826e324f84d378ef"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49":["3cc728b07df73b197e6d940d27f9b08b63918f13","c190847801a50f4dd20fd639bdc29b54ea3b288b"],"ca39562b2d7687143fdb601d5de1b8f7b778f1db":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["ca39562b2d7687143fdb601d5de1b8f7b778f1db"]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}