{"path":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testRandomCircleToBBox().mjava","commits":[{"id":"ed05bb51ea0663dafe0ae9b600553ef0e851f0e5","date":1458616189,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testRandomCircleToBBox().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#testRandomCircleToBBox().mjava","sourceNew":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = GeoUtils.normalizeLat(randomRangeMaybeSlightlyOutside(bbox.minLat, bbox.maxLat));\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.maxLon, -180));\n            } else {\n              lon = GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(0, bbox.minLon));\n            }\n          } else {\n            lon = GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.minLon, bbox.maxLon));\n          }\n        }\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = quantizeLat(GeoUtils.normalizeLat(randomRangeMaybeSlightlyOutside(bbox.minLat, bbox.maxLat)));\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = quantizeLon(GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.maxLon, -180)));\n            } else {\n              lon = quantizeLon(GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(0, bbox.minLon)));\n            }\n          } else {\n            lon = quantizeLon(GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.minLon, bbox.maxLon)));\n          }\n        }\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec996bf2daff09d61a876319e8fae4aebbea58e3","date":1458661946,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testRandomCircleToBBox().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testRandomCircleToBBox().mjava","sourceNew":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = GeoUtils.normalizeLat(randomRangeMaybeSlightlyOutside(bbox.minLat, bbox.maxLat));\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.maxLon, -180));\n            } else {\n              lon = GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(0, bbox.minLon));\n            }\n          } else {\n            lon = GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.minLon, bbox.maxLon));\n          }\n        }\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = GeoUtils.normalizeLat(randomRangeMaybeSlightlyOutside(bbox.minLat, bbox.maxLat));\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.maxLon, -180));\n            } else {\n              lon = GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(0, bbox.minLon));\n            }\n          } else {\n            lon = GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.minLon, bbox.maxLon));\n          }\n        }\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ca8abb1a4010d2a9e71b0162d3600e898a8a4f56","date":1458685284,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testRandomCircleToBBox().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testRandomCircleToBBox().mjava","sourceNew":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = BaseGeoPointTestCase.normalizeLat(randomRangeMaybeSlightlyOutside(bbox.minLat, bbox.maxLat));\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = BaseGeoPointTestCase.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.maxLon, -180));\n            } else {\n              lon = BaseGeoPointTestCase.normalizeLon(randomRangeMaybeSlightlyOutside(0, bbox.minLon));\n            }\n          } else {\n            lon = BaseGeoPointTestCase.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.minLon, bbox.maxLon));\n          }\n        }\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = GeoUtils.normalizeLat(randomRangeMaybeSlightlyOutside(bbox.minLat, bbox.maxLat));\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.maxLon, -180));\n            } else {\n              lon = GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(0, bbox.minLon));\n            }\n          } else {\n            lon = GeoUtils.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.minLon, bbox.maxLon));\n          }\n        }\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","bugFix":["ed05bb51ea0663dafe0ae9b600553ef0e851f0e5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c1079b0e8cc08b4c818211a4fa79d31f0c66ba9","date":1459176843,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testRandomCircleToBBox().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testRandomCircleToBBox().mjava","sourceNew":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = GeoTestUtil.nextLatitudeAround(bbox.minLat, bbox.maxLat);\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = GeoTestUtil.nextLongitudeAround(bbox.maxLon, -180);\n            } else {\n              lon = GeoTestUtil.nextLongitudeAround(0, bbox.minLon);\n            }\n          } else {\n            lon = GeoTestUtil.nextLongitudeAround(bbox.minLon, bbox.maxLon);\n          }\n        }\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = BaseGeoPointTestCase.normalizeLat(randomRangeMaybeSlightlyOutside(bbox.minLat, bbox.maxLat));\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = BaseGeoPointTestCase.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.maxLon, -180));\n            } else {\n              lon = BaseGeoPointTestCase.normalizeLon(randomRangeMaybeSlightlyOutside(0, bbox.minLon));\n            }\n          } else {\n            lon = BaseGeoPointTestCase.normalizeLon(randomRangeMaybeSlightlyOutside(bbox.minLon, bbox.maxLon));\n          }\n        }\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43ddc1b7a872fafd838d3f3129984ca661e29b36","date":1459526591,"type":3,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testRandomCircleToBBox().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testRandomCircleToBBox().mjava","sourceNew":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      GeoRect bbox = GeoRect.fromPointDistance(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = GeoTestUtil.nextLatitudeAround(bbox.minLat, bbox.maxLat);\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = GeoTestUtil.nextLongitudeAround(bbox.maxLon, -180);\n            } else {\n              lon = GeoTestUtil.nextLongitudeAround(0, bbox.minLon);\n            }\n          } else {\n            lon = GeoTestUtil.nextLongitudeAround(bbox.minLon, bbox.maxLon);\n          }\n        }\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      GeoRect bbox = GeoUtils.circleToBBox(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = GeoTestUtil.nextLatitudeAround(bbox.minLat, bbox.maxLat);\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = GeoTestUtil.nextLongitudeAround(bbox.maxLon, -180);\n            } else {\n              lon = GeoTestUtil.nextLongitudeAround(0, bbox.minLon);\n            }\n          } else {\n            lon = GeoTestUtil.nextLongitudeAround(bbox.minLon, bbox.maxLon);\n          }\n        }\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe","date":1459623422,"type":5,"author":"nknize","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/geo/TestGeoUtils#testRandomCircleToBBox().mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils#testRandomCircleToBBox().mjava","sourceNew":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      Rectangle bbox = Rectangle.fromPointDistance(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = GeoTestUtil.nextLatitudeAround(bbox.minLat, bbox.maxLat);\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = GeoTestUtil.nextLongitudeAround(bbox.maxLon, -180);\n            } else {\n              lon = GeoTestUtil.nextLongitudeAround(0, bbox.minLon);\n            }\n          } else {\n            lon = GeoTestUtil.nextLongitudeAround(bbox.minLon, bbox.maxLon);\n          }\n        }\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // We rely heavily on GeoUtils.circleToBBox so we test it here:\n  public void testRandomCircleToBBox() throws Exception {\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n\n      boolean useSmallRanges = random().nextBoolean();\n\n      double radiusMeters;\n\n      double centerLat = randomLat(useSmallRanges);\n      double centerLon = randomLon(useSmallRanges);\n\n      if (useSmallRanges) {\n        // Approx 4 degrees lon at the equator:\n        radiusMeters = random().nextDouble() * 444000;\n      } else {\n        radiusMeters = random().nextDouble() * 50000000;\n      }\n\n      // TODO: randomly quantize radius too, to provoke exact math errors?\n\n      GeoRect bbox = GeoRect.fromPointDistance(centerLat, centerLon, radiusMeters);\n\n      int numPointsToTry = 1000;\n      for(int i=0;i<numPointsToTry;i++) {\n\n        double lat;\n        double lon;\n\n        if (random().nextBoolean()) {\n          lat = randomLat(useSmallRanges);\n          lon = randomLon(useSmallRanges);\n        } else {\n          // pick a lat/lon within the bbox or \"slightly\" outside it to try to improve test efficiency\n          lat = GeoTestUtil.nextLatitudeAround(bbox.minLat, bbox.maxLat);\n          if (bbox.crossesDateline()) {\n            if (random().nextBoolean()) {\n              lon = GeoTestUtil.nextLongitudeAround(bbox.maxLon, -180);\n            } else {\n              lon = GeoTestUtil.nextLongitudeAround(0, bbox.minLon);\n            }\n          } else {\n            lon = GeoTestUtil.nextLongitudeAround(bbox.minLon, bbox.maxLon);\n          }\n        }\n\n        double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);\n\n        // Haversin says it's within the circle:\n        boolean haversinSays = distanceMeters <= radiusMeters;\n\n        // BBox says its within the box:\n        boolean bboxSays;\n        if (bbox.crossesDateline()) {\n          if (lat >= bbox.minLat && lat <= bbox.maxLat) {\n            bboxSays = lon <= bbox.maxLon || lon >= bbox.minLon;\n          } else {\n            bboxSays = false;\n          }\n        } else {\n          bboxSays = lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;\n        }\n\n        if (haversinSays) {\n          if (bboxSays == false) {\n            System.out.println(\"small=\" + useSmallRanges + \" centerLat=\" + centerLat + \" cetnerLon=\" + centerLon + \" radiusMeters=\" + radiusMeters);\n            System.out.println(\"  bbox: lat=\" + bbox.minLat + \" to \" + bbox.maxLat + \" lon=\" + bbox.minLon + \" to \" + bbox.maxLon);\n            System.out.println(\"  point: lat=\" + lat + \" lon=\" + lon);\n            System.out.println(\"  haversin: \" + distanceMeters);\n            fail(\"point was within the distance according to haversin, but the bbox doesn't contain it\");\n          }\n        } else {\n          // it's fine if haversin said it was outside the radius and bbox said it was inside the box\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ca8abb1a4010d2a9e71b0162d3600e898a8a4f56":["ec996bf2daff09d61a876319e8fae4aebbea58e3"],"ec996bf2daff09d61a876319e8fae4aebbea58e3":["ed05bb51ea0663dafe0ae9b600553ef0e851f0e5"],"6c1079b0e8cc08b4c818211a4fa79d31f0c66ba9":["ca8abb1a4010d2a9e71b0162d3600e898a8a4f56"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe":["43ddc1b7a872fafd838d3f3129984ca661e29b36"],"43ddc1b7a872fafd838d3f3129984ca661e29b36":["6c1079b0e8cc08b4c818211a4fa79d31f0c66ba9"],"ed05bb51ea0663dafe0ae9b600553ef0e851f0e5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe"]},"commit2Childs":{"ca8abb1a4010d2a9e71b0162d3600e898a8a4f56":["6c1079b0e8cc08b4c818211a4fa79d31f0c66ba9"],"ec996bf2daff09d61a876319e8fae4aebbea58e3":["ca8abb1a4010d2a9e71b0162d3600e898a8a4f56"],"6c1079b0e8cc08b4c818211a4fa79d31f0c66ba9":["43ddc1b7a872fafd838d3f3129984ca661e29b36"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ed05bb51ea0663dafe0ae9b600553ef0e851f0e5"],"546f71f5b1e19230d6e7e59f117d08dbcf59fbfe":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"43ddc1b7a872fafd838d3f3129984ca661e29b36":["546f71f5b1e19230d6e7e59f117d08dbcf59fbfe"],"ed05bb51ea0663dafe0ae9b600553ef0e851f0e5":["ec996bf2daff09d61a876319e8fae4aebbea58e3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}