{"path":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","pathOld":"modules/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","sourceNew":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    readers[0].taxReader.refresh();\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n  }\n\n","sourceOld":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    readers[0].taxReader.refresh();\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"219dcddcdf2fc13f6271d9e5836bd19c53a4abf1","date":1353511594,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","sourceNew":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    DirectoryTaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(readers[0].taxReader);\n    assertNotNull(newTaxoReader);\n    readers[0].taxReader.close();\n    readers[0].taxReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n  }\n\n","sourceOld":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    readers[0].taxReader.refresh();\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","sourceNew":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    DirectoryTaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(readers[0].taxReader);\n    assertNotNull(newTaxoReader);\n    readers[0].taxReader.close();\n    readers[0].taxReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n  }\n\n","sourceOld":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    readers[0].taxReader.refresh();\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4c6c7f3cda7a0595cabd16e5e9107ca29852708","date":1355402234,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","sourceNew":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils.createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    DirectoryTaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(readers[0].taxReader);\n    assertNotNull(newTaxoReader);\n    readers[0].taxReader.close();\n    readers[0].taxReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n  }\n\n","sourceOld":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    DirectoryTaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(readers[0].taxReader);\n    assertNotNull(newTaxoReader);\n    readers[0].taxReader.close();\n    readers[0].taxReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","sourceNew":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils.createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    DirectoryTaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(readers[0].taxReader);\n    assertNotNull(newTaxoReader);\n    readers[0].taxReader.close();\n    readers[0].taxReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n  }\n\n","sourceOld":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils\n    .createIndexTaxonomyWriterPair(dirs);\n    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {\n      @Override\n      protected int fixedPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    DirectoryTaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(readers[0].taxReader);\n    assertNotNull(newTaxoReader);\n    readers[0].taxReader.close();\n    readers[0].taxReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c2cd18c7da6f499a33f06fc89c07a463ec074c0","date":1358329431,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","sourceNew":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils.createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    DirectoryTaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(readers[0].taxReader);\n    assertNotNull(newTaxoReader);\n    readers[0].taxReader.close();\n    readers[0].taxReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n  }\n\n","sourceOld":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils.createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    DirectoryTaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(readers[0].taxReader);\n    assertNotNull(newTaxoReader);\n    readers[0].taxReader.close();\n    readers[0].taxReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c4015cd39dff8d4dec562d909f9766debac53aa6","date":1358548736,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","sourceNew":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils.createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    DirectoryTaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(readers[0].taxReader);\n    assertNotNull(newTaxoReader);\n    readers[0].taxReader.close();\n    readers[0].taxReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n  }\n\n","sourceOld":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils.createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams, null);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    DirectoryTaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(readers[0].taxReader);\n    assertNotNull(newTaxoReader);\n    readers[0].taxReader.close();\n    readers[0].taxReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(\n        readers[0].indexReader, readers[0].taxReader, iParams, null);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1289047c4a6e31121c9d3a8f4c7a3fb30179f0fc","date":1359570667,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","sourceNew":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    \n    // Create our index/taxonomy writers\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, indexWriter, taxoWriter, \"a\", \"b\");\n    // Commit Changes\n    indexWriter.commit();\n    taxoWriter.commit();\n\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, indexReader, taxoReader, iParams);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      taxoWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    taxoWriter.commit();\n    TaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(taxoReader);\n    assertNotNull(newTaxoReader);\n    taxoReader.close();\n    taxoReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, indexReader, taxoReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(indexReader, taxoReader, iParams);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    \n    outputFile.delete();\n    IOUtils.close(indexWriter, taxoWriter, indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","sourceOld":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils.createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    DirectoryTaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(readers[0].taxReader);\n    assertNotNull(newTaxoReader);\n    readers[0].taxReader.close();\n    readers[0].taxReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61d5f95d14e5b9b046998c51e16709a398c15226","date":1359603451,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","sourceNew":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    \n    // Create our index/taxonomy writers\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, indexWriter, taxoWriter, \"a\", \"b\");\n    // Commit Changes\n    indexWriter.commit();\n    taxoWriter.commit();\n\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, indexReader, taxoReader, iParams);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      taxoWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    taxoWriter.commit();\n    TaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(taxoReader);\n    assertNotNull(newTaxoReader);\n    taxoReader.close();\n    taxoReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, indexReader, taxoReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(indexReader, taxoReader, iParams);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    \n    outputFile.delete();\n    IOUtils.close(indexWriter, taxoWriter, indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","sourceOld":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    // Create temporary RAMDirectories\n    Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);\n    // Create our index/taxonomy writers\n    IndexTaxonomyWriterPair[] writers = FacetTestUtils.createIndexTaxonomyWriterPair(dirs);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, \"a\", \"b\");\n    // Commit Changes\n    writers[0].indexWriter.commit();\n    writers[0].taxWriter.commit();\n\n    IndexTaxonomyReaderPair[] readers = FacetTestUtils.createIndexTaxonomyReaderPair(dirs);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      writers[0].taxWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    writers[0].taxWriter.commit();\n    DirectoryTaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(readers[0].taxReader);\n    assertNotNull(newTaxoReader);\n    readers[0].taxReader.close();\n    readers[0].taxReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, readers[0].indexReader, readers[0].taxReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(readers[0].indexReader, readers[0].taxReader, iParams);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    outputFile.delete();\n    writers[0].close();\n    readers[0].close();\n    IOUtils.close(dirs[0]);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"607428da722dcb3e86bbd11c63de8986e6275c36","date":1360334150,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/complements/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache#testGrowingTaxonomy().mjava","sourceNew":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    \n    // Create our index/taxonomy writers\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, indexWriter, taxoWriter, \"a\", \"b\");\n    // Commit Changes\n    indexWriter.commit();\n    taxoWriter.commit();\n\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, indexReader, taxoReader, iParams);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      taxoWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    taxoWriter.commit();\n    TaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(taxoReader);\n    assertNotNull(newTaxoReader);\n    taxoReader.close();\n    taxoReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, indexReader, taxoReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(indexReader, taxoReader, iParams);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    \n    outputFile.delete();\n    IOUtils.close(indexWriter, taxoWriter, indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","sourceOld":"  /**\n   * This test is to address a bug in a previous version.  If a TFC cache is\n   * written to disk, and then the taxonomy grows (but the index does not change),\n   * and then the TFC cache is re-read from disk, there will be an exception\n   * thrown, as the integers are read off of the disk according to taxonomy\n   * size, which has changed.\n   */\n  @Test\n  public void testGrowingTaxonomy() throws Exception {\n    Directory indexDir = newDirectory();\n    Directory taxoDir = newDirectory();\n    \n    // Create our index/taxonomy writers\n    IndexWriter indexWriter = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, null));\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    FacetIndexingParams iParams = new FacetIndexingParams() {\n      @Override\n      public int getPartitionSize() {\n        return 2;\n      }\n    };\n    // Add a facet to the index\n    addFacets(iParams, indexWriter, taxoWriter, \"a\", \"b\");\n    // Commit Changes\n    indexWriter.commit();\n    taxoWriter.commit();\n\n    DirectoryReader indexReader = DirectoryReader.open(indexDir);\n    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);\n\n    // Create TFC and write cache to disk\n    File outputFile = _TestUtil.createTempFile(\"test\", \"tmp\", TEMP_DIR);\n    TFC.store(outputFile, indexReader, taxoReader, iParams);\n    \n    // Make the taxonomy grow without touching the index\n    for (int i = 0; i < 10; i++) {\n      taxoWriter.addCategory(new CategoryPath(\"foo\", Integer.toString(i)));\n    }\n    taxoWriter.commit();\n    TaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(taxoReader);\n    assertNotNull(newTaxoReader);\n    taxoReader.close();\n    taxoReader = newTaxoReader;\n\n    initCache();\n\n    // With the bug, this next call should result in an exception\n    TFC.load(outputFile, indexReader, taxoReader, iParams);\n    TotalFacetCounts totalCounts = TFC.getTotalCounts(indexReader, taxoReader, iParams);\n    assertReadFromDisc(totalCounts, 0, \"after reading from disk.\");\n    \n    outputFile.delete();\n    IOUtils.close(indexWriter, taxoWriter, indexReader, taxoReader);\n    IOUtils.close(indexDir, taxoDir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","d4c6c7f3cda7a0595cabd16e5e9107ca29852708"],"607428da722dcb3e86bbd11c63de8986e6275c36":["1289047c4a6e31121c9d3a8f4c7a3fb30179f0fc"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"61d5f95d14e5b9b046998c51e16709a398c15226":["c4015cd39dff8d4dec562d909f9766debac53aa6","1289047c4a6e31121c9d3a8f4c7a3fb30179f0fc"],"c4015cd39dff8d4dec562d909f9766debac53aa6":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","6c2cd18c7da6f499a33f06fc89c07a463ec074c0"],"d4c6c7f3cda7a0595cabd16e5e9107ca29852708":["219dcddcdf2fc13f6271d9e5836bd19c53a4abf1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["b89678825b68eccaf09e6ab71675fc0b0af1e099","219dcddcdf2fc13f6271d9e5836bd19c53a4abf1"],"1289047c4a6e31121c9d3a8f4c7a3fb30179f0fc":["6c2cd18c7da6f499a33f06fc89c07a463ec074c0"],"219dcddcdf2fc13f6271d9e5836bd19c53a4abf1":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"6c2cd18c7da6f499a33f06fc89c07a463ec074c0":["d4c6c7f3cda7a0595cabd16e5e9107ca29852708"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["607428da722dcb3e86bbd11c63de8986e6275c36"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["c4015cd39dff8d4dec562d909f9766debac53aa6"],"607428da722dcb3e86bbd11c63de8986e6275c36":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["407687e67faf6e1f02a211ca078d8e3eed631027","219dcddcdf2fc13f6271d9e5836bd19c53a4abf1"],"61d5f95d14e5b9b046998c51e16709a398c15226":[],"c4015cd39dff8d4dec562d909f9766debac53aa6":["61d5f95d14e5b9b046998c51e16709a398c15226"],"d4c6c7f3cda7a0595cabd16e5e9107ca29852708":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","6c2cd18c7da6f499a33f06fc89c07a463ec074c0"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"1289047c4a6e31121c9d3a8f4c7a3fb30179f0fc":["607428da722dcb3e86bbd11c63de8986e6275c36","61d5f95d14e5b9b046998c51e16709a398c15226"],"219dcddcdf2fc13f6271d9e5836bd19c53a4abf1":["d4c6c7f3cda7a0595cabd16e5e9107ca29852708","407687e67faf6e1f02a211ca078d8e3eed631027"],"6c2cd18c7da6f499a33f06fc89c07a463ec074c0":["c4015cd39dff8d4dec562d909f9766debac53aa6","1289047c4a6e31121c9d3a8f4c7a3fb30179f0fc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["61d5f95d14e5b9b046998c51e16709a398c15226","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}