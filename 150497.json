{"path":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","sourceNew":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n\n          if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n            if (dff.limit > 0) {\n              // set the initial limit higher to increase accuracy\n              dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n              dff.initialMincount = 0;      // TODO: we could change this to 1, but would then need more refinement for small facet result sets?\n            } else {\n              // if limit==-1, then no need to artificially lower mincount to 0 if it's 1\n              dff.initialMincount = Math.min(dff.minCount, 1);\n            }\n          } else {\n            // we're sorting by index order.\n            // if minCount==0, we should always be able to get accurate results w/o over-requesting or refining\n            // if minCount==1, we should be able to get accurate results w/o over-requesting, but we'll need to refine\n            // if minCount==n (>1), we can set the initialMincount to minCount/nShards, rounded up.\n            // For example, we know that if minCount=10 and we have 3 shards, then at least one shard must have a count of 4 for the term\n            // For the minCount>1 case, we can generate too short of a list (miss terms at the end of the list) unless limit==-1\n            // For example: each shard could produce a list of top 10, but some of those could fail to make it into the combined list (i.e.\n            //   we needed to go beyond the top 10 to generate the top 10 combined).  Overrequesting can help a little here, but not as\n            //   much as when sorting by count.\n            if (dff.minCount <= 1) {\n              dff.initialMincount = dff.minCount;\n            } else {\n              dff.initialMincount = (int)Math.ceil((double)dff.minCount / rb.slices.length);\n              // dff.initialMincount = 1;\n            }\n          }\n\n          if (dff.initialMincount != 0) {\n            sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n\n          if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n            if (dff.limit > 0) {\n              // set the initial limit higher to increase accuracy\n              dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n              dff.initialMincount = 0;      // TODO: we could change this to 1, but would then need more refinement for small facet result sets?\n            } else {\n              // if limit==-1, then no need to artificially lower mincount to 0 if it's 1\n              dff.initialMincount = Math.min(dff.minCount, 1);\n            }\n          } else {\n            // we're sorting by index order.\n            // if minCount==0, we should always be able to get accurate results w/o over-requesting or refining\n            // if minCount==1, we should be able to get accurate results w/o over-requesting, but we'll need to refine\n            // if minCount==n (>1), we can set the initialMincount to minCount/nShards, rounded up.\n            // For example, we know that if minCount=10 and we have 3 shards, then at least one shard must have a count of 4 for the term\n            // For the minCount>1 case, we can generate too short of a list (miss terms at the end of the list) unless limit==-1\n            // For example: each shard could produce a list of top 10, but some of those could fail to make it into the combined list (i.e.\n            //   we needed to go beyond the top 10 to generate the top 10 combined).  Overrequesting can help a little here, but not as\n            //   much as when sorting by count.\n            if (dff.minCount <= 1) {\n              dff.initialMincount = dff.minCount;\n            } else {\n              dff.initialMincount = (int)Math.ceil((double)dff.minCount / rb.slices.length);\n              // dff.initialMincount = 1;\n            }\n          }\n\n          if (dff.initialMincount != 0) {\n            sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","sourceNew":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n\n          if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n            if (dff.limit > 0) {\n              // set the initial limit higher to increase accuracy\n              dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n              dff.initialMincount = 0;      // TODO: we could change this to 1, but would then need more refinement for small facet result sets?\n            } else {\n              // if limit==-1, then no need to artificially lower mincount to 0 if it's 1\n              dff.initialMincount = Math.min(dff.minCount, 1);\n            }\n          } else {\n            // we're sorting by index order.\n            // if minCount==0, we should always be able to get accurate results w/o over-requesting or refining\n            // if minCount==1, we should be able to get accurate results w/o over-requesting, but we'll need to refine\n            // if minCount==n (>1), we can set the initialMincount to minCount/nShards, rounded up.\n            // For example, we know that if minCount=10 and we have 3 shards, then at least one shard must have a count of 4 for the term\n            // For the minCount>1 case, we can generate too short of a list (miss terms at the end of the list) unless limit==-1\n            // For example: each shard could produce a list of top 10, but some of those could fail to make it into the combined list (i.e.\n            //   we needed to go beyond the top 10 to generate the top 10 combined).  Overrequesting can help a little here, but not as\n            //   much as when sorting by count.\n            if (dff.minCount <= 1) {\n              dff.initialMincount = dff.minCount;\n            } else {\n              dff.initialMincount = (int)Math.ceil((double)dff.minCount / rb.slices.length);\n              // dff.initialMincount = 1;\n            }\n          }\n\n          if (dff.initialMincount != 0) {\n            sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n\n          if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n            if (dff.limit > 0) {\n              // set the initial limit higher to increase accuracy\n              dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n              dff.initialMincount = 0;      // TODO: we could change this to 1, but would then need more refinement for small facet result sets?\n            } else {\n              // if limit==-1, then no need to artificially lower mincount to 0 if it's 1\n              dff.initialMincount = Math.min(dff.minCount, 1);\n            }\n          } else {\n            // we're sorting by index order.\n            // if minCount==0, we should always be able to get accurate results w/o over-requesting or refining\n            // if minCount==1, we should be able to get accurate results w/o over-requesting, but we'll need to refine\n            // if minCount==n (>1), we can set the initialMincount to minCount/nShards, rounded up.\n            // For example, we know that if minCount=10 and we have 3 shards, then at least one shard must have a count of 4 for the term\n            // For the minCount>1 case, we can generate too short of a list (miss terms at the end of the list) unless limit==-1\n            // For example: each shard could produce a list of top 10, but some of those could fail to make it into the combined list (i.e.\n            //   we needed to go beyond the top 10 to generate the top 10 combined).  Overrequesting can help a little here, but not as\n            //   much as when sorting by count.\n            if (dff.minCount <= 1) {\n              dff.initialMincount = dff.minCount;\n            } else {\n              dff.initialMincount = (int)Math.ceil((double)dff.minCount / rb.slices.length);\n              // dff.initialMincount = 1;\n            }\n          }\n\n          if (dff.initialMincount != 0) {\n            sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","sourceNew":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n\n          if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n            if (dff.limit > 0) {\n              // set the initial limit higher to increase accuracy\n              dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n              dff.initialMincount = 0;      // TODO: we could change this to 1, but would then need more refinement for small facet result sets?\n            } else {\n              // if limit==-1, then no need to artificially lower mincount to 0 if it's 1\n              dff.initialMincount = Math.min(dff.minCount, 1);\n            }\n          } else {\n            // we're sorting by index order.\n            // if minCount==0, we should always be able to get accurate results w/o over-requesting or refining\n            // if minCount==1, we should be able to get accurate results w/o over-requesting, but we'll need to refine\n            // if minCount==n (>1), we can set the initialMincount to minCount/nShards, rounded up.\n            // For example, we know that if minCount=10 and we have 3 shards, then at least one shard must have a count of 4 for the term\n            // For the minCount>1 case, we can generate too short of a list (miss terms at the end of the list) unless limit==-1\n            // For example: each shard could produce a list of top 10, but some of those could fail to make it into the combined list (i.e.\n            //   we needed to go beyond the top 10 to generate the top 10 combined).  Overrequesting can help a little here, but not as\n            //   much as when sorting by count.\n            if (dff.minCount <= 1) {\n              dff.initialMincount = dff.minCount;\n            } else {\n              dff.initialMincount = (int)Math.ceil((double)dff.minCount / rb.slices.length);\n              // dff.initialMincount = 1;\n            }\n          }\n\n          if (dff.initialMincount != 0) {\n            sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n\n          if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n            if (dff.limit > 0) {\n              // set the initial limit higher to increase accuracy\n              dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n              dff.initialMincount = 0;      // TODO: we could change this to 1, but would then need more refinement for small facet result sets?\n            } else {\n              // if limit==-1, then no need to artificially lower mincount to 0 if it's 1\n              dff.initialMincount = Math.min(dff.minCount, 1);\n            }\n          } else {\n            // we're sorting by index order.\n            // if minCount==0, we should always be able to get accurate results w/o over-requesting or refining\n            // if minCount==1, we should be able to get accurate results w/o over-requesting, but we'll need to refine\n            // if minCount==n (>1), we can set the initialMincount to minCount/nShards, rounded up.\n            // For example, we know that if minCount=10 and we have 3 shards, then at least one shard must have a count of 4 for the term\n            // For the minCount>1 case, we can generate too short of a list (miss terms at the end of the list) unless limit==-1\n            // For example: each shard could produce a list of top 10, but some of those could fail to make it into the combined list (i.e.\n            //   we needed to go beyond the top 10 to generate the top 10 combined).  Overrequesting can help a little here, but not as\n            //   much as when sorting by count.\n            if (dff.minCount <= 1) {\n              dff.initialMincount = dff.minCount;\n            } else {\n              dff.initialMincount = (int)Math.ceil((double)dff.minCount / rb.slices.length);\n              // dff.initialMincount = 1;\n            }\n          }\n\n          if (dff.initialMincount != 0) {\n            sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92751ba9273251eab6a2e379ec42a1697a32ff96","date":1407954233,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","sourceNew":"  public void modifyRequest(ResponseBuilder rb, SearchComponent who,ShardRequest sreq) {\n\n    if (!rb.doFacets) return;\n    \n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n      \n      FacetInfo fi = rb._facetInfo;\n      if (fi == null) {\n        rb._facetInfo = fi = new FacetInfo();\n        fi.parse(rb.req.getParams(), rb);\n      }\n      \n      modifyRequestForFieldFacets(rb, sreq, fi);\n      \n      modifyRequestForPivotFacets(rb, sreq, fi.pivotFacets);\n      \n      sreq.params.remove(FacetParams.FACET_MINCOUNT);\n      sreq.params.remove(FacetParams.FACET_OFFSET);\n      \n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":"  @Override\n  public void modifyRequest(ResponseBuilder rb, SearchComponent who, ShardRequest sreq) {\n    if (!rb.doFacets) return;\n\n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n        sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n\n        FacetInfo fi = rb._facetInfo;\n        if (fi == null) {\n          rb._facetInfo = fi = new FacetInfo();\n          fi.parse(rb.req.getParams(), rb);\n          // should already be true...\n          // sreq.params.set(FacetParams.FACET, \"true\");\n        }\n\n        sreq.params.remove(FacetParams.FACET_MINCOUNT);\n        sreq.params.remove(FacetParams.FACET_OFFSET);\n        sreq.params.remove(FacetParams.FACET_LIMIT);\n\n        for (DistribFieldFacet dff : fi.facets.values()) {\n          String paramStart = \"f.\" + dff.field + '.';\n          sreq.params.remove(paramStart + FacetParams.FACET_MINCOUNT);\n          sreq.params.remove(paramStart + FacetParams.FACET_OFFSET);\n\n          dff.initialLimit = dff.limit <= 0 ? dff.limit : dff.offset + dff.limit;\n\n          if (dff.sort.equals(FacetParams.FACET_SORT_COUNT)) {\n            if (dff.limit > 0) {\n              // set the initial limit higher to increase accuracy\n              dff.initialLimit = (int)(dff.initialLimit * 1.5) + 10;\n              dff.initialMincount = 0;      // TODO: we could change this to 1, but would then need more refinement for small facet result sets?\n            } else {\n              // if limit==-1, then no need to artificially lower mincount to 0 if it's 1\n              dff.initialMincount = Math.min(dff.minCount, 1);\n            }\n          } else {\n            // we're sorting by index order.\n            // if minCount==0, we should always be able to get accurate results w/o over-requesting or refining\n            // if minCount==1, we should be able to get accurate results w/o over-requesting, but we'll need to refine\n            // if minCount==n (>1), we can set the initialMincount to minCount/nShards, rounded up.\n            // For example, we know that if minCount=10 and we have 3 shards, then at least one shard must have a count of 4 for the term\n            // For the minCount>1 case, we can generate too short of a list (miss terms at the end of the list) unless limit==-1\n            // For example: each shard could produce a list of top 10, but some of those could fail to make it into the combined list (i.e.\n            //   we needed to go beyond the top 10 to generate the top 10 combined).  Overrequesting can help a little here, but not as\n            //   much as when sorting by count.\n            if (dff.minCount <= 1) {\n              dff.initialMincount = dff.minCount;\n            } else {\n              dff.initialMincount = (int)Math.ceil((double)dff.minCount / rb.slices.length);\n              // dff.initialMincount = 1;\n            }\n          }\n\n          if (dff.initialMincount != 0) {\n            sreq.params.set(paramStart + FacetParams.FACET_MINCOUNT, dff.initialMincount);\n          }\n\n          // Currently this is for testing only and allows overriding of the\n          // facet.limit set to the shards\n          dff.initialLimit = rb.req.getParams().getInt(\"facet.shard.limit\", dff.initialLimit);\n\n          sreq.params.set(paramStart + FacetParams.FACET_LIMIT,  dff.initialLimit);\n      }\n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8ff4734b6c86245e852fe8b6a286716d5e59d415","date":1410194063,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","sourceNew":"  public void modifyRequest(ResponseBuilder rb, SearchComponent who,ShardRequest sreq) {\n\n    if (!rb.doFacets) return;\n    \n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n      \n      FacetInfo fi = rb._facetInfo;\n      if (fi == null) {\n        rb._facetInfo = fi = new FacetInfo();\n        fi.parse(rb.req.getParams(), rb);\n      }\n      \n      modifyRequestForFieldFacets(rb, sreq, fi);\n\n      modifyRequestForRangeFacets(sreq, fi);\n      \n      modifyRequestForPivotFacets(rb, sreq, fi.pivotFacets);\n      \n      sreq.params.remove(FacetParams.FACET_MINCOUNT);\n      sreq.params.remove(FacetParams.FACET_OFFSET);\n      \n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":"  public void modifyRequest(ResponseBuilder rb, SearchComponent who,ShardRequest sreq) {\n\n    if (!rb.doFacets) return;\n    \n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n      \n      FacetInfo fi = rb._facetInfo;\n      if (fi == null) {\n        rb._facetInfo = fi = new FacetInfo();\n        fi.parse(rb.req.getParams(), rb);\n      }\n      \n      modifyRequestForFieldFacets(rb, sreq, fi);\n      \n      modifyRequestForPivotFacets(rb, sreq, fi.pivotFacets);\n      \n      sreq.params.remove(FacetParams.FACET_MINCOUNT);\n      sreq.params.remove(FacetParams.FACET_OFFSET);\n      \n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","bugFix":null,"bugIntro":["fa16b8f2a7bb28ece5a9fdc471357e89de17bc57"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"59d82b0be40ecfcc2c94c776b324e0903a62b844","date":1423535462,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","sourceNew":"  public void modifyRequest(ResponseBuilder rb, SearchComponent who,ShardRequest sreq) {\n\n    if (!rb.doFacets) return;\n    \n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n      \n      FacetInfo fi = rb._facetInfo;\n      if (fi == null) {\n        rb._facetInfo = fi = new FacetInfo();\n        fi.parse(rb.req.getParams(), rb);\n      }\n      \n      modifyRequestForFieldFacets(rb, sreq, fi);\n\n      modifyRequestForRangeFacets(sreq, fi);\n      \n      modifyRequestForPivotFacets(rb, sreq, fi.pivotFacets);\n\n      SpatialHeatmapFacets.distribModifyRequest(sreq, fi.heatmapFacets);\n      \n      sreq.params.remove(FacetParams.FACET_MINCOUNT);\n      sreq.params.remove(FacetParams.FACET_OFFSET);\n      \n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":"  public void modifyRequest(ResponseBuilder rb, SearchComponent who,ShardRequest sreq) {\n\n    if (!rb.doFacets) return;\n    \n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n      \n      FacetInfo fi = rb._facetInfo;\n      if (fi == null) {\n        rb._facetInfo = fi = new FacetInfo();\n        fi.parse(rb.req.getParams(), rb);\n      }\n      \n      modifyRequestForFieldFacets(rb, sreq, fi);\n\n      modifyRequestForRangeFacets(sreq, fi);\n      \n      modifyRequestForPivotFacets(rb, sreq, fi.pivotFacets);\n      \n      sreq.params.remove(FacetParams.FACET_MINCOUNT);\n      sreq.params.remove(FacetParams.FACET_OFFSET);\n      \n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fa16b8f2a7bb28ece5a9fdc471357e89de17bc57","date":1423733077,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/FacetComponent#modifyRequest(ResponseBuilder,SearchComponent,ShardRequest).mjava","sourceNew":"  public void modifyRequest(ResponseBuilder rb, SearchComponent who,ShardRequest sreq) {\n\n    if (!rb.doFacets) return;\n    \n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n      \n      FacetInfo fi = rb._facetInfo;\n      if (fi == null) {\n        rb._facetInfo = fi = new FacetInfo();\n        fi.parse(rb.req.getParams(), rb);\n      }\n      \n      modifyRequestForFieldFacets(rb, sreq, fi);\n\n      modifyRequestForRangeFacets(sreq);\n      \n      modifyRequestForPivotFacets(rb, sreq, fi.pivotFacets);\n\n      SpatialHeatmapFacets.distribModifyRequest(sreq, fi.heatmapFacets);\n      \n      sreq.params.remove(FacetParams.FACET_MINCOUNT);\n      sreq.params.remove(FacetParams.FACET_OFFSET);\n      \n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","sourceOld":"  public void modifyRequest(ResponseBuilder rb, SearchComponent who,ShardRequest sreq) {\n\n    if (!rb.doFacets) return;\n    \n    if ((sreq.purpose & ShardRequest.PURPOSE_GET_TOP_IDS) != 0) {\n      sreq.purpose |= ShardRequest.PURPOSE_GET_FACETS;\n      \n      FacetInfo fi = rb._facetInfo;\n      if (fi == null) {\n        rb._facetInfo = fi = new FacetInfo();\n        fi.parse(rb.req.getParams(), rb);\n      }\n      \n      modifyRequestForFieldFacets(rb, sreq, fi);\n\n      modifyRequestForRangeFacets(sreq, fi);\n      \n      modifyRequestForPivotFacets(rb, sreq, fi.pivotFacets);\n\n      SpatialHeatmapFacets.distribModifyRequest(sreq, fi.heatmapFacets);\n      \n      sreq.params.remove(FacetParams.FACET_MINCOUNT);\n      sreq.params.remove(FacetParams.FACET_OFFSET);\n      \n    } else {\n      // turn off faceting on other requests\n      sreq.params.set(FacetParams.FACET, \"false\");\n      // we could optionally remove faceting params\n    }\n  }\n\n","bugFix":["8ff4734b6c86245e852fe8b6a286716d5e59d415"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"59d82b0be40ecfcc2c94c776b324e0903a62b844":["8ff4734b6c86245e852fe8b6a286716d5e59d415"],"92751ba9273251eab6a2e379ec42a1697a32ff96":["c26f00b574427b55127e869b935845554afde1fa"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8ff4734b6c86245e852fe8b6a286716d5e59d415":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"fa16b8f2a7bb28ece5a9fdc471357e89de17bc57":["59d82b0be40ecfcc2c94c776b324e0903a62b844"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fa16b8f2a7bb28ece5a9fdc471357e89de17bc57"]},"commit2Childs":{"59d82b0be40ecfcc2c94c776b324e0903a62b844":["fa16b8f2a7bb28ece5a9fdc471357e89de17bc57"],"92751ba9273251eab6a2e379ec42a1697a32ff96":["8ff4734b6c86245e852fe8b6a286716d5e59d415"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c903c3d15906a3da96b8c0c2fb704491005fdbdb","c26f00b574427b55127e869b935845554afde1fa","a258fbb26824fd104ed795e5d9033d2d040049ee"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"8ff4734b6c86245e852fe8b6a286716d5e59d415":["59d82b0be40ecfcc2c94c776b324e0903a62b844"],"fa16b8f2a7bb28ece5a9fdc471357e89de17bc57":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}