{"path":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testCompositeHashCodes().mjava","commits":[{"id":"9724f10f3fa18adbeba8d1cbfda62676dae942a3","date":1354829537,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testCompositeHashCodes().mjava","pathOld":"/dev/null","sourceNew":"  public void testCompositeHashCodes() throws Exception {\n    DocRouter router = DocRouter.getDocRouter(CompositeIdRouter.NAME);\n    assertTrue(router instanceof CompositeIdRouter);\n    router = DocRouter.DEFAULT;\n    assertTrue(router instanceof CompositeIdRouter);\n\n    DocCollection coll = createCollection(4, router);\n    doNormalIdHashing(coll);\n\n    // ensure that the shard hashed to is only dependent on the first part of the compound key\n    doId(coll, \"b!foo\", \"shard1\");\n    doId(coll, \"c!bar\", \"shard2\");\n    doId(coll, \"d!baz\", \"shard3\");\n    doId(coll, \"e!qux\", \"shard4\");\n\n    // syntax to specify bits\n    doId(coll, \"b/2!foo\", \"shard1\");\n    doId(coll, \"c/2!bar\", \"shard2\");\n    doId(coll, \"d/2!baz\", \"shard3\");\n    doId(coll, \"e/2!qux\", \"shard4\");\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2507ce20f86051a93cc41e273164d9b1da79b4a3","date":1354830692,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testCompositeHashCodes().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testCompositeHashCodes().mjava","sourceNew":"  public void testCompositeHashCodes() throws Exception {\n    DocRouter router = DocRouter.getDocRouter(CompositeIdRouter.NAME);\n    assertTrue(router instanceof CompositeIdRouter);\n    router = DocRouter.DEFAULT;\n    assertTrue(router instanceof CompositeIdRouter);\n\n    DocCollection coll = createCollection(4, router);\n    doNormalIdHashing(coll);\n\n    // ensure that the shard hashed to is only dependent on the first part of the compound key\n    doId(coll, \"b!foo\", \"shard1\");\n    doId(coll, \"c!bar\", \"shard2\");\n    doId(coll, \"d!baz\", \"shard3\");\n    doId(coll, \"e!qux\", \"shard4\");\n\n    // syntax to specify bits.  Anything over 2 should give the same results as above (since only top 2 bits\n    // affect our 4 slice collection).\n    doId(coll, \"b/2!foo\", \"shard1\");\n    doId(coll, \"c/2!bar\", \"shard2\");\n    doId(coll, \"d/2!baz\", \"shard3\");\n    doId(coll, \"e/2!qux\", \"shard4\");\n\n    doId(coll, \"b/32!foo\", \"shard1\");\n    doId(coll, \"c/32!bar\", \"shard2\");\n    doId(coll, \"d/32!baz\", \"shard3\");\n    doId(coll, \"e/32!qux\", \"shard4\");\n  }\n\n","sourceOld":"  public void testCompositeHashCodes() throws Exception {\n    DocRouter router = DocRouter.getDocRouter(CompositeIdRouter.NAME);\n    assertTrue(router instanceof CompositeIdRouter);\n    router = DocRouter.DEFAULT;\n    assertTrue(router instanceof CompositeIdRouter);\n\n    DocCollection coll = createCollection(4, router);\n    doNormalIdHashing(coll);\n\n    // ensure that the shard hashed to is only dependent on the first part of the compound key\n    doId(coll, \"b!foo\", \"shard1\");\n    doId(coll, \"c!bar\", \"shard2\");\n    doId(coll, \"d!baz\", \"shard3\");\n    doId(coll, \"e!qux\", \"shard4\");\n\n    // syntax to specify bits\n    doId(coll, \"b/2!foo\", \"shard1\");\n    doId(coll, \"c/2!bar\", \"shard2\");\n    doId(coll, \"d/2!baz\", \"shard3\");\n    doId(coll, \"e/2!qux\", \"shard4\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a750dc301414dae3a75a82357bab6acb70979c7e","date":1354891654,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testCompositeHashCodes().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testCompositeHashCodes().mjava","sourceNew":"  public void testCompositeHashCodes() throws Exception {\n    DocRouter router = DocRouter.getDocRouter(CompositeIdRouter.NAME);\n    assertTrue(router instanceof CompositeIdRouter);\n    router = DocRouter.DEFAULT;\n    assertTrue(router instanceof CompositeIdRouter);\n\n    DocCollection coll = createCollection(4, router);\n    doNormalIdHashing(coll);\n\n    // ensure that the shard hashed to is only dependent on the first part of the compound key\n    doId(coll, \"b!foo\", \"shard1\");\n    doId(coll, \"c!bar\", \"shard2\");\n    doId(coll, \"d!baz\", \"shard3\");\n    doId(coll, \"e!qux\", \"shard4\");\n\n    // syntax to specify bits.\n    // Anything over 2 bits should give the same results as above (since only top 2 bits\n    // affect our 4 slice collection).\n    doId(coll, \"b/2!foo\", \"shard1\");\n    doId(coll, \"c/2!bar\", \"shard2\");\n    doId(coll, \"d/2!baz\", \"shard3\");\n    doId(coll, \"e/2!qux\", \"shard4\");\n\n    doId(coll, \"b/32!foo\", \"shard1\");\n    doId(coll, \"c/32!bar\", \"shard2\");\n    doId(coll, \"d/32!baz\", \"shard3\");\n    doId(coll, \"e/32!qux\", \"shard4\");\n\n    // no bits allocated to the first part (kind of odd why anyone would do that though)\n    doIndex(coll, \"foo/0!b\", \"shard1\");\n    doIndex(coll, \"foo/0!c\", \"shard2\");\n    doIndex(coll, \"foo/0!d\", \"shard3\");\n    doIndex(coll, \"foo/0!e\", \"shard4\");\n\n    // means cover whole range on the query side\n    doQuery(coll, \"foo/0!\", \"shard1,shard2,shard3,shard4\");\n\n    doQuery(coll, \"b/1!\", \"shard1,shard2\");   // top bit of hash(b)==1, so shard1 and shard2\n    doQuery(coll, \"d/1!\", \"shard3,shard4\");   // top bit of hash(b)==0, so shard3 and shard4\n  }\n\n","sourceOld":"  public void testCompositeHashCodes() throws Exception {\n    DocRouter router = DocRouter.getDocRouter(CompositeIdRouter.NAME);\n    assertTrue(router instanceof CompositeIdRouter);\n    router = DocRouter.DEFAULT;\n    assertTrue(router instanceof CompositeIdRouter);\n\n    DocCollection coll = createCollection(4, router);\n    doNormalIdHashing(coll);\n\n    // ensure that the shard hashed to is only dependent on the first part of the compound key\n    doId(coll, \"b!foo\", \"shard1\");\n    doId(coll, \"c!bar\", \"shard2\");\n    doId(coll, \"d!baz\", \"shard3\");\n    doId(coll, \"e!qux\", \"shard4\");\n\n    // syntax to specify bits.  Anything over 2 should give the same results as above (since only top 2 bits\n    // affect our 4 slice collection).\n    doId(coll, \"b/2!foo\", \"shard1\");\n    doId(coll, \"c/2!bar\", \"shard2\");\n    doId(coll, \"d/2!baz\", \"shard3\");\n    doId(coll, \"e/2!qux\", \"shard4\");\n\n    doId(coll, \"b/32!foo\", \"shard1\");\n    doId(coll, \"c/32!bar\", \"shard2\");\n    doId(coll, \"d/32!baz\", \"shard3\");\n    doId(coll, \"e/32!qux\", \"shard4\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestHashPartitioner#testCompositeHashCodes().mjava","pathOld":"/dev/null","sourceNew":"  public void testCompositeHashCodes() throws Exception {\n    DocRouter router = DocRouter.getDocRouter(CompositeIdRouter.NAME);\n    assertTrue(router instanceof CompositeIdRouter);\n    router = DocRouter.DEFAULT;\n    assertTrue(router instanceof CompositeIdRouter);\n\n    DocCollection coll = createCollection(4, router);\n    doNormalIdHashing(coll);\n\n    // ensure that the shard hashed to is only dependent on the first part of the compound key\n    doId(coll, \"b!foo\", \"shard1\");\n    doId(coll, \"c!bar\", \"shard2\");\n    doId(coll, \"d!baz\", \"shard3\");\n    doId(coll, \"e!qux\", \"shard4\");\n\n    // syntax to specify bits.\n    // Anything over 2 bits should give the same results as above (since only top 2 bits\n    // affect our 4 slice collection).\n    doId(coll, \"b/2!foo\", \"shard1\");\n    doId(coll, \"c/2!bar\", \"shard2\");\n    doId(coll, \"d/2!baz\", \"shard3\");\n    doId(coll, \"e/2!qux\", \"shard4\");\n\n    doId(coll, \"b/32!foo\", \"shard1\");\n    doId(coll, \"c/32!bar\", \"shard2\");\n    doId(coll, \"d/32!baz\", \"shard3\");\n    doId(coll, \"e/32!qux\", \"shard4\");\n\n    // no bits allocated to the first part (kind of odd why anyone would do that though)\n    doIndex(coll, \"foo/0!b\", \"shard1\");\n    doIndex(coll, \"foo/0!c\", \"shard2\");\n    doIndex(coll, \"foo/0!d\", \"shard3\");\n    doIndex(coll, \"foo/0!e\", \"shard4\");\n\n    // means cover whole range on the query side\n    doQuery(coll, \"foo/0!\", \"shard1,shard2,shard3,shard4\");\n\n    doQuery(coll, \"b/1!\", \"shard1,shard2\");   // top bit of hash(b)==1, so shard1 and shard2\n    doQuery(coll, \"d/1!\", \"shard3,shard4\");   // top bit of hash(b)==0, so shard3 and shard4\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2507ce20f86051a93cc41e273164d9b1da79b4a3":["9724f10f3fa18adbeba8d1cbfda62676dae942a3"],"a750dc301414dae3a75a82357bab6acb70979c7e":["2507ce20f86051a93cc41e273164d9b1da79b4a3"],"9724f10f3fa18adbeba8d1cbfda62676dae942a3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a750dc301414dae3a75a82357bab6acb70979c7e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a750dc301414dae3a75a82357bab6acb70979c7e"]},"commit2Childs":{"2507ce20f86051a93cc41e273164d9b1da79b4a3":["a750dc301414dae3a75a82357bab6acb70979c7e"],"a750dc301414dae3a75a82357bab6acb70979c7e":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9724f10f3fa18adbeba8d1cbfda62676dae942a3":["2507ce20f86051a93cc41e273164d9b1da79b4a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9724f10f3fa18adbeba8d1cbfda62676dae942a3","407687e67faf6e1f02a211ca078d8e3eed631027"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}