{"path":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","commits":[{"id":"0df90bc132fdbbdb6a51c335b2f35e3cdd73845a","date":1391923085,"type":0,"author":"Areek Zillur","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n          new File(indexPath), indexAnalyzer, queryAnalyzer, minPrefixChars, blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["4637747f71df783fc2014ef1f1e0418466e3bed6","d260f7acf1b257299e8b096b3835154485a73694"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d285ea522f4ccece252e83366423b739a17e17df","date":1394126445,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath)),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n          new File(indexPath), indexAnalyzer, queryAnalyzer, minPrefixChars, blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4637747f71df783fc2014ef1f1e0418466e3bed6","date":1394196311,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath)),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n          new File(indexPath), indexAnalyzer, queryAnalyzer, minPrefixChars, blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":["0df90bc132fdbbdb6a51c335b2f35e3cdd73845a"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96ea64d994d340044e0d57aeb6a5871539d10ca5","date":1394225445,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath)),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n          new File(indexPath), indexAnalyzer, queryAnalyzer, minPrefixChars, blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"123698fbe83b595f9e084f0019cd35ab4a01d7f7","date":1399070065,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath)),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath)),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4a9c941a7004ea2e95b10aa67dafa319ff8d8c19","date":1400739326,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath)),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath)),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath)),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath)),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6549d5ea6b7b25525309b981de3ec92b4dff99d1","date":1408666035,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath)),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath)),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":["ec083aa3f3ecd55f91c47009d49e45553f99bd77"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f4abec28b874149a7223e32cc7a01704c27790de","date":1410644789,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath)),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec083aa3f3ecd55f91c47009d49e45553f99bd77","date":1416002645,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true);\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":["6549d5ea6b7b25525309b981de3ec92b4dff99d1"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6fc92bf7f56dcfe9d5bd75dfdc902b9597ea95b3","date":1417215914,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(core.getSolrConfig().luceneMatchVersion, \n                                       FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b459e8a3dade13ab7cb9100d764358ea5412965e","date":1423160641,"type":3,"author":"Tomas Eduardo Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true,\n                                       allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d260f7acf1b257299e8b096b3835154485a73694","date":1427305311,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true,\n                                       allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true,\n                                       allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":["0df90bc132fdbbdb6a51c335b2f35e3cdd73845a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true,\n                                       allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true,\n                                       allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f074d711053c296894efa2d36276eff5030e62e","date":1450779998,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n\n    Double exponent = params.get(EXPONENT) == null ? null : Double.valueOf(params.get(EXPONENT).toString());\n\n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, exponent, true,\n                                       allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n    \n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, true,\n                                       allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd25fa3647fa73152703b8dccb4fb5f43633de20","date":1592060458,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory#create(NamedList,SolrCore).mjava","sourceNew":"  @Override\n  public Lookup create(@SuppressWarnings({\"rawtypes\"})NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n\n    Double exponent = params.get(EXPONENT) == null ? null : Double.valueOf(params.get(EXPONENT).toString());\n\n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, exponent, true,\n                                       allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public Lookup create(NamedList params, SolrCore core) {\n    // mandatory parameter\n    Object fieldTypeName = params.get(QUERY_ANALYZER);\n    if (fieldTypeName == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + QUERY_ANALYZER + \" parameter is mandatory\");\n    }\n    FieldType ft = core.getLatestSchema().getFieldTypeByName(fieldTypeName.toString());\n    if (ft == null) {\n      throw new IllegalArgumentException(\"Error in configuration: \" + fieldTypeName.toString() + \" is not defined in the schema\");\n    }\n    Analyzer indexAnalyzer = ft.getIndexAnalyzer();\n    Analyzer queryAnalyzer = ft.getQueryAnalyzer();\n    \n    // optional parameters\n    \n    String indexPath = params.get(INDEX_PATH) != null\n    ? params.get(INDEX_PATH).toString()\n    : DEFAULT_INDEX_PATH;\n    if (new File(indexPath).isAbsolute() == false) {\n      indexPath = core.getDataDir() + File.separator + indexPath;\n    }\n    \n    int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null\n    ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())\n    : AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS;\n    \n    boolean allTermsRequired = params.get(ALL_TERMS_REQUIRED) != null\n    ? Boolean.getBoolean(params.get(ALL_TERMS_REQUIRED).toString())\n    : AnalyzingInfixSuggester.DEFAULT_ALL_TERMS_REQUIRED;\n    \n    boolean highlight = params.get(HIGHLIGHT) != null\n    ? Boolean.getBoolean(params.get(HIGHLIGHT).toString())\n    : AnalyzingInfixSuggester.DEFAULT_HIGHLIGHT;\n\n    BlenderType blenderType = getBlenderType(params.get(BLENDER_TYPE));\n    \n    int numFactor = params.get(NUM_FACTOR) != null\n    ? Integer.parseInt(params.get(NUM_FACTOR).toString())\n    : BlendedInfixSuggester.DEFAULT_NUM_FACTOR;\n\n    Double exponent = params.get(EXPONENT) == null ? null : Double.valueOf(params.get(EXPONENT).toString());\n\n    try {\n      return new BlendedInfixSuggester(FSDirectory.open(new File(indexPath).toPath()),\n                                       indexAnalyzer, queryAnalyzer, minPrefixChars,\n                                       blenderType, numFactor, exponent, true,\n                                       allTermsRequired, highlight) {\n        @Override\n        public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, int num, boolean allTermsRequired, boolean doHighlight) throws IOException {\n          List<LookupResult> res = super.lookup(key, contexts, num, allTermsRequired, doHighlight);\n          if (doHighlight) {\n            List<LookupResult> res2 = new ArrayList<>();\n            for(LookupResult hit : res) {\n              res2.add(new LookupResult(hit.highlightKey.toString(),\n                                        hit.highlightKey,\n                                        hit.value,\n                                        hit.payload,\n                                        hit.contexts));\n            }\n            res = res2;\n          }\n\n          return res;\n        }\n      };\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"96ea64d994d340044e0d57aeb6a5871539d10ca5":["0df90bc132fdbbdb6a51c335b2f35e3cdd73845a","4637747f71df783fc2014ef1f1e0418466e3bed6"],"d285ea522f4ccece252e83366423b739a17e17df":["0df90bc132fdbbdb6a51c335b2f35e3cdd73845a"],"6549d5ea6b7b25525309b981de3ec92b4dff99d1":["4a9c941a7004ea2e95b10aa67dafa319ff8d8c19"],"6fc92bf7f56dcfe9d5bd75dfdc902b9597ea95b3":["ec083aa3f3ecd55f91c47009d49e45553f99bd77"],"0df90bc132fdbbdb6a51c335b2f35e3cdd73845a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b7605579001505896d48b07160075a5c8b8e128e":["123698fbe83b595f9e084f0019cd35ab4a01d7f7","4a9c941a7004ea2e95b10aa67dafa319ff8d8c19"],"f4abec28b874149a7223e32cc7a01704c27790de":["6549d5ea6b7b25525309b981de3ec92b4dff99d1"],"d260f7acf1b257299e8b096b3835154485a73694":["b459e8a3dade13ab7cb9100d764358ea5412965e"],"4a9c941a7004ea2e95b10aa67dafa319ff8d8c19":["123698fbe83b595f9e084f0019cd35ab4a01d7f7"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["b459e8a3dade13ab7cb9100d764358ea5412965e","d260f7acf1b257299e8b096b3835154485a73694"],"123698fbe83b595f9e084f0019cd35ab4a01d7f7":["4637747f71df783fc2014ef1f1e0418466e3bed6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ec083aa3f3ecd55f91c47009d49e45553f99bd77":["f4abec28b874149a7223e32cc7a01704c27790de"],"6f074d711053c296894efa2d36276eff5030e62e":["d260f7acf1b257299e8b096b3835154485a73694"],"b459e8a3dade13ab7cb9100d764358ea5412965e":["6fc92bf7f56dcfe9d5bd75dfdc902b9597ea95b3"],"4637747f71df783fc2014ef1f1e0418466e3bed6":["0df90bc132fdbbdb6a51c335b2f35e3cdd73845a","d285ea522f4ccece252e83366423b739a17e17df"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["6f074d711053c296894efa2d36276eff5030e62e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bd25fa3647fa73152703b8dccb4fb5f43633de20"]},"commit2Childs":{"96ea64d994d340044e0d57aeb6a5871539d10ca5":[],"d285ea522f4ccece252e83366423b739a17e17df":["4637747f71df783fc2014ef1f1e0418466e3bed6"],"6549d5ea6b7b25525309b981de3ec92b4dff99d1":["f4abec28b874149a7223e32cc7a01704c27790de"],"6fc92bf7f56dcfe9d5bd75dfdc902b9597ea95b3":["b459e8a3dade13ab7cb9100d764358ea5412965e"],"0df90bc132fdbbdb6a51c335b2f35e3cdd73845a":["96ea64d994d340044e0d57aeb6a5871539d10ca5","d285ea522f4ccece252e83366423b739a17e17df","4637747f71df783fc2014ef1f1e0418466e3bed6"],"b7605579001505896d48b07160075a5c8b8e128e":[],"f4abec28b874149a7223e32cc7a01704c27790de":["ec083aa3f3ecd55f91c47009d49e45553f99bd77"],"d260f7acf1b257299e8b096b3835154485a73694":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","6f074d711053c296894efa2d36276eff5030e62e"],"4a9c941a7004ea2e95b10aa67dafa319ff8d8c19":["6549d5ea6b7b25525309b981de3ec92b4dff99d1","b7605579001505896d48b07160075a5c8b8e128e"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0df90bc132fdbbdb6a51c335b2f35e3cdd73845a"],"123698fbe83b595f9e084f0019cd35ab4a01d7f7":["b7605579001505896d48b07160075a5c8b8e128e","4a9c941a7004ea2e95b10aa67dafa319ff8d8c19"],"ec083aa3f3ecd55f91c47009d49e45553f99bd77":["6fc92bf7f56dcfe9d5bd75dfdc902b9597ea95b3"],"4637747f71df783fc2014ef1f1e0418466e3bed6":["96ea64d994d340044e0d57aeb6a5871539d10ca5","123698fbe83b595f9e084f0019cd35ab4a01d7f7"],"b459e8a3dade13ab7cb9100d764358ea5412965e":["d260f7acf1b257299e8b096b3835154485a73694","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"6f074d711053c296894efa2d36276eff5030e62e":["bd25fa3647fa73152703b8dccb4fb5f43633de20"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["96ea64d994d340044e0d57aeb6a5871539d10ca5","b7605579001505896d48b07160075a5c8b8e128e","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}