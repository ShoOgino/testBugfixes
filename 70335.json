{"path":"lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery#verify(double[],double[]).mjava","commits":[{"id":"e91b7d9f5000faefb0e81b98e76ad5b9463283e8","date":1433799348,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery#verify(double[],double[]).mjava","pathOld":"/dev/null","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestGeoPointQuery\"));\n    } else {\n      dir = newDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        if (VERBOSE) {\n          System.out.println(\"  id=\" + id + \" lat=\" + lats[id] + \" lon=\" + lons[id]);\n        }\n        doc.add(new GeoPointField(FIELD_NAME, lons[id], lats[id], Field.Store.NO));\n      } else if (VERBOSE) {\n        System.out.println(\"  id=\" + id + \" skipped\");\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters;iter++) {\n              double lat0 = randomLat();\n              double lat1 = randomLat();\n              double lon0 = randomLon();\n              double lon1 = randomLon();\n\n              if (lat1 < lat0) {\n                double x = lat0;\n                lat0 = lat1;\n                lat1 = x;\n              }\n\n              if (lon1 < lon0) {\n                double x = lon0;\n                lon0 = lon1;\n                lon1 = x;\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" lat=\" + lat0 + \" TO \" + lat1 + \" lon=\" + lon0 + \" TO \" + lon1);\n              }\n\n              Query query;\n              boolean tooBigBBox = false;\n              boolean polySearch = false;\n\n              double bboxLat0 = lat0;\n              double bboxLat1 = lat1;\n              double bboxLon0 = lon0;\n              double bboxLon1 = lon1;\n\n              if (random().nextBoolean()) {\n                query = new GeoPointInBBoxQuery(FIELD_NAME, lon0, lat0, lon1, lat1);\n              } else {\n                polySearch = true;\n                if (random().nextBoolean()) {\n                  // Intentionally pass a \"too big\" bounding box:\n                  double pct = random().nextDouble()*0.5;\n                  double width = lon1-lon0;\n                  bboxLon0 = Math.max(-180.0, lon0-width*pct);\n                  bboxLon1 = Math.min(180.0, lon1+width*pct);\n                  double height = lat1-lat0;\n                  bboxLat0 = Math.max(-90.0, lat0-height*pct);\n                  bboxLat1 = Math.min(90.0, lat1+height*pct);\n                  tooBigBBox = true;\n                }\n                double[] pLats = new double[5];\n                double[] pLons = new double[5];\n                pLats[0] = bboxLat0;\n                pLons[0] = bboxLon0;\n                pLats[1] = bboxLat1;\n                pLons[1] = bboxLon0;\n                pLats[2] = bboxLat1;\n                pLons[2] = bboxLon1;\n                pLats[3] = bboxLat0;\n                pLons[3] = bboxLon1;\n                pLats[4] = bboxLat0;\n                pLons[4] = bboxLon0;\n                query = new GeoPointInPolygonQuery(FIELD_NAME, bboxLon0, bboxLat0, bboxLon1, bboxLat1, pLons, pLats);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (polySearch) {\n                  lat0 = bboxLat0;\n                  lon0 = bboxLon0;\n                  lat1 = bboxLat1;\n                  lon1 = bboxLon1;\n                }\n                // morton encode & decode to compare apples to apples (that is, compare with same hash precision error\n                // present in the index)\n                final long pointHash = GeoUtils.mortonHash(lons[id], lats[id]);\n                final double pointLon = GeoUtils.mortonUnhashLon(pointHash);\n                final double pointLat = GeoUtils.mortonUnhashLat(pointHash);\n                if (!tolerateIgnorance(lat0, lat1, lon0, lon1, pointLat, pointLon)) {\n                  boolean expected = (deleted.contains(id) == false) &&\n                      rectContainsPointEnc(lat0, lat1, lon0, lon1, pointLat, pointLon);\n                  if (hits.get(docID) != expected) {\n                    System.out.println(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + pointLat + \" lon=\" + pointLon + \" (bbox: lat=\" + lat0 + \" TO \" + lat1 + \" lon=\" + lon0 + \" TO \" + lon1 + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \" query=\" + query);\n                    if (tooBigBBox) {\n                      System.out.println(\"  passed too-big bbox: lat=\" + bboxLat0 + \" TO \" + bboxLat1 + \" lon=\" + bboxLon0 + \" TO \" + bboxLon1);\n                    }\n                    fail(\"wrong result\");\n                  }\n                }\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c442e378ef8e2c67515983770bcd5946324adfa3","date":1435310347,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery#verify(double[],double[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestGeoPointQuery\"));\n      iwc.setCodec(TestUtil.getDefaultCodec());\n    } else {\n      dir = newDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        if (VERBOSE) {\n          System.out.println(\"  id=\" + id + \" lat=\" + lats[id] + \" lon=\" + lons[id]);\n        }\n        doc.add(new GeoPointField(FIELD_NAME, lons[id], lats[id], Field.Store.NO));\n      } else if (VERBOSE) {\n        System.out.println(\"  id=\" + id + \" skipped\");\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters;iter++) {\n              double lat0 = randomLat();\n              double lat1 = randomLat();\n              double lon0 = randomLon();\n              double lon1 = randomLon();\n\n              if (lat1 < lat0) {\n                double x = lat0;\n                lat0 = lat1;\n                lat1 = x;\n              }\n\n              if (lon1 < lon0) {\n                double x = lon0;\n                lon0 = lon1;\n                lon1 = x;\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" lat=\" + lat0 + \" TO \" + lat1 + \" lon=\" + lon0 + \" TO \" + lon1);\n              }\n\n              Query query;\n              boolean tooBigBBox = false;\n              boolean polySearch = false;\n\n              double bboxLat0 = lat0;\n              double bboxLat1 = lat1;\n              double bboxLon0 = lon0;\n              double bboxLon1 = lon1;\n\n              if (random().nextBoolean()) {\n                query = new GeoPointInBBoxQuery(FIELD_NAME, lon0, lat0, lon1, lat1);\n              } else {\n                polySearch = true;\n                if (random().nextBoolean()) {\n                  // Intentionally pass a \"too big\" bounding box:\n                  double pct = random().nextDouble()*0.5;\n                  double width = lon1-lon0;\n                  bboxLon0 = Math.max(-180.0, lon0-width*pct);\n                  bboxLon1 = Math.min(180.0, lon1+width*pct);\n                  double height = lat1-lat0;\n                  bboxLat0 = Math.max(-90.0, lat0-height*pct);\n                  bboxLat1 = Math.min(90.0, lat1+height*pct);\n                  tooBigBBox = true;\n                }\n                double[] pLats = new double[5];\n                double[] pLons = new double[5];\n                pLats[0] = bboxLat0;\n                pLons[0] = bboxLon0;\n                pLats[1] = bboxLat1;\n                pLons[1] = bboxLon0;\n                pLats[2] = bboxLat1;\n                pLons[2] = bboxLon1;\n                pLats[3] = bboxLat0;\n                pLons[3] = bboxLon1;\n                pLats[4] = bboxLat0;\n                pLons[4] = bboxLon0;\n                query = new GeoPointInPolygonQuery(FIELD_NAME, bboxLon0, bboxLat0, bboxLon1, bboxLat1, pLons, pLats);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (polySearch) {\n                  lat0 = bboxLat0;\n                  lon0 = bboxLon0;\n                  lat1 = bboxLat1;\n                  lon1 = bboxLon1;\n                }\n                // morton encode & decode to compare apples to apples (that is, compare with same hash precision error\n                // present in the index)\n                final long pointHash = GeoUtils.mortonHash(lons[id], lats[id]);\n                final double pointLon = GeoUtils.mortonUnhashLon(pointHash);\n                final double pointLat = GeoUtils.mortonUnhashLat(pointHash);\n                if (!tolerateIgnorance(lat0, lat1, lon0, lon1, pointLat, pointLon)) {\n                  boolean expected = (deleted.contains(id) == false) &&\n                      rectContainsPointEnc(lat0, lat1, lon0, lon1, pointLat, pointLon);\n                  if (hits.get(docID) != expected) {\n                    System.out.println(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + pointLat + \" lon=\" + pointLon + \" (bbox: lat=\" + lat0 + \" TO \" + lat1 + \" lon=\" + lon0 + \" TO \" + lon1 + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \" query=\" + query);\n                    if (tooBigBBox) {\n                      System.out.println(\"  passed too-big bbox: lat=\" + bboxLat0 + \" TO \" + bboxLat1 + \" lon=\" + bboxLon0 + \" TO \" + bboxLon1);\n                    }\n                    fail(\"wrong result\");\n                  }\n                }\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestGeoPointQuery\"));\n    } else {\n      dir = newDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        if (VERBOSE) {\n          System.out.println(\"  id=\" + id + \" lat=\" + lats[id] + \" lon=\" + lons[id]);\n        }\n        doc.add(new GeoPointField(FIELD_NAME, lons[id], lats[id], Field.Store.NO));\n      } else if (VERBOSE) {\n        System.out.println(\"  id=\" + id + \" skipped\");\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters;iter++) {\n              double lat0 = randomLat();\n              double lat1 = randomLat();\n              double lon0 = randomLon();\n              double lon1 = randomLon();\n\n              if (lat1 < lat0) {\n                double x = lat0;\n                lat0 = lat1;\n                lat1 = x;\n              }\n\n              if (lon1 < lon0) {\n                double x = lon0;\n                lon0 = lon1;\n                lon1 = x;\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" lat=\" + lat0 + \" TO \" + lat1 + \" lon=\" + lon0 + \" TO \" + lon1);\n              }\n\n              Query query;\n              boolean tooBigBBox = false;\n              boolean polySearch = false;\n\n              double bboxLat0 = lat0;\n              double bboxLat1 = lat1;\n              double bboxLon0 = lon0;\n              double bboxLon1 = lon1;\n\n              if (random().nextBoolean()) {\n                query = new GeoPointInBBoxQuery(FIELD_NAME, lon0, lat0, lon1, lat1);\n              } else {\n                polySearch = true;\n                if (random().nextBoolean()) {\n                  // Intentionally pass a \"too big\" bounding box:\n                  double pct = random().nextDouble()*0.5;\n                  double width = lon1-lon0;\n                  bboxLon0 = Math.max(-180.0, lon0-width*pct);\n                  bboxLon1 = Math.min(180.0, lon1+width*pct);\n                  double height = lat1-lat0;\n                  bboxLat0 = Math.max(-90.0, lat0-height*pct);\n                  bboxLat1 = Math.min(90.0, lat1+height*pct);\n                  tooBigBBox = true;\n                }\n                double[] pLats = new double[5];\n                double[] pLons = new double[5];\n                pLats[0] = bboxLat0;\n                pLons[0] = bboxLon0;\n                pLats[1] = bboxLat1;\n                pLons[1] = bboxLon0;\n                pLats[2] = bboxLat1;\n                pLons[2] = bboxLon1;\n                pLats[3] = bboxLat0;\n                pLons[3] = bboxLon1;\n                pLats[4] = bboxLat0;\n                pLons[4] = bboxLon0;\n                query = new GeoPointInPolygonQuery(FIELD_NAME, bboxLon0, bboxLat0, bboxLon1, bboxLat1, pLons, pLats);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (polySearch) {\n                  lat0 = bboxLat0;\n                  lon0 = bboxLon0;\n                  lat1 = bboxLat1;\n                  lon1 = bboxLon1;\n                }\n                // morton encode & decode to compare apples to apples (that is, compare with same hash precision error\n                // present in the index)\n                final long pointHash = GeoUtils.mortonHash(lons[id], lats[id]);\n                final double pointLon = GeoUtils.mortonUnhashLon(pointHash);\n                final double pointLat = GeoUtils.mortonUnhashLat(pointHash);\n                if (!tolerateIgnorance(lat0, lat1, lon0, lon1, pointLat, pointLon)) {\n                  boolean expected = (deleted.contains(id) == false) &&\n                      rectContainsPointEnc(lat0, lat1, lon0, lon1, pointLat, pointLon);\n                  if (hits.get(docID) != expected) {\n                    System.out.println(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + pointLat + \" lon=\" + pointLon + \" (bbox: lat=\" + lat0 + \" TO \" + lat1 + \" lon=\" + lon0 + \" TO \" + lon1 + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \" query=\" + query);\n                    if (tooBigBBox) {\n                      System.out.println(\"  passed too-big bbox: lat=\" + bboxLat0 + \" TO \" + bboxLat1 + \" lon=\" + bboxLon0 + \" TO \" + bboxLon1);\n                    }\n                    fail(\"wrong result\");\n                  }\n                }\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a4c5421d43870949fb33be27fc9cba0f8f3a7c8d","date":1437181221,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery#verify(double[],double[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestGeoPointQuery\"));\n      iwc.setCodec(TestUtil.getDefaultCodec());\n    } else {\n      dir = newDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        if (VERBOSE) {\n          System.out.println(\"  id=\" + id + \" lat=\" + lats[id] + \" lon=\" + lons[id]);\n        }\n        doc.add(new GeoPointField(FIELD_NAME, lons[id], lats[id], Field.Store.NO));\n      } else if (VERBOSE) {\n        System.out.println(\"  id=\" + id + \" skipped\");\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(10);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters;iter++) {\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter);\n              }\n\n              Query query;\n\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                GeoBoundingBox bbox = randomBBox();\n\n                query = new GeoPointInBBoxQuery(FIELD_NAME, bbox.minLon, bbox.minLat, bbox.maxLon, bbox.maxLat);\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n\n                      // morton encode & decode to compare apples to apples (that is, compare with same hash precision error\n                      // present in the index)\n                      long pointHash = GeoUtils.mortonHash(pointLon, pointLat);\n                      pointLon = GeoUtils.mortonUnhashLon(pointHash);\n                      pointLat = GeoUtils.mortonUnhashLat(pointHash);\n\n                      if (bboxQueryCanBeWrong(bbox, pointLat, pointLon)) {\n                        return null;\n                      } else {\n                        return rectContainsPointEnc(bbox, pointLat, pointLon);\n                      }\n                    }\n                   };\n              } else if (random().nextBoolean()) {\n                \n                // generate a random bounding box\n                GeoBoundingBox bbox = randomBBox();\n\n                double centerLat = bbox.minLat + ((bbox.maxLat - bbox.minLat)/2.0);\n                double centerLon = bbox.minLon + ((bbox.maxLon - bbox.minLon)/2.0);\n\n                // radius (in meters) as a function of the random generated bbox\n                // TODO: change 100 back to 1000\n                final double radius = SloppyMath.haversin(centerLat, centerLon, bbox.minLat, centerLon)*100;\n                if (VERBOSE) {\n                  System.out.println(\"\\t radius = \" + radius);\n                }\n                // query using the centroid of the bounding box\n                query = new GeoPointDistanceQuery(FIELD_NAME, centerLon, centerLat, radius);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (Double.isNaN(pointLat) || Double.isNaN(pointLon)) {\n                        return null;\n                      }\n                      if (radiusQueryCanBeWrong(centerLat, centerLon, pointLon, pointLat, radius)) {\n                        return null;\n                      } else {\n                        return distanceContainsPt(centerLon, centerLat, pointLon, pointLat, radius);\n                      }\n                    }\n                   };\n                \n              } else {\n                GeoBoundingBox bbox = randomBBox();\n\n                double[] pLats = new double[5];\n                double[] pLons = new double[5];\n                pLats[0] = bbox.minLat;\n                pLons[0] = bbox.minLon;\n                pLats[1] = bbox.maxLat;\n                pLons[1] = bbox.minLon;\n                pLats[2] = bbox.maxLat;\n                pLons[2] = bbox.maxLon;\n                pLats[3] = bbox.minLat;\n                pLons[3] = bbox.maxLon;\n                pLats[4] = bbox.minLat;\n                pLons[4] = bbox.minLon;\n                query = new GeoPointInPolygonQuery(FIELD_NAME, pLons, pLats);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      // morton encode & decode to compare apples to apples (that is, compare with same hash precision error\n                      // present in the index)\n                      long pointHash = GeoUtils.mortonHash(pointLon, pointLat);\n                      pointLon = GeoUtils.mortonUnhashLon(pointHash);\n                      pointLat = GeoUtils.mortonUnhashLat(pointHash);\n\n                      if (bboxQueryCanBeWrong(bbox, pointLat, pointLon)) {\n                        return null;\n                      } else {\n                        return rectContainsPointEnc(bbox, pointLat, pointLon);\n                      }\n                    }\n                  };\n              }\n\n              verifyHits.test(s, docIDToID, deleted, query, lats, lons);\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestGeoPointQuery\"));\n      iwc.setCodec(TestUtil.getDefaultCodec());\n    } else {\n      dir = newDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        if (VERBOSE) {\n          System.out.println(\"  id=\" + id + \" lat=\" + lats[id] + \" lon=\" + lons[id]);\n        }\n        doc.add(new GeoPointField(FIELD_NAME, lons[id], lats[id], Field.Store.NO));\n      } else if (VERBOSE) {\n        System.out.println(\"  id=\" + id + \" skipped\");\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters;iter++) {\n              double lat0 = randomLat();\n              double lat1 = randomLat();\n              double lon0 = randomLon();\n              double lon1 = randomLon();\n\n              if (lat1 < lat0) {\n                double x = lat0;\n                lat0 = lat1;\n                lat1 = x;\n              }\n\n              if (lon1 < lon0) {\n                double x = lon0;\n                lon0 = lon1;\n                lon1 = x;\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter + \" lat=\" + lat0 + \" TO \" + lat1 + \" lon=\" + lon0 + \" TO \" + lon1);\n              }\n\n              Query query;\n              boolean tooBigBBox = false;\n              boolean polySearch = false;\n\n              double bboxLat0 = lat0;\n              double bboxLat1 = lat1;\n              double bboxLon0 = lon0;\n              double bboxLon1 = lon1;\n\n              if (random().nextBoolean()) {\n                query = new GeoPointInBBoxQuery(FIELD_NAME, lon0, lat0, lon1, lat1);\n              } else {\n                polySearch = true;\n                if (random().nextBoolean()) {\n                  // Intentionally pass a \"too big\" bounding box:\n                  double pct = random().nextDouble()*0.5;\n                  double width = lon1-lon0;\n                  bboxLon0 = Math.max(-180.0, lon0-width*pct);\n                  bboxLon1 = Math.min(180.0, lon1+width*pct);\n                  double height = lat1-lat0;\n                  bboxLat0 = Math.max(-90.0, lat0-height*pct);\n                  bboxLat1 = Math.min(90.0, lat1+height*pct);\n                  tooBigBBox = true;\n                }\n                double[] pLats = new double[5];\n                double[] pLons = new double[5];\n                pLats[0] = bboxLat0;\n                pLons[0] = bboxLon0;\n                pLats[1] = bboxLat1;\n                pLons[1] = bboxLon0;\n                pLats[2] = bboxLat1;\n                pLons[2] = bboxLon1;\n                pLats[3] = bboxLat0;\n                pLons[3] = bboxLon1;\n                pLats[4] = bboxLat0;\n                pLons[4] = bboxLon0;\n                query = new GeoPointInPolygonQuery(FIELD_NAME, bboxLon0, bboxLat0, bboxLon1, bboxLat1, pLons, pLats);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (polySearch) {\n                  lat0 = bboxLat0;\n                  lon0 = bboxLon0;\n                  lat1 = bboxLat1;\n                  lon1 = bboxLon1;\n                }\n                // morton encode & decode to compare apples to apples (that is, compare with same hash precision error\n                // present in the index)\n                final long pointHash = GeoUtils.mortonHash(lons[id], lats[id]);\n                final double pointLon = GeoUtils.mortonUnhashLon(pointHash);\n                final double pointLat = GeoUtils.mortonUnhashLat(pointHash);\n                if (!tolerateIgnorance(lat0, lat1, lon0, lon1, pointLat, pointLon)) {\n                  boolean expected = (deleted.contains(id) == false) &&\n                      rectContainsPointEnc(lat0, lat1, lon0, lon1, pointLat, pointLon);\n                  if (hits.get(docID) != expected) {\n                    System.out.println(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + pointLat + \" lon=\" + pointLon + \" (bbox: lat=\" + lat0 + \" TO \" + lat1 + \" lon=\" + lon0 + \" TO \" + lon1 + \") expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \" query=\" + query);\n                    if (tooBigBBox) {\n                      System.out.println(\"  passed too-big bbox: lat=\" + bboxLat0 + \" TO \" + bboxLat1 + \" lon=\" + bboxLon0 + \" TO \" + bboxLon1);\n                    }\n                    fail(\"wrong result\");\n                  }\n                }\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":["fc6e227caf7b84b83df6bb987ca077179f03452f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fc6e227caf7b84b83df6bb987ca077179f03452f","date":1438419526,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery#verify(double[],double[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestGeoPointQuery\"));\n      iwc.setCodec(TestUtil.getDefaultCodec());\n    } else {\n      dir = newDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        if (VERBOSE) {\n          System.out.println(\"  id=\" + id + \" lat=\" + lats[id] + \" lon=\" + lons[id]);\n        }\n        doc.add(new GeoPointField(FIELD_NAME, lons[id], lats[id], Field.Store.NO));\n      } else if (VERBOSE) {\n        System.out.println(\"  id=\" + id + \" skipped\");\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(10);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters;iter++) {\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter);\n              }\n\n              Query query;\n\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                GeoBoundingBox bbox = randomBBox();\n\n                query = new GeoPointInBBoxQuery(FIELD_NAME, bbox.minLon, bbox.minLat, bbox.maxLon, bbox.maxLat);\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n\n                      // morton encode & decode to compare apples to apples (that is, compare with same hash precision error\n                      // present in the index)\n                      long pointHash = GeoUtils.mortonHash(pointLon, pointLat);\n                      pointLon = GeoUtils.mortonUnhashLon(pointHash);\n                      pointLat = GeoUtils.mortonUnhashLat(pointHash);\n\n                      if (bboxQueryCanBeWrong(bbox, pointLat, pointLon)) {\n                        return null;\n                      } else {\n                        return rectContainsPointEnc(bbox, pointLat, pointLon);\n                      }\n                    }\n                   };\n              } else if (random().nextBoolean()) {\n                \n                // generate a random bounding box\n                GeoBoundingBox bbox = randomBBox();\n\n                double centerLat = bbox.minLat + ((bbox.maxLat - bbox.minLat)/2.0);\n                double centerLon = bbox.minLon + ((bbox.maxLon - bbox.minLon)/2.0);\n\n                // radius (in meters) as a function of the random generated bbox\n                final double radius = GeoDistanceUtils.vincentyDistance(centerLon, centerLat, centerLon, bbox.minLat);\n                //final double radius = SloppyMath.haversin(centerLat, centerLon, bbox.minLat, centerLon)*1000;\n                if (VERBOSE) {\n                  System.out.println(\"\\t radius = \" + radius);\n                }\n                // query using the centroid of the bounding box\n                query = new GeoPointDistanceQuery(FIELD_NAME, centerLon, centerLat, radius);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (Double.isNaN(pointLat) || Double.isNaN(pointLon)) {\n                        return null;\n                      }\n                      if (radiusQueryCanBeWrong(centerLat, centerLon, pointLon, pointLat, radius)) {\n                        return null;\n                      } else {\n                        return distanceContainsPt(centerLon, centerLat, pointLon, pointLat, radius);\n                      }\n                    }\n                   };\n                \n              } else {\n                GeoBoundingBox bbox = randomBBox();\n\n                double[] pLats = new double[5];\n                double[] pLons = new double[5];\n                pLats[0] = bbox.minLat;\n                pLons[0] = bbox.minLon;\n                pLats[1] = bbox.maxLat;\n                pLons[1] = bbox.minLon;\n                pLats[2] = bbox.maxLat;\n                pLons[2] = bbox.maxLon;\n                pLats[3] = bbox.minLat;\n                pLons[3] = bbox.maxLon;\n                pLats[4] = bbox.minLat;\n                pLons[4] = bbox.minLon;\n                query = new GeoPointInPolygonQuery(FIELD_NAME, pLons, pLats);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      // morton encode & decode to compare apples to apples (that is, compare with same hash precision error\n                      // present in the index)\n                      long pointHash = GeoUtils.mortonHash(pointLon, pointLat);\n                      pointLon = GeoUtils.mortonUnhashLon(pointHash);\n                      pointLat = GeoUtils.mortonUnhashLat(pointHash);\n\n                      if (bboxQueryCanBeWrong(bbox, pointLat, pointLon)) {\n                        return null;\n                      } else {\n                        return rectContainsPointEnc(bbox, pointLat, pointLon);\n                      }\n                    }\n                  };\n              }\n\n              verifyHits.test(s, docIDToID, deleted, query, lats, lons);\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestGeoPointQuery\"));\n      iwc.setCodec(TestUtil.getDefaultCodec());\n    } else {\n      dir = newDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        if (VERBOSE) {\n          System.out.println(\"  id=\" + id + \" lat=\" + lats[id] + \" lon=\" + lons[id]);\n        }\n        doc.add(new GeoPointField(FIELD_NAME, lons[id], lats[id], Field.Store.NO));\n      } else if (VERBOSE) {\n        System.out.println(\"  id=\" + id + \" skipped\");\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(10);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters;iter++) {\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter);\n              }\n\n              Query query;\n\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                GeoBoundingBox bbox = randomBBox();\n\n                query = new GeoPointInBBoxQuery(FIELD_NAME, bbox.minLon, bbox.minLat, bbox.maxLon, bbox.maxLat);\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n\n                      // morton encode & decode to compare apples to apples (that is, compare with same hash precision error\n                      // present in the index)\n                      long pointHash = GeoUtils.mortonHash(pointLon, pointLat);\n                      pointLon = GeoUtils.mortonUnhashLon(pointHash);\n                      pointLat = GeoUtils.mortonUnhashLat(pointHash);\n\n                      if (bboxQueryCanBeWrong(bbox, pointLat, pointLon)) {\n                        return null;\n                      } else {\n                        return rectContainsPointEnc(bbox, pointLat, pointLon);\n                      }\n                    }\n                   };\n              } else if (random().nextBoolean()) {\n                \n                // generate a random bounding box\n                GeoBoundingBox bbox = randomBBox();\n\n                double centerLat = bbox.minLat + ((bbox.maxLat - bbox.minLat)/2.0);\n                double centerLon = bbox.minLon + ((bbox.maxLon - bbox.minLon)/2.0);\n\n                // radius (in meters) as a function of the random generated bbox\n                // TODO: change 100 back to 1000\n                final double radius = SloppyMath.haversin(centerLat, centerLon, bbox.minLat, centerLon)*100;\n                if (VERBOSE) {\n                  System.out.println(\"\\t radius = \" + radius);\n                }\n                // query using the centroid of the bounding box\n                query = new GeoPointDistanceQuery(FIELD_NAME, centerLon, centerLat, radius);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (Double.isNaN(pointLat) || Double.isNaN(pointLon)) {\n                        return null;\n                      }\n                      if (radiusQueryCanBeWrong(centerLat, centerLon, pointLon, pointLat, radius)) {\n                        return null;\n                      } else {\n                        return distanceContainsPt(centerLon, centerLat, pointLon, pointLat, radius);\n                      }\n                    }\n                   };\n                \n              } else {\n                GeoBoundingBox bbox = randomBBox();\n\n                double[] pLats = new double[5];\n                double[] pLons = new double[5];\n                pLats[0] = bbox.minLat;\n                pLons[0] = bbox.minLon;\n                pLats[1] = bbox.maxLat;\n                pLons[1] = bbox.minLon;\n                pLats[2] = bbox.maxLat;\n                pLons[2] = bbox.maxLon;\n                pLats[3] = bbox.minLat;\n                pLons[3] = bbox.maxLon;\n                pLats[4] = bbox.minLat;\n                pLons[4] = bbox.minLon;\n                query = new GeoPointInPolygonQuery(FIELD_NAME, pLons, pLats);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      // morton encode & decode to compare apples to apples (that is, compare with same hash precision error\n                      // present in the index)\n                      long pointHash = GeoUtils.mortonHash(pointLon, pointLat);\n                      pointLon = GeoUtils.mortonUnhashLon(pointHash);\n                      pointLat = GeoUtils.mortonUnhashLat(pointHash);\n\n                      if (bboxQueryCanBeWrong(bbox, pointLat, pointLon)) {\n                        return null;\n                      } else {\n                        return rectContainsPointEnc(bbox, pointLat, pointLon);\n                      }\n                    }\n                  };\n              }\n\n              verifyHits.test(s, docIDToID, deleted, query, lats, lons);\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":["a4c5421d43870949fb33be27fc9cba0f8f3a7c8d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0222f69d35b097815cb3e3e4843fb6a10e4f80c7","date":1445287257,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery#verify(double[],double[]).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestGeoPointQuery\"));\n      iwc.setCodec(TestUtil.getDefaultCodec());\n    } else {\n      dir = newDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        if (VERBOSE) {\n          System.out.println(\"  id=\" + id + \" lat=\" + lats[id] + \" lon=\" + lons[id]);\n        }\n        doc.add(new GeoPointField(FIELD_NAME, lons[id], lats[id], Field.Store.NO));\n      } else if (VERBOSE) {\n        System.out.println(\"  id=\" + id + \" skipped\");\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(10);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters;iter++) {\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter);\n              }\n\n              Query query;\n\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                GeoBoundingBox bbox = randomBBox();\n\n                query = new GeoPointInBBoxQuery(FIELD_NAME, bbox.minLon, bbox.minLat, bbox.maxLon, bbox.maxLat);\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n\n                      // morton encode & decode to compare apples to apples (that is, compare with same hash precision error\n                      // present in the index)\n                      long pointHash = GeoUtils.mortonHash(pointLon, pointLat);\n                      pointLon = GeoUtils.mortonUnhashLon(pointHash);\n                      pointLat = GeoUtils.mortonUnhashLat(pointHash);\n\n                      if (bboxQueryCanBeWrong(bbox, pointLat, pointLon)) {\n                        return null;\n                      } else {\n                        return rectContainsPointEnc(bbox, pointLat, pointLon);\n                      }\n                    }\n                   };\n              } else if (random().nextBoolean()) {\n                // generate a random bounding box\n                GeoBoundingBox bbox = randomBBox();\n\n                double centerLat = bbox.minLat + ((bbox.maxLat - bbox.minLat)/2.0);\n                double centerLon = bbox.minLon + ((bbox.maxLon - bbox.minLon)/2.0);\n\n                // radius (in meters) as a function of the random generated bbox\n                final double radius =  random().nextDouble() * (0.05 * GeoProjectionUtils.SEMIMINOR_AXIS);\n\n                // randomly test range queries\n                final boolean rangeQuery = random().nextBoolean();\n                final double radiusMax = (rangeQuery) ? radius + random().nextDouble() * (0.05 * GeoProjectionUtils.SEMIMINOR_AXIS) : 0;\n\n                if (VERBOSE) {\n                  System.out.println(\"\\t radius = \" + radius + ((rangeQuery) ? \" : \" + radiusMax : \"\"));\n                }\n\n                // query using the centroid of the bounding box\n                if (rangeQuery) {\n                  query = new GeoPointDistanceRangeQuery(FIELD_NAME, centerLon, centerLat, radius, radiusMax);\n                } else {\n                  query = new GeoPointDistanceQuery(FIELD_NAME, centerLon, centerLat, radius);\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (Double.isNaN(pointLat) || Double.isNaN(pointLon)) {\n                        return null;\n                      }\n                      if (radiusQueryCanBeWrong(centerLat, centerLon, pointLon, pointLat, radius)\n                          || (rangeQuery && radiusQueryCanBeWrong(centerLat, centerLon, pointLon, pointLat, radiusMax))) {\n                        return null;\n                      } else {\n                        return distanceContainsPt(centerLon, centerLat, pointLon, pointLat, radius, (rangeQuery) ? radiusMax : 0);\n                      }\n                    }\n                   };\n              } else {\n                GeoBoundingBox bbox = randomBBox();\n\n                double[] pLats = new double[5];\n                double[] pLons = new double[5];\n                pLats[0] = bbox.minLat;\n                pLons[0] = bbox.minLon;\n                pLats[1] = bbox.maxLat;\n                pLons[1] = bbox.minLon;\n                pLats[2] = bbox.maxLat;\n                pLons[2] = bbox.maxLon;\n                pLats[3] = bbox.minLat;\n                pLons[3] = bbox.maxLon;\n                pLats[4] = bbox.minLat;\n                pLons[4] = bbox.minLon;\n                query = new GeoPointInPolygonQuery(FIELD_NAME, pLons, pLats);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      // morton encode & decode to compare apples to apples (that is, compare with same hash precision error\n                      // present in the index)\n                      long pointHash = GeoUtils.mortonHash(pointLon, pointLat);\n                      pointLon = GeoUtils.mortonUnhashLon(pointHash);\n                      pointLat = GeoUtils.mortonUnhashLat(pointHash);\n\n                      if (bboxQueryCanBeWrong(bbox, pointLat, pointLon)) {\n                        return null;\n                      } else {\n                        return rectContainsPointEnc(bbox, pointLat, pointLon);\n                      }\n                    }\n                  };\n              }\n\n              verifyHits.test(s, docIDToID, deleted, query, lats, lons);\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestGeoPointQuery\"));\n      iwc.setCodec(TestUtil.getDefaultCodec());\n    } else {\n      dir = newDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        if (VERBOSE) {\n          System.out.println(\"  id=\" + id + \" lat=\" + lats[id] + \" lon=\" + lons[id]);\n        }\n        doc.add(new GeoPointField(FIELD_NAME, lons[id], lats[id], Field.Store.NO));\n      } else if (VERBOSE) {\n        System.out.println(\"  id=\" + id + \" skipped\");\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(10);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters;iter++) {\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter);\n              }\n\n              Query query;\n\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                GeoBoundingBox bbox = randomBBox();\n\n                query = new GeoPointInBBoxQuery(FIELD_NAME, bbox.minLon, bbox.minLat, bbox.maxLon, bbox.maxLat);\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n\n                      // morton encode & decode to compare apples to apples (that is, compare with same hash precision error\n                      // present in the index)\n                      long pointHash = GeoUtils.mortonHash(pointLon, pointLat);\n                      pointLon = GeoUtils.mortonUnhashLon(pointHash);\n                      pointLat = GeoUtils.mortonUnhashLat(pointHash);\n\n                      if (bboxQueryCanBeWrong(bbox, pointLat, pointLon)) {\n                        return null;\n                      } else {\n                        return rectContainsPointEnc(bbox, pointLat, pointLon);\n                      }\n                    }\n                   };\n              } else if (random().nextBoolean()) {\n                \n                // generate a random bounding box\n                GeoBoundingBox bbox = randomBBox();\n\n                double centerLat = bbox.minLat + ((bbox.maxLat - bbox.minLat)/2.0);\n                double centerLon = bbox.minLon + ((bbox.maxLon - bbox.minLon)/2.0);\n\n                // radius (in meters) as a function of the random generated bbox\n                final double radius = GeoDistanceUtils.vincentyDistance(centerLon, centerLat, centerLon, bbox.minLat);\n                //final double radius = SloppyMath.haversin(centerLat, centerLon, bbox.minLat, centerLon)*1000;\n                if (VERBOSE) {\n                  System.out.println(\"\\t radius = \" + radius);\n                }\n                // query using the centroid of the bounding box\n                query = new GeoPointDistanceQuery(FIELD_NAME, centerLon, centerLat, radius);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (Double.isNaN(pointLat) || Double.isNaN(pointLon)) {\n                        return null;\n                      }\n                      if (radiusQueryCanBeWrong(centerLat, centerLon, pointLon, pointLat, radius)) {\n                        return null;\n                      } else {\n                        return distanceContainsPt(centerLon, centerLat, pointLon, pointLat, radius);\n                      }\n                    }\n                   };\n                \n              } else {\n                GeoBoundingBox bbox = randomBBox();\n\n                double[] pLats = new double[5];\n                double[] pLons = new double[5];\n                pLats[0] = bbox.minLat;\n                pLons[0] = bbox.minLon;\n                pLats[1] = bbox.maxLat;\n                pLons[1] = bbox.minLon;\n                pLats[2] = bbox.maxLat;\n                pLons[2] = bbox.maxLon;\n                pLats[3] = bbox.minLat;\n                pLons[3] = bbox.maxLon;\n                pLats[4] = bbox.minLat;\n                pLons[4] = bbox.minLon;\n                query = new GeoPointInPolygonQuery(FIELD_NAME, pLons, pLats);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      // morton encode & decode to compare apples to apples (that is, compare with same hash precision error\n                      // present in the index)\n                      long pointHash = GeoUtils.mortonHash(pointLon, pointLat);\n                      pointLon = GeoUtils.mortonUnhashLon(pointHash);\n                      pointLat = GeoUtils.mortonUnhashLat(pointHash);\n\n                      if (bboxQueryCanBeWrong(bbox, pointLat, pointLon)) {\n                        return null;\n                      } else {\n                        return rectContainsPointEnc(bbox, pointLat, pointLon);\n                      }\n                    }\n                  };\n              }\n\n              verifyHits.test(s, docIDToID, deleted, query, lats, lons);\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07c50cb1eca5629cac5b6702dd0f5e06157af61a","date":1445464748,"type":4,"author":"Nick Knize","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery#verify(double[],double[]).mjava","sourceNew":null,"sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestGeoPointQuery\"));\n      iwc.setCodec(TestUtil.getDefaultCodec());\n    } else {\n      dir = newDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        if (VERBOSE) {\n          System.out.println(\"  id=\" + id + \" lat=\" + lats[id] + \" lon=\" + lons[id]);\n        }\n        doc.add(new GeoPointField(FIELD_NAME, lons[id], lats[id], Field.Store.NO));\n      } else if (VERBOSE) {\n        System.out.println(\"  id=\" + id + \" skipped\");\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(10);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters;iter++) {\n              if (VERBOSE) {\n                System.out.println(\"\\nTEST: iter=\" + iter);\n              }\n\n              Query query;\n\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                GeoBoundingBox bbox = randomBBox();\n\n                query = new GeoPointInBBoxQuery(FIELD_NAME, bbox.minLon, bbox.minLat, bbox.maxLon, bbox.maxLat);\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n\n                      // morton encode & decode to compare apples to apples (that is, compare with same hash precision error\n                      // present in the index)\n                      long pointHash = GeoUtils.mortonHash(pointLon, pointLat);\n                      pointLon = GeoUtils.mortonUnhashLon(pointHash);\n                      pointLat = GeoUtils.mortonUnhashLat(pointHash);\n\n                      if (bboxQueryCanBeWrong(bbox, pointLat, pointLon)) {\n                        return null;\n                      } else {\n                        return rectContainsPointEnc(bbox, pointLat, pointLon);\n                      }\n                    }\n                   };\n              } else if (random().nextBoolean()) {\n                // generate a random bounding box\n                GeoBoundingBox bbox = randomBBox();\n\n                double centerLat = bbox.minLat + ((bbox.maxLat - bbox.minLat)/2.0);\n                double centerLon = bbox.minLon + ((bbox.maxLon - bbox.minLon)/2.0);\n\n                // radius (in meters) as a function of the random generated bbox\n                final double radius =  random().nextDouble() * (0.05 * GeoProjectionUtils.SEMIMINOR_AXIS);\n\n                // randomly test range queries\n                final boolean rangeQuery = random().nextBoolean();\n                final double radiusMax = (rangeQuery) ? radius + random().nextDouble() * (0.05 * GeoProjectionUtils.SEMIMINOR_AXIS) : 0;\n\n                if (VERBOSE) {\n                  System.out.println(\"\\t radius = \" + radius + ((rangeQuery) ? \" : \" + radiusMax : \"\"));\n                }\n\n                // query using the centroid of the bounding box\n                if (rangeQuery) {\n                  query = new GeoPointDistanceRangeQuery(FIELD_NAME, centerLon, centerLat, radius, radiusMax);\n                } else {\n                  query = new GeoPointDistanceQuery(FIELD_NAME, centerLon, centerLat, radius);\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (Double.isNaN(pointLat) || Double.isNaN(pointLon)) {\n                        return null;\n                      }\n                      if (radiusQueryCanBeWrong(centerLat, centerLon, pointLon, pointLat, radius)\n                          || (rangeQuery && radiusQueryCanBeWrong(centerLat, centerLon, pointLon, pointLat, radiusMax))) {\n                        return null;\n                      } else {\n                        return distanceContainsPt(centerLon, centerLat, pointLon, pointLat, radius, (rangeQuery) ? radiusMax : 0);\n                      }\n                    }\n                   };\n              } else {\n                GeoBoundingBox bbox = randomBBox();\n\n                double[] pLats = new double[5];\n                double[] pLons = new double[5];\n                pLats[0] = bbox.minLat;\n                pLons[0] = bbox.minLon;\n                pLats[1] = bbox.maxLat;\n                pLons[1] = bbox.minLon;\n                pLats[2] = bbox.maxLat;\n                pLons[2] = bbox.maxLon;\n                pLats[3] = bbox.minLat;\n                pLons[3] = bbox.maxLon;\n                pLats[4] = bbox.minLat;\n                pLons[4] = bbox.minLon;\n                query = new GeoPointInPolygonQuery(FIELD_NAME, pLons, pLats);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      // morton encode & decode to compare apples to apples (that is, compare with same hash precision error\n                      // present in the index)\n                      long pointHash = GeoUtils.mortonHash(pointLon, pointLat);\n                      pointLon = GeoUtils.mortonUnhashLon(pointHash);\n                      pointLat = GeoUtils.mortonUnhashLat(pointHash);\n\n                      if (bboxQueryCanBeWrong(bbox, pointLat, pointLon)) {\n                        return null;\n                      } else {\n                        return rectContainsPointEnc(bbox, pointLat, pointLon);\n                      }\n                    }\n                  };\n              }\n\n              verifyHits.test(s, docIDToID, deleted, query, lats, lons);\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fc6e227caf7b84b83df6bb987ca077179f03452f":["a4c5421d43870949fb33be27fc9cba0f8f3a7c8d"],"a4c5421d43870949fb33be27fc9cba0f8f3a7c8d":["c442e378ef8e2c67515983770bcd5946324adfa3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"07c50cb1eca5629cac5b6702dd0f5e06157af61a":["0222f69d35b097815cb3e3e4843fb6a10e4f80c7"],"e91b7d9f5000faefb0e81b98e76ad5b9463283e8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0222f69d35b097815cb3e3e4843fb6a10e4f80c7":["fc6e227caf7b84b83df6bb987ca077179f03452f"],"c442e378ef8e2c67515983770bcd5946324adfa3":["e91b7d9f5000faefb0e81b98e76ad5b9463283e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["07c50cb1eca5629cac5b6702dd0f5e06157af61a"]},"commit2Childs":{"fc6e227caf7b84b83df6bb987ca077179f03452f":["0222f69d35b097815cb3e3e4843fb6a10e4f80c7"],"a4c5421d43870949fb33be27fc9cba0f8f3a7c8d":["fc6e227caf7b84b83df6bb987ca077179f03452f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e91b7d9f5000faefb0e81b98e76ad5b9463283e8"],"07c50cb1eca5629cac5b6702dd0f5e06157af61a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e91b7d9f5000faefb0e81b98e76ad5b9463283e8":["c442e378ef8e2c67515983770bcd5946324adfa3"],"c442e378ef8e2c67515983770bcd5946324adfa3":["a4c5421d43870949fb33be27fc9cba0f8f3a7c8d"],"0222f69d35b097815cb3e3e4843fb6a10e4f80c7":["07c50cb1eca5629cac5b6702dd0f5e06157af61a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}