{"path":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","commits":[{"id":"ccc08aa684aee4964baee0644a6ba047bfd70829","date":1316263707,"type":0,"author":"Martijn van Groningen","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<String, List<TopGroups<BytesRef>>>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<String, List<QueryCommandResult>>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n    for (ShardResponse srsp : shardRequest.responses) {\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        commandTopDocs.get(query).add((QueryCommandResult) result.get(query));\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<TopDocs>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<Object, ShardDoc>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["85d41890f2bad879e6a04c6dd7d2cf276f973994","a2d7ec084be7fa496e6f93352b6e10427881eb35"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"85d41890f2bad879e6a04c6dd7d2cf276f973994","date":1338488367,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<String, List<TopGroups<BytesRef>>>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<String, List<QueryCommandResult>>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n    for (ShardResponse srsp : shardRequest.responses) {\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        commandTopDocs.get(query).add((QueryCommandResult) result.get(query));\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<TopDocs>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<Object, ShardDoc>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<String, List<TopGroups<BytesRef>>>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<String, List<QueryCommandResult>>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n    for (ShardResponse srsp : shardRequest.responses) {\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        commandTopDocs.get(query).add((QueryCommandResult) result.get(query));\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<TopDocs>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<Object, ShardDoc>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":["ccc08aa684aee4964baee0644a6ba047bfd70829"],"bugIntro":["d423443db06bfcac81733aafcce04ee491880cc7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<String, List<TopGroups<BytesRef>>>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<String, List<QueryCommandResult>>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n    for (ShardResponse srsp : shardRequest.responses) {\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        commandTopDocs.get(query).add((QueryCommandResult) result.get(query));\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<TopDocs>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<Object, ShardDoc>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<String, List<TopGroups<BytesRef>>>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<String, List<QueryCommandResult>>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n    for (ShardResponse srsp : shardRequest.responses) {\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        commandTopDocs.get(query).add((QueryCommandResult) result.get(query));\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<TopDocs>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<Object, ShardDoc>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<String, List<TopGroups<BytesRef>>>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<String, List<QueryCommandResult>>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n    for (ShardResponse srsp : shardRequest.responses) {\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        commandTopDocs.get(query).add((QueryCommandResult) result.get(query));\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<TopDocs>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<Object, ShardDoc>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<String, List<TopGroups<BytesRef>>>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<String, List<QueryCommandResult>>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n    for (ShardResponse srsp : shardRequest.responses) {\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        commandTopDocs.get(query).add((QueryCommandResult) result.get(query));\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<TopDocs>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<Object, ShardDoc>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a2d7ec084be7fa496e6f93352b6e10427881eb35","date":1372781416,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<String, List<TopGroups<BytesRef>>>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<String, List<QueryCommandResult>>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<Object>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<Object>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<TopDocs>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<Object, ShardDoc>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<String, List<TopGroups<BytesRef>>>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<String, List<QueryCommandResult>>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n    for (ShardResponse srsp : shardRequest.responses) {\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        commandTopDocs.get(query).add((QueryCommandResult) result.get(query));\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<TopDocs>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<Object, ShardDoc>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":["ccc08aa684aee4964baee0644a6ba047bfd70829"],"bugIntro":["f6ca8ed75ba81801707cefbfca061b629ab49a8a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<String, List<TopGroups<BytesRef>>>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<String, List<QueryCommandResult>>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<Object>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<Object>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<TopDocs>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<Object, ShardDoc>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<String, List<TopGroups<BytesRef>>>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<String, List<QueryCommandResult>>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n    for (ShardResponse srsp : shardRequest.responses) {\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        commandTopDocs.get(query).add((QueryCommandResult) result.get(query));\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<TopDocs>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<Object, ShardDoc>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d31e5ade44c0d23378d22781e2f2c293afdb25d","date":1386771146,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<String, List<TopGroups<BytesRef>>>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<String, List<QueryCommandResult>>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<Object>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<Object>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<TopDocs>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<Object, ShardDoc>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<String, List<TopGroups<BytesRef>>>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<String, List<QueryCommandResult>>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<Object>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<Object>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<TopDocs>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<Object, ShardDoc>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<String, List<TopGroups<BytesRef>>>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<String, List<QueryCommandResult>>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<Object>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<Object>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<TopDocs>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<Object, ShardDoc>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<String, List<TopGroups<BytesRef>>>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<String, List<QueryCommandResult>>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<Object>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<Object>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<TopDocs>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<Object, ShardDoc>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"167c9d3137acf706f53c875de69f3165df85fd3b","date":1391327271,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<String, List<TopGroups<BytesRef>>>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<String, List<QueryCommandResult>>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<Object>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<Object>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n          rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<TopDocs>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<Object, ShardDoc>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<String, List<TopGroups<BytesRef>>>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<String, List<QueryCommandResult>>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<Object>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<Object>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<TopDocs>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<Object, ShardDoc>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3717ad5d6103c6c5c87888e9d0e791b9124c98b6","date":1392066483,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<String, List<TopGroups<BytesRef>>>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<String, List<QueryCommandResult>>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<Object>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<Object>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n          rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<TopDocs>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<Object, ShardDoc>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<String, List<TopGroups<BytesRef>>>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<String, List<QueryCommandResult>>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<Object>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<Object>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n          rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<TopDocs>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<Object, ShardDoc>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n          rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<String, List<TopGroups<BytesRef>>>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<String, List<QueryCommandResult>>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<Object>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<Object>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n          rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<TopDocs>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<Object, ShardDoc>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"944836102ccff275d4e5382638bc2ec1257ff8bc","date":1413785408,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n          rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n          rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a22eafe3f72a4c2945eaad9547e6c78816978f4","date":1413956657,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n          rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n          rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb17639909a369c1e64866842e5c213440acc17e","date":1423238093,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n          rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup == null) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n          rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        TopDocs mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2","date":1448513807,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n          rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n          rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup == null) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83b038ad0480d5e81e058bf9fafb2dd85399985d","date":1450812495,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(\"partialResults\") == null) {\n          rb.rsp.getResponseHeader().add(\"partialResults\", Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f6ca8ed75ba81801707cefbfca061b629ab49a8a","date":1462970566,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":["a2d7ec084be7fa496e6f93352b6e10427881eb35"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d423443db06bfcac81733aafcce04ee491880cc7","date":1477501011,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        int docsPerGroup = docsPerGroupDefault;\n        if (docsPerGroup < 0) {\n          docsPerGroup = 0;\n          for (TopGroups subTopGroups : topGroups) {\n            docsPerGroup += subTopGroups.totalGroupedHitCount;\n          }\n        }\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":["85d41890f2bad879e6a04c6dd7d2cf276f973994"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        int docsPerGroup = docsPerGroupDefault;\n        if (docsPerGroup < 0) {\n          docsPerGroup = 0;\n          for (TopGroups subTopGroups : topGroups) {\n            docsPerGroup += subTopGroups.totalGroupedHitCount;\n          }\n        }\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroupDefault, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a63d32fe2b29dda520043ef60a1424a4d9ccd5c","date":1480426632,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        int docsPerGroup = docsPerGroupDefault;\n        if (docsPerGroup < 0) {\n          docsPerGroup = 0;\n          for (TopGroups subTopGroups : topGroups) {\n            docsPerGroup += subTopGroups.totalGroupedHitCount;\n          }\n        }\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        int docsPerGroup = docsPerGroupDefault;\n        if (docsPerGroup < 0) {\n          docsPerGroup = 0;\n          for (TopGroups subTopGroups : topGroups) {\n            docsPerGroup += subTopGroups.totalGroupedHitCount;\n          }\n        }\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3f20d97ebbd280405cebcc21d53c781bf4456453","date":1480454130,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        int docsPerGroup = docsPerGroupDefault;\n        if (docsPerGroup < 0) {\n          docsPerGroup = 0;\n          for (TopGroups subTopGroups : topGroups) {\n            docsPerGroup += subTopGroups.totalGroupedHitCount;\n          }\n        }\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        int docsPerGroup = docsPerGroupDefault;\n        if (docsPerGroup < 0) {\n          docsPerGroup = 0;\n          for (TopGroups subTopGroups : topGroups) {\n            docsPerGroup += subTopGroups.totalGroupedHitCount;\n          }\n        }\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b101c3c0e7f5871415e80d970cb3289309f3522e","date":1480511898,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        int docsPerGroup = docsPerGroupDefault;\n        if (docsPerGroup < 0) {\n          docsPerGroup = 0;\n          for (TopGroups subTopGroups : topGroups) {\n            docsPerGroup += subTopGroups.totalGroupedHitCount;\n          }\n        }\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        int docsPerGroup = docsPerGroupDefault;\n        if (docsPerGroup < 0) {\n          docsPerGroup = 0;\n          for (TopGroups subTopGroups : topGroups) {\n            docsPerGroup += subTopGroups.totalGroupedHitCount;\n          }\n        }\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        int docsPerGroup = docsPerGroupDefault;\n        if (docsPerGroup < 0) {\n          docsPerGroup = 0;\n          for (TopGroups subTopGroups : topGroups) {\n            docsPerGroup += subTopGroups.totalGroupedHitCount;\n          }\n        }\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    if (sortWithinGroup == null) { // TODO prevent it from being null in the first place\n      sortWithinGroup = Sort.RELEVANCE;\n    }\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        int docsPerGroup = docsPerGroupDefault;\n        if (docsPerGroup < 0) {\n          docsPerGroup = 0;\n          for (TopGroups subTopGroups : topGroups) {\n            docsPerGroup += subTopGroups.totalGroupedHitCount;\n          }\n        }\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"03e38c6374c23083c93e212a9498ff0a9c255476","date":1484767039,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        topDocs.add(queryCommandResult.getTopDocs());\n        mergedMatches += queryCommandResult.getMatches();\n      }\n\n      int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n      final TopDocs mergedTopDocs;\n      if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n    }\n\n    Map<Object, ShardDoc> resultIds = new HashMap<>();\n    int i = 0;\n    for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n      for (GroupDocs<BytesRef> group : topGroups.groups) {\n        for (ScoreDoc scoreDoc : group.scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          // Include the first if there are duplicate IDs\n          if ( ! resultIds.containsKey(solrDoc.id)) {\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n    }\n    for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n      for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n        ShardDoc solrDoc = (ShardDoc) scoreDoc;\n        solrDoc.positionInResponse = i++;\n        resultIds.put(solrDoc.id, solrDoc);\n      }\n    }\n\n    rb.resultIds = resultIds;\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        int docsPerGroup = docsPerGroupDefault;\n        if (docsPerGroup < 0) {\n          docsPerGroup = 0;\n          for (TopGroups subTopGroups : topGroups) {\n            docsPerGroup += subTopGroups.totalGroupedHitCount;\n          }\n        }\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        topDocs.add(queryCommandResult.getTopDocs());\n        mergedMatches += queryCommandResult.getMatches();\n      }\n\n      int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n      final TopDocs mergedTopDocs;\n      if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n    }\n\n    Map<Object, ShardDoc> resultIds = new HashMap<>();\n    int i = 0;\n    for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n      for (GroupDocs<BytesRef> group : topGroups.groups) {\n        for (ScoreDoc scoreDoc : group.scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          // Include the first if there are duplicate IDs\n          if ( ! resultIds.containsKey(solrDoc.id)) {\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n    }\n    for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n      for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n        ShardDoc solrDoc = (ShardDoc) scoreDoc;\n        solrDoc.positionInResponse = i++;\n        resultIds.put(solrDoc.id, solrDoc);\n      }\n    }\n\n    rb.resultIds = resultIds;\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    try {\n      for (String groupField : commandTopGroups.keySet()) {\n        List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n        if (topGroups.isEmpty()) {\n          continue;\n        }\n\n        TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n        int docsPerGroup = docsPerGroupDefault;\n        if (docsPerGroup < 0) {\n          docsPerGroup = 0;\n          for (TopGroups subTopGroups : topGroups) {\n            docsPerGroup += subTopGroups.totalGroupedHitCount;\n          }\n        }\n        rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n      }\n\n      for (String query : commandTopDocs.keySet()) {\n        List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n        List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n        int mergedMatches = 0;\n        for (QueryCommandResult queryCommandResult : queryCommandResults) {\n          topDocs.add(queryCommandResult.getTopDocs());\n          mergedMatches += queryCommandResult.getMatches();\n        }\n\n        int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n        final TopDocs mergedTopDocs;\n        if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n          mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n        } else {\n          mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n        }\n        rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n      }\n\n      Map<Object, ShardDoc> resultIds = new HashMap<>();\n      int i = 0;\n      for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n        for (GroupDocs<BytesRef> group : topGroups.groups) {\n          for (ScoreDoc scoreDoc : group.scoreDocs) {\n            ShardDoc solrDoc = (ShardDoc) scoreDoc;\n            // Include the first if there are duplicate IDs\n            if ( ! resultIds.containsKey(solrDoc.id)) {\n              solrDoc.positionInResponse = i++;\n              resultIds.put(solrDoc.id, solrDoc);\n            }\n          }\n        }\n      }\n      for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n        for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          solrDoc.positionInResponse = i++;\n          resultIds.put(solrDoc.id, solrDoc);\n        }\n      }\n\n      rb.resultIds = resultIds;\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55f7a37353edeecde86a45f4895ef74901a0158b","date":1492601294,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        topDocs.add(queryCommandResult.getTopDocs());\n        mergedMatches += queryCommandResult.getMatches();\n      }\n\n      int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(withinGroupSort, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n    }\n\n    Map<Object, ShardDoc> resultIds = new HashMap<>();\n    int i = 0;\n    for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n      for (GroupDocs<BytesRef> group : topGroups.groups) {\n        for (ScoreDoc scoreDoc : group.scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          // Include the first if there are duplicate IDs\n          if ( ! resultIds.containsKey(solrDoc.id)) {\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n    }\n    for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n      for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n        ShardDoc solrDoc = (ShardDoc) scoreDoc;\n        solrDoc.positionInResponse = i++;\n        resultIds.put(solrDoc.id, solrDoc);\n      }\n    }\n\n    rb.resultIds = resultIds;\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        topDocs.add(queryCommandResult.getTopDocs());\n        mergedMatches += queryCommandResult.getMatches();\n      }\n\n      int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n      final TopDocs mergedTopDocs;\n      if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n    }\n\n    Map<Object, ShardDoc> resultIds = new HashMap<>();\n    int i = 0;\n    for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n      for (GroupDocs<BytesRef> group : topGroups.groups) {\n        for (ScoreDoc scoreDoc : group.scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          // Include the first if there are duplicate IDs\n          if ( ! resultIds.containsKey(solrDoc.id)) {\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n    }\n    for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n      for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n        ShardDoc solrDoc = (ShardDoc) scoreDoc;\n        solrDoc.positionInResponse = i++;\n        resultIds.put(solrDoc.id, solrDoc);\n      }\n    }\n\n    rb.resultIds = resultIds;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        topDocs.add(queryCommandResult.getTopDocs());\n        mergedMatches += queryCommandResult.getMatches();\n      }\n\n      int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(withinGroupSort, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n    }\n\n    Map<Object, ShardDoc> resultIds = new HashMap<>();\n    int i = 0;\n    for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n      for (GroupDocs<BytesRef> group : topGroups.groups) {\n        for (ScoreDoc scoreDoc : group.scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          // Include the first if there are duplicate IDs\n          if ( ! resultIds.containsKey(solrDoc.id)) {\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n    }\n    for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n      for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n        ShardDoc solrDoc = (ShardDoc) scoreDoc;\n        solrDoc.positionInResponse = i++;\n        resultIds.put(solrDoc.id, solrDoc);\n      }\n    }\n\n    rb.resultIds = resultIds;\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort sortWithinGroup = rb.getGroupingSpec().getSortWithinGroup();\n    assert sortWithinGroup != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, sortWithinGroup, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, sortWithinGroup, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        topDocs.add(queryCommandResult.getTopDocs());\n        mergedMatches += queryCommandResult.getMatches();\n      }\n\n      int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n      final TopDocs mergedTopDocs;\n      if (sortWithinGroup.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(sortWithinGroup, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n    }\n\n    Map<Object, ShardDoc> resultIds = new HashMap<>();\n    int i = 0;\n    for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n      for (GroupDocs<BytesRef> group : topGroups.groups) {\n        for (ScoreDoc scoreDoc : group.scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          // Include the first if there are duplicate IDs\n          if ( ! resultIds.containsKey(solrDoc.id)) {\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n    }\n    for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n      for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n        ShardDoc solrDoc = (ShardDoc) scoreDoc;\n        solrDoc.positionInResponse = i++;\n        resultIds.put(solrDoc.id, solrDoc);\n      }\n    }\n\n    rb.resultIds = resultIds;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a80a37ae73034270b57bfd57a44f8fcadc952fa0","date":1515440719,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        topDocs.add(queryCommandResult.getTopDocs());\n        mergedMatches += queryCommandResult.getMatches();\n      }\n\n      int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(withinGroupSort, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n    }\n\n    Map<Object, ShardDoc> resultIds = new HashMap<>();\n    int i = 0;\n    for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n      for (GroupDocs<BytesRef> group : topGroups.groups) {\n        for (ScoreDoc scoreDoc : group.scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          // Include the first if there are duplicate IDs\n          if ( ! resultIds.containsKey(solrDoc.id)) {\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n    }\n    for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n      for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n        ShardDoc solrDoc = (ShardDoc) scoreDoc;\n        solrDoc.positionInResponse = i++;\n        resultIds.put(solrDoc.id, solrDoc);\n      }\n    }\n\n    rb.resultIds = resultIds;\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        topDocs.add(queryCommandResult.getTopDocs());\n        mergedMatches += queryCommandResult.getMatches();\n      }\n\n      int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(withinGroupSort, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n    }\n\n    Map<Object, ShardDoc> resultIds = new HashMap<>();\n    int i = 0;\n    for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n      for (GroupDocs<BytesRef> group : topGroups.groups) {\n        for (ScoreDoc scoreDoc : group.scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          // Include the first if there are duplicate IDs\n          if ( ! resultIds.containsKey(solrDoc.id)) {\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n    }\n    for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n      for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n        ShardDoc solrDoc = (ShardDoc) scoreDoc;\n        solrDoc.positionInResponse = i++;\n        resultIds.put(solrDoc.id, solrDoc);\n      }\n    }\n\n    rb.resultIds = resultIds;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        topDocs.add(queryCommandResult.getTopDocs());\n        mergedMatches += queryCommandResult.getMatches();\n      }\n\n      int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(withinGroupSort, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n    }\n\n    Map<Object, ShardDoc> resultIds = new HashMap<>();\n    int i = 0;\n    for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n      for (GroupDocs<BytesRef> group : topGroups.groups) {\n        for (ScoreDoc scoreDoc : group.scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          // Include the first if there are duplicate IDs\n          if ( ! resultIds.containsKey(solrDoc.id)) {\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n    }\n    for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n      for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n        ShardDoc solrDoc = (ShardDoc) scoreDoc;\n        solrDoc.positionInResponse = i++;\n        resultIds.put(solrDoc.id, solrDoc);\n      }\n    }\n\n    rb.resultIds = resultIds;\n  }\n\n","sourceOld":"  /**\n   * {@inheritDoc}\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        topDocs.add(queryCommandResult.getTopDocs());\n        mergedMatches += queryCommandResult.getMatches();\n      }\n\n      int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(withinGroupSort, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n    }\n\n    Map<Object, ShardDoc> resultIds = new HashMap<>();\n    int i = 0;\n    for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n      for (GroupDocs<BytesRef> group : topGroups.groups) {\n        for (ScoreDoc scoreDoc : group.scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          // Include the first if there are duplicate IDs\n          if ( ! resultIds.containsKey(solrDoc.id)) {\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n    }\n    for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n      for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n        ShardDoc solrDoc = (ShardDoc) scoreDoc;\n        solrDoc.positionInResponse = i++;\n        resultIds.put(solrDoc.id, solrDoc);\n      }\n    }\n\n    rb.resultIds = resultIds;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bd22dcd3ba035a1626face7319c94be45ae07172","date":1527224634,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        topDocs.add(queryCommandResult.getTopDocs());\n        mergedMatches += queryCommandResult.getMatches();\n      }\n\n      int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(withinGroupSort, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n    }\n\n    Map<Object, ShardDoc> resultIds = new HashMap<>();\n    int i = 0;\n    for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n      for (GroupDocs<BytesRef> group : topGroups.groups) {\n        for (ScoreDoc scoreDoc : group.scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          // Include the first if there are duplicate IDs\n          if ( ! resultIds.containsKey(solrDoc.id)) {\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n    }\n    for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n      for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n        ShardDoc solrDoc = (ShardDoc) scoreDoc;\n        solrDoc.positionInResponse = i++;\n        resultIds.put(solrDoc.id, solrDoc);\n      }\n    }\n\n    rb.resultIds = resultIds;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        topDocs.add(queryCommandResult.getTopDocs());\n        mergedMatches += queryCommandResult.getMatches();\n      }\n\n      int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(withinGroupSort, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n    }\n\n    Map<Object, ShardDoc> resultIds = new HashMap<>();\n    int i = 0;\n    for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n      for (GroupDocs<BytesRef> group : topGroups.groups) {\n        for (ScoreDoc scoreDoc : group.scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          // Include the first if there are duplicate IDs\n          if ( ! resultIds.containsKey(solrDoc.id)) {\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n    }\n    for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n      for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n        ShardDoc solrDoc = (ShardDoc) scoreDoc;\n        solrDoc.positionInResponse = i++;\n        resultIds.put(solrDoc.id, solrDoc);\n      }\n    }\n\n    rb.resultIds = resultIds;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      float maxScore = Float.NaN;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        TopDocs thisTopDocs = queryCommandResult.getTopDocs();\n        topDocs.add(thisTopDocs);\n        mergedMatches += queryCommandResult.getMatches();\n        if (thisTopDocs.scoreDocs.length > 0) {\n          float thisMaxScore = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMaxScore > maxScore) {\n            maxScore = thisMaxScore;\n          }\n        }\n      }\n\n      int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(withinGroupSort, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches, maxScore));\n    }\n\n    Map<Object, ShardDoc> resultIds = new HashMap<>();\n    int i = 0;\n    for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n      for (GroupDocs<BytesRef> group : topGroups.groups) {\n        for (ScoreDoc scoreDoc : group.scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          // Include the first if there are duplicate IDs\n          if ( ! resultIds.containsKey(solrDoc.id)) {\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n    }\n    for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n      for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n        ShardDoc solrDoc = (ShardDoc) scoreDoc;\n        solrDoc.positionInResponse = i++;\n        resultIds.put(solrDoc.id, solrDoc);\n      }\n    }\n\n    rb.resultIds = resultIds;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        topDocs.add(queryCommandResult.getTopDocs());\n        mergedMatches += queryCommandResult.getMatches();\n      }\n\n      int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(withinGroupSort, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n    }\n\n    Map<Object, ShardDoc> resultIds = new HashMap<>();\n    int i = 0;\n    for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n      for (GroupDocs<BytesRef> group : topGroups.groups) {\n        for (ScoreDoc scoreDoc : group.scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          // Include the first if there are duplicate IDs\n          if ( ! resultIds.containsKey(solrDoc.id)) {\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n    }\n    for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n      for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n        ShardDoc solrDoc = (ShardDoc) scoreDoc;\n        solrDoc.positionInResponse = i++;\n        resultIds.put(solrDoc.id, solrDoc);\n      }\n    }\n\n    rb.resultIds = resultIds;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      float maxScore = Float.NaN;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        TopDocs thisTopDocs = queryCommandResult.getTopDocs();\n        topDocs.add(thisTopDocs);\n        mergedMatches += queryCommandResult.getMatches();\n        if (thisTopDocs.scoreDocs.length > 0) {\n          float thisMaxScore = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMaxScore > maxScore) {\n            maxScore = thisMaxScore;\n          }\n        }\n      }\n\n      int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(withinGroupSort, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches, maxScore));\n    }\n\n    Map<Object, ShardDoc> resultIds = new HashMap<>();\n    int i = 0;\n    for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n      for (GroupDocs<BytesRef> group : topGroups.groups) {\n        for (ScoreDoc scoreDoc : group.scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          // Include the first if there are duplicate IDs\n          if ( ! resultIds.containsKey(solrDoc.id)) {\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n    }\n    for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n      for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n        ShardDoc solrDoc = (ShardDoc) scoreDoc;\n        solrDoc.positionInResponse = i++;\n        resultIds.put(solrDoc.id, solrDoc);\n      }\n    }\n\n    rb.resultIds = resultIds;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getTopDocs().getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        topDocs.add(queryCommandResult.getTopDocs());\n        mergedMatches += queryCommandResult.getMatches();\n      }\n\n      int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(withinGroupSort, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));\n    }\n\n    Map<Object, ShardDoc> resultIds = new HashMap<>();\n    int i = 0;\n    for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n      for (GroupDocs<BytesRef> group : topGroups.groups) {\n        for (ScoreDoc scoreDoc : group.scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          // Include the first if there are duplicate IDs\n          if ( ! resultIds.containsKey(solrDoc.id)) {\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n    }\n    for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n      for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n        ShardDoc solrDoc = (ShardDoc) scoreDoc;\n        solrDoc.positionInResponse = i++;\n        resultIds.put(solrDoc.id, solrDoc);\n      }\n    }\n\n    rb.resultIds = resultIds;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3584d3db8b472772e3329d9d95d584b68ae997e","date":1551710517,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      float maxScore = Float.NaN;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        TopDocs thisTopDocs = queryCommandResult.getTopDocs();\n        topDocs.add(thisTopDocs);\n        mergedMatches += queryCommandResult.getMatches();\n        if (thisTopDocs.scoreDocs.length > 0) {\n          float thisMaxScore = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMaxScore > maxScore) {\n            maxScore = thisMaxScore;\n          }\n        }\n      }\n\n      int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(withinGroupSort, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches, maxScore));\n    }\n\n    Map<Object, ShardDoc> resultIds = new HashMap<>();\n    int i = 0;\n    for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n      for (GroupDocs<BytesRef> group : topGroups.groups) {\n        for (ScoreDoc scoreDoc : group.scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          // Include the first if there are duplicate IDs\n          if ( ! resultIds.containsKey(solrDoc.id)) {\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n    }\n    for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n      for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n        ShardDoc solrDoc = (ShardDoc) scoreDoc;\n        solrDoc.positionInResponse = i++;\n        resultIds.put(solrDoc.id, solrDoc);\n      }\n    }\n\n    rb.resultIds = resultIds;\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        if(rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY) == null) {\n          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        }\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      float maxScore = Float.NaN;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        TopDocs thisTopDocs = queryCommandResult.getTopDocs();\n        topDocs.add(thisTopDocs);\n        mergedMatches += queryCommandResult.getMatches();\n        if (thisTopDocs.scoreDocs.length > 0) {\n          float thisMaxScore = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMaxScore > maxScore) {\n            maxScore = thisMaxScore;\n          }\n        }\n      }\n\n      int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(withinGroupSort, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches, maxScore));\n    }\n\n    Map<Object, ShardDoc> resultIds = new HashMap<>();\n    int i = 0;\n    for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n      for (GroupDocs<BytesRef> group : topGroups.groups) {\n        for (ScoreDoc scoreDoc : group.scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          // Include the first if there are duplicate IDs\n          if ( ! resultIds.containsKey(solrDoc.id)) {\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n    }\n    for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n      for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n        ShardDoc solrDoc = (ShardDoc) scoreDoc;\n        solrDoc.positionInResponse = i++;\n        resultIds.put(solrDoc.id, solrDoc);\n      }\n    }\n\n    rb.resultIds = resultIds;\n  }\n\n","bugFix":["83b038ad0480d5e81e058bf9fafb2dd85399985d","167c9d3137acf706f53c875de69f3165df85fd3b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"755c262dae0f6ffb923e2eff5845b34ff808032a","date":1561743521,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      float maxScore = Float.NaN;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        TopDocs thisTopDocs = queryCommandResult.getTopDocs();\n        topDocs.add(thisTopDocs);\n        mergedMatches += queryCommandResult.getMatches();\n        if (thisTopDocs.scoreDocs.length > 0) {\n          float thisMaxScore = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMaxScore > maxScore) {\n            maxScore = thisMaxScore;\n          }\n        }\n      }\n\n      int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(withinGroupSort, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches, maxScore));\n    }\n    fillResultIds(rb);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      float maxScore = Float.NaN;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        TopDocs thisTopDocs = queryCommandResult.getTopDocs();\n        topDocs.add(thisTopDocs);\n        mergedMatches += queryCommandResult.getMatches();\n        if (thisTopDocs.scoreDocs.length > 0) {\n          float thisMaxScore = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMaxScore > maxScore) {\n            maxScore = thisMaxScore;\n          }\n        }\n      }\n\n      int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(withinGroupSort, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches, maxScore));\n    }\n\n    Map<Object, ShardDoc> resultIds = new HashMap<>();\n    int i = 0;\n    for (TopGroups<BytesRef> topGroups : rb.mergedTopGroups.values()) {\n      for (GroupDocs<BytesRef> group : topGroups.groups) {\n        for (ScoreDoc scoreDoc : group.scoreDocs) {\n          ShardDoc solrDoc = (ShardDoc) scoreDoc;\n          // Include the first if there are duplicate IDs\n          if ( ! resultIds.containsKey(solrDoc.id)) {\n            solrDoc.positionInResponse = i++;\n            resultIds.put(solrDoc.id, solrDoc);\n          }\n        }\n      }\n    }\n    for (QueryCommandResult queryCommandResult : rb.mergedQueryCommandResults.values()) {\n      for (ScoreDoc scoreDoc : queryCommandResult.getTopDocs().scoreDocs) {\n        ShardDoc solrDoc = (ShardDoc) scoreDoc;\n        solrDoc.positionInResponse = i++;\n        resultIds.put(solrDoc.id, solrDoc);\n      }\n    }\n\n    rb.resultIds = resultIds;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1313c74c6d619d0d98d1284bc17513c9a4b40345","date":1562035273,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    boolean simpleOrMain = rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple ||\n        rb.getGroupingSpec().isMain();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (simpleOrMain) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    // calculate topN and start for group.query\n    int topN = docsPerGroupDefault >= 0? docsPerGroupDefault: Integer.MAX_VALUE;\n    int start = groupOffsetDefault;\n    if (simpleOrMain) {\n      // use start and rows here\n      start = rb.getGroupingSpec().getGroupSortSpec().getOffset();\n      int limit = rb.getGroupingSpec().getGroupSortSpec().getCount();\n      topN = limit >= 0? limit: Integer.MAX_VALUE;\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      float maxScore = Float.NaN;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        TopDocs thisTopDocs = queryCommandResult.getTopDocs();\n        topDocs.add(thisTopDocs);\n        mergedMatches += queryCommandResult.getMatches();\n        if (thisTopDocs.scoreDocs.length > 0) {\n          float thisMaxScore = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMaxScore > maxScore) {\n            maxScore = thisMaxScore;\n          }\n        }\n      }\n\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(\n            start, topN, topDocs.toArray(new TopDocs[topDocs.size()]), true);\n      } else {\n        mergedTopDocs = TopDocs.merge(\n            withinGroupSort, start, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]), true);\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches, maxScore));\n    }\n    fillResultIds(rb);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      float maxScore = Float.NaN;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        TopDocs thisTopDocs = queryCommandResult.getTopDocs();\n        topDocs.add(thisTopDocs);\n        mergedMatches += queryCommandResult.getMatches();\n        if (thisTopDocs.scoreDocs.length > 0) {\n          float thisMaxScore = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMaxScore > maxScore) {\n            maxScore = thisMaxScore;\n          }\n        }\n      }\n\n      int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(withinGroupSort, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches, maxScore));\n    }\n    fillResultIds(rb);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fccd4a691aac1aff06ab8110d8693514a34160c3","date":1562092518,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    boolean simpleOrMain = rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple ||\n        rb.getGroupingSpec().isMain();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (simpleOrMain) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    // calculate topN and start for group.query\n    int topN = docsPerGroupDefault >= 0? docsPerGroupDefault: Integer.MAX_VALUE;\n    int start = groupOffsetDefault;\n    if (simpleOrMain) {\n      // use start and rows here\n      start = rb.getGroupingSpec().getGroupSortSpec().getOffset();\n      int limit = rb.getGroupingSpec().getGroupSortSpec().getCount();\n      topN = limit >= 0? limit: Integer.MAX_VALUE;\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      float maxScore = Float.NaN;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        TopDocs thisTopDocs = queryCommandResult.getTopDocs();\n        topDocs.add(thisTopDocs);\n        mergedMatches += queryCommandResult.getMatches();\n        if (thisTopDocs.scoreDocs.length > 0) {\n          float thisMaxScore = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMaxScore > maxScore) {\n            maxScore = thisMaxScore;\n          }\n        }\n      }\n\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(\n            start, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(\n            withinGroupSort, start, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches, maxScore));\n    }\n    fillResultIds(rb);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    boolean simpleOrMain = rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple ||\n        rb.getGroupingSpec().isMain();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (simpleOrMain) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    // calculate topN and start for group.query\n    int topN = docsPerGroupDefault >= 0? docsPerGroupDefault: Integer.MAX_VALUE;\n    int start = groupOffsetDefault;\n    if (simpleOrMain) {\n      // use start and rows here\n      start = rb.getGroupingSpec().getGroupSortSpec().getOffset();\n      int limit = rb.getGroupingSpec().getGroupSortSpec().getCount();\n      topN = limit >= 0? limit: Integer.MAX_VALUE;\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      float maxScore = Float.NaN;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        TopDocs thisTopDocs = queryCommandResult.getTopDocs();\n        topDocs.add(thisTopDocs);\n        mergedMatches += queryCommandResult.getMatches();\n        if (thisTopDocs.scoreDocs.length > 0) {\n          float thisMaxScore = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMaxScore > maxScore) {\n            maxScore = thisMaxScore;\n          }\n        }\n      }\n\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(\n            start, topN, topDocs.toArray(new TopDocs[topDocs.size()]), true);\n      } else {\n        mergedTopDocs = TopDocs.merge(\n            withinGroupSort, start, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]), true);\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches, maxScore));\n    }\n    fillResultIds(rb);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85bef26bbc598445704c1f9c6d7953f3942d5426","date":1562162588,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSortSpec().getSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    SortSpec withinGroupSortSpec = rb.getGroupingSpec().getWithinGroupSortSpec();\n    Sort withinGroupSort = withinGroupSortSpec.getSort();\n    assert withinGroupSort != null;\n\n    boolean simpleOrMain = rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple ||\n        rb.getGroupingSpec().isMain();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (simpleOrMain) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = withinGroupSortSpec.getOffset();\n    }\n    int docsPerGroupDefault = withinGroupSortSpec.getCount();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    // calculate topN and start for group.query\n    int topN = docsPerGroupDefault >= 0? docsPerGroupDefault: Integer.MAX_VALUE;\n    int start = groupOffsetDefault;\n    if (simpleOrMain) {\n      // use start and rows here\n      start = rb.getGroupingSpec().getGroupSortSpec().getOffset();\n      int limit = rb.getGroupingSpec().getGroupSortSpec().getCount();\n      topN = limit >= 0? limit: Integer.MAX_VALUE;\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      float maxScore = Float.NaN;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        TopDocs thisTopDocs = queryCommandResult.getTopDocs();\n        topDocs.add(thisTopDocs);\n        mergedMatches += queryCommandResult.getMatches();\n        if (thisTopDocs.scoreDocs.length > 0) {\n          float thisMaxScore = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMaxScore > maxScore) {\n            maxScore = thisMaxScore;\n          }\n        }\n      }\n\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(\n            start, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(\n            withinGroupSort, start, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches, maxScore));\n    }\n    fillResultIds(rb);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    Sort withinGroupSort = rb.getGroupingSpec().getSortWithinGroup();\n    assert withinGroupSort != null;\n\n    boolean simpleOrMain = rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple ||\n        rb.getGroupingSpec().isMain();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (simpleOrMain) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = rb.getGroupingSpec().getWithinGroupOffset();\n    }\n    int docsPerGroupDefault = rb.getGroupingSpec().getWithinGroupLimit();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<TopGroups<BytesRef>>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<QueryCommandResult>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    // calculate topN and start for group.query\n    int topN = docsPerGroupDefault >= 0? docsPerGroupDefault: Integer.MAX_VALUE;\n    int start = groupOffsetDefault;\n    if (simpleOrMain) {\n      // use start and rows here\n      start = rb.getGroupingSpec().getGroupSortSpec().getOffset();\n      int limit = rb.getGroupingSpec().getGroupSortSpec().getCount();\n      topN = limit >= 0? limit: Integer.MAX_VALUE;\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      float maxScore = Float.NaN;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        TopDocs thisTopDocs = queryCommandResult.getTopDocs();\n        topDocs.add(thisTopDocs);\n        mergedMatches += queryCommandResult.getMatches();\n        if (thisTopDocs.scoreDocs.length > 0) {\n          float thisMaxScore = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMaxScore > maxScore) {\n            maxScore = thisMaxScore;\n          }\n        }\n      }\n\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(\n            start, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(\n            withinGroupSort, start, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches, maxScore));\n    }\n    fillResultIds(rb);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0","date":1571070979,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSortSpec().getSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    SortSpec withinGroupSortSpec = rb.getGroupingSpec().getWithinGroupSortSpec();\n    Sort withinGroupSort = withinGroupSortSpec.getSort();\n    assert withinGroupSort != null;\n\n    boolean simpleOrMain = rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple ||\n        rb.getGroupingSpec().isMain();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (simpleOrMain) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = withinGroupSortSpec.getOffset();\n    }\n    int docsPerGroupDefault = withinGroupSortSpec.getCount();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (Map.Entry<String, List<TopGroups<BytesRef>>> entry : commandTopGroups.entrySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(entry.getKey());\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        entry.getValue().add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (Map.Entry<String, List<TopGroups<BytesRef>>> entry : commandTopGroups.entrySet()) {\n      List<TopGroups<BytesRef>> topGroups = entry.getValue();\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(entry.getKey(), TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    // calculate topN and start for group.query\n    int topN = docsPerGroupDefault >= 0? docsPerGroupDefault: Integer.MAX_VALUE;\n    int start = groupOffsetDefault;\n    if (simpleOrMain) {\n      // use start and rows here\n      start = rb.getGroupingSpec().getGroupSortSpec().getOffset();\n      int limit = rb.getGroupingSpec().getGroupSortSpec().getCount();\n      topN = limit >= 0? limit: Integer.MAX_VALUE;\n    }\n\n    for (Map.Entry<String, List<QueryCommandResult>> entry : commandTopDocs.entrySet()) {\n      List<QueryCommandResult> queryCommandResults = entry.getValue();\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      float maxScore = Float.NaN;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        TopDocs thisTopDocs = queryCommandResult.getTopDocs();\n        topDocs.add(thisTopDocs);\n        mergedMatches += queryCommandResult.getMatches();\n        if (thisTopDocs.scoreDocs.length > 0) {\n          float thisMaxScore = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMaxScore > maxScore) {\n            maxScore = thisMaxScore;\n          }\n        }\n      }\n\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(\n            start, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(\n            withinGroupSort, start, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(entry.getKey(), new QueryCommandResult(mergedTopDocs, mergedMatches, maxScore));\n    }\n    fillResultIds(rb);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSortSpec().getSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    SortSpec withinGroupSortSpec = rb.getGroupingSpec().getWithinGroupSortSpec();\n    Sort withinGroupSort = withinGroupSortSpec.getSort();\n    assert withinGroupSort != null;\n\n    boolean simpleOrMain = rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple ||\n        rb.getGroupingSpec().isMain();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (simpleOrMain) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = withinGroupSortSpec.getOffset();\n    }\n    int docsPerGroupDefault = withinGroupSortSpec.getCount();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    // calculate topN and start for group.query\n    int topN = docsPerGroupDefault >= 0? docsPerGroupDefault: Integer.MAX_VALUE;\n    int start = groupOffsetDefault;\n    if (simpleOrMain) {\n      // use start and rows here\n      start = rb.getGroupingSpec().getGroupSortSpec().getOffset();\n      int limit = rb.getGroupingSpec().getGroupSortSpec().getCount();\n      topN = limit >= 0? limit: Integer.MAX_VALUE;\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      float maxScore = Float.NaN;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        TopDocs thisTopDocs = queryCommandResult.getTopDocs();\n        topDocs.add(thisTopDocs);\n        mergedMatches += queryCommandResult.getMatches();\n        if (thisTopDocs.scoreDocs.length > 0) {\n          float thisMaxScore = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMaxScore > maxScore) {\n            maxScore = thisMaxScore;\n          }\n        }\n      }\n\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(\n            start, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(\n            withinGroupSort, start, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches, maxScore));\n    }\n    fillResultIds(rb);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSortSpec().getSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    SortSpec withinGroupSortSpec = rb.getGroupingSpec().getWithinGroupSortSpec();\n    Sort withinGroupSort = withinGroupSortSpec.getSort();\n    assert withinGroupSort != null;\n\n    boolean simpleOrMain = rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple ||\n        rb.getGroupingSpec().isMain();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (simpleOrMain) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = withinGroupSortSpec.getOffset();\n    }\n    int docsPerGroupDefault = withinGroupSortSpec.getCount();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (Map.Entry<String, List<TopGroups<BytesRef>>> entry : commandTopGroups.entrySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(entry.getKey());\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        entry.getValue().add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (Map.Entry<String, List<TopGroups<BytesRef>>> entry : commandTopGroups.entrySet()) {\n      List<TopGroups<BytesRef>> topGroups = entry.getValue();\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(entry.getKey(), TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    // calculate topN and start for group.query\n    int topN = docsPerGroupDefault >= 0? docsPerGroupDefault: Integer.MAX_VALUE;\n    int start = groupOffsetDefault;\n    if (simpleOrMain) {\n      // use start and rows here\n      start = rb.getGroupingSpec().getGroupSortSpec().getOffset();\n      int limit = rb.getGroupingSpec().getGroupSortSpec().getCount();\n      topN = limit >= 0? limit: Integer.MAX_VALUE;\n    }\n\n    for (Map.Entry<String, List<QueryCommandResult>> entry : commandTopDocs.entrySet()) {\n      List<QueryCommandResult> queryCommandResults = entry.getValue();\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      float maxScore = Float.NaN;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        TopDocs thisTopDocs = queryCommandResult.getTopDocs();\n        topDocs.add(thisTopDocs);\n        mergedMatches += queryCommandResult.getMatches();\n        if (thisTopDocs.scoreDocs.length > 0) {\n          float thisMaxScore = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMaxScore > maxScore) {\n            maxScore = thisMaxScore;\n          }\n        }\n      }\n\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(\n            start, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(\n            withinGroupSort, start, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(entry.getKey(), new QueryCommandResult(mergedTopDocs, mergedMatches, maxScore));\n    }\n    fillResultIds(rb);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSortSpec().getSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    SortSpec withinGroupSortSpec = rb.getGroupingSpec().getWithinGroupSortSpec();\n    Sort withinGroupSort = withinGroupSortSpec.getSort();\n    assert withinGroupSort != null;\n\n    boolean simpleOrMain = rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple ||\n        rb.getGroupingSpec().isMain();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (simpleOrMain) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = withinGroupSortSpec.getOffset();\n    }\n    int docsPerGroupDefault = withinGroupSortSpec.getCount();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (String field : commandTopGroups.keySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(field);\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        commandTopGroups.get(field).add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (String groupField : commandTopGroups.keySet()) {\n      List<TopGroups<BytesRef>> topGroups = commandTopGroups.get(groupField);\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(groupField, TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    // calculate topN and start for group.query\n    int topN = docsPerGroupDefault >= 0? docsPerGroupDefault: Integer.MAX_VALUE;\n    int start = groupOffsetDefault;\n    if (simpleOrMain) {\n      // use start and rows here\n      start = rb.getGroupingSpec().getGroupSortSpec().getOffset();\n      int limit = rb.getGroupingSpec().getGroupSortSpec().getCount();\n      topN = limit >= 0? limit: Integer.MAX_VALUE;\n    }\n\n    for (String query : commandTopDocs.keySet()) {\n      List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      float maxScore = Float.NaN;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        TopDocs thisTopDocs = queryCommandResult.getTopDocs();\n        topDocs.add(thisTopDocs);\n        mergedMatches += queryCommandResult.getMatches();\n        if (thisTopDocs.scoreDocs.length > 0) {\n          float thisMaxScore = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMaxScore > maxScore) {\n            maxScore = thisMaxScore;\n          }\n        }\n      }\n\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(\n            start, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(\n            withinGroupSort, start, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches, maxScore));\n    }\n    fillResultIds(rb);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50dfd19525c8d73e856dca6edb64b7aea074037f","date":1591579225,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor#process(ResponseBuilder,ShardRequest).mjava","sourceNew":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSortSpec().getSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    SortSpec withinGroupSortSpec = rb.getGroupingSpec().getWithinGroupSortSpec();\n    Sort withinGroupSort = withinGroupSortSpec.getSort();\n    assert withinGroupSort != null;\n\n    boolean simpleOrMain = rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple ||\n        rb.getGroupingSpec().isMain();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (simpleOrMain) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = withinGroupSortSpec.getOffset();\n    }\n    int docsPerGroupDefault = withinGroupSortSpec.getCount();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (Map.Entry<String, List<TopGroups<BytesRef>>> entry : commandTopGroups.entrySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(entry.getKey());\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        entry.getValue().add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (Map.Entry<String, List<TopGroups<BytesRef>>> entry : commandTopGroups.entrySet()) {\n      List<TopGroups<BytesRef>> topGroups = entry.getValue();\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      @SuppressWarnings({\"rawtypes\"})\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (@SuppressWarnings({\"rawtypes\"})TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(entry.getKey(), TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    // calculate topN and start for group.query\n    int topN = docsPerGroupDefault >= 0? docsPerGroupDefault: Integer.MAX_VALUE;\n    int start = groupOffsetDefault;\n    if (simpleOrMain) {\n      // use start and rows here\n      start = rb.getGroupingSpec().getGroupSortSpec().getOffset();\n      int limit = rb.getGroupingSpec().getGroupSortSpec().getCount();\n      topN = limit >= 0? limit: Integer.MAX_VALUE;\n    }\n\n    for (Map.Entry<String, List<QueryCommandResult>> entry : commandTopDocs.entrySet()) {\n      List<QueryCommandResult> queryCommandResults = entry.getValue();\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      float maxScore = Float.NaN;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        TopDocs thisTopDocs = queryCommandResult.getTopDocs();\n        topDocs.add(thisTopDocs);\n        mergedMatches += queryCommandResult.getMatches();\n        if (thisTopDocs.scoreDocs.length > 0) {\n          float thisMaxScore = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMaxScore > maxScore) {\n            maxScore = thisMaxScore;\n          }\n        }\n      }\n\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(\n            start, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(\n            withinGroupSort, start, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(entry.getKey(), new QueryCommandResult(mergedTopDocs, mergedMatches, maxScore));\n    }\n    fillResultIds(rb);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void process(ResponseBuilder rb, ShardRequest shardRequest) {\n    Sort groupSort = rb.getGroupingSpec().getGroupSortSpec().getSort();\n    String[] fields = rb.getGroupingSpec().getFields();\n    String[] queries = rb.getGroupingSpec().getQueries();\n    SortSpec withinGroupSortSpec = rb.getGroupingSpec().getWithinGroupSortSpec();\n    Sort withinGroupSort = withinGroupSortSpec.getSort();\n    assert withinGroupSort != null;\n\n    boolean simpleOrMain = rb.getGroupingSpec().getResponseFormat() == Grouping.Format.simple ||\n        rb.getGroupingSpec().isMain();\n\n    // If group.format=simple group.offset doesn't make sense\n    int groupOffsetDefault;\n    if (simpleOrMain) {\n      groupOffsetDefault = 0;\n    } else {\n      groupOffsetDefault = withinGroupSortSpec.getOffset();\n    }\n    int docsPerGroupDefault = withinGroupSortSpec.getCount();\n\n    Map<String, List<TopGroups<BytesRef>>> commandTopGroups = new HashMap<>();\n    for (String field : fields) {\n      commandTopGroups.put(field, new ArrayList<>());\n    }\n\n    Map<String, List<QueryCommandResult>> commandTopDocs = new HashMap<>();\n    for (String query : queries) {\n      commandTopDocs.put(query, new ArrayList<>());\n    }\n\n    TopGroupsResultTransformer serializer = new TopGroupsResultTransformer(rb);\n\n    NamedList<Object> shardInfo = null;\n    if (rb.req.getParams().getBool(ShardParams.SHARDS_INFO, false)) {\n      shardInfo = new SimpleOrderedMap<>();\n      rb.rsp.getValues().add(ShardParams.SHARDS_INFO, shardInfo);\n    }\n\n    for (ShardResponse srsp : shardRequest.responses) {\n      SimpleOrderedMap<Object> individualShardInfo = null;\n      if (shardInfo != null) {\n        individualShardInfo = new SimpleOrderedMap<>();\n\n        if (srsp.getException() != null) {\n          Throwable t = srsp.getException();\n          if (t instanceof SolrServerException && ((SolrServerException) t).getCause() != null) {\n            t = ((SolrServerException) t).getCause();\n          }\n          individualShardInfo.add(\"error\", t.toString());\n          StringWriter trace = new StringWriter();\n          t.printStackTrace(new PrintWriter(trace));\n          individualShardInfo.add(\"trace\", trace.toString());\n        } else {\n          // summary for successful shard response is added down below\n        }\n        if (srsp.getSolrResponse() != null) {\n          individualShardInfo.add(\"time\", srsp.getSolrResponse().getElapsedTime());\n        }\n        if (srsp.getShardAddress() != null) {\n          individualShardInfo.add(\"shardAddress\", srsp.getShardAddress());\n        }\n        shardInfo.add(srsp.getShard(), individualShardInfo);\n      }\n      if (ShardParams.getShardsTolerantAsBool(rb.req.getParams()) && srsp.getException() != null) {\n        rb.rsp.getResponseHeader().asShallowMap().put(SolrQueryResponse.RESPONSE_HEADER_PARTIAL_RESULTS_KEY, Boolean.TRUE);\n        continue; // continue if there was an error and we're tolerant.  \n      }\n      NamedList<NamedList> secondPhaseResult = (NamedList<NamedList>) srsp.getSolrResponse().getResponse().get(\"secondPhase\");\n      if(secondPhaseResult == null)\n        continue;\n      Map<String, ?> result = serializer.transformToNative(secondPhaseResult, groupSort, withinGroupSort, srsp.getShard());\n      int numFound = 0;\n      float maxScore = Float.NaN;\n      for (Map.Entry<String, List<TopGroups<BytesRef>>> entry : commandTopGroups.entrySet()) {\n        TopGroups<BytesRef> topGroups = (TopGroups<BytesRef>) result.get(entry.getKey());\n        if (topGroups == null) {\n          continue;\n        }\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += topGroups.totalHitCount;\n          if (Float.isNaN(maxScore) || topGroups.maxScore > maxScore) maxScore = topGroups.maxScore;\n        }\n        entry.getValue().add(topGroups);\n      }\n      for (String query : queries) {\n        QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);\n        if (individualShardInfo != null) { // keep track of this when shards.info=true\n          numFound += queryCommandResult.getMatches();\n          float thisMax = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;\n        }\n        commandTopDocs.get(query).add(queryCommandResult);\n      }\n      if (individualShardInfo != null) { // when shards.info=true\n        individualShardInfo.add(\"numFound\", numFound);\n        individualShardInfo.add(\"maxScore\", maxScore);\n      }\n    }\n    for (Map.Entry<String, List<TopGroups<BytesRef>>> entry : commandTopGroups.entrySet()) {\n      List<TopGroups<BytesRef>> topGroups = entry.getValue();\n      if (topGroups.isEmpty()) {\n        continue;\n      }\n\n      TopGroups<BytesRef>[] topGroupsArr = new TopGroups[topGroups.size()];\n      int docsPerGroup = docsPerGroupDefault;\n      if (docsPerGroup < 0) {\n        docsPerGroup = 0;\n        for (TopGroups subTopGroups : topGroups) {\n          docsPerGroup += subTopGroups.totalGroupedHitCount;\n        }\n      }\n      rb.mergedTopGroups.put(entry.getKey(), TopGroups.merge(topGroups.toArray(topGroupsArr), groupSort, withinGroupSort, groupOffsetDefault, docsPerGroup, TopGroups.ScoreMergeMode.None));\n    }\n\n    // calculate topN and start for group.query\n    int topN = docsPerGroupDefault >= 0? docsPerGroupDefault: Integer.MAX_VALUE;\n    int start = groupOffsetDefault;\n    if (simpleOrMain) {\n      // use start and rows here\n      start = rb.getGroupingSpec().getGroupSortSpec().getOffset();\n      int limit = rb.getGroupingSpec().getGroupSortSpec().getCount();\n      topN = limit >= 0? limit: Integer.MAX_VALUE;\n    }\n\n    for (Map.Entry<String, List<QueryCommandResult>> entry : commandTopDocs.entrySet()) {\n      List<QueryCommandResult> queryCommandResults = entry.getValue();\n      List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());\n      int mergedMatches = 0;\n      float maxScore = Float.NaN;\n      for (QueryCommandResult queryCommandResult : queryCommandResults) {\n        TopDocs thisTopDocs = queryCommandResult.getTopDocs();\n        topDocs.add(thisTopDocs);\n        mergedMatches += queryCommandResult.getMatches();\n        if (thisTopDocs.scoreDocs.length > 0) {\n          float thisMaxScore = queryCommandResult.getMaxScore();\n          if (Float.isNaN(maxScore) || thisMaxScore > maxScore) {\n            maxScore = thisMaxScore;\n          }\n        }\n      }\n\n      final TopDocs mergedTopDocs;\n      if (withinGroupSort.equals(Sort.RELEVANCE)) {\n        mergedTopDocs = TopDocs.merge(\n            start, topN, topDocs.toArray(new TopDocs[topDocs.size()]));\n      } else {\n        mergedTopDocs = TopDocs.merge(\n            withinGroupSort, start, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));\n      }\n      rb.mergedQueryCommandResults.put(entry.getKey(), new QueryCommandResult(mergedTopDocs, mergedMatches, maxScore));\n    }\n    fillResultIds(rb);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["03e38c6374c23083c93e212a9498ff0a9c255476"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["85d41890f2bad879e6a04c6dd7d2cf276f973994","7530de27b87b961b51f01bd1299b7004d46e8823"],"1313c74c6d619d0d98d1284bc17513c9a4b40345":["755c262dae0f6ffb923e2eff5845b34ff808032a"],"fb17639909a369c1e64866842e5c213440acc17e":["944836102ccff275d4e5382638bc2ec1257ff8bc"],"b94236357aaa22b76c10629851fe4e376e0cea82":["55f7a37353edeecde86a45f4895ef74901a0158b","a80a37ae73034270b57bfd57a44f8fcadc952fa0"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["7530de27b87b961b51f01bd1299b7004d46e8823","a2d7ec084be7fa496e6f93352b6e10427881eb35"],"5d31e5ade44c0d23378d22781e2f2c293afdb25d":["a2d7ec084be7fa496e6f93352b6e10427881eb35"],"ccc08aa684aee4964baee0644a6ba047bfd70829":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a80a37ae73034270b57bfd57a44f8fcadc952fa0":["55f7a37353edeecde86a45f4895ef74901a0158b"],"a3584d3db8b472772e3329d9d95d584b68ae997e":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"a2d7ec084be7fa496e6f93352b6e10427881eb35":["7530de27b87b961b51f01bd1299b7004d46e8823"],"5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2":["fb17639909a369c1e64866842e5c213440acc17e"],"55f7a37353edeecde86a45f4895ef74901a0158b":["03e38c6374c23083c93e212a9498ff0a9c255476"],"0a63d32fe2b29dda520043ef60a1424a4d9ccd5c":["d423443db06bfcac81733aafcce04ee491880cc7"],"83b038ad0480d5e81e058bf9fafb2dd85399985d":["5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["83b038ad0480d5e81e058bf9fafb2dd85399985d","f6ca8ed75ba81801707cefbfca061b629ab49a8a"],"85d41890f2bad879e6a04c6dd7d2cf276f973994":["ccc08aa684aee4964baee0644a6ba047bfd70829"],"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0":["85bef26bbc598445704c1f9c6d7953f3942d5426"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["bd22dcd3ba035a1626face7319c94be45ae07172","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"755c262dae0f6ffb923e2eff5845b34ff808032a":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"b101c3c0e7f5871415e80d970cb3289309f3522e":["d423443db06bfcac81733aafcce04ee491880cc7","3f20d97ebbd280405cebcc21d53c781bf4456453"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3717ad5d6103c6c5c87888e9d0e791b9124c98b6":["167c9d3137acf706f53c875de69f3165df85fd3b"],"9856095f7afb5a607bf5e65077615ed91273508c":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","b101c3c0e7f5871415e80d970cb3289309f3522e"],"d423443db06bfcac81733aafcce04ee491880cc7":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["3717ad5d6103c6c5c87888e9d0e791b9124c98b6"],"3f20d97ebbd280405cebcc21d53c781bf4456453":["0a63d32fe2b29dda520043ef60a1424a4d9ccd5c"],"944836102ccff275d4e5382638bc2ec1257ff8bc":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"167c9d3137acf706f53c875de69f3165df85fd3b":["5d31e5ade44c0d23378d22781e2f2c293afdb25d"],"f6ca8ed75ba81801707cefbfca061b629ab49a8a":["83b038ad0480d5e81e058bf9fafb2dd85399985d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["83b038ad0480d5e81e058bf9fafb2dd85399985d","d470c8182e92b264680e34081b75e70a9f2b3c89"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["9856095f7afb5a607bf5e65077615ed91273508c","03e38c6374c23083c93e212a9498ff0a9c255476"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","944836102ccff275d4e5382638bc2ec1257ff8bc"],"50dfd19525c8d73e856dca6edb64b7aea074037f":["7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0"],"03e38c6374c23083c93e212a9498ff0a9c255476":["b101c3c0e7f5871415e80d970cb3289309f3522e"],"fccd4a691aac1aff06ab8110d8693514a34160c3":["1313c74c6d619d0d98d1284bc17513c9a4b40345"],"85bef26bbc598445704c1f9c6d7953f3942d5426":["fccd4a691aac1aff06ab8110d8693514a34160c3"],"bd22dcd3ba035a1626face7319c94be45ae07172":["b94236357aaa22b76c10629851fe4e376e0cea82"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d423443db06bfcac81733aafcce04ee491880cc7"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["a2d7ec084be7fa496e6f93352b6e10427881eb35","5d31e5ade44c0d23378d22781e2f2c293afdb25d"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["bd22dcd3ba035a1626face7319c94be45ae07172"],"7530de27b87b961b51f01bd1299b7004d46e8823":["85d41890f2bad879e6a04c6dd7d2cf276f973994"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["50dfd19525c8d73e856dca6edb64b7aea074037f"],"b0b597c65628ca9e73913a07e81691f8229bae35":["85bef26bbc598445704c1f9c6d7953f3942d5426","7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"1313c74c6d619d0d98d1284bc17513c9a4b40345":["fccd4a691aac1aff06ab8110d8693514a34160c3"],"fb17639909a369c1e64866842e5c213440acc17e":["5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2"],"b94236357aaa22b76c10629851fe4e376e0cea82":["bd22dcd3ba035a1626face7319c94be45ae07172"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"5d31e5ade44c0d23378d22781e2f2c293afdb25d":["167c9d3137acf706f53c875de69f3165df85fd3b","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"a80a37ae73034270b57bfd57a44f8fcadc952fa0":["b94236357aaa22b76c10629851fe4e376e0cea82"],"ccc08aa684aee4964baee0644a6ba047bfd70829":["85d41890f2bad879e6a04c6dd7d2cf276f973994"],"a3584d3db8b472772e3329d9d95d584b68ae997e":["755c262dae0f6ffb923e2eff5845b34ff808032a"],"a2d7ec084be7fa496e6f93352b6e10427881eb35":["37a0f60745e53927c4c876cfe5b5a58170f0646c","5d31e5ade44c0d23378d22781e2f2c293afdb25d","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"5e8a6094f2ecf9edcd3bb224b087580ac0aa13f2":["83b038ad0480d5e81e058bf9fafb2dd85399985d"],"55f7a37353edeecde86a45f4895ef74901a0158b":["b94236357aaa22b76c10629851fe4e376e0cea82","a80a37ae73034270b57bfd57a44f8fcadc952fa0"],"0a63d32fe2b29dda520043ef60a1424a4d9ccd5c":["3f20d97ebbd280405cebcc21d53c781bf4456453"],"83b038ad0480d5e81e058bf9fafb2dd85399985d":["d470c8182e92b264680e34081b75e70a9f2b3c89","f6ca8ed75ba81801707cefbfca061b629ab49a8a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["d423443db06bfcac81733aafcce04ee491880cc7","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"85d41890f2bad879e6a04c6dd7d2cf276f973994":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0":["50dfd19525c8d73e856dca6edb64b7aea074037f","b0b597c65628ca9e73913a07e81691f8229bae35"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"755c262dae0f6ffb923e2eff5845b34ff808032a":["1313c74c6d619d0d98d1284bc17513c9a4b40345"],"b101c3c0e7f5871415e80d970cb3289309f3522e":["9856095f7afb5a607bf5e65077615ed91273508c","03e38c6374c23083c93e212a9498ff0a9c255476"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ccc08aa684aee4964baee0644a6ba047bfd70829"],"3717ad5d6103c6c5c87888e9d0e791b9124c98b6":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"9856095f7afb5a607bf5e65077615ed91273508c":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"d423443db06bfcac81733aafcce04ee491880cc7":["0a63d32fe2b29dda520043ef60a1424a4d9ccd5c","b101c3c0e7f5871415e80d970cb3289309f3522e","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["944836102ccff275d4e5382638bc2ec1257ff8bc","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"3f20d97ebbd280405cebcc21d53c781bf4456453":["b101c3c0e7f5871415e80d970cb3289309f3522e"],"944836102ccff275d4e5382638bc2ec1257ff8bc":["fb17639909a369c1e64866842e5c213440acc17e","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"167c9d3137acf706f53c875de69f3165df85fd3b":["3717ad5d6103c6c5c87888e9d0e791b9124c98b6"],"f6ca8ed75ba81801707cefbfca061b629ab49a8a":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":[],"03e38c6374c23083c93e212a9498ff0a9c255476":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","55f7a37353edeecde86a45f4895ef74901a0158b","90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"50dfd19525c8d73e856dca6edb64b7aea074037f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fccd4a691aac1aff06ab8110d8693514a34160c3":["85bef26bbc598445704c1f9c6d7953f3942d5426"],"85bef26bbc598445704c1f9c6d7953f3942d5426":["7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0","b0b597c65628ca9e73913a07e81691f8229bae35"],"bd22dcd3ba035a1626face7319c94be45ae07172":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["9856095f7afb5a607bf5e65077615ed91273508c"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["a3584d3db8b472772e3329d9d95d584b68ae997e","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","37a0f60745e53927c4c876cfe5b5a58170f0646c","a2d7ec084be7fa496e6f93352b6e10427881eb35"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","37a0f60745e53927c4c876cfe5b5a58170f0646c","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","90a682dc1bfd188ef61cc28373c7f5d700b4ac75","0a22eafe3f72a4c2945eaad9547e6c78816978f4","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}