{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","commits":[{"id":"40aa98241c87d86a0077beb8023713d93a0becfe","date":1459784560,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param pointList        is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, pointList.get(0), pointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    final GeoPolygon trial = buildPolygonShape(planetModel, pointList, 0, 1, initialPlane, false, holes, testPoint);\n    if (trial == null) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        return buildPolygonShape(planetModel, pointList, 0, 1, initialPlane, false, holes, null);\n      }\n      // No: do the complement and return that.\n      return buildPolygonShape(planetModel, pointList, 0, 1, new SidedPlane(initialPlane), false, holes, null);\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return trial;\n      }\n      // No: return the complement\n      return buildPolygonShape(planetModel, pointList, 0, 1, new SidedPlane(initialPlane), false, holes, null);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09af2c9610ce53a4b25fd99344299b40318a4a1a","date":1459876565,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param pointList        is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, pointList.get(0), pointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    final GeoPolygon trial = buildPolygonShape(planetModel, pointList, 0, 1, initialPlane, false, holes, testPoint);\n    if (trial == null) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        return buildPolygonShape(planetModel, pointList, 0, 1, initialPlane, false, holes, null);\n      }\n      // No: do the complement and return that.\n      return buildPolygonShape(planetModel, pointList, 0, 1, new SidedPlane(initialPlane), false, holes, null);\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return trial;\n      }\n      // No: return the complement\n      return buildPolygonShape(planetModel, pointList, 0, 1, new SidedPlane(initialPlane), false, holes, null);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a75c862521bb895a29958e7bc5cb188597205a08","date":1459977470,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param pointList        is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, pointList.get(0), pointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    final GeoPolygon trial = buildPolygonShape(new GeoCompositePolygon(), planetModel, pointList, new BitSet(), 0, 1, initialPlane, holes, testPoint);\n    if (trial == null) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        return buildPolygonShape(new GeoCompositePolygon(), planetModel, pointList, new BitSet(), 0, 1, initialPlane, holes, null);\n      }\n      // No: do the complement and return that.\n      return buildPolygonShape(new GeoCompositePolygon(), planetModel, pointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return trial;\n      }\n      // No: return the complement\n      return buildPolygonShape(new GeoCompositePolygon(), planetModel, pointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param pointList        is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, pointList.get(0), pointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    final GeoPolygon trial = buildPolygonShape(planetModel, pointList, 0, 1, initialPlane, false, holes, testPoint);\n    if (trial == null) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        return buildPolygonShape(planetModel, pointList, 0, 1, initialPlane, false, holes, null);\n      }\n      // No: do the complement and return that.\n      return buildPolygonShape(planetModel, pointList, 0, 1, new SidedPlane(initialPlane), false, holes, null);\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return trial;\n      }\n      // No: return the complement\n      return buildPolygonShape(planetModel, pointList, 0, 1, new SidedPlane(initialPlane), false, holes, null);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fbb12e3e731744399ac2b3429316a721561ccc4e","date":1460029207,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param pointList        is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, pointList.get(0), pointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    GeoCompositePolygon rval = new GeoCompositePolygon();\n    if (buildPolygonShape(rval, planetModel, pointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        rval = new GeoCompositePolygon();\n        buildPolygonShape(rval, planetModel, pointList, new BitSet(), 0, 1, initialPlane, holes, null);\n        return rval;\n      }\n      // No: do the complement and return that.\n      rval = new GeoCompositePolygon();\n      buildPolygonShape(rval, planetModel, pointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return rval;\n      }\n      // No: return the complement\n      rval = new GeoCompositePolygon();\n      buildPolygonShape(rval, planetModel, pointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param pointList        is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, pointList.get(0), pointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    final GeoPolygon trial = buildPolygonShape(new GeoCompositePolygon(), planetModel, pointList, new BitSet(), 0, 1, initialPlane, holes, testPoint);\n    if (trial == null) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        return buildPolygonShape(new GeoCompositePolygon(), planetModel, pointList, new BitSet(), 0, 1, initialPlane, holes, null);\n      }\n      // No: do the complement and return that.\n      return buildPolygonShape(new GeoCompositePolygon(), planetModel, pointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return trial;\n      }\n      // No: return the complement\n      return buildPolygonShape(new GeoCompositePolygon(), planetModel, pointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d85423d45b4f1c56d97b657faad35d1a3100d50","date":1460895224,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param pointList        is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    final List<GeoPoint> filteredPointList = filterPoints(pointList);\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    GeoCompositePolygon rval = new GeoCompositePolygon();\n    if (buildPolygonShape(rval, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        rval = new GeoCompositePolygon();\n        buildPolygonShape(rval, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\n        return rval;\n      }\n      // No: do the complement and return that.\n      rval = new GeoCompositePolygon();\n      buildPolygonShape(rval, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return rval;\n      }\n      // No: return the complement\n      rval = new GeoCompositePolygon();\n      buildPolygonShape(rval, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param pointList        is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, pointList.get(0), pointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    GeoCompositePolygon rval = new GeoCompositePolygon();\n    if (buildPolygonShape(rval, planetModel, pointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        rval = new GeoCompositePolygon();\n        buildPolygonShape(rval, planetModel, pointList, new BitSet(), 0, 1, initialPlane, holes, null);\n        return rval;\n      }\n      // No: do the complement and return that.\n      rval = new GeoCompositePolygon();\n      buildPolygonShape(rval, planetModel, pointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return rval;\n      }\n      // No: return the complement\n      rval = new GeoCompositePolygon();\n      buildPolygonShape(rval, planetModel, pointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    }\n  }\n\n","bugFix":null,"bugIntro":["fa76b98015a97f0eca94f0f11fd1b6975838c3ee"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fa76b98015a97f0eca94f0f11fd1b6975838c3ee","date":1461000501,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param pointList        is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    final List<GeoPoint> filteredPointList = filterPoints(pointList);\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    GeoCompositePolygon rval = new GeoCompositePolygon();\n    MutableBoolean seenConcave = new MutableBoolean();\n    if (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        rval = new GeoCompositePolygon();\n        seenConcave = new MutableBoolean();\n        buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\n        return rval;\n      }\n      // No: do the complement and return that.\n      rval = new GeoCompositePolygon();\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return rval;\n      }\n      // No: return the complement\n      rval = new GeoCompositePolygon();\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param pointList        is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    final List<GeoPoint> filteredPointList = filterPoints(pointList);\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    GeoCompositePolygon rval = new GeoCompositePolygon();\n    if (buildPolygonShape(rval, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        rval = new GeoCompositePolygon();\n        buildPolygonShape(rval, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\n        return rval;\n      }\n      // No: do the complement and return that.\n      rval = new GeoCompositePolygon();\n      buildPolygonShape(rval, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return rval;\n      }\n      // No: return the complement\n      rval = new GeoCompositePolygon();\n      buildPolygonShape(rval, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    }\n  }\n\n","bugFix":["4d85423d45b4f1c56d97b657faad35d1a3100d50"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"536a864ce38bf14fb3f072a3129a389e95200e20","date":1461068886,"type":5,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#generateGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeGeoPolygon(PlanetModel,List[GeoPoint],List[GeoPolygon],GeoPoint,boolean).mjava","sourceNew":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param filteredPointList is a filtered list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified, or null if what was specified\n   *  cannot be turned into a valid non-degenerate polygon.\n   */\n  static GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> filteredPointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    GeoCompositePolygon rval = new GeoCompositePolygon();\n    MutableBoolean seenConcave = new MutableBoolean();\n    if (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        rval = new GeoCompositePolygon();\n        seenConcave = new MutableBoolean();\n        buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\n        return rval;\n      }\n      // No: do the complement and return that.\n      rval = new GeoCompositePolygon();\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return rval;\n      }\n      // No: return the complement\n      rval = new GeoCompositePolygon();\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    }\n  }\n\n","sourceOld":"  /**\n   * Create a GeoPolygon using the specified points and holes and a test point.\n   *\n   * @param pointList        is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param holes is a list of polygons representing \"holes\" in the outside polygon.  Null == none.\n   * @param testPoint is a test point that is either known to be within the polygon area, or not.\n   * @param testPointInside is true if the test point is within the area, false otherwise.\n   * @return a GeoPolygon corresponding to what was specified.\n   */\n  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> pointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks\n    final List<GeoPoint> filteredPointList = filterPoints(pointList);\n    // We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    // side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    // find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n    // We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    // So we need to be prepared to try both possibilities.\n    GeoCompositePolygon rval = new GeoCompositePolygon();\n    MutableBoolean seenConcave = new MutableBoolean();\n    if (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n      // The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        // Yes: build it for real\n        rval = new GeoCompositePolygon();\n        seenConcave = new MutableBoolean();\n        buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\n        return rval;\n      }\n      // No: do the complement and return that.\n      rval = new GeoCompositePolygon();\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    } else {\n      // The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        // Yes: return what we just built\n        return rval;\n      }\n      // No: return the complement\n      rval = new GeoCompositePolygon();\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"09af2c9610ce53a4b25fd99344299b40318a4a1a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","40aa98241c87d86a0077beb8023713d93a0becfe"],"4d85423d45b4f1c56d97b657faad35d1a3100d50":["fbb12e3e731744399ac2b3429316a721561ccc4e"],"fa76b98015a97f0eca94f0f11fd1b6975838c3ee":["4d85423d45b4f1c56d97b657faad35d1a3100d50"],"fbb12e3e731744399ac2b3429316a721561ccc4e":["a75c862521bb895a29958e7bc5cb188597205a08"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"40aa98241c87d86a0077beb8023713d93a0becfe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"536a864ce38bf14fb3f072a3129a389e95200e20":["fa76b98015a97f0eca94f0f11fd1b6975838c3ee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["536a864ce38bf14fb3f072a3129a389e95200e20"],"a75c862521bb895a29958e7bc5cb188597205a08":["40aa98241c87d86a0077beb8023713d93a0becfe"]},"commit2Childs":{"09af2c9610ce53a4b25fd99344299b40318a4a1a":[],"4d85423d45b4f1c56d97b657faad35d1a3100d50":["fa76b98015a97f0eca94f0f11fd1b6975838c3ee"],"fa76b98015a97f0eca94f0f11fd1b6975838c3ee":["536a864ce38bf14fb3f072a3129a389e95200e20"],"fbb12e3e731744399ac2b3429316a721561ccc4e":["4d85423d45b4f1c56d97b657faad35d1a3100d50"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["09af2c9610ce53a4b25fd99344299b40318a4a1a","40aa98241c87d86a0077beb8023713d93a0becfe"],"40aa98241c87d86a0077beb8023713d93a0becfe":["09af2c9610ce53a4b25fd99344299b40318a4a1a","a75c862521bb895a29958e7bc5cb188597205a08"],"536a864ce38bf14fb3f072a3129a389e95200e20":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a75c862521bb895a29958e7bc5cb188597205a08":["fbb12e3e731744399ac2b3429316a721561ccc4e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["09af2c9610ce53a4b25fd99344299b40318a4a1a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}