{"path":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testDeleteOneOfTwoCollectionsAliased().mjava","commits":[{"id":"4b342321d8906f4b19f6f87ea33ea3fff12bffa7","date":1515547632,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testDeleteOneOfTwoCollectionsAliased().mjava","pathOld":"/dev/null","sourceNew":"  // While writing the above test I wondered what happens when an alias points to two collections and one of them\n  // is deleted.\n  @Test\n  public void testDeleteOneOfTwoCollectionsAliased() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection_one\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection_two\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection_one to be created with 2 shards and 1 replica\", \"collection_one\", clusterShape(2, 1));\n    waitForState(\"Expected collection_two to be created with 1 shard and 1 replica\", \"collection_two\", clusterShape(1, 1));\n\n    new UpdateRequest()\n        .add(\"id\", \"1\", \"a_t\", \"humpty dumpy sat on a wall\")\n        .commit(cluster.getSolrClient(), \"collection_one\");\n\n\n    new UpdateRequest()\n        .add(\"id\", \"10\", \"a_t\", \"humpty dumpy sat on a high wall\")\n        .add(\"id\", \"11\", \"a_t\", \"humpty dumpy sat on a low wall\")\n        .commit(cluster.getSolrClient(), \"collection_two\");\n\n    // Create an alias pointing to both\n    CollectionAdminRequest.createAlias(\"collection_alias_pair\", \"collection_one,collection_two\").process(cluster.getSolrClient());\n\n    QueryResponse res = cluster.getSolrClient().query(\"collection_alias_pair\", new SolrQuery(\"*:*\"));\n    assertEquals(3, res.getResults().getNumFound());\n\n    // Now delete one of the collections, should fail since an alias points to it.\n    RequestStatusState delResp = CollectionAdminRequest.deleteCollection(\"collection_one\").processAndWait(cluster.getSolrClient(), 60);\n\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    // Now redefine the alias to only point to colletion two\n    CollectionAdminRequest.createAlias(\"collection_alias_pair\", \"collection_two\").process(cluster.getSolrClient());\n\n    //Delete collection_one.\n    delResp = CollectionAdminRequest.deleteCollection(\"collection_one\").processAndWait(cluster.getSolrClient(), 60);\n\n    assertEquals(\"Should not have failed to delete collection, it was removed from the alias: \", delResp, RequestStatusState.COMPLETED);\n\n    // Should only see two docs now in second collection\n    res = cluster.getSolrClient().query(\"collection_alias_pair\", new SolrQuery(\"*:*\"));\n    assertEquals(2, res.getResults().getNumFound());\n\n    // We shouldn't be able to ping the deleted collection directly as\n    // was deleted (and, assuming that it only points to collection_old).\n    try {\n      cluster.getSolrClient().query(\"collection_one\", new SolrQuery(\"*:*\"));\n    } catch (SolrServerException se) {\n      assertTrue(se.getMessage().contains(\"No live SolrServers\"));\n    }\n\n    // Clean up\n    CollectionAdminRequest.deleteAlias(\"collection_alias_pair\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_two\").processAndWait(cluster.getSolrClient(), 60);\n    // collection_one already deleted\n\n    assertNull(\"collection_alias_pair should be gone\",\n        cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_alias_pair\"));\n\n    assertFalse(\"collection_one should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_one\"));\n\n    assertFalse(\"collection_two should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_two\"));\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ce0b61a2648584b34304ab915de569c63bdb36b4","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testDeleteOneOfTwoCollectionsAliased().mjava","pathOld":"/dev/null","sourceNew":"  // While writing the above test I wondered what happens when an alias points to two collections and one of them\n  // is deleted.\n  @Test\n  public void testDeleteOneOfTwoCollectionsAliased() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection_one\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection_two\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection_one to be created with 2 shards and 1 replica\", \"collection_one\", clusterShape(2, 1));\n    waitForState(\"Expected collection_two to be created with 1 shard and 1 replica\", \"collection_two\", clusterShape(1, 1));\n\n    new UpdateRequest()\n        .add(\"id\", \"1\", \"a_t\", \"humpty dumpy sat on a wall\")\n        .commit(cluster.getSolrClient(), \"collection_one\");\n\n\n    new UpdateRequest()\n        .add(\"id\", \"10\", \"a_t\", \"humpty dumpy sat on a high wall\")\n        .add(\"id\", \"11\", \"a_t\", \"humpty dumpy sat on a low wall\")\n        .commit(cluster.getSolrClient(), \"collection_two\");\n\n    // Create an alias pointing to both\n    CollectionAdminRequest.createAlias(\"collection_alias_pair\", \"collection_one,collection_two\").process(cluster.getSolrClient());\n\n    QueryResponse res = cluster.getSolrClient().query(\"collection_alias_pair\", new SolrQuery(\"*:*\"));\n    assertEquals(3, res.getResults().getNumFound());\n\n    // Now delete one of the collections, should fail since an alias points to it.\n    RequestStatusState delResp = CollectionAdminRequest.deleteCollection(\"collection_one\").processAndWait(cluster.getSolrClient(), 60);\n\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    // Now redefine the alias to only point to colletion two\n    CollectionAdminRequest.createAlias(\"collection_alias_pair\", \"collection_two\").process(cluster.getSolrClient());\n\n    //Delete collection_one.\n    delResp = CollectionAdminRequest.deleteCollection(\"collection_one\").processAndWait(cluster.getSolrClient(), 60);\n\n    assertEquals(\"Should not have failed to delete collection, it was removed from the alias: \", delResp, RequestStatusState.COMPLETED);\n\n    // Should only see two docs now in second collection\n    res = cluster.getSolrClient().query(\"collection_alias_pair\", new SolrQuery(\"*:*\"));\n    assertEquals(2, res.getResults().getNumFound());\n\n    // We shouldn't be able to ping the deleted collection directly as\n    // was deleted (and, assuming that it only points to collection_old).\n    try {\n      cluster.getSolrClient().query(\"collection_one\", new SolrQuery(\"*:*\"));\n    } catch (SolrServerException se) {\n      assertTrue(se.getMessage().contains(\"No live SolrServers\"));\n    }\n\n    // Clean up\n    CollectionAdminRequest.deleteAlias(\"collection_alias_pair\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_two\").processAndWait(cluster.getSolrClient(), 60);\n    // collection_one already deleted\n\n    assertNull(\"collection_alias_pair should be gone\",\n        cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_alias_pair\"));\n\n    assertFalse(\"collection_one should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_one\"));\n\n    assertFalse(\"collection_two should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_two\"));\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testDeleteOneOfTwoCollectionsAliased().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testDeleteOneOfTwoCollectionsAliased().mjava","sourceNew":"  // While writing the above test I wondered what happens when an alias points to two collections and one of them\n  // is deleted.\n  @Test\n  public void testDeleteOneOfTwoCollectionsAliased() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection_one\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection_two\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(\"collection_one\", 2, 2);\n    cluster.waitForActiveCollection(\"collection_two\", 1, 1);\n    \n    waitForState(\"Expected collection_one to be created with 2 shards and 1 replica\", \"collection_one\", clusterShape(2, 2));\n    waitForState(\"Expected collection_two to be created with 1 shard and 1 replica\", \"collection_two\", clusterShape(1, 1));\n\n    new UpdateRequest()\n        .add(\"id\", \"1\", \"a_t\", \"humpty dumpy sat on a wall\")\n        .commit(cluster.getSolrClient(), \"collection_one\");\n\n\n    new UpdateRequest()\n        .add(\"id\", \"10\", \"a_t\", \"humpty dumpy sat on a high wall\")\n        .add(\"id\", \"11\", \"a_t\", \"humpty dumpy sat on a low wall\")\n        .commit(cluster.getSolrClient(), \"collection_two\");\n\n    // Create an alias pointing to both\n    CollectionAdminRequest.createAlias(\"collection_alias_pair\", \"collection_one,collection_two\").process(cluster.getSolrClient());\n\n    QueryResponse res = cluster.getSolrClient().query(\"collection_alias_pair\", new SolrQuery(\"*:*\"));\n    assertEquals(3, res.getResults().getNumFound());\n\n    // Now delete one of the collections, should fail since an alias points to it.\n    RequestStatusState delResp = CollectionAdminRequest.deleteCollection(\"collection_one\").processAndWait(cluster.getSolrClient(), 60);\n\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    // Now redefine the alias to only point to colletion two\n    CollectionAdminRequest.createAlias(\"collection_alias_pair\", \"collection_two\").process(cluster.getSolrClient());\n\n    //Delete collection_one.\n    delResp = CollectionAdminRequest.deleteCollection(\"collection_one\").processAndWait(cluster.getSolrClient(), 60);\n\n    assertEquals(\"Should not have failed to delete collection, it was removed from the alias: \", delResp, RequestStatusState.COMPLETED);\n\n    // Should only see two docs now in second collection\n    res = cluster.getSolrClient().query(\"collection_alias_pair\", new SolrQuery(\"*:*\"));\n    assertEquals(2, res.getResults().getNumFound());\n\n    // We shouldn't be able to ping the deleted collection directly as\n    // was deleted (and, assuming that it only points to collection_old).\n    try {\n      cluster.getSolrClient().query(\"collection_one\", new SolrQuery(\"*:*\"));\n      fail(\"should have failed\");\n    } catch (SolrServerException | SolrException se) {\n \n    }\n\n    // Clean up\n    CollectionAdminRequest.deleteAlias(\"collection_alias_pair\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_two\").processAndWait(cluster.getSolrClient(), 60);\n    // collection_one already deleted\n\n    assertNull(\"collection_alias_pair should be gone\",\n        cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_alias_pair\"));\n\n    assertFalse(\"collection_one should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_one\"));\n\n    assertFalse(\"collection_two should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_two\"));\n\n  }\n\n","sourceOld":"  // While writing the above test I wondered what happens when an alias points to two collections and one of them\n  // is deleted.\n  @Test\n  public void testDeleteOneOfTwoCollectionsAliased() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection_one\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection_two\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection_one to be created with 2 shards and 1 replica\", \"collection_one\", clusterShape(2, 1));\n    waitForState(\"Expected collection_two to be created with 1 shard and 1 replica\", \"collection_two\", clusterShape(1, 1));\n\n    new UpdateRequest()\n        .add(\"id\", \"1\", \"a_t\", \"humpty dumpy sat on a wall\")\n        .commit(cluster.getSolrClient(), \"collection_one\");\n\n\n    new UpdateRequest()\n        .add(\"id\", \"10\", \"a_t\", \"humpty dumpy sat on a high wall\")\n        .add(\"id\", \"11\", \"a_t\", \"humpty dumpy sat on a low wall\")\n        .commit(cluster.getSolrClient(), \"collection_two\");\n\n    // Create an alias pointing to both\n    CollectionAdminRequest.createAlias(\"collection_alias_pair\", \"collection_one,collection_two\").process(cluster.getSolrClient());\n\n    QueryResponse res = cluster.getSolrClient().query(\"collection_alias_pair\", new SolrQuery(\"*:*\"));\n    assertEquals(3, res.getResults().getNumFound());\n\n    // Now delete one of the collections, should fail since an alias points to it.\n    RequestStatusState delResp = CollectionAdminRequest.deleteCollection(\"collection_one\").processAndWait(cluster.getSolrClient(), 60);\n\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    // Now redefine the alias to only point to colletion two\n    CollectionAdminRequest.createAlias(\"collection_alias_pair\", \"collection_two\").process(cluster.getSolrClient());\n\n    //Delete collection_one.\n    delResp = CollectionAdminRequest.deleteCollection(\"collection_one\").processAndWait(cluster.getSolrClient(), 60);\n\n    assertEquals(\"Should not have failed to delete collection, it was removed from the alias: \", delResp, RequestStatusState.COMPLETED);\n\n    // Should only see two docs now in second collection\n    res = cluster.getSolrClient().query(\"collection_alias_pair\", new SolrQuery(\"*:*\"));\n    assertEquals(2, res.getResults().getNumFound());\n\n    // We shouldn't be able to ping the deleted collection directly as\n    // was deleted (and, assuming that it only points to collection_old).\n    try {\n      cluster.getSolrClient().query(\"collection_one\", new SolrQuery(\"*:*\"));\n    } catch (SolrServerException se) {\n      assertTrue(se.getMessage().contains(\"No live SolrServers\"));\n    }\n\n    // Clean up\n    CollectionAdminRequest.deleteAlias(\"collection_alias_pair\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_two\").processAndWait(cluster.getSolrClient(), 60);\n    // collection_one already deleted\n\n    assertNull(\"collection_alias_pair should be gone\",\n        cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_alias_pair\"));\n\n    assertFalse(\"collection_one should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_one\"));\n\n    assertFalse(\"collection_two should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_two\"));\n\n  }\n\n","bugFix":["4b342321d8906f4b19f6f87ea33ea3fff12bffa7"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fc21266829f9cffb210032f5808ce3a630780ab3","date":1560248034,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testDeleteOneOfTwoCollectionsAliased().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testDeleteOneOfTwoCollectionsAliased().mjava","sourceNew":"  // While writing the above test I wondered what happens when an alias points to two collections and one of them\n  // is deleted.\n  @Test\n  public void testDeleteOneOfTwoCollectionsAliased() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection_one\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection_two\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(\"collection_one\", 2, 2);\n    cluster.waitForActiveCollection(\"collection_two\", 1, 1);\n    \n    waitForState(\"Expected collection_one to be created with 2 shards and 1 replica\", \"collection_one\", clusterShape(2, 2));\n    waitForState(\"Expected collection_two to be created with 1 shard and 1 replica\", \"collection_two\", clusterShape(1, 1));\n\n    new UpdateRequest()\n        .add(\"id\", \"1\", \"a_t\", \"humpty dumpy sat on a wall\")\n        .commit(cluster.getSolrClient(), \"collection_one\");\n\n\n    new UpdateRequest()\n        .add(\"id\", \"10\", \"a_t\", \"humpty dumpy sat on a high wall\")\n        .add(\"id\", \"11\", \"a_t\", \"humpty dumpy sat on a low wall\")\n        .commit(cluster.getSolrClient(), \"collection_two\");\n\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    int lastVersion = zkStateReader.aliasesManager.getAliases().getZNodeVersion();\n\n    // Create an alias pointing to both\n    CollectionAdminRequest.createAlias(\"collection_alias_pair\", \"collection_one,collection_two\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    QueryResponse res = cluster.getSolrClient().query(\"collection_alias_pair\", new SolrQuery(\"*:*\"));\n    assertEquals(3, res.getResults().getNumFound());\n\n    // Now delete one of the collections, should fail since an alias points to it.\n    RequestStatusState delResp = CollectionAdminRequest.deleteCollection(\"collection_one\").processAndWait(cluster.getSolrClient(), 60);\n\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    // Now redefine the alias to only point to colletion two\n    CollectionAdminRequest.createAlias(\"collection_alias_pair\", \"collection_two\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    //Delete collection_one.\n    delResp = CollectionAdminRequest.deleteCollection(\"collection_one\").processAndWait(cluster.getSolrClient(), 60);\n\n    assertEquals(\"Should not have failed to delete collection, it was removed from the alias: \", delResp, RequestStatusState.COMPLETED);\n\n    // Should only see two docs now in second collection\n    res = cluster.getSolrClient().query(\"collection_alias_pair\", new SolrQuery(\"*:*\"));\n    assertEquals(2, res.getResults().getNumFound());\n\n    // We shouldn't be able to ping the deleted collection directly as\n    // was deleted (and, assuming that it only points to collection_old).\n    try {\n      cluster.getSolrClient().query(\"collection_one\", new SolrQuery(\"*:*\"));\n      fail(\"should have failed\");\n    } catch (SolrServerException | SolrException se) {\n \n    }\n\n    // Clean up\n    CollectionAdminRequest.deleteAlias(\"collection_alias_pair\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_two\").processAndWait(cluster.getSolrClient(), 60);\n    // collection_one already deleted\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    assertNull(\"collection_alias_pair should be gone\",\n        cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_alias_pair\"));\n\n    assertFalse(\"collection_one should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_one\"));\n\n    assertFalse(\"collection_two should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_two\"));\n\n  }\n\n","sourceOld":"  // While writing the above test I wondered what happens when an alias points to two collections and one of them\n  // is deleted.\n  @Test\n  public void testDeleteOneOfTwoCollectionsAliased() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection_one\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection_two\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(\"collection_one\", 2, 2);\n    cluster.waitForActiveCollection(\"collection_two\", 1, 1);\n    \n    waitForState(\"Expected collection_one to be created with 2 shards and 1 replica\", \"collection_one\", clusterShape(2, 2));\n    waitForState(\"Expected collection_two to be created with 1 shard and 1 replica\", \"collection_two\", clusterShape(1, 1));\n\n    new UpdateRequest()\n        .add(\"id\", \"1\", \"a_t\", \"humpty dumpy sat on a wall\")\n        .commit(cluster.getSolrClient(), \"collection_one\");\n\n\n    new UpdateRequest()\n        .add(\"id\", \"10\", \"a_t\", \"humpty dumpy sat on a high wall\")\n        .add(\"id\", \"11\", \"a_t\", \"humpty dumpy sat on a low wall\")\n        .commit(cluster.getSolrClient(), \"collection_two\");\n\n    // Create an alias pointing to both\n    CollectionAdminRequest.createAlias(\"collection_alias_pair\", \"collection_one,collection_two\").process(cluster.getSolrClient());\n\n    QueryResponse res = cluster.getSolrClient().query(\"collection_alias_pair\", new SolrQuery(\"*:*\"));\n    assertEquals(3, res.getResults().getNumFound());\n\n    // Now delete one of the collections, should fail since an alias points to it.\n    RequestStatusState delResp = CollectionAdminRequest.deleteCollection(\"collection_one\").processAndWait(cluster.getSolrClient(), 60);\n\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    // Now redefine the alias to only point to colletion two\n    CollectionAdminRequest.createAlias(\"collection_alias_pair\", \"collection_two\").process(cluster.getSolrClient());\n\n    //Delete collection_one.\n    delResp = CollectionAdminRequest.deleteCollection(\"collection_one\").processAndWait(cluster.getSolrClient(), 60);\n\n    assertEquals(\"Should not have failed to delete collection, it was removed from the alias: \", delResp, RequestStatusState.COMPLETED);\n\n    // Should only see two docs now in second collection\n    res = cluster.getSolrClient().query(\"collection_alias_pair\", new SolrQuery(\"*:*\"));\n    assertEquals(2, res.getResults().getNumFound());\n\n    // We shouldn't be able to ping the deleted collection directly as\n    // was deleted (and, assuming that it only points to collection_old).\n    try {\n      cluster.getSolrClient().query(\"collection_one\", new SolrQuery(\"*:*\"));\n      fail(\"should have failed\");\n    } catch (SolrServerException | SolrException se) {\n \n    }\n\n    // Clean up\n    CollectionAdminRequest.deleteAlias(\"collection_alias_pair\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_two\").processAndWait(cluster.getSolrClient(), 60);\n    // collection_one already deleted\n\n    assertNull(\"collection_alias_pair should be gone\",\n        cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_alias_pair\"));\n\n    assertFalse(\"collection_one should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_one\"));\n\n    assertFalse(\"collection_two should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_two\"));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ce0b61a2648584b34304ab915de569c63bdb36b4","date":1562311172,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testDeleteOneOfTwoCollectionsAliased().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testDeleteOneOfTwoCollectionsAliased().mjava","sourceNew":"  // While writing the above test I wondered what happens when an alias points to two collections and one of them\n  // is deleted.\n  @Test\n  public void testDeleteOneOfTwoCollectionsAliased() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection_one\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection_two\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(\"collection_one\", 2, 2);\n    cluster.waitForActiveCollection(\"collection_two\", 1, 1);\n    \n    waitForState(\"Expected collection_one to be created with 2 shards and 1 replica\", \"collection_one\", clusterShape(2, 2));\n    waitForState(\"Expected collection_two to be created with 1 shard and 1 replica\", \"collection_two\", clusterShape(1, 1));\n\n    new UpdateRequest()\n        .add(\"id\", \"1\", \"a_t\", \"humpty dumpy sat on a wall\")\n        .commit(cluster.getSolrClient(), \"collection_one\");\n\n\n    new UpdateRequest()\n        .add(\"id\", \"10\", \"a_t\", \"humpty dumpy sat on a high wall\")\n        .add(\"id\", \"11\", \"a_t\", \"humpty dumpy sat on a low wall\")\n        .commit(cluster.getSolrClient(), \"collection_two\");\n\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    int lastVersion = zkStateReader.aliasesManager.getAliases().getZNodeVersion();\n\n    // Create an alias pointing to both\n    CollectionAdminRequest.createAlias(\"collection_alias_pair\", \"collection_one,collection_two\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    QueryResponse res = cluster.getSolrClient().query(\"collection_alias_pair\", new SolrQuery(\"*:*\"));\n    assertEquals(3, res.getResults().getNumFound());\n\n    // Now delete one of the collections, should fail since an alias points to it.\n    RequestStatusState delResp = CollectionAdminRequest.deleteCollection(\"collection_one\").processAndWait(cluster.getSolrClient(), 60);\n    // failed because the collection is a part of a compound alias\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    CollectionAdminRequest.Delete delete = CollectionAdminRequest.deleteCollection(\"collection_alias_pair\");\n    delResp = delete.processAndWait(cluster.getSolrClient(), 60);\n    // failed because we tried to delete an alias with followAliases=false\n    assertEquals(\"Should have failed to delete alias: \", delResp, RequestStatusState.FAILED);\n\n    delete.setFollowAliases(true);\n    delResp = delete.processAndWait(cluster.getSolrClient(), 60);\n    // failed because we tried to delete compound alias\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    CollectionAdminRequest.createAlias(\"collection_alias_one\", \"collection_one\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    delete = CollectionAdminRequest.deleteCollection(\"collection_one\");\n    delResp = delete.processAndWait(cluster.getSolrClient(), 60);\n    // failed because we tried to delete collection referenced by multiple aliases\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    delete = CollectionAdminRequest.deleteCollection(\"collection_alias_one\");\n    delete.setFollowAliases(true);\n    delResp = delete.processAndWait(cluster.getSolrClient(), 60);\n    // failed because we tried to delete collection referenced by multiple aliases\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    CollectionAdminRequest.deleteAlias(\"collection_alias_one\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    // Now redefine the alias to only point to collection two\n    CollectionAdminRequest.createAlias(\"collection_alias_pair\", \"collection_two\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    //Delete collection_one.\n    delResp = CollectionAdminRequest.deleteCollection(\"collection_one\").processAndWait(cluster.getSolrClient(), 60);\n\n    assertEquals(\"Should not have failed to delete collection, it was removed from the alias: \", delResp, RequestStatusState.COMPLETED);\n\n    // Should only see two docs now in second collection\n    res = cluster.getSolrClient().query(\"collection_alias_pair\", new SolrQuery(\"*:*\"));\n    assertEquals(2, res.getResults().getNumFound());\n\n    // We shouldn't be able to ping the deleted collection directly as\n    // was deleted (and, assuming that it only points to collection_old).\n    try {\n      cluster.getSolrClient().query(\"collection_one\", new SolrQuery(\"*:*\"));\n      fail(\"should have failed\");\n    } catch (SolrServerException | SolrException se) {\n \n    }\n\n    // Clean up\n    CollectionAdminRequest.deleteAlias(\"collection_alias_pair\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_two\").processAndWait(cluster.getSolrClient(), 60);\n    // collection_one already deleted\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    assertNull(\"collection_alias_pair should be gone\",\n        cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_alias_pair\"));\n\n    assertFalse(\"collection_one should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_one\"));\n\n    assertFalse(\"collection_two should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_two\"));\n\n  }\n\n","sourceOld":"  // While writing the above test I wondered what happens when an alias points to two collections and one of them\n  // is deleted.\n  @Test\n  public void testDeleteOneOfTwoCollectionsAliased() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection_one\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection_two\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(\"collection_one\", 2, 2);\n    cluster.waitForActiveCollection(\"collection_two\", 1, 1);\n    \n    waitForState(\"Expected collection_one to be created with 2 shards and 1 replica\", \"collection_one\", clusterShape(2, 2));\n    waitForState(\"Expected collection_two to be created with 1 shard and 1 replica\", \"collection_two\", clusterShape(1, 1));\n\n    new UpdateRequest()\n        .add(\"id\", \"1\", \"a_t\", \"humpty dumpy sat on a wall\")\n        .commit(cluster.getSolrClient(), \"collection_one\");\n\n\n    new UpdateRequest()\n        .add(\"id\", \"10\", \"a_t\", \"humpty dumpy sat on a high wall\")\n        .add(\"id\", \"11\", \"a_t\", \"humpty dumpy sat on a low wall\")\n        .commit(cluster.getSolrClient(), \"collection_two\");\n\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    int lastVersion = zkStateReader.aliasesManager.getAliases().getZNodeVersion();\n\n    // Create an alias pointing to both\n    CollectionAdminRequest.createAlias(\"collection_alias_pair\", \"collection_one,collection_two\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    QueryResponse res = cluster.getSolrClient().query(\"collection_alias_pair\", new SolrQuery(\"*:*\"));\n    assertEquals(3, res.getResults().getNumFound());\n\n    // Now delete one of the collections, should fail since an alias points to it.\n    RequestStatusState delResp = CollectionAdminRequest.deleteCollection(\"collection_one\").processAndWait(cluster.getSolrClient(), 60);\n\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    // Now redefine the alias to only point to colletion two\n    CollectionAdminRequest.createAlias(\"collection_alias_pair\", \"collection_two\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    //Delete collection_one.\n    delResp = CollectionAdminRequest.deleteCollection(\"collection_one\").processAndWait(cluster.getSolrClient(), 60);\n\n    assertEquals(\"Should not have failed to delete collection, it was removed from the alias: \", delResp, RequestStatusState.COMPLETED);\n\n    // Should only see two docs now in second collection\n    res = cluster.getSolrClient().query(\"collection_alias_pair\", new SolrQuery(\"*:*\"));\n    assertEquals(2, res.getResults().getNumFound());\n\n    // We shouldn't be able to ping the deleted collection directly as\n    // was deleted (and, assuming that it only points to collection_old).\n    try {\n      cluster.getSolrClient().query(\"collection_one\", new SolrQuery(\"*:*\"));\n      fail(\"should have failed\");\n    } catch (SolrServerException | SolrException se) {\n \n    }\n\n    // Clean up\n    CollectionAdminRequest.deleteAlias(\"collection_alias_pair\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_two\").processAndWait(cluster.getSolrClient(), 60);\n    // collection_one already deleted\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    assertNull(\"collection_alias_pair should be gone\",\n        cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_alias_pair\"));\n\n    assertFalse(\"collection_one should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_one\"));\n\n    assertFalse(\"collection_two should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_two\"));\n\n  }\n\n","bugFix":["4b342321d8906f4b19f6f87ea33ea3fff12bffa7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eebf1b080530bdd7572c4927fb2bb52334b7a86","date":1563199033,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testDeleteOneOfTwoCollectionsAliased().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testDeleteOneOfTwoCollectionsAliased().mjava","sourceNew":"  // While writing the above test I wondered what happens when an alias points to two collections and one of them\n  // is deleted.\n  @Test\n  public void testDeleteOneOfTwoCollectionsAliased() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection_one\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection_two\", \"conf\", 1, 1).process(cluster.getSolrClient());\n\n    cluster.waitForActiveCollection(\"collection_one\", 2, 2);\n    cluster.waitForActiveCollection(\"collection_two\", 1, 1);\n\n    waitForState(\"Expected collection_one to be created with 2 shards and 1 replica\", \"collection_one\", clusterShape(2, 2));\n    waitForState(\"Expected collection_two to be created with 1 shard and 1 replica\", \"collection_two\", clusterShape(1, 1));\n\n    new UpdateRequest()\n        .add(\"id\", \"1\", \"a_t\", \"humpty dumpy sat on a wall\")\n        .commit(cluster.getSolrClient(), \"collection_one\");\n\n\n    new UpdateRequest()\n        .add(\"id\", \"10\", \"a_t\", \"humpty dumpy sat on a high wall\")\n        .add(\"id\", \"11\", \"a_t\", \"humpty dumpy sat on a low wall\")\n        .commit(cluster.getSolrClient(), \"collection_two\");\n\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    int lastVersion = zkStateReader.aliasesManager.getAliases().getZNodeVersion();\n\n    // Create an alias pointing to both\n    CollectionAdminRequest.createAlias(\"collection_alias_pair\", \"collection_one,collection_two\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    QueryResponse res = cluster.getSolrClient().query(\"collection_alias_pair\", new SolrQuery(\"*:*\"));\n    assertEquals(3, res.getResults().getNumFound());\n\n    // Now delete one of the collections, should fail since an alias points to it.\n    RequestStatusState delResp = CollectionAdminRequest.deleteCollection(\"collection_one\").processAndWait(cluster.getSolrClient(), 60);\n    // failed because the collection is a part of a compound alias\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    CollectionAdminRequest.Delete delete = CollectionAdminRequest.deleteCollection(\"collection_alias_pair\");\n    delResp = delete.processAndWait(cluster.getSolrClient(), 60);\n    // failed because we tried to delete an alias with followAliases=false\n    assertEquals(\"Should have failed to delete alias: \", delResp, RequestStatusState.FAILED);\n\n    delete.setFollowAliases(true);\n    delResp = delete.processAndWait(cluster.getSolrClient(), 60);\n    // failed because we tried to delete compound alias\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    CollectionAdminRequest.createAlias(\"collection_alias_one\", \"collection_one\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    delete = CollectionAdminRequest.deleteCollection(\"collection_one\");\n    delResp = delete.processAndWait(cluster.getSolrClient(), 60);\n    // failed because we tried to delete collection referenced by multiple aliases\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    delete = CollectionAdminRequest.deleteCollection(\"collection_alias_one\");\n    delete.setFollowAliases(true);\n    delResp = delete.processAndWait(cluster.getSolrClient(), 60);\n    // failed because we tried to delete collection referenced by multiple aliases\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    CollectionAdminRequest.deleteAlias(\"collection_alias_one\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    // Now redefine the alias to only point to collection two\n    CollectionAdminRequest.createAlias(\"collection_alias_pair\", \"collection_two\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    //Delete collection_one.\n    delResp = CollectionAdminRequest.deleteCollection(\"collection_one\").processAndWait(cluster.getSolrClient(), 60);\n\n    assertEquals(\"Should not have failed to delete collection, it was removed from the alias: \", delResp, RequestStatusState.COMPLETED);\n\n    // Should only see two docs now in second collection\n    res = cluster.getSolrClient().query(\"collection_alias_pair\", new SolrQuery(\"*:*\"));\n    assertEquals(2, res.getResults().getNumFound());\n\n    // We shouldn't be able to ping the deleted collection directly as\n    // was deleted (and, assuming that it only points to collection_old).\n    try {\n      cluster.getSolrClient().query(\"collection_one\", new SolrQuery(\"*:*\"));\n      fail(\"should have failed\");\n    } catch (SolrServerException | SolrException se) {\n\n    }\n\n    // Clean up\n    CollectionAdminRequest.deleteAlias(\"collection_alias_pair\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_two\").processAndWait(cluster.getSolrClient(), 60);\n    // collection_one already deleted\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    assertNull(\"collection_alias_pair should be gone\",\n        cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_alias_pair\"));\n\n    assertFalse(\"collection_one should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_one\"));\n\n    assertFalse(\"collection_two should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_two\"));\n\n  }\n\n","sourceOld":"  // While writing the above test I wondered what happens when an alias points to two collections and one of them\n  // is deleted.\n  @Test\n  public void testDeleteOneOfTwoCollectionsAliased() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection_one\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection_two\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(\"collection_one\", 2, 2);\n    cluster.waitForActiveCollection(\"collection_two\", 1, 1);\n    \n    waitForState(\"Expected collection_one to be created with 2 shards and 1 replica\", \"collection_one\", clusterShape(2, 2));\n    waitForState(\"Expected collection_two to be created with 1 shard and 1 replica\", \"collection_two\", clusterShape(1, 1));\n\n    new UpdateRequest()\n        .add(\"id\", \"1\", \"a_t\", \"humpty dumpy sat on a wall\")\n        .commit(cluster.getSolrClient(), \"collection_one\");\n\n\n    new UpdateRequest()\n        .add(\"id\", \"10\", \"a_t\", \"humpty dumpy sat on a high wall\")\n        .add(\"id\", \"11\", \"a_t\", \"humpty dumpy sat on a low wall\")\n        .commit(cluster.getSolrClient(), \"collection_two\");\n\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    int lastVersion = zkStateReader.aliasesManager.getAliases().getZNodeVersion();\n\n    // Create an alias pointing to both\n    CollectionAdminRequest.createAlias(\"collection_alias_pair\", \"collection_one,collection_two\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    QueryResponse res = cluster.getSolrClient().query(\"collection_alias_pair\", new SolrQuery(\"*:*\"));\n    assertEquals(3, res.getResults().getNumFound());\n\n    // Now delete one of the collections, should fail since an alias points to it.\n    RequestStatusState delResp = CollectionAdminRequest.deleteCollection(\"collection_one\").processAndWait(cluster.getSolrClient(), 60);\n    // failed because the collection is a part of a compound alias\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    CollectionAdminRequest.Delete delete = CollectionAdminRequest.deleteCollection(\"collection_alias_pair\");\n    delResp = delete.processAndWait(cluster.getSolrClient(), 60);\n    // failed because we tried to delete an alias with followAliases=false\n    assertEquals(\"Should have failed to delete alias: \", delResp, RequestStatusState.FAILED);\n\n    delete.setFollowAliases(true);\n    delResp = delete.processAndWait(cluster.getSolrClient(), 60);\n    // failed because we tried to delete compound alias\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    CollectionAdminRequest.createAlias(\"collection_alias_one\", \"collection_one\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    delete = CollectionAdminRequest.deleteCollection(\"collection_one\");\n    delResp = delete.processAndWait(cluster.getSolrClient(), 60);\n    // failed because we tried to delete collection referenced by multiple aliases\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    delete = CollectionAdminRequest.deleteCollection(\"collection_alias_one\");\n    delete.setFollowAliases(true);\n    delResp = delete.processAndWait(cluster.getSolrClient(), 60);\n    // failed because we tried to delete collection referenced by multiple aliases\n    assertEquals(\"Should have failed to delete collection: \", delResp, RequestStatusState.FAILED);\n\n    CollectionAdminRequest.deleteAlias(\"collection_alias_one\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    // Now redefine the alias to only point to collection two\n    CollectionAdminRequest.createAlias(\"collection_alias_pair\", \"collection_two\").process(cluster.getSolrClient());\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    //Delete collection_one.\n    delResp = CollectionAdminRequest.deleteCollection(\"collection_one\").processAndWait(cluster.getSolrClient(), 60);\n\n    assertEquals(\"Should not have failed to delete collection, it was removed from the alias: \", delResp, RequestStatusState.COMPLETED);\n\n    // Should only see two docs now in second collection\n    res = cluster.getSolrClient().query(\"collection_alias_pair\", new SolrQuery(\"*:*\"));\n    assertEquals(2, res.getResults().getNumFound());\n\n    // We shouldn't be able to ping the deleted collection directly as\n    // was deleted (and, assuming that it only points to collection_old).\n    try {\n      cluster.getSolrClient().query(\"collection_one\", new SolrQuery(\"*:*\"));\n      fail(\"should have failed\");\n    } catch (SolrServerException | SolrException se) {\n \n    }\n\n    // Clean up\n    CollectionAdminRequest.deleteAlias(\"collection_alias_pair\").processAndWait(cluster.getSolrClient(), 60);\n    CollectionAdminRequest.deleteCollection(\"collection_two\").processAndWait(cluster.getSolrClient(), 60);\n    // collection_one already deleted\n    lastVersion = waitForAliasesUpdate(lastVersion, zkStateReader);\n\n    assertNull(\"collection_alias_pair should be gone\",\n        cluster.getSolrClient().getZkStateReader().getAliases().getCollectionAliasMap().get(\"collection_alias_pair\"));\n\n    assertFalse(\"collection_one should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_one\"));\n\n    assertFalse(\"collection_two should be gone\",\n        cluster.getSolrClient().getZkStateReader().getClusterState().hasCollection(\"collection_two\"));\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4b342321d8906f4b19f6f87ea33ea3fff12bffa7"],"ce0b61a2648584b34304ab915de569c63bdb36b4":["fc21266829f9cffb210032f5808ce3a630780ab3"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["b94236357aaa22b76c10629851fe4e376e0cea82"],"4b342321d8906f4b19f6f87ea33ea3fff12bffa7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["ce0b61a2648584b34304ab915de569c63bdb36b4"],"fc21266829f9cffb210032f5808ce3a630780ab3":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"ce0b61a2648584b34304ab915de569c63bdb36b4":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"4b342321d8906f4b19f6f87ea33ea3fff12bffa7":["b94236357aaa22b76c10629851fe4e376e0cea82"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["fc21266829f9cffb210032f5808ce3a630780ab3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","4b342321d8906f4b19f6f87ea33ea3fff12bffa7"],"fc21266829f9cffb210032f5808ce3a630780ab3":["ce0b61a2648584b34304ab915de569c63bdb36b4"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}