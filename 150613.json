{"path":"solr/core/src/java/org/apache/solr/metrics/SolrMetricManager#registerAll(String,MetricSet,ResolutionStrategy,String...).mjava","commits":[{"id":"1d5f160125c0bc785bf95466c3633984b77845d0","date":1585162097,"type":1,"author":"Mike","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/metrics/SolrMetricManager#registerAll(String,MetricSet,ResolutionStrategy,String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/metrics/SolrMetricManager#registerAll(String,MetricSet,boolean,String...).mjava","sourceNew":"  /**\n   * Register all metrics in the provided {@link MetricSet}, optionally skipping those that\n   * already exist.\n   *\n   * @param registry   registry name\n   * @param metrics    metric set to register\n   * @param strategy   the conflict resolution strategy to use if the named metric already exists.\n   * @param metricPath (optional) additional top-most metric name path elements\n   * @throws Exception if a metric with this name already exists.\n   */\n  public void registerAll(String registry, MetricSet metrics, ResolutionStrategy strategy, String... metricPath) throws Exception {\n    MetricRegistry metricRegistry = registry(registry);\n    synchronized (metricRegistry) {\n      Map<String, Metric> existingMetrics = metricRegistry.getMetrics();\n      for (Map.Entry<String, Metric> entry : metrics.getMetrics().entrySet()) {\n        String fullName = mkName(entry.getKey(), metricPath);\n        if (existingMetrics.containsKey(fullName)) {\n          if (strategy == ResolutionStrategy.REPLACE) {\n            metricRegistry.remove(fullName);\n          } else if (strategy == ResolutionStrategy.IGNORE) {\n            continue;\n          } // strategy == ERROR will fail when we try to register later\n        }\n        metricRegistry.register(fullName, entry.getValue());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Register all metrics in the provided {@link MetricSet}, optionally skipping those that\n   * already exist.\n   *\n   * @param registry   registry name\n   * @param metrics    metric set to register\n   * @param force      if true then already existing metrics with the same name will be replaced.\n   *                   When false and a metric with the same name already exists an exception\n   *                   will be thrown.\n   * @param metricPath (optional) additional top-most metric name path elements\n   * @throws Exception if a metric with this name already exists.\n   */\n  public void registerAll(String registry, MetricSet metrics, boolean force, String... metricPath) throws Exception {\n    MetricRegistry metricRegistry = registry(registry);\n    synchronized (metricRegistry) {\n      Map<String, Metric> existingMetrics = metricRegistry.getMetrics();\n      for (Map.Entry<String, Metric> entry : metrics.getMetrics().entrySet()) {\n        String fullName = mkName(entry.getKey(), metricPath);\n        if (force && existingMetrics.containsKey(fullName)) {\n          metricRegistry.remove(fullName);\n        }\n        metricRegistry.register(fullName, entry.getValue());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"462c81bfb611619a4867328837e70c876bd5a94f","date":1588355232,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/metrics/SolrMetricManager#registerAll(String,MetricSet,ResolutionStrategy,String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/metrics/SolrMetricManager#registerAll(String,MetricSet,ResolutionStrategy,String...).mjava","sourceNew":"  /**\n   * Register all metrics in the provided {@link MetricSet}, optionally skipping those that\n   * already exist.\n   *\n   * @param registry   registry name\n   * @param metrics    metric set to register\n   * @param strategy   the conflict resolution strategy to use if the named metric already exists.\n   * @param metricPath (optional) additional top-most metric name path elements\n   * @throws Exception if a metric with this name already exists.\n   */\n  public void registerAll(String registry, MetricSet metrics, ResolutionStrategy strategy, String... metricPath) throws Exception {\n    MetricRegistry metricRegistry = registry(registry);\n    synchronized (metricRegistry) {\n      Map<String, Metric> existingMetrics = metricRegistry.getMetrics();\n      for (Map.Entry<String, Metric> entry : metrics.getMetrics().entrySet()) {\n        String fullName = mkName(entry.getKey(), metricPath);\n        if (strategy == ResolutionStrategy.REPLACE) {\n          metricRegistry.remove(fullName);\n        } else if (strategy == ResolutionStrategy.IGNORE && existingMetrics.containsKey(fullName)) {\n          continue;\n        } // strategy == ERROR will fail when we try to register\n        metricRegistry.register(fullName, entry.getValue());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Register all metrics in the provided {@link MetricSet}, optionally skipping those that\n   * already exist.\n   *\n   * @param registry   registry name\n   * @param metrics    metric set to register\n   * @param strategy   the conflict resolution strategy to use if the named metric already exists.\n   * @param metricPath (optional) additional top-most metric name path elements\n   * @throws Exception if a metric with this name already exists.\n   */\n  public void registerAll(String registry, MetricSet metrics, ResolutionStrategy strategy, String... metricPath) throws Exception {\n    MetricRegistry metricRegistry = registry(registry);\n    synchronized (metricRegistry) {\n      Map<String, Metric> existingMetrics = metricRegistry.getMetrics();\n      for (Map.Entry<String, Metric> entry : metrics.getMetrics().entrySet()) {\n        String fullName = mkName(entry.getKey(), metricPath);\n        if (existingMetrics.containsKey(fullName)) {\n          if (strategy == ResolutionStrategy.REPLACE) {\n            metricRegistry.remove(fullName);\n          } else if (strategy == ResolutionStrategy.IGNORE) {\n            continue;\n          } // strategy == ERROR will fail when we try to register later\n        }\n        metricRegistry.register(fullName, entry.getValue());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff7b5fca5c4207413bd78695e460f6eb81bc2e99","date":1588356568,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/metrics/SolrMetricManager#registerAll(String,MetricSet,ResolutionStrategy,String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/metrics/SolrMetricManager#registerAll(String,MetricSet,ResolutionStrategy,String...).mjava","sourceNew":"  /**\n   * Register all metrics in the provided {@link MetricSet}, optionally skipping those that\n   * already exist.\n   *\n   * @param registry   registry name\n   * @param metrics    metric set to register\n   * @param strategy   the conflict resolution strategy to use if the named metric already exists.\n   * @param metricPath (optional) additional top-most metric name path elements\n   * @throws Exception if a metric with this name already exists.\n   */\n  public void registerAll(String registry, MetricSet metrics, ResolutionStrategy strategy, String... metricPath) throws Exception {\n    MetricRegistry metricRegistry = registry(registry);\n    synchronized (metricRegistry) {\n      Map<String, Metric> existingMetrics = metricRegistry.getMetrics();\n      for (Map.Entry<String, Metric> entry : metrics.getMetrics().entrySet()) {\n        String fullName = mkName(entry.getKey(), metricPath);\n        if (existingMetrics.containsKey(fullName)) {\n          if (strategy == ResolutionStrategy.REPLACE) {\n            metricRegistry.remove(fullName);\n          } else if (strategy == ResolutionStrategy.IGNORE) {\n            continue;\n          } // strategy == ERROR will fail when we try to register later\n        }\n        metricRegistry.register(fullName, entry.getValue());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Register all metrics in the provided {@link MetricSet}, optionally skipping those that\n   * already exist.\n   *\n   * @param registry   registry name\n   * @param metrics    metric set to register\n   * @param strategy   the conflict resolution strategy to use if the named metric already exists.\n   * @param metricPath (optional) additional top-most metric name path elements\n   * @throws Exception if a metric with this name already exists.\n   */\n  public void registerAll(String registry, MetricSet metrics, ResolutionStrategy strategy, String... metricPath) throws Exception {\n    MetricRegistry metricRegistry = registry(registry);\n    synchronized (metricRegistry) {\n      Map<String, Metric> existingMetrics = metricRegistry.getMetrics();\n      for (Map.Entry<String, Metric> entry : metrics.getMetrics().entrySet()) {\n        String fullName = mkName(entry.getKey(), metricPath);\n        if (strategy == ResolutionStrategy.REPLACE) {\n          metricRegistry.remove(fullName);\n        } else if (strategy == ResolutionStrategy.IGNORE && existingMetrics.containsKey(fullName)) {\n          continue;\n        } // strategy == ERROR will fail when we try to register\n        metricRegistry.register(fullName, entry.getValue());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bad14379f15be20a5f4871be82a276e5e69731fc","date":1599578304,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/metrics/SolrMetricManager#registerAll(String,MetricSet,ResolutionStrategy,String...).mjava","pathOld":"solr/core/src/java/org/apache/solr/metrics/SolrMetricManager#registerAll(String,MetricSet,ResolutionStrategy,String...).mjava","sourceNew":"  /**\n   * Register all metrics in the provided {@link MetricSet}, optionally skipping those that\n   * already exist.\n   *\n   * @param registry   registry name\n   * @param metrics    metric set to register\n   * @param strategy   the conflict resolution strategy to use if the named metric already exists.\n   * @param metricPath (optional) additional top-most metric name path elements\n   * @throws Exception if a metric with this name already exists.\n   */\n  public void registerAll(String registry, MetricSet metrics, ResolutionStrategy strategy, String... metricPath) throws Exception {\n    MetricRegistry metricRegistry = registry(registry);\n    synchronized (metricRegistry) {\n      Map<String, Metric> existingMetrics = metricRegistry.getMetrics();\n      for (Map.Entry<String, Metric> entry : metrics.getMetrics().entrySet()) {\n        String fullName = mkName(entry.getKey(), metricPath);\n        if (strategy == ResolutionStrategy.REPLACE) {\n          metricRegistry.remove(fullName);\n        } else if (strategy == ResolutionStrategy.IGNORE && existingMetrics.containsKey(fullName)) {\n          continue;\n        } // strategy == ERROR will fail when we try to register\n        metricRegistry.register(fullName, entry.getValue());\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Register all metrics in the provided {@link MetricSet}, optionally skipping those that\n   * already exist.\n   *\n   * @param registry   registry name\n   * @param metrics    metric set to register\n   * @param strategy   the conflict resolution strategy to use if the named metric already exists.\n   * @param metricPath (optional) additional top-most metric name path elements\n   * @throws Exception if a metric with this name already exists.\n   */\n  public void registerAll(String registry, MetricSet metrics, ResolutionStrategy strategy, String... metricPath) throws Exception {\n    MetricRegistry metricRegistry = registry(registry);\n    synchronized (metricRegistry) {\n      Map<String, Metric> existingMetrics = metricRegistry.getMetrics();\n      for (Map.Entry<String, Metric> entry : metrics.getMetrics().entrySet()) {\n        String fullName = mkName(entry.getKey(), metricPath);\n        if (existingMetrics.containsKey(fullName)) {\n          if (strategy == ResolutionStrategy.REPLACE) {\n            metricRegistry.remove(fullName);\n          } else if (strategy == ResolutionStrategy.IGNORE) {\n            continue;\n          } // strategy == ERROR will fail when we try to register later\n        }\n        metricRegistry.register(fullName, entry.getValue());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"462c81bfb611619a4867328837e70c876bd5a94f":["1d5f160125c0bc785bf95466c3633984b77845d0"],"1d5f160125c0bc785bf95466c3633984b77845d0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ff7b5fca5c4207413bd78695e460f6eb81bc2e99":["462c81bfb611619a4867328837e70c876bd5a94f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bad14379f15be20a5f4871be82a276e5e69731fc":["ff7b5fca5c4207413bd78695e460f6eb81bc2e99"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bad14379f15be20a5f4871be82a276e5e69731fc"]},"commit2Childs":{"462c81bfb611619a4867328837e70c876bd5a94f":["ff7b5fca5c4207413bd78695e460f6eb81bc2e99"],"1d5f160125c0bc785bf95466c3633984b77845d0":["462c81bfb611619a4867328837e70c876bd5a94f"],"ff7b5fca5c4207413bd78695e460f6eb81bc2e99":["bad14379f15be20a5f4871be82a276e5e69731fc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1d5f160125c0bc785bf95466c3633984b77845d0"],"bad14379f15be20a5f4871be82a276e5e69731fc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}