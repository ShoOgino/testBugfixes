{"path":"lucene/contrib/analyzers/stempel/src/java/org/egothor/stemmer/Diff#exec(String,String).mjava","commits":[{"id":"67748b41458c73d49a48168362cc7f4c960a2542","date":1272890662,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/contrib/analyzers/stempel/src/java/org/egothor/stemmer/Diff#exec(String,String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Construct a patch string that transforms a to b.\n   * \n   * @param a String 1st string\n   * @param b String 2nd string\n   * @return String\n   */\n  public synchronized String exec(String a, String b) {\n    if (a == null || b == null) {\n      return null;\n    }\n    \n    int x;\n    int y;\n    int maxx;\n    int maxy;\n    int go[] = new int[4];\n    final int X = 1;\n    final int Y = 2;\n    final int R = 3;\n    final int D = 0;\n    \n    /*\n     * setup memory if needed => processing speed up\n     */\n    maxx = a.length() + 1;\n    maxy = b.length() + 1;\n    if ((maxx >= sizex) || (maxy >= sizey)) {\n      sizex = maxx + 8;\n      sizey = maxy + 8;\n      net = new int[sizex][sizey];\n      way = new int[sizex][sizey];\n    }\n    \n    /*\n     * clear the network\n     */\n    for (x = 0; x < maxx; x++) {\n      for (y = 0; y < maxy; y++) {\n        net[x][y] = 0;\n      }\n    }\n    \n    /*\n     * set known persistent values\n     */\n    for (x = 1; x < maxx; x++) {\n      net[x][0] = x;\n      way[x][0] = X;\n    }\n    for (y = 1; y < maxy; y++) {\n      net[0][y] = y;\n      way[0][y] = Y;\n    }\n    \n    for (x = 1; x < maxx; x++) {\n      for (y = 1; y < maxy; y++) {\n        go[X] = net[x - 1][y] + DELETE;\n        // way on x costs 1 unit\n        go[Y] = net[x][y - 1] + INSERT;\n        // way on y costs 1 unit\n        go[R] = net[x - 1][y - 1] + REPLACE;\n        go[D] = net[x - 1][y - 1]\n            + ((a.charAt(x - 1) == b.charAt(y - 1)) ? NOOP : 100);\n        // diagonal costs 0, when no change\n        short min = D;\n        if (go[min] >= go[X]) {\n          min = X;\n        }\n        if (go[min] > go[Y]) {\n          min = Y;\n        }\n        if (go[min] > go[R]) {\n          min = R;\n        }\n        way[x][y] = min;\n        net[x][y] = (short) go[min];\n      }\n    }\n    \n    // read the patch string\n    StringBuffer result = new StringBuffer();\n    final char base = 'a' - 1;\n    char deletes = base;\n    char equals = base;\n    for (x = maxx - 1, y = maxy - 1; x + y != 0;) {\n      switch (way[x][y]) {\n        case X:\n          if (equals != base) {\n            result.append(\"-\" + (equals));\n            equals = base;\n          }\n          deletes++;\n          x--;\n          break;\n        // delete\n        case Y:\n          if (deletes != base) {\n            result.append(\"D\" + (deletes));\n            deletes = base;\n          }\n          if (equals != base) {\n            result.append(\"-\" + (equals));\n            equals = base;\n          }\n          result.append('I');\n          result.append(b.charAt(--y));\n          break;\n        // insert\n        case R:\n          if (deletes != base) {\n            result.append(\"D\" + (deletes));\n            deletes = base;\n          }\n          if (equals != base) {\n            result.append(\"-\" + (equals));\n            equals = base;\n          }\n          result.append('R');\n          result.append(b.charAt(--y));\n          x--;\n          break;\n        // replace\n        case D:\n          if (deletes != base) {\n            result.append(\"D\" + (deletes));\n            deletes = base;\n          }\n          equals++;\n          x--;\n          y--;\n          break;\n        // no change\n      }\n    }\n    if (deletes != base) {\n      result.append(\"D\" + (deletes));\n      deletes = base;\n    }\n    \n    return result.toString();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d06343967a29132f5d782f74e8d0988400278a02"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0f080986da691a3bba7b757f43ab72cdc82b57ce","date":1273069619,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/stempel/src/java/org/egothor/stemmer/Diff#exec(String,String).mjava","pathOld":"lucene/contrib/analyzers/stempel/src/java/org/egothor/stemmer/Diff#exec(String,String).mjava","sourceNew":"  /**\n   * Construct a patch string that transforms a to b.\n   * \n   * @param a String 1st string\n   * @param b String 2nd string\n   * @return String\n   */\n  public synchronized String exec(String a, String b) {\n    if (a == null || b == null) {\n      return null;\n    }\n    \n    int x;\n    int y;\n    int maxx;\n    int maxy;\n    int go[] = new int[4];\n    final int X = 1;\n    final int Y = 2;\n    final int R = 3;\n    final int D = 0;\n    \n    /*\n     * setup memory if needed => processing speed up\n     */\n    maxx = a.length() + 1;\n    maxy = b.length() + 1;\n    if ((maxx >= sizex) || (maxy >= sizey)) {\n      sizex = maxx + 8;\n      sizey = maxy + 8;\n      net = new int[sizex][sizey];\n      way = new int[sizex][sizey];\n    }\n    \n    /*\n     * clear the network\n     */\n    for (x = 0; x < maxx; x++) {\n      for (y = 0; y < maxy; y++) {\n        net[x][y] = 0;\n      }\n    }\n    \n    /*\n     * set known persistent values\n     */\n    for (x = 1; x < maxx; x++) {\n      net[x][0] = x;\n      way[x][0] = X;\n    }\n    for (y = 1; y < maxy; y++) {\n      net[0][y] = y;\n      way[0][y] = Y;\n    }\n    \n    for (x = 1; x < maxx; x++) {\n      for (y = 1; y < maxy; y++) {\n        go[X] = net[x - 1][y] + DELETE;\n        // way on x costs 1 unit\n        go[Y] = net[x][y - 1] + INSERT;\n        // way on y costs 1 unit\n        go[R] = net[x - 1][y - 1] + REPLACE;\n        go[D] = net[x - 1][y - 1]\n            + ((a.charAt(x - 1) == b.charAt(y - 1)) ? NOOP : 100);\n        // diagonal costs 0, when no change\n        short min = D;\n        if (go[min] >= go[X]) {\n          min = X;\n        }\n        if (go[min] > go[Y]) {\n          min = Y;\n        }\n        if (go[min] > go[R]) {\n          min = R;\n        }\n        way[x][y] = min;\n        net[x][y] = (short) go[min];\n      }\n    }\n    \n    // read the patch string\n    StringBuffer result = new StringBuffer();\n    final char base = 'a' - 1;\n    char deletes = base;\n    char equals = base;\n    for (x = maxx - 1, y = maxy - 1; x + y != 0;) {\n      switch (way[x][y]) {\n        case X:\n          if (equals != base) {\n            result.append(\"-\" + (equals));\n            equals = base;\n          }\n          deletes++;\n          x--;\n          break;\n        // delete\n        case Y:\n          if (deletes != base) {\n            result.append(\"D\" + (deletes));\n            deletes = base;\n          }\n          if (equals != base) {\n            result.append(\"-\" + (equals));\n            equals = base;\n          }\n          result.append('I');\n          result.append(b.charAt(--y));\n          break;\n        // insert\n        case R:\n          if (deletes != base) {\n            result.append(\"D\" + (deletes));\n            deletes = base;\n          }\n          if (equals != base) {\n            result.append(\"-\" + (equals));\n            equals = base;\n          }\n          result.append('R');\n          result.append(b.charAt(--y));\n          x--;\n          break;\n        // replace\n        case D:\n          if (deletes != base) {\n            result.append(\"D\" + (deletes));\n            deletes = base;\n          }\n          equals++;\n          x--;\n          y--;\n          break;\n        // no change\n      }\n    }\n    if (deletes != base) {\n      result.append(\"D\" + (deletes));\n      deletes = base;\n    }\n    \n    return result.toString();\n  }\n\n","sourceOld":"  /**\n   * Construct a patch string that transforms a to b.\n   * \n   * @param a String 1st string\n   * @param b String 2nd string\n   * @return String\n   */\n  public synchronized String exec(String a, String b) {\n    if (a == null || b == null) {\n      return null;\n    }\n    \n    int x;\n    int y;\n    int maxx;\n    int maxy;\n    int go[] = new int[4];\n    final int X = 1;\n    final int Y = 2;\n    final int R = 3;\n    final int D = 0;\n    \n    /*\n     * setup memory if needed => processing speed up\n     */\n    maxx = a.length() + 1;\n    maxy = b.length() + 1;\n    if ((maxx >= sizex) || (maxy >= sizey)) {\n      sizex = maxx + 8;\n      sizey = maxy + 8;\n      net = new int[sizex][sizey];\n      way = new int[sizex][sizey];\n    }\n    \n    /*\n     * clear the network\n     */\n    for (x = 0; x < maxx; x++) {\n      for (y = 0; y < maxy; y++) {\n        net[x][y] = 0;\n      }\n    }\n    \n    /*\n     * set known persistent values\n     */\n    for (x = 1; x < maxx; x++) {\n      net[x][0] = x;\n      way[x][0] = X;\n    }\n    for (y = 1; y < maxy; y++) {\n      net[0][y] = y;\n      way[0][y] = Y;\n    }\n    \n    for (x = 1; x < maxx; x++) {\n      for (y = 1; y < maxy; y++) {\n        go[X] = net[x - 1][y] + DELETE;\n        // way on x costs 1 unit\n        go[Y] = net[x][y - 1] + INSERT;\n        // way on y costs 1 unit\n        go[R] = net[x - 1][y - 1] + REPLACE;\n        go[D] = net[x - 1][y - 1]\n            + ((a.charAt(x - 1) == b.charAt(y - 1)) ? NOOP : 100);\n        // diagonal costs 0, when no change\n        short min = D;\n        if (go[min] >= go[X]) {\n          min = X;\n        }\n        if (go[min] > go[Y]) {\n          min = Y;\n        }\n        if (go[min] > go[R]) {\n          min = R;\n        }\n        way[x][y] = min;\n        net[x][y] = (short) go[min];\n      }\n    }\n    \n    // read the patch string\n    StringBuffer result = new StringBuffer();\n    final char base = 'a' - 1;\n    char deletes = base;\n    char equals = base;\n    for (x = maxx - 1, y = maxy - 1; x + y != 0;) {\n      switch (way[x][y]) {\n        case X:\n          if (equals != base) {\n            result.append(\"-\" + (equals));\n            equals = base;\n          }\n          deletes++;\n          x--;\n          break;\n        // delete\n        case Y:\n          if (deletes != base) {\n            result.append(\"D\" + (deletes));\n            deletes = base;\n          }\n          if (equals != base) {\n            result.append(\"-\" + (equals));\n            equals = base;\n          }\n          result.append('I');\n          result.append(b.charAt(--y));\n          break;\n        // insert\n        case R:\n          if (deletes != base) {\n            result.append(\"D\" + (deletes));\n            deletes = base;\n          }\n          if (equals != base) {\n            result.append(\"-\" + (equals));\n            equals = base;\n          }\n          result.append('R');\n          result.append(b.charAt(--y));\n          x--;\n          break;\n        // replace\n        case D:\n          if (deletes != base) {\n            result.append(\"D\" + (deletes));\n            deletes = base;\n          }\n          equals++;\n          x--;\n          y--;\n          break;\n        // no change\n      }\n    }\n    if (deletes != base) {\n      result.append(\"D\" + (deletes));\n      deletes = base;\n    }\n    \n    return result.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"67748b41458c73d49a48168362cc7f4c960a2542":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0f080986da691a3bba7b757f43ab72cdc82b57ce":["67748b41458c73d49a48168362cc7f4c960a2542"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f080986da691a3bba7b757f43ab72cdc82b57ce"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["67748b41458c73d49a48168362cc7f4c960a2542"],"67748b41458c73d49a48168362cc7f4c960a2542":["0f080986da691a3bba7b757f43ab72cdc82b57ce"],"0f080986da691a3bba7b757f43ab72cdc82b57ce":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}