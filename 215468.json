{"path":"lucene/src/java/org/apache/lucene/util/automaton/RegExp#toAutomaton(Map[String,Automaton],AutomatonProvider).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/RegExp#toAutomaton(Map[String,Automaton],AutomatonProvider).mjava","pathOld":"/dev/null","sourceNew":"  private Automaton toAutomaton(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider) throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<Automaton>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        a = BasicOperations.union(list);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<Automaton>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        a = BasicOperations.concatenate(list);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_INTERSECTION:\n        a = exp1.toAutomaton(automata, automaton_provider).intersection(\n            exp2.toAutomaton(automata, automaton_provider));\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_OPTIONAL:\n        a = exp1.toAutomaton(automata, automaton_provider).optional();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat(min);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat(min, max);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = exp1.toAutomaton(automata, automaton_provider).complement();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CHAR:\n        a = BasicAutomata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = BasicAutomata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = BasicAutomata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = BasicAutomata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = BasicAutomata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = BasicAutomata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) aa = automata.get(s);\n        if (aa == null && automaton_provider != null) try {\n          aa = automaton_provider.getAutomaton(s);\n        } catch (IOException e) {\n          throw new IllegalArgumentException(e);\n        }\n        if (aa == null) throw new IllegalArgumentException(\"'\" + s\n            + \"' not found\");\n        a = aa.clone(); // always clone here (ignore allow_mutate)\n        break;\n      case REGEXP_INTERVAL:\n        a = BasicAutomata.makeInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/RegExp#toAutomaton(Map[String,Automaton],AutomatonProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/RegExp#toAutomaton(Map[String,Automaton],AutomatonProvider).mjava","sourceNew":"  private Automaton toAutomaton(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider) throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<Automaton>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        a = BasicOperations.union(list);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<Automaton>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        a = BasicOperations.concatenate(list);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_INTERSECTION:\n        a = exp1.toAutomaton(automata, automaton_provider).intersection(\n            exp2.toAutomaton(automata, automaton_provider));\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_OPTIONAL:\n        a = exp1.toAutomaton(automata, automaton_provider).optional();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat(min);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat(min, max);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = exp1.toAutomaton(automata, automaton_provider).complement();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CHAR:\n        a = BasicAutomata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = BasicAutomata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = BasicAutomata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = BasicAutomata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = BasicAutomata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = BasicAutomata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) aa = automata.get(s);\n        if (aa == null && automaton_provider != null) try {\n          aa = automaton_provider.getAutomaton(s);\n        } catch (IOException e) {\n          throw new IllegalArgumentException(e);\n        }\n        if (aa == null) throw new IllegalArgumentException(\"'\" + s\n            + \"' not found\");\n        a = aa.clone(); // always clone here (ignore allow_mutate)\n        break;\n      case REGEXP_INTERVAL:\n        a = BasicAutomata.makeInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","sourceOld":"  private Automaton toAutomaton(Map<String,Automaton> automata,\n      AutomatonProvider automaton_provider) throws IllegalArgumentException {\n    List<Automaton> list;\n    Automaton a = null;\n    switch (kind) {\n      case REGEXP_UNION:\n        list = new ArrayList<Automaton>();\n        findLeaves(exp1, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_UNION, list, automata, automaton_provider);\n        a = BasicOperations.union(list);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CONCATENATION:\n        list = new ArrayList<Automaton>();\n        findLeaves(exp1, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        findLeaves(exp2, Kind.REGEXP_CONCATENATION, list, automata,\n            automaton_provider);\n        a = BasicOperations.concatenate(list);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_INTERSECTION:\n        a = exp1.toAutomaton(automata, automaton_provider).intersection(\n            exp2.toAutomaton(automata, automaton_provider));\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_OPTIONAL:\n        a = exp1.toAutomaton(automata, automaton_provider).optional();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MIN:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat(min);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_REPEAT_MINMAX:\n        a = exp1.toAutomaton(automata, automaton_provider).repeat(min, max);\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_COMPLEMENT:\n        a = exp1.toAutomaton(automata, automaton_provider).complement();\n        MinimizationOperations.minimize(a);\n        break;\n      case REGEXP_CHAR:\n        a = BasicAutomata.makeChar(c);\n        break;\n      case REGEXP_CHAR_RANGE:\n        a = BasicAutomata.makeCharRange(from, to);\n        break;\n      case REGEXP_ANYCHAR:\n        a = BasicAutomata.makeAnyChar();\n        break;\n      case REGEXP_EMPTY:\n        a = BasicAutomata.makeEmpty();\n        break;\n      case REGEXP_STRING:\n        a = BasicAutomata.makeString(s);\n        break;\n      case REGEXP_ANYSTRING:\n        a = BasicAutomata.makeAnyString();\n        break;\n      case REGEXP_AUTOMATON:\n        Automaton aa = null;\n        if (automata != null) aa = automata.get(s);\n        if (aa == null && automaton_provider != null) try {\n          aa = automaton_provider.getAutomaton(s);\n        } catch (IOException e) {\n          throw new IllegalArgumentException(e);\n        }\n        if (aa == null) throw new IllegalArgumentException(\"'\" + s\n            + \"' not found\");\n        a = aa.clone(); // always clone here (ignore allow_mutate)\n        break;\n      case REGEXP_INTERVAL:\n        a = BasicAutomata.makeInterval(min, max, digits);\n        break;\n    }\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}