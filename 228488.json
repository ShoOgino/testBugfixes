{"path":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer#mergeNumericField(FieldInfo,MergeState,List[NumericDocValues]).mjava","commits":[{"id":"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200","date":1358521790,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer#mergeNumericField(FieldInfo,MergeState,List[NumericDocValues]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer#mergeNumericField(FieldInfo,MergeState,List[NumericDocValues]).mjava","sourceNew":"  // dead simple impl: codec can optimize\n  public void mergeNumericField(FieldInfo fieldInfo, final MergeState mergeState, final List<NumericDocValues> toMerge) throws IOException {\n\n    addNumericField(fieldInfo,\n                    new Iterable<Number>() {\n                      @Override\n                      public Iterator<Number> iterator() {\n                        return new Iterator<Number>() {\n                          int readerUpto = -1;\n                          int docIDUpto;\n                          long nextValue;\n                          AtomicReader currentReader;\n                          NumericDocValues currentValues;\n                          Bits currentLiveDocs;\n                          boolean nextIsSet;\n\n                          @Override\n                          public boolean hasNext() {\n                            return nextIsSet || setNext();\n                          }\n\n                          @Override\n                          public void remove() {\n                            throw new UnsupportedOperationException();\n                          }\n\n                          @Override\n                          public Number next() {\n                            if (!hasNext()) {\n                              throw new NoSuchElementException();\n                            }\n                            assert nextIsSet;\n                            nextIsSet = false;\n                            // nocommit make a mutable number\n                            return nextValue;\n                          }\n\n                          private boolean setNext() {\n                            while (true) {\n                              if (readerUpto == toMerge.size()) {\n                                return false;\n                              }\n\n                              if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                                readerUpto++;\n                                if (readerUpto < toMerge.size()) {\n                                  currentReader = mergeState.readers.get(readerUpto);\n                                  currentValues = toMerge.get(readerUpto);\n                                  currentLiveDocs = currentReader.getLiveDocs();\n                                }\n                                docIDUpto = 0;\n                                continue;\n                              }\n\n                              if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                                nextIsSet = true;\n                                nextValue = currentValues.get(docIDUpto);\n                                docIDUpto++;\n                                return true;\n                              }\n\n                              docIDUpto++;\n                            }\n                          }\n                        };\n                      }\n                    });\n  }\n\n","sourceOld":"  // dead simple impl: codec can optimize\n  public void mergeNumericField(FieldInfo fieldInfo, final MergeState mergeState, final List<NumericDocValues> toMerge) throws IOException {\n\n    addNumericField(fieldInfo,\n                    new Iterable<Number>() {\n                      @Override\n                      public Iterator<Number> iterator() {\n                        return new Iterator<Number>() {\n                          int readerUpto = -1;\n                          int docIDUpto;\n                          long nextValue;\n                          AtomicReader currentReader;\n                          NumericDocValues currentValues;\n                          Bits currentLiveDocs;\n                          boolean nextIsSet;\n\n                          @Override\n                          public boolean hasNext() {\n                            return nextIsSet || setNext();\n                          }\n\n                          @Override\n                          public void remove() {\n                            throw new UnsupportedOperationException();\n                          }\n\n                          @Override\n                          public Number next() {\n                            if (!hasNext()) {\n                              throw new NoSuchElementException();\n                            }\n                            assert nextIsSet;\n                            nextIsSet = false;\n                            // nocommit make a mutable number\n                            return nextValue;\n                          }\n\n                          private boolean setNext() {\n                            while (true) {\n                              if (readerUpto == toMerge.size()) {\n                                return false;\n                              }\n\n                              if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                                readerUpto++;\n                                if (readerUpto < toMerge.size()) {\n                                  currentReader = mergeState.readers.get(readerUpto);\n                                  currentValues = toMerge.get(readerUpto);\n                                  currentLiveDocs = currentReader.getLiveDocs();\n                                }\n                                docIDUpto = 0;\n                                continue;\n                              }\n\n                              if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                                nextIsSet = true;\n                                nextValue = currentValues.get(docIDUpto);\n                                docIDUpto++;\n                                return true;\n                              }\n\n                              docIDUpto++;\n                            }\n                          }\n                        };\n                      }\n                    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a9a6724ea8fca14131aa2741cc57f4fdbfef50d","date":1359129694,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer#mergeNumericField(FieldInfo,MergeState,List[NumericDocValues]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer#mergeNumericField(FieldInfo,MergeState,List[NumericDocValues]).mjava","sourceNew":"  // dead simple impl: codec can optimize\n  public void mergeNumericField(FieldInfo fieldInfo, final MergeState mergeState, final List<NumericDocValues> toMerge) throws IOException {\n\n    addNumericField(fieldInfo,\n                    new Iterable<Number>() {\n                      @Override\n                      public Iterator<Number> iterator() {\n                        return new Iterator<Number>() {\n                          int readerUpto = -1;\n                          int docIDUpto;\n                          long nextValue;\n                          AtomicReader currentReader;\n                          NumericDocValues currentValues;\n                          Bits currentLiveDocs;\n                          boolean nextIsSet;\n\n                          @Override\n                          public boolean hasNext() {\n                            return nextIsSet || setNext();\n                          }\n\n                          @Override\n                          public void remove() {\n                            throw new UnsupportedOperationException();\n                          }\n\n                          @Override\n                          public Number next() {\n                            if (!hasNext()) {\n                              throw new NoSuchElementException();\n                            }\n                            assert nextIsSet;\n                            nextIsSet = false;\n                            // TODO: make a mutable number\n                            return nextValue;\n                          }\n\n                          private boolean setNext() {\n                            while (true) {\n                              if (readerUpto == toMerge.size()) {\n                                return false;\n                              }\n\n                              if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                                readerUpto++;\n                                if (readerUpto < toMerge.size()) {\n                                  currentReader = mergeState.readers.get(readerUpto);\n                                  currentValues = toMerge.get(readerUpto);\n                                  currentLiveDocs = currentReader.getLiveDocs();\n                                }\n                                docIDUpto = 0;\n                                continue;\n                              }\n\n                              if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                                nextIsSet = true;\n                                nextValue = currentValues.get(docIDUpto);\n                                docIDUpto++;\n                                return true;\n                              }\n\n                              docIDUpto++;\n                            }\n                          }\n                        };\n                      }\n                    });\n  }\n\n","sourceOld":"  // dead simple impl: codec can optimize\n  public void mergeNumericField(FieldInfo fieldInfo, final MergeState mergeState, final List<NumericDocValues> toMerge) throws IOException {\n\n    addNumericField(fieldInfo,\n                    new Iterable<Number>() {\n                      @Override\n                      public Iterator<Number> iterator() {\n                        return new Iterator<Number>() {\n                          int readerUpto = -1;\n                          int docIDUpto;\n                          long nextValue;\n                          AtomicReader currentReader;\n                          NumericDocValues currentValues;\n                          Bits currentLiveDocs;\n                          boolean nextIsSet;\n\n                          @Override\n                          public boolean hasNext() {\n                            return nextIsSet || setNext();\n                          }\n\n                          @Override\n                          public void remove() {\n                            throw new UnsupportedOperationException();\n                          }\n\n                          @Override\n                          public Number next() {\n                            if (!hasNext()) {\n                              throw new NoSuchElementException();\n                            }\n                            assert nextIsSet;\n                            nextIsSet = false;\n                            // nocommit make a mutable number\n                            return nextValue;\n                          }\n\n                          private boolean setNext() {\n                            while (true) {\n                              if (readerUpto == toMerge.size()) {\n                                return false;\n                              }\n\n                              if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                                readerUpto++;\n                                if (readerUpto < toMerge.size()) {\n                                  currentReader = mergeState.readers.get(readerUpto);\n                                  currentValues = toMerge.get(readerUpto);\n                                  currentLiveDocs = currentReader.getLiveDocs();\n                                }\n                                docIDUpto = 0;\n                                continue;\n                              }\n\n                              if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                                nextIsSet = true;\n                                nextValue = currentValues.get(docIDUpto);\n                                docIDUpto++;\n                                return true;\n                              }\n\n                              docIDUpto++;\n                            }\n                          }\n                        };\n                      }\n                    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f2e50e80d6a567d6b1590f373e8b32093c72de02","date":1359140279,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer#mergeNumericField(FieldInfo,MergeState,List[NumericDocValues]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer#mergeNumericField(FieldInfo,MergeState,List[NumericDocValues]).mjava","sourceNew":"  /**\n   * Merges the numeric docvalues from <code>toMerge</code>.\n   * <p>\n   * The default implementation calls {@link #addNumericField}, passing\n   * an Iterable that merges and filters deleted documents on the fly.\n   */\n  public void mergeNumericField(FieldInfo fieldInfo, final MergeState mergeState, final List<NumericDocValues> toMerge) throws IOException {\n\n    addNumericField(fieldInfo,\n                    new Iterable<Number>() {\n                      @Override\n                      public Iterator<Number> iterator() {\n                        return new Iterator<Number>() {\n                          int readerUpto = -1;\n                          int docIDUpto;\n                          long nextValue;\n                          AtomicReader currentReader;\n                          NumericDocValues currentValues;\n                          Bits currentLiveDocs;\n                          boolean nextIsSet;\n\n                          @Override\n                          public boolean hasNext() {\n                            return nextIsSet || setNext();\n                          }\n\n                          @Override\n                          public void remove() {\n                            throw new UnsupportedOperationException();\n                          }\n\n                          @Override\n                          public Number next() {\n                            if (!hasNext()) {\n                              throw new NoSuchElementException();\n                            }\n                            assert nextIsSet;\n                            nextIsSet = false;\n                            // TODO: make a mutable number\n                            return nextValue;\n                          }\n\n                          private boolean setNext() {\n                            while (true) {\n                              if (readerUpto == toMerge.size()) {\n                                return false;\n                              }\n\n                              if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                                readerUpto++;\n                                if (readerUpto < toMerge.size()) {\n                                  currentReader = mergeState.readers.get(readerUpto);\n                                  currentValues = toMerge.get(readerUpto);\n                                  currentLiveDocs = currentReader.getLiveDocs();\n                                }\n                                docIDUpto = 0;\n                                continue;\n                              }\n\n                              if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                                nextIsSet = true;\n                                nextValue = currentValues.get(docIDUpto);\n                                docIDUpto++;\n                                return true;\n                              }\n\n                              docIDUpto++;\n                            }\n                          }\n                        };\n                      }\n                    });\n  }\n\n","sourceOld":"  // dead simple impl: codec can optimize\n  public void mergeNumericField(FieldInfo fieldInfo, final MergeState mergeState, final List<NumericDocValues> toMerge) throws IOException {\n\n    addNumericField(fieldInfo,\n                    new Iterable<Number>() {\n                      @Override\n                      public Iterator<Number> iterator() {\n                        return new Iterator<Number>() {\n                          int readerUpto = -1;\n                          int docIDUpto;\n                          long nextValue;\n                          AtomicReader currentReader;\n                          NumericDocValues currentValues;\n                          Bits currentLiveDocs;\n                          boolean nextIsSet;\n\n                          @Override\n                          public boolean hasNext() {\n                            return nextIsSet || setNext();\n                          }\n\n                          @Override\n                          public void remove() {\n                            throw new UnsupportedOperationException();\n                          }\n\n                          @Override\n                          public Number next() {\n                            if (!hasNext()) {\n                              throw new NoSuchElementException();\n                            }\n                            assert nextIsSet;\n                            nextIsSet = false;\n                            // TODO: make a mutable number\n                            return nextValue;\n                          }\n\n                          private boolean setNext() {\n                            while (true) {\n                              if (readerUpto == toMerge.size()) {\n                                return false;\n                              }\n\n                              if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                                readerUpto++;\n                                if (readerUpto < toMerge.size()) {\n                                  currentReader = mergeState.readers.get(readerUpto);\n                                  currentValues = toMerge.get(readerUpto);\n                                  currentLiveDocs = currentReader.getLiveDocs();\n                                }\n                                docIDUpto = 0;\n                                continue;\n                              }\n\n                              if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                                nextIsSet = true;\n                                nextValue = currentValues.get(docIDUpto);\n                                docIDUpto++;\n                                return true;\n                              }\n\n                              docIDUpto++;\n                            }\n                          }\n                        };\n                      }\n                    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer#mergeNumericField(FieldInfo,MergeState,List[NumericDocValues]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Merges the numeric docvalues from <code>toMerge</code>.\n   * <p>\n   * The default implementation calls {@link #addNumericField}, passing\n   * an Iterable that merges and filters deleted documents on the fly.\n   */\n  public void mergeNumericField(FieldInfo fieldInfo, final MergeState mergeState, final List<NumericDocValues> toMerge) throws IOException {\n\n    addNumericField(fieldInfo,\n                    new Iterable<Number>() {\n                      @Override\n                      public Iterator<Number> iterator() {\n                        return new Iterator<Number>() {\n                          int readerUpto = -1;\n                          int docIDUpto;\n                          long nextValue;\n                          AtomicReader currentReader;\n                          NumericDocValues currentValues;\n                          Bits currentLiveDocs;\n                          boolean nextIsSet;\n\n                          @Override\n                          public boolean hasNext() {\n                            return nextIsSet || setNext();\n                          }\n\n                          @Override\n                          public void remove() {\n                            throw new UnsupportedOperationException();\n                          }\n\n                          @Override\n                          public Number next() {\n                            if (!hasNext()) {\n                              throw new NoSuchElementException();\n                            }\n                            assert nextIsSet;\n                            nextIsSet = false;\n                            // TODO: make a mutable number\n                            return nextValue;\n                          }\n\n                          private boolean setNext() {\n                            while (true) {\n                              if (readerUpto == toMerge.size()) {\n                                return false;\n                              }\n\n                              if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                                readerUpto++;\n                                if (readerUpto < toMerge.size()) {\n                                  currentReader = mergeState.readers.get(readerUpto);\n                                  currentValues = toMerge.get(readerUpto);\n                                  currentLiveDocs = currentReader.getLiveDocs();\n                                }\n                                docIDUpto = 0;\n                                continue;\n                              }\n\n                              if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                                nextIsSet = true;\n                                nextValue = currentValues.get(docIDUpto);\n                                docIDUpto++;\n                                return true;\n                              }\n\n                              docIDUpto++;\n                            }\n                          }\n                        };\n                      }\n                    });\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9faa42f41b6adb98daf009cf99a4ee239189e469","date":1376648738,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer#mergeNumericField(FieldInfo,MergeState,List[NumericDocValues],List[Bits]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer#mergeNumericField(FieldInfo,MergeState,List[NumericDocValues]).mjava","sourceNew":"  /**\n   * Merges the numeric docvalues from <code>toMerge</code>.\n   * <p>\n   * The default implementation calls {@link #addNumericField}, passing\n   * an Iterable that merges and filters deleted documents on the fly.\n   */\n  public void mergeNumericField(final FieldInfo fieldInfo, final MergeState mergeState, final List<NumericDocValues> toMerge, final List<Bits> docsWithField) throws IOException {\n\n    addNumericField(fieldInfo,\n                    new Iterable<Number>() {\n                      @Override\n                      public Iterator<Number> iterator() {\n                        return new Iterator<Number>() {\n                          int readerUpto = -1;\n                          int docIDUpto;\n                          Long nextValue;\n                          AtomicReader currentReader;\n                          NumericDocValues currentValues;\n                          Bits currentLiveDocs;\n                          Bits currentDocsWithField;\n                          boolean nextIsSet;\n\n                          @Override\n                          public boolean hasNext() {\n                            return nextIsSet || setNext();\n                          }\n\n                          @Override\n                          public void remove() {\n                            throw new UnsupportedOperationException();\n                          }\n\n                          @Override\n                          public Number next() {\n                            if (!hasNext()) {\n                              throw new NoSuchElementException();\n                            }\n                            assert nextIsSet;\n                            nextIsSet = false;\n                            return nextValue;\n                          }\n\n                          private boolean setNext() {\n                            while (true) {\n                              if (readerUpto == toMerge.size()) {\n                                return false;\n                              }\n\n                              if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                                readerUpto++;\n                                if (readerUpto < toMerge.size()) {\n                                  currentReader = mergeState.readers.get(readerUpto);\n                                  currentValues = toMerge.get(readerUpto);\n                                  currentLiveDocs = currentReader.getLiveDocs();\n                                  currentDocsWithField = docsWithField.get(readerUpto);\n                                }\n                                docIDUpto = 0;\n                                continue;\n                              }\n\n                              if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                                nextIsSet = true;\n                                if (currentDocsWithField.get(docIDUpto)) {\n                                  nextValue = currentValues.get(docIDUpto);\n                                } else {\n                                  nextValue = null;\n                                }\n                                docIDUpto++;\n                                return true;\n                              }\n\n                              docIDUpto++;\n                            }\n                          }\n                        };\n                      }\n                    });\n  }\n\n","sourceOld":"  /**\n   * Merges the numeric docvalues from <code>toMerge</code>.\n   * <p>\n   * The default implementation calls {@link #addNumericField}, passing\n   * an Iterable that merges and filters deleted documents on the fly.\n   */\n  public void mergeNumericField(FieldInfo fieldInfo, final MergeState mergeState, final List<NumericDocValues> toMerge) throws IOException {\n\n    addNumericField(fieldInfo,\n                    new Iterable<Number>() {\n                      @Override\n                      public Iterator<Number> iterator() {\n                        return new Iterator<Number>() {\n                          int readerUpto = -1;\n                          int docIDUpto;\n                          long nextValue;\n                          AtomicReader currentReader;\n                          NumericDocValues currentValues;\n                          Bits currentLiveDocs;\n                          boolean nextIsSet;\n\n                          @Override\n                          public boolean hasNext() {\n                            return nextIsSet || setNext();\n                          }\n\n                          @Override\n                          public void remove() {\n                            throw new UnsupportedOperationException();\n                          }\n\n                          @Override\n                          public Number next() {\n                            if (!hasNext()) {\n                              throw new NoSuchElementException();\n                            }\n                            assert nextIsSet;\n                            nextIsSet = false;\n                            // TODO: make a mutable number\n                            return nextValue;\n                          }\n\n                          private boolean setNext() {\n                            while (true) {\n                              if (readerUpto == toMerge.size()) {\n                                return false;\n                              }\n\n                              if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                                readerUpto++;\n                                if (readerUpto < toMerge.size()) {\n                                  currentReader = mergeState.readers.get(readerUpto);\n                                  currentValues = toMerge.get(readerUpto);\n                                  currentLiveDocs = currentReader.getLiveDocs();\n                                }\n                                docIDUpto = 0;\n                                continue;\n                              }\n\n                              if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                                nextIsSet = true;\n                                nextValue = currentValues.get(docIDUpto);\n                                docIDUpto++;\n                                return true;\n                              }\n\n                              docIDUpto++;\n                            }\n                          }\n                        };\n                      }\n                    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff","date":1377034255,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer#mergeNumericField(FieldInfo,MergeState,List[NumericDocValues],List[Bits]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer#mergeNumericField(FieldInfo,MergeState,List[NumericDocValues]).mjava","sourceNew":"  /**\n   * Merges the numeric docvalues from <code>toMerge</code>.\n   * <p>\n   * The default implementation calls {@link #addNumericField}, passing\n   * an Iterable that merges and filters deleted documents on the fly.\n   */\n  public void mergeNumericField(final FieldInfo fieldInfo, final MergeState mergeState, final List<NumericDocValues> toMerge, final List<Bits> docsWithField) throws IOException {\n\n    addNumericField(fieldInfo,\n                    new Iterable<Number>() {\n                      @Override\n                      public Iterator<Number> iterator() {\n                        return new Iterator<Number>() {\n                          int readerUpto = -1;\n                          int docIDUpto;\n                          Long nextValue;\n                          AtomicReader currentReader;\n                          NumericDocValues currentValues;\n                          Bits currentLiveDocs;\n                          Bits currentDocsWithField;\n                          boolean nextIsSet;\n\n                          @Override\n                          public boolean hasNext() {\n                            return nextIsSet || setNext();\n                          }\n\n                          @Override\n                          public void remove() {\n                            throw new UnsupportedOperationException();\n                          }\n\n                          @Override\n                          public Number next() {\n                            if (!hasNext()) {\n                              throw new NoSuchElementException();\n                            }\n                            assert nextIsSet;\n                            nextIsSet = false;\n                            return nextValue;\n                          }\n\n                          private boolean setNext() {\n                            while (true) {\n                              if (readerUpto == toMerge.size()) {\n                                return false;\n                              }\n\n                              if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                                readerUpto++;\n                                if (readerUpto < toMerge.size()) {\n                                  currentReader = mergeState.readers.get(readerUpto);\n                                  currentValues = toMerge.get(readerUpto);\n                                  currentLiveDocs = currentReader.getLiveDocs();\n                                  currentDocsWithField = docsWithField.get(readerUpto);\n                                }\n                                docIDUpto = 0;\n                                continue;\n                              }\n\n                              if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                                nextIsSet = true;\n                                if (currentDocsWithField.get(docIDUpto)) {\n                                  nextValue = currentValues.get(docIDUpto);\n                                } else {\n                                  nextValue = null;\n                                }\n                                docIDUpto++;\n                                return true;\n                              }\n\n                              docIDUpto++;\n                            }\n                          }\n                        };\n                      }\n                    });\n  }\n\n","sourceOld":"  /**\n   * Merges the numeric docvalues from <code>toMerge</code>.\n   * <p>\n   * The default implementation calls {@link #addNumericField}, passing\n   * an Iterable that merges and filters deleted documents on the fly.\n   */\n  public void mergeNumericField(FieldInfo fieldInfo, final MergeState mergeState, final List<NumericDocValues> toMerge) throws IOException {\n\n    addNumericField(fieldInfo,\n                    new Iterable<Number>() {\n                      @Override\n                      public Iterator<Number> iterator() {\n                        return new Iterator<Number>() {\n                          int readerUpto = -1;\n                          int docIDUpto;\n                          long nextValue;\n                          AtomicReader currentReader;\n                          NumericDocValues currentValues;\n                          Bits currentLiveDocs;\n                          boolean nextIsSet;\n\n                          @Override\n                          public boolean hasNext() {\n                            return nextIsSet || setNext();\n                          }\n\n                          @Override\n                          public void remove() {\n                            throw new UnsupportedOperationException();\n                          }\n\n                          @Override\n                          public Number next() {\n                            if (!hasNext()) {\n                              throw new NoSuchElementException();\n                            }\n                            assert nextIsSet;\n                            nextIsSet = false;\n                            // TODO: make a mutable number\n                            return nextValue;\n                          }\n\n                          private boolean setNext() {\n                            while (true) {\n                              if (readerUpto == toMerge.size()) {\n                                return false;\n                              }\n\n                              if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                                readerUpto++;\n                                if (readerUpto < toMerge.size()) {\n                                  currentReader = mergeState.readers.get(readerUpto);\n                                  currentValues = toMerge.get(readerUpto);\n                                  currentLiveDocs = currentReader.getLiveDocs();\n                                }\n                                docIDUpto = 0;\n                                continue;\n                              }\n\n                              if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                                nextIsSet = true;\n                                nextValue = currentValues.get(docIDUpto);\n                                docIDUpto++;\n                                return true;\n                              }\n\n                              docIDUpto++;\n                            }\n                          }\n                        };\n                      }\n                    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":4,"author":"Han Jiang","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer#mergeNumericField(FieldInfo,MergeState,List[NumericDocValues]).mjava","sourceNew":null,"sourceOld":"  /**\n   * Merges the numeric docvalues from <code>toMerge</code>.\n   * <p>\n   * The default implementation calls {@link #addNumericField}, passing\n   * an Iterable that merges and filters deleted documents on the fly.\n   */\n  public void mergeNumericField(FieldInfo fieldInfo, final MergeState mergeState, final List<NumericDocValues> toMerge) throws IOException {\n\n    addNumericField(fieldInfo,\n                    new Iterable<Number>() {\n                      @Override\n                      public Iterator<Number> iterator() {\n                        return new Iterator<Number>() {\n                          int readerUpto = -1;\n                          int docIDUpto;\n                          long nextValue;\n                          AtomicReader currentReader;\n                          NumericDocValues currentValues;\n                          Bits currentLiveDocs;\n                          boolean nextIsSet;\n\n                          @Override\n                          public boolean hasNext() {\n                            return nextIsSet || setNext();\n                          }\n\n                          @Override\n                          public void remove() {\n                            throw new UnsupportedOperationException();\n                          }\n\n                          @Override\n                          public Number next() {\n                            if (!hasNext()) {\n                              throw new NoSuchElementException();\n                            }\n                            assert nextIsSet;\n                            nextIsSet = false;\n                            // TODO: make a mutable number\n                            return nextValue;\n                          }\n\n                          private boolean setNext() {\n                            while (true) {\n                              if (readerUpto == toMerge.size()) {\n                                return false;\n                              }\n\n                              if (currentReader == null || docIDUpto == currentReader.maxDoc()) {\n                                readerUpto++;\n                                if (readerUpto < toMerge.size()) {\n                                  currentReader = mergeState.readers.get(readerUpto);\n                                  currentValues = toMerge.get(readerUpto);\n                                  currentLiveDocs = currentReader.getLiveDocs();\n                                }\n                                docIDUpto = 0;\n                                continue;\n                              }\n\n                              if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {\n                                nextIsSet = true;\n                                nextValue = currentValues.get(docIDUpto);\n                                docIDUpto++;\n                                return true;\n                              }\n\n                              docIDUpto++;\n                            }\n                          }\n                        };\n                      }\n                    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f2e50e80d6a567d6b1590f373e8b32093c72de02"],"9faa42f41b6adb98daf009cf99a4ee239189e469":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"9a9a6724ea8fca14131aa2741cc57f4fdbfef50d":["b8acf0807ca5f38beda8e0f7d5ab46ff39f81200"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["d4d69c535930b5cce125cff868d40f6373dc27d4","e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f2e50e80d6a567d6b1590f373e8b32093c72de02":["9a9a6724ea8fca14131aa2741cc57f4fdbfef50d"],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["d4d69c535930b5cce125cff868d40f6373dc27d4","9faa42f41b6adb98daf009cf99a4ee239189e469"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"]},"commit2Childs":{"b8acf0807ca5f38beda8e0f7d5ab46ff39f81200":["9a9a6724ea8fca14131aa2741cc57f4fdbfef50d"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["9faa42f41b6adb98daf009cf99a4ee239189e469","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"9faa42f41b6adb98daf009cf99a4ee239189e469":["e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff"],"9a9a6724ea8fca14131aa2741cc57f4fdbfef50d":["f2e50e80d6a567d6b1590f373e8b32093c72de02"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b8acf0807ca5f38beda8e0f7d5ab46ff39f81200","d4d69c535930b5cce125cff868d40f6373dc27d4"],"f2e50e80d6a567d6b1590f373e8b32093c72de02":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"e70ec9cf78e14cbbf13fd0e1a9aefa8081c325ff":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}