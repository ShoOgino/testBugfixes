{"path":"solr/core/src/test/org/apache/solr/handler/component/ShardsWhitelistTest#test().mjava","commits":[{"id":"4d51e7db479b42602c7e23ba871b177387268179","date":1547581497,"type":0,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/ShardsWhitelistTest#test().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void test() throws Exception {\n    assertThat(getShardHandlerFactory(EXPLICIT_CLUSTER_KEY).getWhitelistHostChecker().getWhitelistHosts(), notNullValue());\n    assertThat(getShardHandlerFactory(IMPLICIT_CLUSTER_KEY).getWhitelistHostChecker().getWhitelistHosts(), nullValue());\n\n    assertThat(getShardHandlerFactory(EXPLICIT_CLUSTER_KEY).getWhitelistHostChecker().hasExplicitWhitelist(), is(true));\n    assertThat(getShardHandlerFactory(IMPLICIT_CLUSTER_KEY).getWhitelistHostChecker().hasExplicitWhitelist(), is(false));\n    for (MiniSolrCloudCluster cluster : clusterId2cluster.values()) {\n      for (JettySolrRunner runner : cluster.getJettySolrRunners()) {\n        URI uri = runner.getBaseUrl().toURI();\n        assertThat(getShardHandlerFactory(EXPLICIT_CLUSTER_KEY).getWhitelistHostChecker().getWhitelistHosts(),\n            hasItem(uri.getHost() + \":\" + uri.getPort()));\n      }\n    }\n\n    MiniSolrCloudCluster implicitCluster = clusterId2cluster.get(IMPLICIT_CLUSTER_KEY);\n    MiniSolrCloudCluster explicitCluster = clusterId2cluster.get(EXPLICIT_CLUSTER_KEY);\n\n    for (Map.Entry<String,MiniSolrCloudCluster> entry : clusterId2cluster.entrySet()) {\n      List<SolrInputDocument> docs = new ArrayList<>(10);\n      for (int i = 0; i < 10; i++) {\n        docs.add(new SolrInputDocument(\"id\", entry.getKey() + i));\n      }\n      MiniSolrCloudCluster cluster = entry.getValue();\n      cluster.getSolrClient().add(COLLECTION_NAME, docs);\n      cluster.getSolrClient().commit(COLLECTION_NAME, true, true);\n\n      // test using ClusterState elements\n      assertThat(\"No shards specified, should work in both clusters\",\n          numDocs(\"*:*\", null, cluster), is(10));\n      assertThat(\"Both shards specified, should work in both clusters\",\n          numDocs(\"*:*\", \"shard1,shard2\", cluster), is(10));\n      assertThat(\"Both shards specified with collection name, should work in both clusters\",\n          numDocs(\"*:*\", COLLECTION_NAME + \"_shard1\", cluster), is(numDocs(\"*:*\", \"shard1\", cluster)));\n\n      // test using explicit urls from within the cluster\n      assertThat(\"Shards has the full URLs, should be allowed since they are internal. Cluster=\" + entry.getKey(),\n          numDocs(\"*:*\", getShardUrl(\"shard1\", cluster) + \",\" + getShardUrl(\"shard2\", cluster), cluster), is(10));\n      assertThat(\"Full URL without scheme\",\n          numDocs(\"*:*\", getShardUrl(\"shard1\", cluster).replaceAll(\"http://\", \"\") + \",\"\n              + getShardUrl(\"shard2\", cluster).replaceAll(\"http://\", \"\"), cluster),\n          is(10));\n\n      // Mix shards with URLs\n      assertThat(\"Mix URL and cluster state object\",\n          numDocs(\"*:*\", \"shard1,\" + getShardUrl(\"shard2\", cluster), cluster), is(10));\n      assertThat(\"Mix URL and cluster state object\",\n          numDocs(\"*:*\", getShardUrl(\"shard1\", cluster) + \",shard2\", cluster), is(10));\n    }\n\n    // explicit whitelist includes all the nodes in both clusters. Requests should be allowed to go through\n    assertThat(\"A request to the explicit cluster with shards that point to the implicit one\",\n        numDocs(\n            \"id:implicitCluster*\",\n            getShardUrl(\"shard1\", implicitCluster) + \",\" + getShardUrl(\"shard2\", implicitCluster),\n            explicitCluster),\n        is(10));\n\n    assertThat(\"A request to the explicit cluster with shards that point to the both clusters\",\n        numDocs(\n            \"*:*\",\n            getShardUrl(\"shard1\", implicitCluster)\n                + \",\" + getShardUrl(\"shard2\", implicitCluster)\n                + \",\" + getShardUrl(\"shard1\", explicitCluster)\n                + \",\" + getShardUrl(\"shard2\", explicitCluster),\n            explicitCluster),\n        is(20));\n\n    // Implicit shouldn't allow requests to the other cluster\n    assertForbidden(\"id:explicitCluster*\",\n        getShardUrl(\"shard1\", explicitCluster) + \",\" + getShardUrl(\"shard2\", explicitCluster),\n        implicitCluster);\n\n    assertForbidden(\"id:explicitCluster*\",\n        \"shard1,\" + getShardUrl(\"shard2\", explicitCluster),\n        implicitCluster);\n\n    assertForbidden(\"id:explicitCluster*\",\n        getShardUrl(\"shard1\", explicitCluster) + \",shard2\",\n        implicitCluster);\n\n    assertForbidden(\"id:explicitCluster*\",\n        getShardUrl(\"shard1\", explicitCluster),\n        implicitCluster);\n\n    assertThat(\"A typical internal request, should be handled locally\",\n        numDocs(\n            \"id:explicitCluster*\",\n            null,\n            implicitCluster,\n            \"distrib\", \"false\",\n            \"shard.url\", getShardUrl(\"shard2\", explicitCluster),\n            \"shards.purpose\", \"64\",\n            \"isShard\", \"true\"),\n        is(0));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4d51e7db479b42602c7e23ba871b177387268179":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4d51e7db479b42602c7e23ba871b177387268179"]},"commit2Childs":{"4d51e7db479b42602c7e23ba871b177387268179":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4d51e7db479b42602c7e23ba871b177387268179"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}