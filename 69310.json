{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","commits":[{"id":"00aca69329b84bc12b5a402a8745f8e4db7b7d40","date":1506911750,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","pathOld":"/dev/null","sourceNew":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      for (Preference p : clusterPreferences) {\n        Collections.sort(tmpMatrix, (r1, r2) -> p.compare(r1, r2, false));\n        p.setApproxVal(tmpMatrix);\n      }\n      //approximate values are set now. Let's do recursive sorting\n      Collections.sort(matrix, (Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","pathOld":"/dev/null","sourceNew":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      for (Preference p : clusterPreferences) {\n        Collections.sort(tmpMatrix, (r1, r2) -> p.compare(r1, r2, false));\n        p.setApproxVal(tmpMatrix);\n      }\n      //approximate values are set now. Let's do recursive sorting\n      Collections.sort(matrix, (Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":0,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","pathOld":"/dev/null","sourceNew":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      for (Preference p : clusterPreferences) {\n        Collections.sort(tmpMatrix, (r1, r2) -> p.compare(r1, r2, false));\n        p.setApproxVal(tmpMatrix);\n      }\n      //approximate values are set now. Let's do recursive sorting\n      Collections.sort(matrix, (Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df90d3a4877753a1be8bab8241becef2265e61cd","date":1519638982,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","sourceNew":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      for (Preference p : clusterPreferences) {\n        try {\n          Collections.sort(tmpMatrix, (r1, r2) -> p.compare(r1, r2, false));\n        } catch (Exception e) {\n          LOG.error(\"Exception! prefs = {}, matrix = {}\", clusterPreferences, matrix);\n          throw e;\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      //approximate values are set now. Let's do recursive sorting\n      Collections.sort(matrix, (Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n    }\n  }\n\n","sourceOld":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      for (Preference p : clusterPreferences) {\n        Collections.sort(tmpMatrix, (r1, r2) -> p.compare(r1, r2, false));\n        p.setApproxVal(tmpMatrix);\n      }\n      //approximate values are set now. Let's do recursive sorting\n      Collections.sort(matrix, (Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n    }\n  }\n\n","bugFix":null,"bugIntro":["34dd1818ff2313f17cf59834695ab7ee0c7853d7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"33ae23947c41339ea2b352422bb762dfb4a17077","date":1524235117,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","sourceNew":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> p.compare(r1, r2, false));\n        } catch (Exception e) {\n          LOG.error(\"Exception! prefs = {}, matrix = {}\", clusterPreferences, matrix);\n          throw e;\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n    }\n  }\n\n","sourceOld":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      for (Preference p : clusterPreferences) {\n        try {\n          Collections.sort(tmpMatrix, (r1, r2) -> p.compare(r1, r2, false));\n        } catch (Exception e) {\n          LOG.error(\"Exception! prefs = {}, matrix = {}\", clusterPreferences, matrix);\n          throw e;\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      //approximate values are set now. Let's do recursive sorting\n      Collections.sort(matrix, (Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n    }\n  }\n\n","bugFix":null,"bugIntro":["34dd1818ff2313f17cf59834695ab7ee0c7853d7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"34dd1818ff2313f17cf59834695ab7ee0c7853d7","date":1527089210,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","sourceNew":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          LOG.error(\"Exception! prefs = {}, recent r1 = {}, r2 = {}, compare : {} matrix = {}\",\n              clusterPreferences,\n              lastComparison[0].node,\n              lastComparison[1].node,\n              p.compare(lastComparison[0],lastComparison[1], false ),\n              Utils.toJSONString(Utils.getDeepCopy(tmpMatrix, 6, false)));\n          throw e;\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> p.compare(r1, r2, false));\n        } catch (Exception e) {\n          LOG.error(\"Exception! prefs = {}, matrix = {}\", clusterPreferences, matrix);\n          throw e;\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n    }\n  }\n\n","bugFix":["df90d3a4877753a1be8bab8241becef2265e61cd","33ae23947c41339ea2b352422bb762dfb4a17077"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad60b6945c360ff89899d716d9cdec8dd674e2a0","date":1528114819,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","sourceNew":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          LOG.error(\"Exception! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}\",\n              clusterPreferences,\n              lastComparison[0],\n              lastComparison[1],\n              Utils.toJSONString(Utils.getDeepCopy(tmpMatrix, 6, false)));\n          throw e;\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          LOG.error(\"Exception! prefs = {}, recent r1 = {}, r2 = {}, compare : {} matrix = {}\",\n              clusterPreferences,\n              lastComparison[0].node,\n              lastComparison[1].node,\n              p.compare(lastComparison[0],lastComparison[1], false ),\n              Utils.toJSONString(Utils.getDeepCopy(tmpMatrix, 6, false)));\n          throw e;\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","sourceNew":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          LOG.error(\"Exception! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}\",\n              clusterPreferences,\n              lastComparison[0],\n              lastComparison[1],\n              Utils.toJSONString(Utils.getDeepCopy(tmpMatrix, 6, false)));\n          throw e;\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          LOG.error(\"Exception! prefs = {}, recent r1 = {}, r2 = {}, compare : {} matrix = {}\",\n              clusterPreferences,\n              lastComparison[0].node,\n              lastComparison[1].node,\n              p.compare(lastComparison[0],lastComparison[1], false ),\n              Utils.toJSONString(Utils.getDeepCopy(tmpMatrix, 6, false)));\n          throw e;\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","sourceNew":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          LOG.error(\"Exception! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}\",\n              clusterPreferences,\n              lastComparison[0],\n              lastComparison[1],\n              Utils.toJSONString(Utils.getDeepCopy(tmpMatrix, 6, false)));\n          throw e;\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          LOG.error(\"Exception! prefs = {}, recent r1 = {}, r2 = {}, compare : {} matrix = {}\",\n              clusterPreferences,\n              lastComparison[0].node,\n              lastComparison[1].node,\n              p.compare(lastComparison[0],lastComparison[1], false ),\n              Utils.toJSONString(Utils.getDeepCopy(tmpMatrix, 6, false)));\n          throw e;\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","sourceNew":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          log.error(\"Exception! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}\",\n              clusterPreferences,\n              lastComparison[0],\n              lastComparison[1],\n              Utils.toJSONString(Utils.getDeepCopy(tmpMatrix, 6, false)));\n          throw e;\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          LOG.error(\"Exception! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}\",\n              clusterPreferences,\n              lastComparison[0],\n              lastComparison[1],\n              Utils.toJSONString(Utils.getDeepCopy(tmpMatrix, 6, false)));\n          throw e;\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc18bc8ea2e2c1e308757ff50671c774438e9f3e","date":1538052583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","sourceNew":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n//          log.error(\"Exception! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}\",\n//              clusterPreferences,\n//              lastComparison[0],\n//              lastComparison[1],\n//              Utils.toJSONString(Utils.getDeepCopy(tmpMatrix, 6, false)));\n          log.error(\"Exception! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}\",\n              clusterPreferences,\n              lastComparison[0].node,\n              lastComparison[1].node,\n              matrix.size());\n          throw new RuntimeException(e.getMessage());\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          log.error(\"Exception! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}\",\n              clusterPreferences,\n              lastComparison[0],\n              lastComparison[1],\n              Utils.toJSONString(Utils.getDeepCopy(tmpMatrix, 6, false)));\n          throw e;\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58e890cd5653ae8550bc6088d739f4eaaf950aff","date":1547036285,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","sourceNew":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> matrixCopy = new ArrayList<>(matrix);\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          try {\n            Map m = Collections.singletonMap(\"diagnostics\", (MapWriter) ew -> {\n              PolicyHelper.writeNodes(ew, matrixCopy);\n              ew.put(\"config\", matrix.get(0).session.getPolicy());\n            });\n            log.error(\"Exception! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}\",\n                clusterPreferences,\n                lastComparison[0].node,\n                lastComparison[1].node,\n                Utils.writeJson(m, new StringWriter(), true).toString());\n          } catch (IOException e1) {\n            //\n          }\n          throw new RuntimeException(e.getMessage());\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n//          log.error(\"Exception! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}\",\n//              clusterPreferences,\n//              lastComparison[0],\n//              lastComparison[1],\n//              Utils.toJSONString(Utils.getDeepCopy(tmpMatrix, 6, false)));\n          log.error(\"Exception! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}\",\n              clusterPreferences,\n              lastComparison[0].node,\n              lastComparison[1].node,\n              matrix.size());\n          throw new RuntimeException(e.getMessage());\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9","date":1574619880,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","sourceNew":"  @SuppressWarnings(\"rawtypes\")\n  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> matrixCopy = new ArrayList<>(matrix);\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          try {\n            Map m = Collections.singletonMap(\"diagnostics\", (MapWriter) ew -> {\n              PolicyHelper.writeNodes(ew, matrixCopy);\n              ew.put(\"config\", matrix.get(0).session.getPolicy());\n            });\n            log.error(\"Exception! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}\",\n                clusterPreferences,\n                lastComparison[0].node,\n                lastComparison[1].node,\n                Utils.writeJson(m, new StringWriter(), true).toString());\n          } catch (IOException e1) {\n            //\n          }\n          throw new RuntimeException(e.getMessage());\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> matrixCopy = new ArrayList<>(matrix);\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          try {\n            Map m = Collections.singletonMap(\"diagnostics\", (MapWriter) ew -> {\n              PolicyHelper.writeNodes(ew, matrixCopy);\n              ew.put(\"config\", matrix.get(0).session.getPolicy());\n            });\n            log.error(\"Exception! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}\",\n                clusterPreferences,\n                lastComparison[0].node,\n                lastComparison[1].node,\n                Utils.writeJson(m, new StringWriter(), true).toString());\n          } catch (IOException e1) {\n            //\n          }\n          throw new RuntimeException(e.getMessage());\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb9c3baacabd473e8ecd6c4948aabacead49b88e","date":1574700980,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","sourceNew":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> matrixCopy = new ArrayList<>(matrix);\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          try {\n            Map m = Collections.singletonMap(\"diagnostics\", (MapWriter) ew -> {\n              PolicyHelper.writeNodes(ew, matrixCopy);\n              ew.put(\"config\", matrix.get(0).session.getPolicy());\n            });\n            log.error(\"Exception! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}\",\n                clusterPreferences,\n                lastComparison[0].node,\n                lastComparison[1].node,\n                Utils.writeJson(m, new StringWriter(), true).toString());\n          } catch (IOException e1) {\n            //\n          }\n          throw new RuntimeException(e.getMessage());\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"rawtypes\")\n  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> matrixCopy = new ArrayList<>(matrix);\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          try {\n            Map m = Collections.singletonMap(\"diagnostics\", (MapWriter) ew -> {\n              PolicyHelper.writeNodes(ew, matrixCopy);\n              ew.put(\"config\", matrix.get(0).session.getPolicy());\n            });\n            log.error(\"Exception! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}\",\n                clusterPreferences,\n                lastComparison[0].node,\n                lastComparison[1].node,\n                Utils.writeJson(m, new StringWriter(), true).toString());\n          } catch (IOException e1) {\n            //\n          }\n          throw new RuntimeException(e.getMessage());\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"067ba8c807b0f23eae8bf41bc27046a87b548134","date":1587570399,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","sourceNew":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> matrixCopy = new ArrayList<>(matrix);\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          try {\n            Map m = Collections.singletonMap(\"diagnostics\", (MapWriter) ew -> {\n              PolicyHelper.writeNodes(ew, matrixCopy);\n              ew.put(\"config\", matrix.get(0).session.getPolicy());\n            });\n            StringWriter exc = new StringWriter();\n            e.printStackTrace(new PrintWriter(exc));\n            log.error(\"Exception during matrix sorting! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}, exception={}\",\n                clusterPreferences,\n                lastComparison[0].node,\n                lastComparison[1].node,\n                Utils.writeJson(m, new StringWriter(), true).toString(), exc.toString());\n          } catch (IOException e1) {\n            //\n          }\n          throw new RuntimeException(e.getMessage());\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> matrixCopy = new ArrayList<>(matrix);\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          try {\n            Map m = Collections.singletonMap(\"diagnostics\", (MapWriter) ew -> {\n              PolicyHelper.writeNodes(ew, matrixCopy);\n              ew.put(\"config\", matrix.get(0).session.getPolicy());\n            });\n            log.error(\"Exception! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}\",\n                clusterPreferences,\n                lastComparison[0].node,\n                lastComparison[1].node,\n                Utils.writeJson(m, new StringWriter(), true).toString());\n          } catch (IOException e1) {\n            //\n          }\n          throw new RuntimeException(e.getMessage());\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dc613ed6f75d1988140301ee8de8fdb056fa337","date":1588034757,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","sourceNew":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> matrixCopy = new ArrayList<>(matrix);\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          try {\n            Map m = Collections.singletonMap(\"diagnostics\", (MapWriter) ew -> {\n              PolicyHelper.writeNodes(ew, matrixCopy);\n              ew.put(\"config\", matrix.get(0).session.getPolicy());\n            });\n            StringWriter exc = new StringWriter();\n            e.printStackTrace(new PrintWriter(exc));\n            log.error(\"Exception during matrix sorting! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}, exception={}\",\n                clusterPreferences,\n                lastComparison[0].node,\n                lastComparison[1].node,\n                Utils.writeJson(m, new StringWriter(), true).toString(), exc.toString()); // logOK\n          } catch (IOException e1) {\n            //\n          }\n          throw new RuntimeException(e.getMessage());\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> matrixCopy = new ArrayList<>(matrix);\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          try {\n            Map m = Collections.singletonMap(\"diagnostics\", (MapWriter) ew -> {\n              PolicyHelper.writeNodes(ew, matrixCopy);\n              ew.put(\"config\", matrix.get(0).session.getPolicy());\n            });\n            StringWriter exc = new StringWriter();\n            e.printStackTrace(new PrintWriter(exc));\n            log.error(\"Exception during matrix sorting! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}, exception={}\",\n                clusterPreferences,\n                lastComparison[0].node,\n                lastComparison[1].node,\n                Utils.writeJson(m, new StringWriter(), true).toString(), exc.toString());\n          } catch (IOException e1) {\n            //\n          }\n          throw new RuntimeException(e.getMessage());\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4","date":1588172214,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","sourceNew":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> matrixCopy = new ArrayList<>(matrix);\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          try {\n            Map m = Collections.singletonMap(\"diagnostics\", (MapWriter) ew -> {\n              PolicyHelper.writeNodes(ew, matrixCopy);\n              ew.put(\"config\", matrix.get(0).session.getPolicy());\n            });\n            StringWriter exc = new StringWriter();\n            e.printStackTrace(new PrintWriter(exc));\n            log.error(\"Exception during matrix sorting! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}, exception={}\",\n                clusterPreferences,\n                lastComparison[0].node,\n                lastComparison[1].node,\n                Utils.writeJson(m, new StringWriter(), true).toString(), exc.toString()); // logOk\n          } catch (IOException e1) {\n            //\n          }\n          throw new RuntimeException(e.getMessage());\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> matrixCopy = new ArrayList<>(matrix);\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          try {\n            Map m = Collections.singletonMap(\"diagnostics\", (MapWriter) ew -> {\n              PolicyHelper.writeNodes(ew, matrixCopy);\n              ew.put(\"config\", matrix.get(0).session.getPolicy());\n            });\n            StringWriter exc = new StringWriter();\n            e.printStackTrace(new PrintWriter(exc));\n            log.error(\"Exception during matrix sorting! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}, exception={}\",\n                clusterPreferences,\n                lastComparison[0].node,\n                lastComparison[1].node,\n                Utils.writeJson(m, new StringWriter(), true).toString(), exc.toString()); // logOK\n          } catch (IOException e1) {\n            //\n          }\n          throw new RuntimeException(e.getMessage());\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"527adea7ce767368d7317339023e18e39702132e","date":1592163810,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","sourceNew":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> matrixCopy = new ArrayList<>(matrix);\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          try {\n            @SuppressWarnings({\"rawtypes\"})\n            Map m = Collections.singletonMap(\"diagnostics\", (MapWriter) ew -> {\n              PolicyHelper.writeNodes(ew, matrixCopy);\n              ew.put(\"config\", matrix.get(0).session.getPolicy());\n            });\n            StringWriter exc = new StringWriter();\n            e.printStackTrace(new PrintWriter(exc));\n            log.error(\"Exception during matrix sorting! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}, exception={}\",\n                clusterPreferences,\n                lastComparison[0].node,\n                lastComparison[1].node,\n                Utils.writeJson(m, new StringWriter(), true).toString(), exc.toString()); // logOk\n          } catch (IOException e1) {\n            //\n          }\n          throw new RuntimeException(e.getMessage());\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> matrixCopy = new ArrayList<>(matrix);\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          try {\n            Map m = Collections.singletonMap(\"diagnostics\", (MapWriter) ew -> {\n              PolicyHelper.writeNodes(ew, matrixCopy);\n              ew.put(\"config\", matrix.get(0).session.getPolicy());\n            });\n            StringWriter exc = new StringWriter();\n            e.printStackTrace(new PrintWriter(exc));\n            log.error(\"Exception during matrix sorting! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}, exception={}\",\n                clusterPreferences,\n                lastComparison[0].node,\n                lastComparison[1].node,\n                Utils.writeJson(m, new StringWriter(), true).toString(), exc.toString()); // logOk\n          } catch (IOException e1) {\n            //\n          }\n          throw new RuntimeException(e.getMessage());\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Policy#setApproxValuesAndSortNodes(List[Preference],List[Row]).mjava","sourceNew":null,"sourceOld":"  static void setApproxValuesAndSortNodes(List<Preference> clusterPreferences, List<Row> matrix) {\n    List<Row> matrixCopy = new ArrayList<>(matrix);\n    List<Row> deadNodes = null;\n    Iterator<Row> it =matrix.iterator();\n    while (it.hasNext()){\n      Row row = it.next();\n      if(!row.isLive){\n        if(deadNodes == null) deadNodes = new ArrayList<>();\n        deadNodes.add(row);\n        it.remove();\n      }\n    }\n\n    if (!clusterPreferences.isEmpty()) {\n      //this is to set the approximate value according to the precision\n      ArrayList<Row> tmpMatrix = new ArrayList<>(matrix);\n      Row[] lastComparison = new Row[2];\n      for (Preference p : clusterPreferences) {\n        try {\n          tmpMatrix.sort((r1, r2) -> {\n            lastComparison[0] = r1;\n            lastComparison[1] = r2;\n            return p.compare(r1, r2, false);\n          });\n        } catch (Exception e) {\n          try {\n            @SuppressWarnings({\"rawtypes\"})\n            Map m = Collections.singletonMap(\"diagnostics\", (MapWriter) ew -> {\n              PolicyHelper.writeNodes(ew, matrixCopy);\n              ew.put(\"config\", matrix.get(0).session.getPolicy());\n            });\n            StringWriter exc = new StringWriter();\n            e.printStackTrace(new PrintWriter(exc));\n            log.error(\"Exception during matrix sorting! prefs = {}, recent r1 = {}, r2 = {}, matrix = {}, exception={}\",\n                clusterPreferences,\n                lastComparison[0].node,\n                lastComparison[1].node,\n                Utils.writeJson(m, new StringWriter(), true).toString(), exc.toString()); // logOk\n          } catch (IOException e1) {\n            //\n          }\n          throw new RuntimeException(e.getMessage());\n        }\n        p.setApproxVal(tmpMatrix);\n      }\n      // the tmpMatrix was needed only to set the approximate values, now we sort the real matrix\n      // recursing through each preference\n      matrix.sort((Row r1, Row r2) -> {\n        int result = clusterPreferences.get(0).compare(r1, r2, true);\n        if (result == 0) result = clusterPreferences.get(0).compare(r1, r2, false);\n        return result;\n      });\n\n      if(deadNodes != null){\n        for (Row deadNode : deadNodes) {\n          matrix.add(0, deadNode);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"6dc613ed6f75d1988140301ee8de8fdb056fa337":["067ba8c807b0f23eae8bf41bc27046a87b548134"],"df90d3a4877753a1be8bab8241becef2265e61cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","00aca69329b84bc12b5a402a8745f8e4db7b7d40"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["58e890cd5653ae8550bc6088d739f4eaaf950aff"],"3f504512a03d978990cbff30db0522b354e846db":["527adea7ce767368d7317339023e18e39702132e"],"067ba8c807b0f23eae8bf41bc27046a87b548134":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"00aca69329b84bc12b5a402a8745f8e4db7b7d40":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"34dd1818ff2313f17cf59834695ab7ee0c7853d7":["33ae23947c41339ea2b352422bb762dfb4a17077"],"58e890cd5653ae8550bc6088d739f4eaaf950aff":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["34dd1818ff2313f17cf59834695ab7ee0c7853d7","ad60b6945c360ff89899d716d9cdec8dd674e2a0"],"527adea7ce767368d7317339023e18e39702132e":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"33ae23947c41339ea2b352422bb762dfb4a17077":["df90d3a4877753a1be8bab8241becef2265e61cd"],"ad60b6945c360ff89899d716d9cdec8dd674e2a0":["34dd1818ff2313f17cf59834695ab7ee0c7853d7"],"560c18d71dad43d675158783c3840f8c80d6d39c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"f592209545c71895260367152601e9200399776d":["34dd1818ff2313f17cf59834695ab7ee0c7853d7","ad60b6945c360ff89899d716d9cdec8dd674e2a0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["ad60b6945c360ff89899d716d9cdec8dd674e2a0"]},"commit2Childs":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["58e890cd5653ae8550bc6088d739f4eaaf950aff"],"6dc613ed6f75d1988140301ee8de8fdb056fa337":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"df90d3a4877753a1be8bab8241becef2265e61cd":["33ae23947c41339ea2b352422bb762dfb4a17077"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"067ba8c807b0f23eae8bf41bc27046a87b548134":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"00aca69329b84bc12b5a402a8745f8e4db7b7d40":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"34dd1818ff2313f17cf59834695ab7ee0c7853d7":["b70042a8a492f7054d480ccdd2be9796510d4327","ad60b6945c360ff89899d716d9cdec8dd674e2a0","f592209545c71895260367152601e9200399776d"],"58e890cd5653ae8550bc6088d739f4eaaf950aff":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c304e97e7c1d472bc70e801b35ee78583916c6cd","00aca69329b84bc12b5a402a8745f8e4db7b7d40","560c18d71dad43d675158783c3840f8c80d6d39c"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["527adea7ce767368d7317339023e18e39702132e"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"527adea7ce767368d7317339023e18e39702132e":["3f504512a03d978990cbff30db0522b354e846db"],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["067ba8c807b0f23eae8bf41bc27046a87b548134"],"33ae23947c41339ea2b352422bb762dfb4a17077":["34dd1818ff2313f17cf59834695ab7ee0c7853d7"],"560c18d71dad43d675158783c3840f8c80d6d39c":["df90d3a4877753a1be8bab8241becef2265e61cd"],"ad60b6945c360ff89899d716d9cdec8dd674e2a0":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"f592209545c71895260367152601e9200399776d":[],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}