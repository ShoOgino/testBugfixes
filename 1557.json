{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","commits":[{"id":"0ad7bdba3e91cf3373cda2e52239cb761fc0b452","date":1408019547,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    Map<String,Counts> counts = new HashMap<>();\n    ValueComparator vc = new ValueComparator(counts);\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String collection : collections) {\n        log.debug(\"look at collection {} as possible create candidate\", collection); \n        DocCollection docCollection = clusterState.getCollection(collection);\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState().equals(Slice.ACTIVE)) {\n            log.debug(\"look at slice {} as possible create candidate\", slice.getName()); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              if (replica.getStr(ZkStateReader.BASE_URL_PROP).equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              // on a live node?\n              log.debug(\"nodename={} livenodes={}\", replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"look at replica {} as possible create candidate, live={}\", replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                int maxShardsPerNode = docCollection.getMaxShardsPerNode();\n                log.debug(\"max shards per node={} good replicas={}\", maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(replica.getStr(ZkStateReader.BASE_URL_PROP));\n                } else {\n                  counts.put(replica.getStr(ZkStateReader.BASE_URL_PROP), cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      return null;\n    }\n    \n    Map<String,Counts> sortedCounts = new TreeMap<>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={}\", liveNodes);\n    log.debug(\"sorted hosts={}\", sortedCounts);\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["3747a28ce6c262c1e27f7c7b30a827bc1a17260b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","date":1427866967,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","sourceNew":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    Map<String,Counts> counts = new HashMap<>();\n    ValueComparator vc = new ValueComparator(counts);\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String collection : collections) {\n        log.debug(\"look at collection {} as possible create candidate\", collection); \n        DocCollection docCollection = clusterState.getCollection(collection);\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} as possible create candidate\", slice.getName()); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              if (replica.getStr(ZkStateReader.BASE_URL_PROP).equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              // on a live node?\n              log.debug(\"nodename={} livenodes={}\", replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"look at replica {} as possible create candidate, live={}\", replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                int maxShardsPerNode = docCollection.getMaxShardsPerNode();\n                log.debug(\"max shards per node={} good replicas={}\", maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(replica.getStr(ZkStateReader.BASE_URL_PROP));\n                } else {\n                  counts.put(replica.getStr(ZkStateReader.BASE_URL_PROP), cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      return null;\n    }\n    \n    Map<String,Counts> sortedCounts = new TreeMap<>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={}\", liveNodes);\n    log.debug(\"sorted hosts={}\", sortedCounts);\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","sourceOld":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    Map<String,Counts> counts = new HashMap<>();\n    ValueComparator vc = new ValueComparator(counts);\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String collection : collections) {\n        log.debug(\"look at collection {} as possible create candidate\", collection); \n        DocCollection docCollection = clusterState.getCollection(collection);\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState().equals(Slice.ACTIVE)) {\n            log.debug(\"look at slice {} as possible create candidate\", slice.getName()); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              if (replica.getStr(ZkStateReader.BASE_URL_PROP).equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              // on a live node?\n              log.debug(\"nodename={} livenodes={}\", replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"look at replica {} as possible create candidate, live={}\", replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                int maxShardsPerNode = docCollection.getMaxShardsPerNode();\n                log.debug(\"max shards per node={} good replicas={}\", maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(replica.getStr(ZkStateReader.BASE_URL_PROP));\n                } else {\n                  counts.put(replica.getStr(ZkStateReader.BASE_URL_PROP), cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      return null;\n    }\n    \n    Map<String,Counts> sortedCounts = new TreeMap<>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={}\", liveNodes);\n    log.debug(\"sorted hosts={}\", sortedCounts);\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0c924d4069ef5a5bc479a493befe0121aada6896","date":1427901860,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","sourceNew":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    Map<String,Counts> counts = new HashMap<>();\n    ValueComparator vc = new ValueComparator(counts);\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String collection : collections) {\n        log.debug(\"look at collection {} as possible create candidate\", collection); \n        DocCollection docCollection = clusterState.getCollection(collection);\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} as possible create candidate\", slice.getName()); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              if (replica.getStr(ZkStateReader.BASE_URL_PROP).equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              // on a live node?\n              log.debug(\"nodename={} livenodes={}\", replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"look at replica {} as possible create candidate, live={}\", replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                int maxShardsPerNode = docCollection.getMaxShardsPerNode();\n                log.debug(\"max shards per node={} good replicas={}\", maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(replica.getStr(ZkStateReader.BASE_URL_PROP));\n                } else {\n                  counts.put(replica.getStr(ZkStateReader.BASE_URL_PROP), cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      return null;\n    }\n    \n    Map<String,Counts> sortedCounts = new TreeMap<>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={}\", liveNodes);\n    log.debug(\"sorted hosts={}\", sortedCounts);\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","sourceOld":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    Map<String,Counts> counts = new HashMap<>();\n    ValueComparator vc = new ValueComparator(counts);\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String collection : collections) {\n        log.debug(\"look at collection {} as possible create candidate\", collection); \n        DocCollection docCollection = clusterState.getCollection(collection);\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState().equals(Slice.ACTIVE)) {\n            log.debug(\"look at slice {} as possible create candidate\", slice.getName()); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              if (replica.getStr(ZkStateReader.BASE_URL_PROP).equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              // on a live node?\n              log.debug(\"nodename={} livenodes={}\", replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"look at replica {} as possible create candidate, live={}\", replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                int maxShardsPerNode = docCollection.getMaxShardsPerNode();\n                log.debug(\"max shards per node={} good replicas={}\", maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(replica.getStr(ZkStateReader.BASE_URL_PROP));\n                } else {\n                  counts.put(replica.getStr(ZkStateReader.BASE_URL_PROP), cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      return null;\n    }\n    \n    Map<String,Counts> sortedCounts = new TreeMap<>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={}\", liveNodes);\n    log.debug(\"sorted hosts={}\", sortedCounts);\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3747a28ce6c262c1e27f7c7b30a827bc1a17260b","date":1428529761,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","sourceNew":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<String, Counts>();\n    Set<String> unsuitableHosts = new HashSet<String>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String collection : collections) {\n        log.debug(\"look at collection {} as possible create candidate\", collection); \n        DocCollection docCollection = clusterState.getCollection(collection);\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (baseUrl.equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} max shards per node={} potential hosts={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","sourceOld":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    Map<String,Counts> counts = new HashMap<>();\n    ValueComparator vc = new ValueComparator(counts);\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String collection : collections) {\n        log.debug(\"look at collection {} as possible create candidate\", collection); \n        DocCollection docCollection = clusterState.getCollection(collection);\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} as possible create candidate\", slice.getName()); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              if (replica.getStr(ZkStateReader.BASE_URL_PROP).equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              // on a live node?\n              log.debug(\"nodename={} livenodes={}\", replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"look at replica {} as possible create candidate, live={}\", replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                int maxShardsPerNode = docCollection.getMaxShardsPerNode();\n                log.debug(\"max shards per node={} good replicas={}\", maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(replica.getStr(ZkStateReader.BASE_URL_PROP));\n                } else {\n                  counts.put(replica.getStr(ZkStateReader.BASE_URL_PROP), cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      return null;\n    }\n    \n    Map<String,Counts> sortedCounts = new TreeMap<>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={}\", liveNodes);\n    log.debug(\"sorted hosts={}\", sortedCounts);\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","bugFix":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9974f61802aea1d15849a1053f88f5e89fc32b4","date":1462405923,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","sourceNew":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<String, Counts>();\n    Set<String> unsuitableHosts = new HashSet<String>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        String collection = entry.getKey();\n        log.debug(\"look at collection {} as possible create candidate\", collection);\n        DocCollection docCollection = entry.getValue();\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (baseUrl.equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} max shards per node={} potential hosts={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","sourceOld":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<String, Counts>();\n    Set<String> unsuitableHosts = new HashSet<String>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String collection : collections) {\n        log.debug(\"look at collection {} as possible create candidate\", collection); \n        DocCollection docCollection = clusterState.getCollection(collection);\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (baseUrl.equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} max shards per node={} potential hosts={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73450c0955930295d34703e7ddbfc6973b7a121a","date":1462431925,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","sourceNew":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<String, Counts>();\n    Set<String> unsuitableHosts = new HashSet<String>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        String collection = entry.getKey();\n        log.debug(\"look at collection {} as possible create candidate\", collection);\n        DocCollection docCollection = entry.getValue();\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (baseUrl.equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} max shards per node={} potential hosts={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","sourceOld":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<String, Counts>();\n    Set<String> unsuitableHosts = new HashSet<String>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String collection : collections) {\n        log.debug(\"look at collection {} as possible create candidate\", collection); \n        DocCollection docCollection = clusterState.getCollection(collection);\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (baseUrl.equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} max shards per node={} potential hosts={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dc08f02757dd10637b16a5c65eaaef839a91a9a","date":1462455462,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","sourceNew":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<String, Counts>();\n    Set<String> unsuitableHosts = new HashSet<String>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        String collection = entry.getKey();\n        log.debug(\"look at collection {} as possible create candidate\", collection);\n        DocCollection docCollection = entry.getValue();\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (baseUrl.equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} max shards per node={} potential hosts={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","sourceOld":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<String, Counts>();\n    Set<String> unsuitableHosts = new HashSet<String>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String collection : collections) {\n        log.debug(\"look at collection {} as possible create candidate\", collection); \n        DocCollection docCollection = clusterState.getCollection(collection);\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (baseUrl.equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} max shards per node={} potential hosts={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","sourceNew":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<String, Counts>();\n    Set<String> unsuitableHosts = new HashSet<String>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        String collection = entry.getKey();\n        log.debug(\"look at collection {} as possible create candidate\", collection);\n        DocCollection docCollection = entry.getValue();\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (baseUrl.equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} max shards per node={} potential hosts={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","sourceOld":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<String, Counts>();\n    Set<String> unsuitableHosts = new HashSet<String>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Set<String> collections = clusterState.getCollections();\n      for (String collection : collections) {\n        log.debug(\"look at collection {} as possible create candidate\", collection); \n        DocCollection docCollection = clusterState.getCollection(collection);\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (baseUrl.equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} max shards per node={} potential hosts={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fbed9f780536d62957bf82cf6c87b75c5b4cd30b","date":1462731618,"type":5,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica,Integer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","sourceNew":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica, Integer maxCoreCount) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<>();\n    Set<String> unsuitableHosts = new HashSet<>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    Map<String, Integer> coresPerNode = new HashMap<>();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        String collection = entry.getKey();\n        log.debug(\"look at collection {} as possible create candidate\", collection);\n        DocCollection docCollection = entry.getValue();\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (coresPerNode.containsKey(baseUrl)) {\n                Integer nodeCount = coresPerNode.get(baseUrl);\n                coresPerNode.put(baseUrl, nodeCount++);\n              } else {\n                coresPerNode.put(baseUrl, 1);\n              }\n              if (baseUrl.equals(badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} maxShardsPerNode={} maxCoresPerNode={} potential hosts={}\",\n                    collection, baseUrl, maxShardsPerNode, maxCoreCount, cnt);\n\n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode\n                    || (maxCoreCount != null && coresPerNode.get(baseUrl) >= maxCoreCount) ) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","sourceOld":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<String, Counts>();\n    Set<String> unsuitableHosts = new HashSet<String>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        String collection = entry.getKey();\n        log.debug(\"look at collection {} as possible create candidate\", collection);\n        DocCollection docCollection = entry.getValue();\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (baseUrl.equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} max shards per node={} potential hosts={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55a4fb564f94e7d0f0dfce705d51533be9f1c22e","date":1462769458,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica,Integer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","sourceNew":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica, Integer maxCoreCount) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<>();\n    Set<String> unsuitableHosts = new HashSet<>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    Map<String, Integer> coresPerNode = new HashMap<>();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        String collection = entry.getKey();\n        log.debug(\"look at collection {} as possible create candidate\", collection);\n        DocCollection docCollection = entry.getValue();\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (coresPerNode.containsKey(baseUrl)) {\n                Integer nodeCount = coresPerNode.get(baseUrl);\n                coresPerNode.put(baseUrl, nodeCount++);\n              } else {\n                coresPerNode.put(baseUrl, 1);\n              }\n              if (baseUrl.equals(badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} maxShardsPerNode={} maxCoresPerNode={} potential hosts={}\",\n                    collection, baseUrl, maxShardsPerNode, maxCoreCount, cnt);\n\n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode\n                    || (maxCoreCount != null && coresPerNode.get(baseUrl) >= maxCoreCount) ) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","sourceOld":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<String, Counts>();\n    Set<String> unsuitableHosts = new HashSet<String>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        String collection = entry.getKey();\n        log.debug(\"look at collection {} as possible create candidate\", collection);\n        DocCollection docCollection = entry.getValue();\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (baseUrl.equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} max shards per node={} potential hosts={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e66a459d38c1c4a2f97128433dab546f683a9fed","date":1462873476,"type":5,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica,Integer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","sourceNew":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica, Integer maxCoreCount) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<>();\n    Set<String> unsuitableHosts = new HashSet<>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    Map<String, Integer> coresPerNode = new HashMap<>();\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        String collection = entry.getKey();\n        log.debug(\"look at collection {} as possible create candidate\", collection);\n        DocCollection docCollection = entry.getValue();\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (coresPerNode.containsKey(baseUrl)) {\n                Integer nodeCount = coresPerNode.get(baseUrl);\n                coresPerNode.put(baseUrl, nodeCount++);\n              } else {\n                coresPerNode.put(baseUrl, 1);\n              }\n              if (baseUrl.equals(badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} maxShardsPerNode={} maxCoresPerNode={} potential hosts={}\",\n                    collection, baseUrl, maxShardsPerNode, maxCoreCount, cnt);\n\n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode\n                    || (maxCoreCount != null && coresPerNode.get(baseUrl) >= maxCoreCount) ) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","sourceOld":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<String, Counts>();\n    Set<String> unsuitableHosts = new HashSet<String>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        String collection = entry.getKey();\n        log.debug(\"look at collection {} as possible create candidate\", collection);\n        DocCollection docCollection = entry.getValue();\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (baseUrl.equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} max shards per node={} potential hosts={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerAutoReplicaFailoverThread#getBestCreateUrl(ZkStateReader,DownReplica).mjava","sourceNew":null,"sourceOld":"  /**\n   * \n   * @return the best node to replace the badReplica on or null if there is no\n   *         such node\n   */\n  static String getBestCreateUrl(ZkStateReader zkStateReader, DownReplica badReplica) {\n    assert badReplica != null;\n    assert badReplica.collection != null;\n    assert badReplica.slice != null;\n    log.debug(\"getBestCreateUrl for \" + badReplica.replica);\n    Map<String,Counts> counts = new HashMap<String, Counts>();\n    Set<String> unsuitableHosts = new HashSet<String>();\n    \n    Set<String> liveNodes = new HashSet<>(zkStateReader.getClusterState().getLiveNodes());\n    \n    ClusterState clusterState = zkStateReader.getClusterState();\n    if (clusterState != null) {\n      Map<String, DocCollection> collections = clusterState.getCollectionsMap();\n      for (Map.Entry<String, DocCollection> entry : collections.entrySet()) {\n        String collection = entry.getKey();\n        log.debug(\"look at collection {} as possible create candidate\", collection);\n        DocCollection docCollection = entry.getValue();\n        // TODO - only operate on collections with sharedfs failover = true ??\n        Collection<Slice> slices = docCollection.getSlices();\n        for (Slice slice : slices) {\n          // only look at active shards\n          if (slice.getState() == Slice.State.ACTIVE) {\n            log.debug(\"look at slice {} for collection {} as possible create candidate\", slice.getName(), collection); \n            Collection<Replica> replicas = slice.getReplicas();\n\n            for (Replica replica : replicas) {\n              liveNodes.remove(replica.getNodeName());\n              String baseUrl = replica.getStr(ZkStateReader.BASE_URL_PROP);\n              if (baseUrl.equals(\n                  badReplica.replica.getStr(ZkStateReader.BASE_URL_PROP))) {\n                continue;\n              }\n              // on a live node?\n              log.debug(\"collection={} nodename={} livenodes={}\", collection, replica.getNodeName(), clusterState.getLiveNodes());\n              boolean live = clusterState.liveNodesContain(replica.getNodeName());\n              log.debug(\"collection={} look at replica {} as possible create candidate, live={}\", collection, replica.getName(), live); \n              if (live) {\n                Counts cnt = counts.get(baseUrl);\n                if (cnt == null) {\n                  cnt = new Counts();\n                }\n                if (badReplica.collection.getName().equals(collection)) {\n                  cnt.negRankingWeight += 3;\n                  cnt.collectionShardsOnNode += 1;\n                } else {\n                  cnt.negRankingWeight += 1;\n                }\n                if (badReplica.collection.getName().equals(collection) && badReplica.slice.getName().equals(slice.getName())) {\n                  cnt.ourReplicas++;\n                }\n                \n                // TODO: this is collection wide and we want to take into\n                // account cluster wide - use new cluster sys prop\n                Integer maxShardsPerNode = badReplica.collection.getMaxShardsPerNode();\n                if (maxShardsPerNode == null) {\n                  log.warn(\"maxShardsPerNode is not defined for collection, name=\" + badReplica.collection.getName());\n                  maxShardsPerNode = Integer.MAX_VALUE;\n                }\n                log.debug(\"collection={} node={} max shards per node={} potential hosts={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                \n                Collection<Replica> badSliceReplicas = null;\n                DocCollection c = clusterState.getCollection(badReplica.collection.getName());\n                if (c != null) {\n                  Slice s = c.getSlice(badReplica.slice.getName());\n                  if (s != null) {\n                    badSliceReplicas = s.getReplicas();\n                  }\n                }\n                boolean alreadyExistsOnNode = replicaAlreadyExistsOnNode(zkStateReader.getClusterState(), badSliceReplicas, badReplica, baseUrl);\n                if (unsuitableHosts.contains(baseUrl) || alreadyExistsOnNode || cnt.collectionShardsOnNode >= maxShardsPerNode) {\n                  counts.remove(baseUrl);\n                  unsuitableHosts.add(baseUrl);\n                  log.debug(\"not a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                } else {\n                  counts.put(baseUrl, cnt);\n                  log.debug(\"is a candidate node, collection={} node={} max shards per node={} good replicas={}\", collection, baseUrl, maxShardsPerNode, cnt);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    for (String node : liveNodes) {\n      counts.put(zkStateReader.getBaseUrlForNodeName(node), new Counts(0, 0));\n    }\n    \n    if (counts.size() == 0) {\n      log.debug(\"no suitable hosts found for getBestCreateUrl for collection={}\", badReplica.collection.getName());\n      return null;\n    }\n    \n    ValueComparator vc = new ValueComparator(counts);\n    Map<String,Counts> sortedCounts = new TreeMap<String, Counts>(vc);\n    sortedCounts.putAll(counts);\n    \n    log.debug(\"empty nodes={} for collection={}\", liveNodes, badReplica.collection.getName());\n    log.debug(\"sorted hosts={} for collection={}\", sortedCounts, badReplica.collection.getName());\n    log.debug(\"unsuitable hosts={} for collection={}\", unsuitableHosts, badReplica.collection.getName());\n    \n    return sortedCounts.keySet().iterator().next();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"73450c0955930295d34703e7ddbfc6973b7a121a":["3747a28ce6c262c1e27f7c7b30a827bc1a17260b","e9974f61802aea1d15849a1053f88f5e89fc32b4"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["3747a28ce6c262c1e27f7c7b30a827bc1a17260b","73450c0955930295d34703e7ddbfc6973b7a121a"],"3747a28ce6c262c1e27f7c7b30a827bc1a17260b":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"fbed9f780536d62957bf82cf6c87b75c5b4cd30b":["73450c0955930295d34703e7ddbfc6973b7a121a"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","55a4fb564f94e7d0f0dfce705d51533be9f1c22e"],"0c924d4069ef5a5bc479a493befe0121aada6896":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452","d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296"],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"55a4fb564f94e7d0f0dfce705d51533be9f1c22e":["73450c0955930295d34703e7ddbfc6973b7a121a","fbed9f780536d62957bf82cf6c87b75c5b4cd30b"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["3747a28ce6c262c1e27f7c7b30a827bc1a17260b","73450c0955930295d34703e7ddbfc6973b7a121a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e66a459d38c1c4a2f97128433dab546f683a9fed":["a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","55a4fb564f94e7d0f0dfce705d51533be9f1c22e"],"e9974f61802aea1d15849a1053f88f5e89fc32b4":["3747a28ce6c262c1e27f7c7b30a827bc1a17260b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["55a4fb564f94e7d0f0dfce705d51533be9f1c22e"]},"commit2Childs":{"d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296":["3747a28ce6c262c1e27f7c7b30a827bc1a17260b","0c924d4069ef5a5bc479a493befe0121aada6896"],"73450c0955930295d34703e7ddbfc6973b7a121a":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","fbed9f780536d62957bf82cf6c87b75c5b4cd30b","55a4fb564f94e7d0f0dfce705d51533be9f1c22e","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"3747a28ce6c262c1e27f7c7b30a827bc1a17260b":["73450c0955930295d34703e7ddbfc6973b7a121a","7dc08f02757dd10637b16a5c65eaaef839a91a9a","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","e9974f61802aea1d15849a1053f88f5e89fc32b4"],"fbed9f780536d62957bf82cf6c87b75c5b4cd30b":["55a4fb564f94e7d0f0dfce705d51533be9f1c22e"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"0c924d4069ef5a5bc479a493befe0121aada6896":[],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","0c924d4069ef5a5bc479a493befe0121aada6896"],"55a4fb564f94e7d0f0dfce705d51533be9f1c22e":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e66a459d38c1c4a2f97128433dab546f683a9fed","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["e66a459d38c1c4a2f97128433dab546f683a9fed"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"e66a459d38c1c4a2f97128433dab546f683a9fed":[],"e9974f61802aea1d15849a1053f88f5e89fc32b4":["73450c0955930295d34703e7ddbfc6973b7a121a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0c924d4069ef5a5bc479a493befe0121aada6896","e66a459d38c1c4a2f97128433dab546f683a9fed","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}