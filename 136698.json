{"path":"solr/core/src/java/org/apache/solr/update/processor/NestedUpdateProcessorFactory.NestedUpdateProcessor#processDocChildren(SolrInputDocument,String).mjava","commits":[{"id":"0734346f2ba692d6dbf402faa9e19f958bbd0fc2","date":1531277981,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/NestedUpdateProcessorFactory.NestedUpdateProcessor#processDocChildren(SolrInputDocument,String).mjava","pathOld":"/dev/null","sourceNew":"    private void processDocChildren(SolrInputDocument doc, String fullPath) {\n      for(SolrInputField field: doc.values()) {\n        int childNum = 0;\n        boolean isSingleVal = !(field.getValue() instanceof Collection);\n        for(Object val: field) {\n          if(!(val instanceof SolrInputDocument)) {\n            // either all collection items are child docs or none are.\n            break;\n          }\n          final String fieldName = field.getName();\n\n          if(fieldName.contains(PATH_SEP_CHAR)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Field name: '\" + fieldName\n                + \"' contains: '\" + PATH_SEP_CHAR + \"' , which is reserved for the nested URP\");\n          }\n          final String sChildNum = isSingleVal ? SINGULAR_VALUE_CHAR : String.valueOf(childNum);\n          SolrInputDocument cDoc = (SolrInputDocument) val;\n          if(!cDoc.containsKey(uniqueKeyFieldName)) {\n            String parentDocId = doc.getField(uniqueKeyFieldName).getFirstValue().toString();\n            cDoc.setField(uniqueKeyFieldName, generateChildUniqueId(parentDocId, fieldName, sChildNum));\n          }\n          final String lastKeyPath = fieldName + NUM_SEP_CHAR + sChildNum;\n          // concat of all paths children.grandChild => children#1/grandChild#\n          final String childDocPath = fullPath == null ? lastKeyPath : fullPath + PATH_SEP_CHAR + lastKeyPath;\n          processChildDoc((SolrInputDocument) val, doc, childDocPath);\n          ++childNum;\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":0,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/NestedUpdateProcessorFactory.NestedUpdateProcessor#processDocChildren(SolrInputDocument,String).mjava","pathOld":"/dev/null","sourceNew":"    private void processDocChildren(SolrInputDocument doc, String fullPath) {\n      for(SolrInputField field: doc.values()) {\n        int childNum = 0;\n        boolean isSingleVal = !(field.getValue() instanceof Collection);\n        for(Object val: field) {\n          if(!(val instanceof SolrInputDocument)) {\n            // either all collection items are child docs or none are.\n            break;\n          }\n          final String fieldName = field.getName();\n\n          if(fieldName.contains(PATH_SEP_CHAR)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Field name: '\" + fieldName\n                + \"' contains: '\" + PATH_SEP_CHAR + \"' , which is reserved for the nested URP\");\n          }\n          final String sChildNum = isSingleVal ? SINGULAR_VALUE_CHAR : String.valueOf(childNum);\n          SolrInputDocument cDoc = (SolrInputDocument) val;\n          if(!cDoc.containsKey(uniqueKeyFieldName)) {\n            String parentDocId = doc.getField(uniqueKeyFieldName).getFirstValue().toString();\n            cDoc.setField(uniqueKeyFieldName, generateChildUniqueId(parentDocId, fieldName, sChildNum));\n          }\n          final String lastKeyPath = fieldName + NUM_SEP_CHAR + sChildNum;\n          // concat of all paths children.grandChild => children#1/grandChild#\n          final String childDocPath = fullPath == null ? lastKeyPath : fullPath + PATH_SEP_CHAR + lastKeyPath;\n          processChildDoc((SolrInputDocument) val, doc, childDocPath);\n          ++childNum;\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":0,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/NestedUpdateProcessorFactory.NestedUpdateProcessor#processDocChildren(SolrInputDocument,String).mjava","pathOld":"/dev/null","sourceNew":"    private void processDocChildren(SolrInputDocument doc, String fullPath) {\n      for(SolrInputField field: doc.values()) {\n        int childNum = 0;\n        boolean isSingleVal = !(field.getValue() instanceof Collection);\n        for(Object val: field) {\n          if(!(val instanceof SolrInputDocument)) {\n            // either all collection items are child docs or none are.\n            break;\n          }\n          final String fieldName = field.getName();\n\n          if(fieldName.contains(PATH_SEP_CHAR)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Field name: '\" + fieldName\n                + \"' contains: '\" + PATH_SEP_CHAR + \"' , which is reserved for the nested URP\");\n          }\n          final String sChildNum = isSingleVal ? SINGULAR_VALUE_CHAR : String.valueOf(childNum);\n          SolrInputDocument cDoc = (SolrInputDocument) val;\n          if(!cDoc.containsKey(uniqueKeyFieldName)) {\n            String parentDocId = doc.getField(uniqueKeyFieldName).getFirstValue().toString();\n            cDoc.setField(uniqueKeyFieldName, generateChildUniqueId(parentDocId, fieldName, sChildNum));\n          }\n          final String lastKeyPath = fieldName + NUM_SEP_CHAR + sChildNum;\n          // concat of all paths children.grandChild => children#1/grandChild#\n          final String childDocPath = fullPath == null ? lastKeyPath : fullPath + PATH_SEP_CHAR + lastKeyPath;\n          processChildDoc((SolrInputDocument) val, doc, childDocPath);\n          ++childNum;\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8da0c9170fd1c418b47b9a76a0447c60b1b99e5f","date":1548699906,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/NestedUpdateProcessorFactory.NestedUpdateProcessor#processDocChildren(SolrInputDocument,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/NestedUpdateProcessorFactory.NestedUpdateProcessor#processDocChildren(SolrInputDocument,String).mjava","sourceNew":"    private void processDocChildren(SolrInputDocument doc, String fullPath) {\n      for(SolrInputField field: doc.values()) {\n        int childNum = 0;\n        boolean isSingleVal = !(field.getValue() instanceof Collection);\n        for(Object val: field) {\n          if(!(val instanceof SolrInputDocument)) {\n            // either all collection items are child docs or none are.\n            break;\n          }\n          final String fieldName = field.getName();\n\n          if(fieldName.contains(PATH_SEP_CHAR)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Field name: '\" + fieldName\n                + \"' contains: '\" + PATH_SEP_CHAR + \"' , which is reserved for the nested URP\");\n          }\n          final String sChildNum = isSingleVal ? SINGULAR_VALUE_CHAR : String.valueOf(childNum);\n          SolrInputDocument cDoc = (SolrInputDocument) val;\n          if(!cDoc.containsKey(uniqueKeyFieldName)) {\n            String parentDocId = doc.getField(uniqueKeyFieldName).getFirstValue().toString();\n            cDoc.setField(uniqueKeyFieldName, generateChildUniqueId(parentDocId, fieldName, sChildNum));\n          }\n          final String lastKeyPath = PATH_SEP_CHAR + fieldName + NUM_SEP_CHAR + sChildNum;\n          // concat of all paths children.grandChild => /children#1/grandChild#\n          final String childDocPath = fullPath == null ? lastKeyPath : fullPath + lastKeyPath;\n          processChildDoc(cDoc, doc, childDocPath);\n          ++childNum;\n        }\n      }\n    }\n\n","sourceOld":"    private void processDocChildren(SolrInputDocument doc, String fullPath) {\n      for(SolrInputField field: doc.values()) {\n        int childNum = 0;\n        boolean isSingleVal = !(field.getValue() instanceof Collection);\n        for(Object val: field) {\n          if(!(val instanceof SolrInputDocument)) {\n            // either all collection items are child docs or none are.\n            break;\n          }\n          final String fieldName = field.getName();\n\n          if(fieldName.contains(PATH_SEP_CHAR)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Field name: '\" + fieldName\n                + \"' contains: '\" + PATH_SEP_CHAR + \"' , which is reserved for the nested URP\");\n          }\n          final String sChildNum = isSingleVal ? SINGULAR_VALUE_CHAR : String.valueOf(childNum);\n          SolrInputDocument cDoc = (SolrInputDocument) val;\n          if(!cDoc.containsKey(uniqueKeyFieldName)) {\n            String parentDocId = doc.getField(uniqueKeyFieldName).getFirstValue().toString();\n            cDoc.setField(uniqueKeyFieldName, generateChildUniqueId(parentDocId, fieldName, sChildNum));\n          }\n          final String lastKeyPath = fieldName + NUM_SEP_CHAR + sChildNum;\n          // concat of all paths children.grandChild => children#1/grandChild#\n          final String childDocPath = fullPath == null ? lastKeyPath : fullPath + PATH_SEP_CHAR + lastKeyPath;\n          processChildDoc((SolrInputDocument) val, doc, childDocPath);\n          ++childNum;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07749612bed4eb54dd05255c1434c301133310c1","date":1554879779,"type":3,"author":"Moshe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/NestedUpdateProcessorFactory.NestedUpdateProcessor#processDocChildren(SolrInputDocument,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/NestedUpdateProcessorFactory.NestedUpdateProcessor#processDocChildren(SolrInputDocument,String).mjava","sourceNew":"    private boolean processDocChildren(SolrInputDocument doc, String fullPath) {\n      boolean isNested = false;\n      for(SolrInputField field: doc.values()) {\n        int childNum = 0;\n        boolean isSingleVal = !(field.getValue() instanceof Collection);\n        for(Object val: field) {\n          if (!(val instanceof SolrInputDocument)) {\n            // either all collection items are child docs or none are.\n            break;\n          }\n          final String fieldName = field.getName();\n\n          if (fieldName.contains(PATH_SEP_CHAR)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Field name: '\" + fieldName\n                + \"' contains: '\" + PATH_SEP_CHAR + \"' , which is reserved for the nested URP\");\n          }\n          final String sChildNum = isSingleVal ? SINGULAR_VALUE_CHAR : String.valueOf(childNum);\n          SolrInputDocument cDoc = (SolrInputDocument) val;\n          if (!cDoc.containsKey(uniqueKeyFieldName)) {\n            String parentDocId = doc.getField(uniqueKeyFieldName).getFirstValue().toString();\n            cDoc.setField(uniqueKeyFieldName, generateChildUniqueId(parentDocId, fieldName, sChildNum));\n          }\n          if (!isNested) {\n            isNested = true;\n          }\n          final String lastKeyPath = PATH_SEP_CHAR + fieldName + NUM_SEP_CHAR + sChildNum;\n          // concat of all paths children.grandChild => /children#1/grandChild#\n          final String childDocPath = fullPath == null ? lastKeyPath : fullPath + lastKeyPath;\n          processChildDoc(cDoc, doc, childDocPath);\n          ++childNum;\n        }\n      }\n      return isNested;\n    }\n\n","sourceOld":"    private void processDocChildren(SolrInputDocument doc, String fullPath) {\n      for(SolrInputField field: doc.values()) {\n        int childNum = 0;\n        boolean isSingleVal = !(field.getValue() instanceof Collection);\n        for(Object val: field) {\n          if(!(val instanceof SolrInputDocument)) {\n            // either all collection items are child docs or none are.\n            break;\n          }\n          final String fieldName = field.getName();\n\n          if(fieldName.contains(PATH_SEP_CHAR)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Field name: '\" + fieldName\n                + \"' contains: '\" + PATH_SEP_CHAR + \"' , which is reserved for the nested URP\");\n          }\n          final String sChildNum = isSingleVal ? SINGULAR_VALUE_CHAR : String.valueOf(childNum);\n          SolrInputDocument cDoc = (SolrInputDocument) val;\n          if(!cDoc.containsKey(uniqueKeyFieldName)) {\n            String parentDocId = doc.getField(uniqueKeyFieldName).getFirstValue().toString();\n            cDoc.setField(uniqueKeyFieldName, generateChildUniqueId(parentDocId, fieldName, sChildNum));\n          }\n          final String lastKeyPath = PATH_SEP_CHAR + fieldName + NUM_SEP_CHAR + sChildNum;\n          // concat of all paths children.grandChild => /children#1/grandChild#\n          final String childDocPath = fullPath == null ? lastKeyPath : fullPath + lastKeyPath;\n          processChildDoc(cDoc, doc, childDocPath);\n          ++childNum;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8da0c9170fd1c418b47b9a76a0447c60b1b99e5f":["0734346f2ba692d6dbf402faa9e19f958bbd0fc2"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0734346f2ba692d6dbf402faa9e19f958bbd0fc2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0734346f2ba692d6dbf402faa9e19f958bbd0fc2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"07749612bed4eb54dd05255c1434c301133310c1":["8da0c9170fd1c418b47b9a76a0447c60b1b99e5f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["07749612bed4eb54dd05255c1434c301133310c1"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0734346f2ba692d6dbf402faa9e19f958bbd0fc2"]},"commit2Childs":{"8da0c9170fd1c418b47b9a76a0447c60b1b99e5f":["07749612bed4eb54dd05255c1434c301133310c1"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","0734346f2ba692d6dbf402faa9e19f958bbd0fc2","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"0734346f2ba692d6dbf402faa9e19f958bbd0fc2":["8da0c9170fd1c418b47b9a76a0447c60b1b99e5f","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"07749612bed4eb54dd05255c1434c301133310c1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}