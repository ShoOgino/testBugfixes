{"path":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","commits":[{"id":"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4","date":1368446242,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    if (revisionFiles.size() > 1) {\n      throw new IllegalArgumentException(\"this handler handles only a single source; got \" + revisionFiles.keySet());\n    }\n    \n    Directory clientDir = sourceDirectory.values().iterator().next();\n    List<String> files = copiedFiles.values().iterator().next();\n    String segmentsFile = getSegmentsFile(files, false);\n    \n    boolean success = false;\n    try {\n      // copy files from the client to index directory\n      copyFiles(clientDir, indexDir, files);\n      \n      // fsync all copied files (except segmentsFile)\n      indexDir.sync(files);\n      \n      // now copy and fsync segmentsFile\n      clientDir.copy(indexDir, segmentsFile, segmentsFile, IOContext.READONCE);\n      indexDir.sync(Collections.singletonList(segmentsFile));\n      \n      success = true;\n    } finally {\n      if (!success) {\n        files.add(segmentsFile); // add it back so it gets deleted too\n        cleanupFilesOnFailure(indexDir, files);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n\n    // update the segments.gen file\n    writeSegmentsGen(segmentsFile, indexDir);\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    cleanupOldIndexFiles(indexDir, segmentsFile);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["1e25519c3e0ea41f0b2bb8bfad72fd834014ee76"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","sourceNew":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    if (revisionFiles.size() > 1) {\n      throw new IllegalArgumentException(\"this handler handles only a single source; got \" + revisionFiles.keySet());\n    }\n    \n    Directory clientDir = sourceDirectory.values().iterator().next();\n    List<String> files = copiedFiles.values().iterator().next();\n    String segmentsFile = getSegmentsFile(files, false);\n    \n    boolean success = false;\n    try {\n      // copy files from the client to index directory\n      copyFiles(clientDir, indexDir, files);\n      \n      // fsync all copied files (except segmentsFile)\n      indexDir.sync(files);\n      \n      // now copy and fsync segmentsFile\n      clientDir.copy(indexDir, segmentsFile, segmentsFile, IOContext.READONCE);\n      indexDir.sync(Collections.singletonList(segmentsFile));\n      \n      success = true;\n    } finally {\n      if (!success) {\n        files.add(segmentsFile); // add it back so it gets deleted too\n        cleanupFilesOnFailure(indexDir, files);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n\n    // update the segments.gen file\n    writeSegmentsGen(segmentsFile, indexDir);\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    cleanupOldIndexFiles(indexDir, segmentsFile);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    if (revisionFiles.size() > 1) {\n      throw new IllegalArgumentException(\"this handler handles only a single source; got \" + revisionFiles.keySet());\n    }\n    \n    Directory clientDir = sourceDirectory.values().iterator().next();\n    List<String> files = copiedFiles.values().iterator().next();\n    String segmentsFile = getSegmentsFile(files, false);\n    \n    boolean success = false;\n    try {\n      // copy files from the client to index directory\n      copyFiles(clientDir, indexDir, files);\n      \n      // fsync all copied files (except segmentsFile)\n      indexDir.sync(files);\n      \n      // now copy and fsync segmentsFile\n      clientDir.copy(indexDir, segmentsFile, segmentsFile, IOContext.READONCE);\n      indexDir.sync(Collections.singletonList(segmentsFile));\n      \n      success = true;\n    } finally {\n      if (!success) {\n        files.add(segmentsFile); // add it back so it gets deleted too\n        cleanupFilesOnFailure(indexDir, files);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n\n    // update the segments.gen file\n    writeSegmentsGen(segmentsFile, indexDir);\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    cleanupOldIndexFiles(indexDir, segmentsFile);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","sourceNew":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    if (revisionFiles.size() > 1) {\n      throw new IllegalArgumentException(\"this handler handles only a single source; got \" + revisionFiles.keySet());\n    }\n    \n    Directory clientDir = sourceDirectory.values().iterator().next();\n    List<String> files = copiedFiles.values().iterator().next();\n    String segmentsFile = getSegmentsFile(files, false);\n    \n    boolean success = false;\n    try {\n      // copy files from the client to index directory\n      copyFiles(clientDir, indexDir, files);\n      \n      // fsync all copied files (except segmentsFile)\n      indexDir.sync(files);\n      \n      // now copy and fsync segmentsFile\n      clientDir.copy(indexDir, segmentsFile, segmentsFile, IOContext.READONCE);\n      indexDir.sync(Collections.singletonList(segmentsFile));\n      \n      success = true;\n    } finally {\n      if (!success) {\n        files.add(segmentsFile); // add it back so it gets deleted too\n        cleanupFilesOnFailure(indexDir, files);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n\n    // update the segments.gen file\n    writeSegmentsGen(segmentsFile, indexDir);\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    cleanupOldIndexFiles(indexDir, segmentsFile);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    if (revisionFiles.size() > 1) {\n      throw new IllegalArgumentException(\"this handler handles only a single source; got \" + revisionFiles.keySet());\n    }\n    \n    Directory clientDir = sourceDirectory.values().iterator().next();\n    List<String> files = copiedFiles.values().iterator().next();\n    String segmentsFile = getSegmentsFile(files, false);\n    \n    boolean success = false;\n    try {\n      // copy files from the client to index directory\n      copyFiles(clientDir, indexDir, files);\n      \n      // fsync all copied files (except segmentsFile)\n      indexDir.sync(files);\n      \n      // now copy and fsync segmentsFile\n      clientDir.copy(indexDir, segmentsFile, segmentsFile, IOContext.READONCE);\n      indexDir.sync(Collections.singletonList(segmentsFile));\n      \n      success = true;\n    } finally {\n      if (!success) {\n        files.add(segmentsFile); // add it back so it gets deleted too\n        cleanupFilesOnFailure(indexDir, files);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n\n    // update the segments.gen file\n    writeSegmentsGen(segmentsFile, indexDir);\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    cleanupOldIndexFiles(indexDir, segmentsFile);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e25519c3e0ea41f0b2bb8bfad72fd834014ee76","date":1406617066,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","sourceNew":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    if (revisionFiles.size() > 1) {\n      throw new IllegalArgumentException(\"this handler handles only a single source; got \" + revisionFiles.keySet());\n    }\n    \n    Directory clientDir = sourceDirectory.values().iterator().next();\n    List<String> files = copiedFiles.values().iterator().next();\n    String segmentsFile = getSegmentsFile(files, false);\n    \n    boolean success = false;\n    try {\n      // copy files from the client to index directory\n      copyFiles(clientDir, indexDir, files);\n      \n      // fsync all copied files (except segmentsFile)\n      indexDir.sync(files);\n      \n      // now copy and fsync segmentsFile\n      clientDir.copy(indexDir, segmentsFile, segmentsFile, IOContext.READONCE);\n      indexDir.sync(Collections.singletonList(segmentsFile));\n      \n      success = true;\n    } finally {\n      if (!success) {\n        files.add(segmentsFile); // add it back so it gets deleted too\n        cleanupFilesOnFailure(indexDir, files);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n\n    // update the segments.gen file\n    writeSegmentsGen(segmentsFile, indexDir);\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    cleanupOldIndexFiles(indexDir, segmentsFile, infoStream);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    if (revisionFiles.size() > 1) {\n      throw new IllegalArgumentException(\"this handler handles only a single source; got \" + revisionFiles.keySet());\n    }\n    \n    Directory clientDir = sourceDirectory.values().iterator().next();\n    List<String> files = copiedFiles.values().iterator().next();\n    String segmentsFile = getSegmentsFile(files, false);\n    \n    boolean success = false;\n    try {\n      // copy files from the client to index directory\n      copyFiles(clientDir, indexDir, files);\n      \n      // fsync all copied files (except segmentsFile)\n      indexDir.sync(files);\n      \n      // now copy and fsync segmentsFile\n      clientDir.copy(indexDir, segmentsFile, segmentsFile, IOContext.READONCE);\n      indexDir.sync(Collections.singletonList(segmentsFile));\n      \n      success = true;\n    } finally {\n      if (!success) {\n        files.add(segmentsFile); // add it back so it gets deleted too\n        cleanupFilesOnFailure(indexDir, files);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n\n    // update the segments.gen file\n    writeSegmentsGen(segmentsFile, indexDir);\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    cleanupOldIndexFiles(indexDir, segmentsFile);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","bugFix":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46e4a8bdfbafda795ef9c39a2bc2d47095770299","date":1410411846,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","sourceNew":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    if (revisionFiles.size() > 1) {\n      throw new IllegalArgumentException(\"this handler handles only a single source; got \" + revisionFiles.keySet());\n    }\n    \n    Directory clientDir = sourceDirectory.values().iterator().next();\n    List<String> files = copiedFiles.values().iterator().next();\n    String segmentsFile = getSegmentsFile(files, false);\n    String pendingSegmentsFile = \"pending_\" + segmentsFile;\n    \n    boolean success = false;\n    try {\n      // copy files from the client to index directory\n      copyFiles(clientDir, indexDir, files);\n      \n      // fsync all copied files (except segmentsFile)\n      indexDir.sync(files);\n      \n      // now copy and fsync segmentsFile as pending, then rename (simulating lucene commit)\n      clientDir.copy(indexDir, segmentsFile, pendingSegmentsFile, IOContext.READONCE);\n      indexDir.sync(Collections.singletonList(pendingSegmentsFile));\n      indexDir.renameFile(pendingSegmentsFile, segmentsFile);\n      \n      success = true;\n    } finally {\n      if (!success) {\n        files.add(segmentsFile); // add it back so it gets deleted too\n        files.add(pendingSegmentsFile);\n        cleanupFilesOnFailure(indexDir, files);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    cleanupOldIndexFiles(indexDir, segmentsFile, infoStream);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    if (revisionFiles.size() > 1) {\n      throw new IllegalArgumentException(\"this handler handles only a single source; got \" + revisionFiles.keySet());\n    }\n    \n    Directory clientDir = sourceDirectory.values().iterator().next();\n    List<String> files = copiedFiles.values().iterator().next();\n    String segmentsFile = getSegmentsFile(files, false);\n    \n    boolean success = false;\n    try {\n      // copy files from the client to index directory\n      copyFiles(clientDir, indexDir, files);\n      \n      // fsync all copied files (except segmentsFile)\n      indexDir.sync(files);\n      \n      // now copy and fsync segmentsFile\n      clientDir.copy(indexDir, segmentsFile, segmentsFile, IOContext.READONCE);\n      indexDir.sync(Collections.singletonList(segmentsFile));\n      \n      success = true;\n    } finally {\n      if (!success) {\n        files.add(segmentsFile); // add it back so it gets deleted too\n        cleanupFilesOnFailure(indexDir, files);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n\n    // update the segments.gen file\n    writeSegmentsGen(segmentsFile, indexDir);\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    cleanupOldIndexFiles(indexDir, segmentsFile, infoStream);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"52d4cfb22484037a9b8e9080e03aeaff60954880","date":1420125313,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","sourceNew":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    if (revisionFiles.size() > 1) {\n      throw new IllegalArgumentException(\"this handler handles only a single source; got \" + revisionFiles.keySet());\n    }\n    \n    Directory clientDir = sourceDirectory.values().iterator().next();\n    List<String> files = copiedFiles.values().iterator().next();\n    String segmentsFile = getSegmentsFile(files, false);\n    String pendingSegmentsFile = \"pending_\" + segmentsFile;\n    \n    boolean success = false;\n    try {\n      // copy files from the client to index directory\n      copyFiles(clientDir, indexDir, files);\n      \n      // fsync all copied files (except segmentsFile)\n      indexDir.sync(files);\n      \n      // now copy and fsync segmentsFile as pending, then rename (simulating lucene commit)\n      indexDir.copyFrom(clientDir, segmentsFile, pendingSegmentsFile, IOContext.READONCE);\n      indexDir.sync(Collections.singletonList(pendingSegmentsFile));\n      indexDir.renameFile(pendingSegmentsFile, segmentsFile);\n      \n      success = true;\n    } finally {\n      if (!success) {\n        files.add(segmentsFile); // add it back so it gets deleted too\n        files.add(pendingSegmentsFile);\n        cleanupFilesOnFailure(indexDir, files);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    cleanupOldIndexFiles(indexDir, segmentsFile, infoStream);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    if (revisionFiles.size() > 1) {\n      throw new IllegalArgumentException(\"this handler handles only a single source; got \" + revisionFiles.keySet());\n    }\n    \n    Directory clientDir = sourceDirectory.values().iterator().next();\n    List<String> files = copiedFiles.values().iterator().next();\n    String segmentsFile = getSegmentsFile(files, false);\n    String pendingSegmentsFile = \"pending_\" + segmentsFile;\n    \n    boolean success = false;\n    try {\n      // copy files from the client to index directory\n      copyFiles(clientDir, indexDir, files);\n      \n      // fsync all copied files (except segmentsFile)\n      indexDir.sync(files);\n      \n      // now copy and fsync segmentsFile as pending, then rename (simulating lucene commit)\n      clientDir.copy(indexDir, segmentsFile, pendingSegmentsFile, IOContext.READONCE);\n      indexDir.sync(Collections.singletonList(pendingSegmentsFile));\n      indexDir.renameFile(pendingSegmentsFile, segmentsFile);\n      \n      success = true;\n    } finally {\n      if (!success) {\n        files.add(segmentsFile); // add it back so it gets deleted too\n        files.add(pendingSegmentsFile);\n        cleanupFilesOnFailure(indexDir, files);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    cleanupOldIndexFiles(indexDir, segmentsFile, infoStream);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"214256b5eeeaba88b8293b37d30460b462b19562","date":1468250146,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","sourceNew":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    if (revisionFiles.size() > 1) {\n      throw new IllegalArgumentException(\"this handler handles only a single source; got \" + revisionFiles.keySet());\n    }\n    \n    Directory clientDir = sourceDirectory.values().iterator().next();\n    List<String> files = copiedFiles.values().iterator().next();\n    String segmentsFile = getSegmentsFile(files, false);\n    String pendingSegmentsFile = \"pending_\" + segmentsFile;\n    \n    boolean success = false;\n    try {\n      // copy files from the client to index directory\n      copyFiles(clientDir, indexDir, files);\n      \n      // fsync all copied files (except segmentsFile)\n      indexDir.sync(files);\n      \n      // now copy and fsync segmentsFile as pending, then rename (simulating lucene commit)\n      indexDir.copyFrom(clientDir, segmentsFile, pendingSegmentsFile, IOContext.READONCE);\n      indexDir.sync(Collections.singletonList(pendingSegmentsFile));\n      indexDir.rename(pendingSegmentsFile, segmentsFile);\n      indexDir.syncMetaData();\n      \n      success = true;\n    } finally {\n      if (!success) {\n        files.add(segmentsFile); // add it back so it gets deleted too\n        files.add(pendingSegmentsFile);\n        cleanupFilesOnFailure(indexDir, files);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    cleanupOldIndexFiles(indexDir, segmentsFile, infoStream);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    if (revisionFiles.size() > 1) {\n      throw new IllegalArgumentException(\"this handler handles only a single source; got \" + revisionFiles.keySet());\n    }\n    \n    Directory clientDir = sourceDirectory.values().iterator().next();\n    List<String> files = copiedFiles.values().iterator().next();\n    String segmentsFile = getSegmentsFile(files, false);\n    String pendingSegmentsFile = \"pending_\" + segmentsFile;\n    \n    boolean success = false;\n    try {\n      // copy files from the client to index directory\n      copyFiles(clientDir, indexDir, files);\n      \n      // fsync all copied files (except segmentsFile)\n      indexDir.sync(files);\n      \n      // now copy and fsync segmentsFile as pending, then rename (simulating lucene commit)\n      indexDir.copyFrom(clientDir, segmentsFile, pendingSegmentsFile, IOContext.READONCE);\n      indexDir.sync(Collections.singletonList(pendingSegmentsFile));\n      indexDir.renameFile(pendingSegmentsFile, segmentsFile);\n      \n      success = true;\n    } finally {\n      if (!success) {\n        files.add(segmentsFile); // add it back so it gets deleted too\n        files.add(pendingSegmentsFile);\n        cleanupFilesOnFailure(indexDir, files);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    cleanupOldIndexFiles(indexDir, segmentsFile, infoStream);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/IndexReplicationHandler#revisionReady(String,Map[String,List[RevisionFile]],Map[String,List[String]],Map[String,Directory]).mjava","sourceNew":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    if (revisionFiles.size() > 1) {\n      throw new IllegalArgumentException(\"this handler handles only a single source; got \" + revisionFiles.keySet());\n    }\n    \n    Directory clientDir = sourceDirectory.values().iterator().next();\n    List<String> files = copiedFiles.values().iterator().next();\n    String segmentsFile = getSegmentsFile(files, false);\n    String pendingSegmentsFile = \"pending_\" + segmentsFile;\n    \n    boolean success = false;\n    try {\n      // copy files from the client to index directory\n      copyFiles(clientDir, indexDir, files);\n      \n      // fsync all copied files (except segmentsFile)\n      indexDir.sync(files);\n      \n      // now copy and fsync segmentsFile as pending, then rename (simulating lucene commit)\n      indexDir.copyFrom(clientDir, segmentsFile, pendingSegmentsFile, IOContext.READONCE);\n      indexDir.sync(Collections.singletonList(pendingSegmentsFile));\n      indexDir.rename(pendingSegmentsFile, segmentsFile);\n      indexDir.syncMetaData();\n      \n      success = true;\n    } finally {\n      if (!success) {\n        files.add(segmentsFile); // add it back so it gets deleted too\n        files.add(pendingSegmentsFile);\n        cleanupFilesOnFailure(indexDir, files);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    cleanupOldIndexFiles(indexDir, segmentsFile, infoStream);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void revisionReady(String version, Map<String,List<RevisionFile>> revisionFiles,\n      Map<String,List<String>> copiedFiles, Map<String,Directory> sourceDirectory) throws IOException {\n    if (revisionFiles.size() > 1) {\n      throw new IllegalArgumentException(\"this handler handles only a single source; got \" + revisionFiles.keySet());\n    }\n    \n    Directory clientDir = sourceDirectory.values().iterator().next();\n    List<String> files = copiedFiles.values().iterator().next();\n    String segmentsFile = getSegmentsFile(files, false);\n    String pendingSegmentsFile = \"pending_\" + segmentsFile;\n    \n    boolean success = false;\n    try {\n      // copy files from the client to index directory\n      copyFiles(clientDir, indexDir, files);\n      \n      // fsync all copied files (except segmentsFile)\n      indexDir.sync(files);\n      \n      // now copy and fsync segmentsFile as pending, then rename (simulating lucene commit)\n      indexDir.copyFrom(clientDir, segmentsFile, pendingSegmentsFile, IOContext.READONCE);\n      indexDir.sync(Collections.singletonList(pendingSegmentsFile));\n      indexDir.renameFile(pendingSegmentsFile, segmentsFile);\n      \n      success = true;\n    } finally {\n      if (!success) {\n        files.add(segmentsFile); // add it back so it gets deleted too\n        files.add(pendingSegmentsFile);\n        cleanupFilesOnFailure(indexDir, files);\n      }\n    }\n\n    // all files have been successfully copied + sync'd. update the handler's state\n    currentRevisionFiles = revisionFiles;\n    currentVersion = version;\n    \n    if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {\n      infoStream.message(INFO_STREAM_COMPONENT, \"revisionReady(): currentVersion=\" + currentVersion\n          + \" currentRevisionFiles=\" + currentRevisionFiles);\n    }\n    \n    // Cleanup the index directory from old and unused index files.\n    // NOTE: we don't use IndexWriter.deleteUnusedFiles here since it may have\n    // side-effects, e.g. if it hits sudden IO errors while opening the index\n    // (and can end up deleting the entire index). It is not our job to protect\n    // against those errors, app will probably hit them elsewhere.\n    cleanupOldIndexFiles(indexDir, segmentsFile, infoStream);\n\n    // successfully updated the index, notify the callback that the index is\n    // ready.\n    if (callback != null) {\n      try {\n        callback.call();\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"46e4a8bdfbafda795ef9c39a2bc2d47095770299":["1e25519c3e0ea41f0b2bb8bfad72fd834014ee76"],"1e25519c3e0ea41f0b2bb8bfad72fd834014ee76":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"214256b5eeeaba88b8293b37d30460b462b19562":["52d4cfb22484037a9b8e9080e03aeaff60954880"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"52d4cfb22484037a9b8e9080e03aeaff60954880":["46e4a8bdfbafda795ef9c39a2bc2d47095770299"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["52d4cfb22484037a9b8e9080e03aeaff60954880","214256b5eeeaba88b8293b37d30460b462b19562"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["214256b5eeeaba88b8293b37d30460b462b19562"]},"commit2Childs":{"46e4a8bdfbafda795ef9c39a2bc2d47095770299":["52d4cfb22484037a9b8e9080e03aeaff60954880"],"1e25519c3e0ea41f0b2bb8bfad72fd834014ee76":["46e4a8bdfbafda795ef9c39a2bc2d47095770299"],"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","19275ba31e621f6da1b83bf13af75233876fd3d4"],"214256b5eeeaba88b8293b37d30460b462b19562":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"52d4cfb22484037a9b8e9080e03aeaff60954880":["214256b5eeeaba88b8293b37d30460b462b19562","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["1e25519c3e0ea41f0b2bb8bfad72fd834014ee76"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}