{"path":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#checkReplay(String,Object...).mjava","commits":[{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#checkReplay(String,Object...).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Executes a sequence of commands against Solr, while tracking the expected value of a specified \n   * <code>valField</code> Long field (presumably that only uses docvalues) against an in memory model \n   * maintained in parallel (for the purpose of testing the correctness of in-place updates..\n   *\n   * <p>\n   * A few restrictions are placed on the {@link SolrInputDocument}s that can be included when using \n   * this method, in order to keep the in-memory model management simple:\n   * </p>\n   * <ul>\n   *  <li><code>id</code> must be uniqueKey field</li>\n   *  <li><code>id</code> may have any FieldType, but all values must be parsable as Integers</li>\n   *  <li><code>valField</code> must be a single valued field</li>\n   *  <li>All values in the <code>valField</code> must either be {@link Number}s, or Maps containing \n   *      atomic updates (\"inc\" or \"set\") where the atomic value is a {@link Number}</li>\n   * </ul>\n   * \n   * @param valField the field to model\n   * @param commands A sequence of Commands which can either be SolrInputDocuments \n   *                 (regular or containing atomic update Maps)\n   *                 or one of the {@link TestInPlaceUpdatesStandalone#HARDCOMMIT} or {@link TestInPlaceUpdatesStandalone#SOFTCOMMIT} sentinal objects.\n   */\n  public void checkReplay(final String valField, Object... commands) throws Exception {\n    \n    HashMap<Integer, DocInfo> model = new LinkedHashMap<>();\n    HashMap<Integer, DocInfo> committedModel = new LinkedHashMap<>();\n\n    // by default, we only check the committed model after a commit\n    // of if the number of total commands is relatively small.\n    //\n    // (in theory, there's no reason to check the committed model unless we know there's been a commit\n    // but for smaller tests the overhead of doing so is tiny, so we might as well)\n    //\n    // if some test seed fails, and you want to force the committed model to be checked\n    // after every command, just temporaribly force this variable to true...\n    boolean checkCommittedModel = (commands.length < 50);\n    \n    for (Object cmd : commands) {\n      if (cmd == SOFTCOMMIT) {\n        assertU(commit(\"softCommit\", \"true\"));\n        committedModel = new LinkedHashMap(model);\n        checkCommittedModel = true;\n      } else if (cmd == HARDCOMMIT) {\n        assertU(commit(\"softCommit\", \"false\"));\n        committedModel = new LinkedHashMap(model);\n        checkCommittedModel = true;\n      } else {\n        assertNotNull(\"null command in checkReplay\", cmd);\n        assertTrue(\"cmd is neither sentinal (HARD|SOFT)COMMIT object, nor Solr doc: \" + cmd.getClass(),\n                   cmd instanceof SolrInputDocument);\n        \n        final SolrInputDocument sdoc = (SolrInputDocument) cmd;\n        final int id = Integer.parseInt(sdoc.getFieldValue(\"id\").toString());\n        \n        final DocInfo previousInfo = model.get(id);\n        final Long previousValue = (null == previousInfo) ? null : previousInfo.value;\n        \n        final long version = addAndGetVersion(sdoc, null);\n        \n        final Object val = sdoc.getFieldValue(valField);\n        if (val instanceof Map) {\n          // atomic update of the field we're modeling\n          \n          Map<String,?> atomicUpdate = (Map) val;\n          assertEquals(sdoc.toString(), 1, atomicUpdate.size());\n          if (atomicUpdate.containsKey(\"inc\")) {\n            // Solr treats inc on a non-existing doc (or doc w/o existing value) as if existing value is 0\n            final long base = (null == previousValue) ? 0L : previousValue;\n            model.put(id, new DocInfo(version,\n                                      base + ((Number)atomicUpdate.get(\"inc\")).longValue()));\n          } else if (atomicUpdate.containsKey(\"set\")) {\n            model.put(id, new DocInfo(version, ((Number)atomicUpdate.get(\"set\")).longValue()));\n          } else {\n            fail(\"wtf update is this? ... \" + sdoc);\n          }\n        } else if (null == val) {\n          // the field we are modeling is not mentioned in this update, It's either...\n          //\n          // a) a regular update of some other fields (our model should have a null value)\n          // b) an atomic update of some other field (keep existing value in model)\n          //\n          // for now, assume it's atomic and we're going to keep our existing value...\n          Long newValue = (null == previousInfo) ? null : previousInfo.value;\n          for (SolrInputField field : sdoc) {\n            if (! ( \"id\".equals(field.getName()) || (field.getValue() instanceof Map)) ) {\n              // not an atomic update, newValue in model should be null\n              newValue = null;\n              break;\n            }\n          }\n          model.put(id, new DocInfo(version, newValue));\n          \n        } else {\n          // regular replacement of the value in the field we're modeling\n          \n          assertTrue(\"Model field value is not a Number: \" + val.getClass(), val instanceof Number);\n          model.put(id, new DocInfo(version, ((Number)val).longValue()));\n        }\n      }\n\n      // after every op, check the model(s)\n      \n      // RTG to check the values for every id against the model\n      for (Map.Entry<Integer, DocInfo> entry : model.entrySet()) {\n        final Long expected = entry.getValue().value;\n        assertEquals(expected, client.getById(String.valueOf(entry.getKey())).getFirstValue(valField));\n      }\n\n      // search to check the values for every id in the committed model\n      if (checkCommittedModel) {\n        final int numCommitedDocs = committedModel.size();\n        String[] xpaths = new String[1 + numCommitedDocs];\n        int i = 0;\n        for (Map.Entry<Integer, DocInfo> entry : committedModel.entrySet()) {\n          Integer id = entry.getKey();\n          Long expected = entry.getValue().value;\n          if (null != expected) {\n            xpaths[i] = \"//result/doc[./str='\"+id+\"'][./long='\"+expected+\"']\";\n          } else {\n            xpaths[i] = \"//result/doc[./str='\"+id+\"'][not(./long)]\";\n          }           \n          i++;\n        }\n        xpaths[i] = \"//*[@numFound='\"+numCommitedDocs+\"']\";\n        assertQ(req(\"q\", \"*:*\",\n                    \"fl\", \"id,\" + valField,\n                    \"rows\", \"\"+numCommitedDocs),\n                xpaths);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#checkReplay(String,Object...).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Executes a sequence of commands against Solr, while tracking the expected value of a specified \n   * <code>valField</code> Long field (presumably that only uses docvalues) against an in memory model \n   * maintained in parallel (for the purpose of testing the correctness of in-place updates..\n   *\n   * <p>\n   * A few restrictions are placed on the {@link SolrInputDocument}s that can be included when using \n   * this method, in order to keep the in-memory model management simple:\n   * </p>\n   * <ul>\n   *  <li><code>id</code> must be uniqueKey field</li>\n   *  <li><code>id</code> may have any FieldType, but all values must be parsable as Integers</li>\n   *  <li><code>valField</code> must be a single valued field</li>\n   *  <li>All values in the <code>valField</code> must either be {@link Number}s, or Maps containing \n   *      atomic updates (\"inc\" or \"set\") where the atomic value is a {@link Number}</li>\n   * </ul>\n   * \n   * @param valField the field to model\n   * @param commands A sequence of Commands which can either be SolrInputDocuments \n   *                 (regular or containing atomic update Maps)\n   *                 or one of the {@link TestInPlaceUpdatesStandalone#HARDCOMMIT} or {@link TestInPlaceUpdatesStandalone#SOFTCOMMIT} sentinal objects.\n   */\n  public void checkReplay(final String valField, Object... commands) throws Exception {\n    \n    HashMap<Integer, DocInfo> model = new LinkedHashMap<>();\n    HashMap<Integer, DocInfo> committedModel = new LinkedHashMap<>();\n\n    // by default, we only check the committed model after a commit\n    // of if the number of total commands is relatively small.\n    //\n    // (in theory, there's no reason to check the committed model unless we know there's been a commit\n    // but for smaller tests the overhead of doing so is tiny, so we might as well)\n    //\n    // if some test seed fails, and you want to force the committed model to be checked\n    // after every command, just temporaribly force this variable to true...\n    boolean checkCommittedModel = (commands.length < 50);\n    \n    for (Object cmd : commands) {\n      if (cmd == SOFTCOMMIT) {\n        assertU(commit(\"softCommit\", \"true\"));\n        committedModel = new LinkedHashMap(model);\n        checkCommittedModel = true;\n      } else if (cmd == HARDCOMMIT) {\n        assertU(commit(\"softCommit\", \"false\"));\n        committedModel = new LinkedHashMap(model);\n        checkCommittedModel = true;\n      } else {\n        assertNotNull(\"null command in checkReplay\", cmd);\n        assertTrue(\"cmd is neither sentinal (HARD|SOFT)COMMIT object, nor Solr doc: \" + cmd.getClass(),\n                   cmd instanceof SolrInputDocument);\n        \n        final SolrInputDocument sdoc = (SolrInputDocument) cmd;\n        final int id = Integer.parseInt(sdoc.getFieldValue(\"id\").toString());\n        \n        final DocInfo previousInfo = model.get(id);\n        final Long previousValue = (null == previousInfo) ? null : previousInfo.value;\n        \n        final long version = addAndGetVersion(sdoc, null);\n        \n        final Object val = sdoc.getFieldValue(valField);\n        if (val instanceof Map) {\n          // atomic update of the field we're modeling\n          \n          Map<String,?> atomicUpdate = (Map) val;\n          assertEquals(sdoc.toString(), 1, atomicUpdate.size());\n          if (atomicUpdate.containsKey(\"inc\")) {\n            // Solr treats inc on a non-existing doc (or doc w/o existing value) as if existing value is 0\n            final long base = (null == previousValue) ? 0L : previousValue;\n            model.put(id, new DocInfo(version,\n                                      base + ((Number)atomicUpdate.get(\"inc\")).longValue()));\n          } else if (atomicUpdate.containsKey(\"set\")) {\n            model.put(id, new DocInfo(version, ((Number)atomicUpdate.get(\"set\")).longValue()));\n          } else {\n            fail(\"wtf update is this? ... \" + sdoc);\n          }\n        } else if (null == val) {\n          // the field we are modeling is not mentioned in this update, It's either...\n          //\n          // a) a regular update of some other fields (our model should have a null value)\n          // b) an atomic update of some other field (keep existing value in model)\n          //\n          // for now, assume it's atomic and we're going to keep our existing value...\n          Long newValue = (null == previousInfo) ? null : previousInfo.value;\n          for (SolrInputField field : sdoc) {\n            if (! ( \"id\".equals(field.getName()) || (field.getValue() instanceof Map)) ) {\n              // not an atomic update, newValue in model should be null\n              newValue = null;\n              break;\n            }\n          }\n          model.put(id, new DocInfo(version, newValue));\n          \n        } else {\n          // regular replacement of the value in the field we're modeling\n          \n          assertTrue(\"Model field value is not a Number: \" + val.getClass(), val instanceof Number);\n          model.put(id, new DocInfo(version, ((Number)val).longValue()));\n        }\n      }\n\n      // after every op, check the model(s)\n      \n      // RTG to check the values for every id against the model\n      for (Map.Entry<Integer, DocInfo> entry : model.entrySet()) {\n        final Long expected = entry.getValue().value;\n        assertEquals(expected, client.getById(String.valueOf(entry.getKey())).getFirstValue(valField));\n      }\n\n      // search to check the values for every id in the committed model\n      if (checkCommittedModel) {\n        final int numCommitedDocs = committedModel.size();\n        String[] xpaths = new String[1 + numCommitedDocs];\n        int i = 0;\n        for (Map.Entry<Integer, DocInfo> entry : committedModel.entrySet()) {\n          Integer id = entry.getKey();\n          Long expected = entry.getValue().value;\n          if (null != expected) {\n            xpaths[i] = \"//result/doc[./str='\"+id+\"'][./long='\"+expected+\"']\";\n          } else {\n            xpaths[i] = \"//result/doc[./str='\"+id+\"'][not(./long)]\";\n          }           \n          i++;\n        }\n        xpaths[i] = \"//*[@numFound='\"+numCommitedDocs+\"']\";\n        assertQ(req(\"q\", \"*:*\",\n                    \"fl\", \"id,\" + valField,\n                    \"rows\", \"\"+numCommitedDocs),\n                xpaths);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#checkReplay(String,Object...).mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesStandalone#checkReplay(String,Object...).mjava","sourceNew":"  /**\n   * Executes a sequence of commands against Solr, while tracking the expected value of a specified \n   * <code>valField</code> Long field (presumably that only uses docvalues) against an in memory model \n   * maintained in parallel (for the purpose of testing the correctness of in-place updates..\n   *\n   * <p>\n   * A few restrictions are placed on the {@link SolrInputDocument}s that can be included when using \n   * this method, in order to keep the in-memory model management simple:\n   * </p>\n   * <ul>\n   *  <li><code>id</code> must be uniqueKey field</li>\n   *  <li><code>id</code> may have any FieldType, but all values must be parsable as Integers</li>\n   *  <li><code>valField</code> must be a single valued field</li>\n   *  <li>All values in the <code>valField</code> must either be {@link Number}s, or Maps containing \n   *      atomic updates (\"inc\" or \"set\") where the atomic value is a {@link Number}</li>\n   * </ul>\n   * \n   * @param valField the field to model\n   * @param commands A sequence of Commands which can either be SolrInputDocuments \n   *                 (regular or containing atomic update Maps)\n   *                 or one of the {@link TestInPlaceUpdatesStandalone#HARDCOMMIT} or {@link TestInPlaceUpdatesStandalone#SOFTCOMMIT} sentinal objects.\n   */\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void checkReplay(final String valField, Object... commands) throws Exception {\n    \n    HashMap<Integer, DocInfo> model = new LinkedHashMap<>();\n    HashMap<Integer, DocInfo> committedModel = new LinkedHashMap<>();\n\n    // by default, we only check the committed model after a commit\n    // of if the number of total commands is relatively small.\n    //\n    // (in theory, there's no reason to check the committed model unless we know there's been a commit\n    // but for smaller tests the overhead of doing so is tiny, so we might as well)\n    //\n    // if some test seed fails, and you want to force the committed model to be checked\n    // after every command, just temporaribly force this variable to true...\n    boolean checkCommittedModel = (commands.length < 50);\n    \n    for (Object cmd : commands) {\n      if (cmd == SOFTCOMMIT) {\n        assertU(commit(\"softCommit\", \"true\"));\n        committedModel = new LinkedHashMap(model);\n        checkCommittedModel = true;\n      } else if (cmd == HARDCOMMIT) {\n        assertU(commit(\"softCommit\", \"false\"));\n        committedModel = new LinkedHashMap(model);\n        checkCommittedModel = true;\n      } else {\n        assertNotNull(\"null command in checkReplay\", cmd);\n        assertTrue(\"cmd is neither sentinal (HARD|SOFT)COMMIT object, nor Solr doc: \" + cmd.getClass(),\n                   cmd instanceof SolrInputDocument);\n        \n        final SolrInputDocument sdoc = (SolrInputDocument) cmd;\n        final int id = Integer.parseInt(sdoc.getFieldValue(\"id\").toString());\n        \n        final DocInfo previousInfo = model.get(id);\n        final Long previousValue = (null == previousInfo) ? null : previousInfo.value;\n        \n        final long version = addAndGetVersion(sdoc, null);\n        \n        final Object val = sdoc.getFieldValue(valField);\n        if (val instanceof Map) {\n          // atomic update of the field we're modeling\n          \n          Map<String,?> atomicUpdate = (Map) val;\n          assertEquals(sdoc.toString(), 1, atomicUpdate.size());\n          if (atomicUpdate.containsKey(\"inc\")) {\n            // Solr treats inc on a non-existing doc (or doc w/o existing value) as if existing value is 0\n            final long base = (null == previousValue) ? 0L : previousValue;\n            model.put(id, new DocInfo(version,\n                                      base + ((Number)atomicUpdate.get(\"inc\")).longValue()));\n          } else if (atomicUpdate.containsKey(\"set\")) {\n            model.put(id, new DocInfo(version, ((Number)atomicUpdate.get(\"set\")).longValue()));\n          } else {\n            fail(\"wtf update is this? ... \" + sdoc);\n          }\n        } else if (null == val) {\n          // the field we are modeling is not mentioned in this update, It's either...\n          //\n          // a) a regular update of some other fields (our model should have a null value)\n          // b) an atomic update of some other field (keep existing value in model)\n          //\n          // for now, assume it's atomic and we're going to keep our existing value...\n          Long newValue = (null == previousInfo) ? null : previousInfo.value;\n          for (SolrInputField field : sdoc) {\n            if (! ( \"id\".equals(field.getName()) || (field.getValue() instanceof Map)) ) {\n              // not an atomic update, newValue in model should be null\n              newValue = null;\n              break;\n            }\n          }\n          model.put(id, new DocInfo(version, newValue));\n          \n        } else {\n          // regular replacement of the value in the field we're modeling\n          \n          assertTrue(\"Model field value is not a Number: \" + val.getClass(), val instanceof Number);\n          model.put(id, new DocInfo(version, ((Number)val).longValue()));\n        }\n      }\n\n      // after every op, check the model(s)\n      \n      // RTG to check the values for every id against the model\n      for (Map.Entry<Integer, DocInfo> entry : model.entrySet()) {\n        final Long expected = entry.getValue().value;\n        assertEquals(expected, client.getById(String.valueOf(entry.getKey())).getFirstValue(valField));\n      }\n\n      // search to check the values for every id in the committed model\n      if (checkCommittedModel) {\n        final int numCommitedDocs = committedModel.size();\n        String[] xpaths = new String[1 + numCommitedDocs];\n        int i = 0;\n        for (Map.Entry<Integer, DocInfo> entry : committedModel.entrySet()) {\n          Integer id = entry.getKey();\n          Long expected = entry.getValue().value;\n          if (null != expected) {\n            xpaths[i] = \"//result/doc[./str='\"+id+\"'][./long='\"+expected+\"']\";\n          } else {\n            xpaths[i] = \"//result/doc[./str='\"+id+\"'][not(./long)]\";\n          }           \n          i++;\n        }\n        xpaths[i] = \"//*[@numFound='\"+numCommitedDocs+\"']\";\n        assertQ(req(\"q\", \"*:*\",\n                    \"fl\", \"id,\" + valField,\n                    \"rows\", \"\"+numCommitedDocs),\n                xpaths);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Executes a sequence of commands against Solr, while tracking the expected value of a specified \n   * <code>valField</code> Long field (presumably that only uses docvalues) against an in memory model \n   * maintained in parallel (for the purpose of testing the correctness of in-place updates..\n   *\n   * <p>\n   * A few restrictions are placed on the {@link SolrInputDocument}s that can be included when using \n   * this method, in order to keep the in-memory model management simple:\n   * </p>\n   * <ul>\n   *  <li><code>id</code> must be uniqueKey field</li>\n   *  <li><code>id</code> may have any FieldType, but all values must be parsable as Integers</li>\n   *  <li><code>valField</code> must be a single valued field</li>\n   *  <li>All values in the <code>valField</code> must either be {@link Number}s, or Maps containing \n   *      atomic updates (\"inc\" or \"set\") where the atomic value is a {@link Number}</li>\n   * </ul>\n   * \n   * @param valField the field to model\n   * @param commands A sequence of Commands which can either be SolrInputDocuments \n   *                 (regular or containing atomic update Maps)\n   *                 or one of the {@link TestInPlaceUpdatesStandalone#HARDCOMMIT} or {@link TestInPlaceUpdatesStandalone#SOFTCOMMIT} sentinal objects.\n   */\n  public void checkReplay(final String valField, Object... commands) throws Exception {\n    \n    HashMap<Integer, DocInfo> model = new LinkedHashMap<>();\n    HashMap<Integer, DocInfo> committedModel = new LinkedHashMap<>();\n\n    // by default, we only check the committed model after a commit\n    // of if the number of total commands is relatively small.\n    //\n    // (in theory, there's no reason to check the committed model unless we know there's been a commit\n    // but for smaller tests the overhead of doing so is tiny, so we might as well)\n    //\n    // if some test seed fails, and you want to force the committed model to be checked\n    // after every command, just temporaribly force this variable to true...\n    boolean checkCommittedModel = (commands.length < 50);\n    \n    for (Object cmd : commands) {\n      if (cmd == SOFTCOMMIT) {\n        assertU(commit(\"softCommit\", \"true\"));\n        committedModel = new LinkedHashMap(model);\n        checkCommittedModel = true;\n      } else if (cmd == HARDCOMMIT) {\n        assertU(commit(\"softCommit\", \"false\"));\n        committedModel = new LinkedHashMap(model);\n        checkCommittedModel = true;\n      } else {\n        assertNotNull(\"null command in checkReplay\", cmd);\n        assertTrue(\"cmd is neither sentinal (HARD|SOFT)COMMIT object, nor Solr doc: \" + cmd.getClass(),\n                   cmd instanceof SolrInputDocument);\n        \n        final SolrInputDocument sdoc = (SolrInputDocument) cmd;\n        final int id = Integer.parseInt(sdoc.getFieldValue(\"id\").toString());\n        \n        final DocInfo previousInfo = model.get(id);\n        final Long previousValue = (null == previousInfo) ? null : previousInfo.value;\n        \n        final long version = addAndGetVersion(sdoc, null);\n        \n        final Object val = sdoc.getFieldValue(valField);\n        if (val instanceof Map) {\n          // atomic update of the field we're modeling\n          \n          Map<String,?> atomicUpdate = (Map) val;\n          assertEquals(sdoc.toString(), 1, atomicUpdate.size());\n          if (atomicUpdate.containsKey(\"inc\")) {\n            // Solr treats inc on a non-existing doc (or doc w/o existing value) as if existing value is 0\n            final long base = (null == previousValue) ? 0L : previousValue;\n            model.put(id, new DocInfo(version,\n                                      base + ((Number)atomicUpdate.get(\"inc\")).longValue()));\n          } else if (atomicUpdate.containsKey(\"set\")) {\n            model.put(id, new DocInfo(version, ((Number)atomicUpdate.get(\"set\")).longValue()));\n          } else {\n            fail(\"wtf update is this? ... \" + sdoc);\n          }\n        } else if (null == val) {\n          // the field we are modeling is not mentioned in this update, It's either...\n          //\n          // a) a regular update of some other fields (our model should have a null value)\n          // b) an atomic update of some other field (keep existing value in model)\n          //\n          // for now, assume it's atomic and we're going to keep our existing value...\n          Long newValue = (null == previousInfo) ? null : previousInfo.value;\n          for (SolrInputField field : sdoc) {\n            if (! ( \"id\".equals(field.getName()) || (field.getValue() instanceof Map)) ) {\n              // not an atomic update, newValue in model should be null\n              newValue = null;\n              break;\n            }\n          }\n          model.put(id, new DocInfo(version, newValue));\n          \n        } else {\n          // regular replacement of the value in the field we're modeling\n          \n          assertTrue(\"Model field value is not a Number: \" + val.getClass(), val instanceof Number);\n          model.put(id, new DocInfo(version, ((Number)val).longValue()));\n        }\n      }\n\n      // after every op, check the model(s)\n      \n      // RTG to check the values for every id against the model\n      for (Map.Entry<Integer, DocInfo> entry : model.entrySet()) {\n        final Long expected = entry.getValue().value;\n        assertEquals(expected, client.getById(String.valueOf(entry.getKey())).getFirstValue(valField));\n      }\n\n      // search to check the values for every id in the committed model\n      if (checkCommittedModel) {\n        final int numCommitedDocs = committedModel.size();\n        String[] xpaths = new String[1 + numCommitedDocs];\n        int i = 0;\n        for (Map.Entry<Integer, DocInfo> entry : committedModel.entrySet()) {\n          Integer id = entry.getKey();\n          Long expected = entry.getValue().value;\n          if (null != expected) {\n            xpaths[i] = \"//result/doc[./str='\"+id+\"'][./long='\"+expected+\"']\";\n          } else {\n            xpaths[i] = \"//result/doc[./str='\"+id+\"'][not(./long)]\";\n          }           \n          i++;\n        }\n        xpaths[i] = \"//*[@numFound='\"+numCommitedDocs+\"']\";\n        assertQ(req(\"q\", \"*:*\",\n                    \"fl\", \"id,\" + valField,\n                    \"rows\", \"\"+numCommitedDocs),\n                xpaths);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","415bbbe7da8065dd3c477bdc3c703c6425622998"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e98520789adb1d5ad05afb4956eca0944a929688"],"e98520789adb1d5ad05afb4956eca0944a929688":["415bbbe7da8065dd3c477bdc3c703c6425622998"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","e98520789adb1d5ad05afb4956eca0944a929688"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"e98520789adb1d5ad05afb4956eca0944a929688":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}