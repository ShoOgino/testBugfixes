{"path":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#preferCurrentHostForDistributedReq(ShardRequest,List[String]).mjava","commits":[{"id":"51b92ffe30c50bb08699200b62c40420378ac3df","date":1423881454,"type":0,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#preferCurrentHostForDistributedReq(ShardRequest,List[String]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * A distributed request is made via {@link LBHttpSolrClient} to the first live server in the URL list.\n   * This means it is just as likely to choose current host as any of the other hosts.\n   * This function makes sure that the cores of current host are always put first in the URL list.\n   * If all nodes prefer local-cores then a bad/heavily-loaded node will receive less requests from healthy nodes.\n   * This will help prevent a distributed deadlock or timeouts in all the healthy nodes due to one bad node.\n   */\n  private void preferCurrentHostForDistributedReq(final ShardRequest sreq, final List<String> urls) {\n    if (sreq == null || sreq.rb == null || sreq.rb.req == null || urls == null || urls.size() <= 1)\n      return;\n\n    SolrQueryRequest req = sreq.rb.req;\n\n    // determine if we should apply the local preference\n    if (!req.getOriginalParams().getBool(CommonParams.PREFER_LOCAL_SHARDS, false))\n      return;\n\n    // Get this node's base URL from ZK\n    SolrCore core = req.getCore();\n    ZkController zkController = (core != null) ? core.getCoreDescriptor().getCoreContainer().getZkController() : null;\n    String currentHostAddress = (zkController != null) ? zkController.getBaseUrl() : null;\n    if (currentHostAddress == null) {\n      log.debug(\"Couldn't determine current host address to prefer local shards \" +\n                \"because either core is null? {} or there is no ZkController? {}\",\n                Boolean.valueOf(core == null), Boolean.valueOf(zkController == null));\n      return;\n    }\n\n    if (log.isDebugEnabled())\n      log.debug(\"Trying to prefer local shard on {} among the urls: {}\",\n          currentHostAddress, Arrays.toString(urls.toArray()));\n\n    ListIterator<String> itr = urls.listIterator();\n    while (itr.hasNext()) {\n      String url = itr.next();\n      if (url.startsWith(currentHostAddress)) {\n        // move current URL to the fore-front\n        itr.remove();\n        urls.add(0, url);\n\n        if (log.isDebugEnabled())\n          log.debug(\"Applied local shard preference for urls: {}\",\n              Arrays.toString(urls.toArray()));\n\n        break;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23e55c29de60130e8a1226800b66c5f6d7e16e8a","date":1447950053,"type":5,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#preferCurrentHostForDistributedReq(String,List[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler#preferCurrentHostForDistributedReq(ShardRequest,List[String]).mjava","sourceNew":"  /**\n   * A distributed request is made via {@link LBHttpSolrClient} to the first live server in the URL list.\n   * This means it is just as likely to choose current host as any of the other hosts.\n   * This function makes sure that the cores of current host are always put first in the URL list.\n   * If all nodes prefer local-cores then a bad/heavily-loaded node will receive less requests from healthy nodes.\n   * This will help prevent a distributed deadlock or timeouts in all the healthy nodes due to one bad node.\n   */\n  private void preferCurrentHostForDistributedReq(final String currentHostAddress, final List<String> urls) {\n    if (log.isDebugEnabled())\n      log.debug(\"Trying to prefer local shard on {} among the urls: {}\",\n          currentHostAddress, Arrays.toString(urls.toArray()));\n\n    ListIterator<String> itr = urls.listIterator();\n    while (itr.hasNext()) {\n      String url = itr.next();\n      if (url.startsWith(currentHostAddress)) {\n        // move current URL to the fore-front\n        itr.remove();\n        urls.add(0, url);\n\n        if (log.isDebugEnabled())\n          log.debug(\"Applied local shard preference for urls: {}\",\n              Arrays.toString(urls.toArray()));\n\n        break;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * A distributed request is made via {@link LBHttpSolrClient} to the first live server in the URL list.\n   * This means it is just as likely to choose current host as any of the other hosts.\n   * This function makes sure that the cores of current host are always put first in the URL list.\n   * If all nodes prefer local-cores then a bad/heavily-loaded node will receive less requests from healthy nodes.\n   * This will help prevent a distributed deadlock or timeouts in all the healthy nodes due to one bad node.\n   */\n  private void preferCurrentHostForDistributedReq(final ShardRequest sreq, final List<String> urls) {\n    if (sreq == null || sreq.rb == null || sreq.rb.req == null || urls == null || urls.size() <= 1)\n      return;\n\n    SolrQueryRequest req = sreq.rb.req;\n\n    // determine if we should apply the local preference\n    if (!req.getOriginalParams().getBool(CommonParams.PREFER_LOCAL_SHARDS, false))\n      return;\n\n    // Get this node's base URL from ZK\n    SolrCore core = req.getCore();\n    ZkController zkController = (core != null) ? core.getCoreDescriptor().getCoreContainer().getZkController() : null;\n    String currentHostAddress = (zkController != null) ? zkController.getBaseUrl() : null;\n    if (currentHostAddress == null) {\n      log.debug(\"Couldn't determine current host address to prefer local shards \" +\n                \"because either core is null? {} or there is no ZkController? {}\",\n                Boolean.valueOf(core == null), Boolean.valueOf(zkController == null));\n      return;\n    }\n\n    if (log.isDebugEnabled())\n      log.debug(\"Trying to prefer local shard on {} among the urls: {}\",\n          currentHostAddress, Arrays.toString(urls.toArray()));\n\n    ListIterator<String> itr = urls.listIterator();\n    while (itr.hasNext()) {\n      String url = itr.next();\n      if (url.startsWith(currentHostAddress)) {\n        // move current URL to the fore-front\n        itr.remove();\n        urls.add(0, url);\n\n        if (log.isDebugEnabled())\n          log.debug(\"Applied local shard preference for urls: {}\",\n              Arrays.toString(urls.toArray()));\n\n        break;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"51b92ffe30c50bb08699200b62c40420378ac3df":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"23e55c29de60130e8a1226800b66c5f6d7e16e8a":["51b92ffe30c50bb08699200b62c40420378ac3df"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["23e55c29de60130e8a1226800b66c5f6d7e16e8a"]},"commit2Childs":{"51b92ffe30c50bb08699200b62c40420378ac3df":["23e55c29de60130e8a1226800b66c5f6d7e16e8a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["51b92ffe30c50bb08699200b62c40420378ac3df"],"23e55c29de60130e8a1226800b66c5f6d7e16e8a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}