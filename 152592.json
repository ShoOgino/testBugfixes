{"path":"solr/core/src/java/org/apache/solr/cloud/DeleteNodeCmd#verifyReplicaAvailability(List[ZkNodeProps],ClusterState).mjava","commits":[{"id":"558f47e41524183823173884b3aaf0c03653dec0","date":1499192348,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DeleteNodeCmd#verifyReplicaAvailability(List[ZkNodeProps],ClusterState).mjava","pathOld":"/dev/null","sourceNew":"  // collect names of replicas that cannot be deleted\n  static List<String> verifyReplicaAvailability(List<ZkNodeProps> sourceReplicas, ClusterState state) {\n    List<String> res = new ArrayList<>();\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      String coll = sourceReplica.getStr(COLLECTION_PROP);\n      String shard = sourceReplica.getStr(SHARD_ID_PROP);\n      String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n      DocCollection collection = state.getCollection(coll);\n      Slice slice = collection.getSlice(shard);\n      if (slice.getReplicas().size() < 2) {\n        // can't delete the only replica in existence\n        res.add(coll + \"/\" + shard + \"/\" + replicaName + \", type=\" + sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n      } else { // check replica types\n        int otherNonPullReplicas = 0;\n        for (Replica r : slice.getReplicas()) {\n          if (!r.getName().equals(replicaName) && !r.getType().equals(Replica.Type.PULL)) {\n            otherNonPullReplicas++;\n          }\n        }\n        // can't delete - there are no other non-pull replicas\n        if (otherNonPullReplicas == 0) {\n          res.add(coll + \"/\" + shard + \"/\" + replicaName + \", type=\" + sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n        }\n      }\n    }\n    return res;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ea161f828a3a7a6eb9410a431aecda6d7ab1065","date":1499213384,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DeleteNodeCmd#verifyReplicaAvailability(List[ZkNodeProps],ClusterState).mjava","pathOld":"/dev/null","sourceNew":"  // collect names of replicas that cannot be deleted\n  static List<String> verifyReplicaAvailability(List<ZkNodeProps> sourceReplicas, ClusterState state) {\n    List<String> res = new ArrayList<>();\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      String coll = sourceReplica.getStr(COLLECTION_PROP);\n      String shard = sourceReplica.getStr(SHARD_ID_PROP);\n      String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n      DocCollection collection = state.getCollection(coll);\n      Slice slice = collection.getSlice(shard);\n      if (slice.getReplicas().size() < 2) {\n        // can't delete the only replica in existence\n        res.add(coll + \"/\" + shard + \"/\" + replicaName + \", type=\" + sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n      } else { // check replica types\n        int otherNonPullReplicas = 0;\n        for (Replica r : slice.getReplicas()) {\n          if (!r.getName().equals(replicaName) && !r.getType().equals(Replica.Type.PULL)) {\n            otherNonPullReplicas++;\n          }\n        }\n        // can't delete - there are no other non-pull replicas\n        if (otherNonPullReplicas == 0) {\n          res.add(coll + \"/\" + shard + \"/\" + replicaName + \", type=\" + sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n        }\n      }\n    }\n    return res;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":5,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteNodeCmd#verifyReplicaAvailability(List[ZkNodeProps],ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DeleteNodeCmd#verifyReplicaAvailability(List[ZkNodeProps],ClusterState).mjava","sourceNew":"  // collect names of replicas that cannot be deleted\n  static List<String> verifyReplicaAvailability(List<ZkNodeProps> sourceReplicas, ClusterState state) {\n    List<String> res = new ArrayList<>();\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      String coll = sourceReplica.getStr(COLLECTION_PROP);\n      String shard = sourceReplica.getStr(SHARD_ID_PROP);\n      String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n      DocCollection collection = state.getCollection(coll);\n      Slice slice = collection.getSlice(shard);\n      if (slice.getReplicas().size() < 2) {\n        // can't delete the only replica in existence\n        res.add(coll + \"/\" + shard + \"/\" + replicaName + \", type=\" + sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n      } else { // check replica types\n        int otherNonPullReplicas = 0;\n        for (Replica r : slice.getReplicas()) {\n          if (!r.getName().equals(replicaName) && !r.getType().equals(Replica.Type.PULL)) {\n            otherNonPullReplicas++;\n          }\n        }\n        // can't delete - there are no other non-pull replicas\n        if (otherNonPullReplicas == 0) {\n          res.add(coll + \"/\" + shard + \"/\" + replicaName + \", type=\" + sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n        }\n      }\n    }\n    return res;\n  }\n\n","sourceOld":"  // collect names of replicas that cannot be deleted\n  static List<String> verifyReplicaAvailability(List<ZkNodeProps> sourceReplicas, ClusterState state) {\n    List<String> res = new ArrayList<>();\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      String coll = sourceReplica.getStr(COLLECTION_PROP);\n      String shard = sourceReplica.getStr(SHARD_ID_PROP);\n      String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n      DocCollection collection = state.getCollection(coll);\n      Slice slice = collection.getSlice(shard);\n      if (slice.getReplicas().size() < 2) {\n        // can't delete the only replica in existence\n        res.add(coll + \"/\" + shard + \"/\" + replicaName + \", type=\" + sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n      } else { // check replica types\n        int otherNonPullReplicas = 0;\n        for (Replica r : slice.getReplicas()) {\n          if (!r.getName().equals(replicaName) && !r.getType().equals(Replica.Type.PULL)) {\n            otherNonPullReplicas++;\n          }\n        }\n        // can't delete - there are no other non-pull replicas\n        if (otherNonPullReplicas == 0) {\n          res.add(coll + \"/\" + shard + \"/\" + replicaName + \", type=\" + sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n        }\n      }\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteNodeCmd#verifyReplicaAvailability(List[ZkNodeProps],ClusterState).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DeleteNodeCmd#verifyReplicaAvailability(List[ZkNodeProps],ClusterState).mjava","sourceNew":"  // collect names of replicas that cannot be deleted\n  static List<String> verifyReplicaAvailability(List<ZkNodeProps> sourceReplicas, ClusterState state) {\n    List<String> res = new ArrayList<>();\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      String coll = sourceReplica.getStr(COLLECTION_PROP);\n      String shard = sourceReplica.getStr(SHARD_ID_PROP);\n      String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n      DocCollection collection = state.getCollection(coll);\n      Slice slice = collection.getSlice(shard);\n      if (slice.getReplicas().size() < 2) {\n        // can't delete the only replica in existence\n        res.add(coll + \"/\" + shard + \"/\" + replicaName + \", type=\" + sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n      } else { // check replica types\n        int otherNonPullReplicas = 0;\n        for (Replica r : slice.getReplicas()) {\n          if (!r.getName().equals(replicaName) && !r.getType().equals(Replica.Type.PULL)) {\n            otherNonPullReplicas++;\n          }\n        }\n        // can't delete - there are no other non-pull replicas\n        if (otherNonPullReplicas == 0) {\n          res.add(coll + \"/\" + shard + \"/\" + replicaName + \", type=\" + sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n        }\n      }\n    }\n    return res;\n  }\n\n","sourceOld":"  // collect names of replicas that cannot be deleted\n  static List<String> verifyReplicaAvailability(List<ZkNodeProps> sourceReplicas, ClusterState state) {\n    List<String> res = new ArrayList<>();\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      String coll = sourceReplica.getStr(COLLECTION_PROP);\n      String shard = sourceReplica.getStr(SHARD_ID_PROP);\n      String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n      DocCollection collection = state.getCollection(coll);\n      Slice slice = collection.getSlice(shard);\n      if (slice.getReplicas().size() < 2) {\n        // can't delete the only replica in existence\n        res.add(coll + \"/\" + shard + \"/\" + replicaName + \", type=\" + sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n      } else { // check replica types\n        int otherNonPullReplicas = 0;\n        for (Replica r : slice.getReplicas()) {\n          if (!r.getName().equals(replicaName) && !r.getType().equals(Replica.Type.PULL)) {\n            otherNonPullReplicas++;\n          }\n        }\n        // can't delete - there are no other non-pull replicas\n        if (otherNonPullReplicas == 0) {\n          res.add(coll + \"/\" + shard + \"/\" + replicaName + \", type=\" + sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n        }\n      }\n    }\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["558f47e41524183823173884b3aaf0c03653dec0","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","558f47e41524183823173884b3aaf0c03653dec0"],"558f47e41524183823173884b3aaf0c03653dec0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["558f47e41524183823173884b3aaf0c03653dec0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":[],"558f47e41524183823173884b3aaf0c03653dec0":["b94236357aaa22b76c10629851fe4e376e0cea82","2ea161f828a3a7a6eb9410a431aecda6d7ab1065","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2ea161f828a3a7a6eb9410a431aecda6d7ab1065","558f47e41524183823173884b3aaf0c03653dec0"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2ea161f828a3a7a6eb9410a431aecda6d7ab1065","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}