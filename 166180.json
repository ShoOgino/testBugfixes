{"path":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    Map<String, SpellCheckCollation> collations = new HashMap<String, SpellCheckCollation>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n          NamedList suggestions = (NamedList) nl.get(\"suggestions\");\n          if(suggestions != null) {\n\t      \t\tList<Object> collationList = suggestions.getAll(\"collation\");\n\t      \t\tList<Object> collationRankList = suggestions.getAll(\"collationInternalRank\");\n\t      \t\tint i=0;\n\t      \t\tif(collationList != null) {\n\t\t      \t\tfor(Object o : collationList)\n\t\t      \t\t{\n\t\t      \t\t\tif(o instanceof String)\n\t\t      \t\t\t{\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) o);\n\t\t      \t\t\t\tif(collationRankList!= null && collationRankList.size()>0)\n\t\t      \t\t\t\t{\n\t\t\t      \t\t\t\tcoll.setInternalRank((Integer) collationRankList.get(i));\n\t\t\t      \t\t\t\ti++;\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t} else\n\t\t      \t\t\t{\n\t\t      \t\t\t\tNamedList expandedCollation = (NamedList) o;\t\t      \t\t\t\t\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) expandedCollation.get(\"collationQuery\"));\n\t\t      \t\t\t\tcoll.setHits((Integer) expandedCollation.get(\"hits\"));\n\t\t      \t\t\t\tif(maxCollationTries>0)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank((Integer) expandedCollation.get(\"collationInternalRank\"));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcoll.setMisspellingsAndCorrections((NamedList) expandedCollation.get(\"misspellingsAndCorrections\"));\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setHits(coll.getHits() + priorColl.getHits());\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t}\n\t\t      \t\t}\n\t      \t\t}\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = collations.values().toArray(new SpellCheckCollation[collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    Map<String, SpellCheckCollation> collations = new HashMap<String, SpellCheckCollation>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n          NamedList suggestions = (NamedList) nl.get(\"suggestions\");\n          if(suggestions != null) {\n\t      \t\tList<Object> collationList = suggestions.getAll(\"collation\");\n\t      \t\tList<Object> collationRankList = suggestions.getAll(\"collationInternalRank\");\n\t      \t\tint i=0;\n\t      \t\tif(collationList != null) {\n\t\t      \t\tfor(Object o : collationList)\n\t\t      \t\t{\n\t\t      \t\t\tif(o instanceof String)\n\t\t      \t\t\t{\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) o);\n\t\t      \t\t\t\tif(collationRankList!= null && collationRankList.size()>0)\n\t\t      \t\t\t\t{\n\t\t\t      \t\t\t\tcoll.setInternalRank((Integer) collationRankList.get(i));\n\t\t\t      \t\t\t\ti++;\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t} else\n\t\t      \t\t\t{\n\t\t      \t\t\t\tNamedList expandedCollation = (NamedList) o;\t\t      \t\t\t\t\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) expandedCollation.get(\"collationQuery\"));\n\t\t      \t\t\t\tcoll.setHits((Integer) expandedCollation.get(\"hits\"));\n\t\t      \t\t\t\tif(maxCollationTries>0)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank((Integer) expandedCollation.get(\"collationInternalRank\"));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcoll.setMisspellingsAndCorrections((NamedList) expandedCollation.get(\"misspellingsAndCorrections\"));\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setHits(coll.getHits() + priorColl.getHits());\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t}\n\t\t      \t\t}\n\t      \t\t}\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = collations.values().toArray(new SpellCheckCollation[collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    Map<String, SpellCheckCollation> collations = new HashMap<String, SpellCheckCollation>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n          NamedList suggestions = (NamedList) nl.get(\"suggestions\");\n          if(suggestions != null) {\n\t      \t\tList<Object> collationList = suggestions.getAll(\"collation\");\n\t      \t\tList<Object> collationRankList = suggestions.getAll(\"collationInternalRank\");\n\t      \t\tint i=0;\n\t      \t\tif(collationList != null) {\n\t\t      \t\tfor(Object o : collationList)\n\t\t      \t\t{\n\t\t      \t\t\tif(o instanceof String)\n\t\t      \t\t\t{\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) o);\n\t\t      \t\t\t\tif(collationRankList!= null && collationRankList.size()>0)\n\t\t      \t\t\t\t{\n\t\t\t      \t\t\t\tcoll.setInternalRank((Integer) collationRankList.get(i));\n\t\t\t      \t\t\t\ti++;\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t} else\n\t\t      \t\t\t{\n\t\t      \t\t\t\tNamedList expandedCollation = (NamedList) o;\t\t      \t\t\t\t\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) expandedCollation.get(\"collationQuery\"));\n\t\t      \t\t\t\tcoll.setHits((Integer) expandedCollation.get(\"hits\"));\n\t\t      \t\t\t\tif(maxCollationTries>0)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank((Integer) expandedCollation.get(\"collationInternalRank\"));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcoll.setMisspellingsAndCorrections((NamedList) expandedCollation.get(\"misspellingsAndCorrections\"));\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setHits(coll.getHits() + priorColl.getHits());\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t}\n\t\t      \t\t}\n\t      \t\t}\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = collations.values().toArray(new SpellCheckCollation[collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    Map<String, SpellCheckCollation> collations = new HashMap<String, SpellCheckCollation>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n          NamedList suggestions = (NamedList) nl.get(\"suggestions\");\n          if(suggestions != null) {\n\t      \t\tList<Object> collationList = suggestions.getAll(\"collation\");\n\t      \t\tList<Object> collationRankList = suggestions.getAll(\"collationInternalRank\");\n\t      \t\tint i=0;\n\t      \t\tif(collationList != null) {\n\t\t      \t\tfor(Object o : collationList)\n\t\t      \t\t{\n\t\t      \t\t\tif(o instanceof String)\n\t\t      \t\t\t{\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) o);\n\t\t      \t\t\t\tif(collationRankList!= null && collationRankList.size()>0)\n\t\t      \t\t\t\t{\n\t\t\t      \t\t\t\tcoll.setInternalRank((Integer) collationRankList.get(i));\n\t\t\t      \t\t\t\ti++;\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t} else\n\t\t      \t\t\t{\n\t\t      \t\t\t\tNamedList expandedCollation = (NamedList) o;\t\t      \t\t\t\t\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) expandedCollation.get(\"collationQuery\"));\n\t\t      \t\t\t\tcoll.setHits((Integer) expandedCollation.get(\"hits\"));\n\t\t      \t\t\t\tif(maxCollationTries>0)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank((Integer) expandedCollation.get(\"collationInternalRank\"));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcoll.setMisspellingsAndCorrections((NamedList) expandedCollation.get(\"misspellingsAndCorrections\"));\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setHits(coll.getHits() + priorColl.getHits());\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t}\n\t\t      \t\t}\n\t      \t\t}\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = collations.values().toArray(new SpellCheckCollation[collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    Map<String, SpellCheckCollation> collations = new HashMap<String, SpellCheckCollation>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n          NamedList suggestions = (NamedList) nl.get(\"suggestions\");\n          if(suggestions != null) {\n\t      \t\tList<Object> collationList = suggestions.getAll(\"collation\");\n\t      \t\tList<Object> collationRankList = suggestions.getAll(\"collationInternalRank\");\n\t      \t\tint i=0;\n\t      \t\tif(collationList != null) {\n\t\t      \t\tfor(Object o : collationList)\n\t\t      \t\t{\n\t\t      \t\t\tif(o instanceof String)\n\t\t      \t\t\t{\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) o);\n\t\t      \t\t\t\tif(collationRankList!= null && collationRankList.size()>0)\n\t\t      \t\t\t\t{\n\t\t\t      \t\t\t\tcoll.setInternalRank((Integer) collationRankList.get(i));\n\t\t\t      \t\t\t\ti++;\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t} else\n\t\t      \t\t\t{\n\t\t      \t\t\t\tNamedList expandedCollation = (NamedList) o;\t\t      \t\t\t\t\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) expandedCollation.get(\"collationQuery\"));\n\t\t      \t\t\t\tcoll.setHits((Integer) expandedCollation.get(\"hits\"));\n\t\t      \t\t\t\tif(maxCollationTries>0)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank((Integer) expandedCollation.get(\"collationInternalRank\"));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcoll.setMisspellingsAndCorrections((NamedList) expandedCollation.get(\"misspellingsAndCorrections\"));\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setHits(coll.getHits() + priorColl.getHits());\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t}\n\t\t      \t\t}\n\t      \t\t}\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = collations.values().toArray(new SpellCheckCollation[collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    Map<String, SpellCheckCollation> collations = new HashMap<String, SpellCheckCollation>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n          NamedList suggestions = (NamedList) nl.get(\"suggestions\");\n          if(suggestions != null) {\n\t      \t\tList<Object> collationList = suggestions.getAll(\"collation\");\n\t      \t\tList<Object> collationRankList = suggestions.getAll(\"collationInternalRank\");\n\t      \t\tint i=0;\n\t      \t\tif(collationList != null) {\n\t\t      \t\tfor(Object o : collationList)\n\t\t      \t\t{\n\t\t      \t\t\tif(o instanceof String)\n\t\t      \t\t\t{\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) o);\n\t\t      \t\t\t\tif(collationRankList!= null && collationRankList.size()>0)\n\t\t      \t\t\t\t{\n\t\t\t      \t\t\t\tcoll.setInternalRank((Integer) collationRankList.get(i));\n\t\t\t      \t\t\t\ti++;\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t} else\n\t\t      \t\t\t{\n\t\t      \t\t\t\tNamedList expandedCollation = (NamedList) o;\t\t      \t\t\t\t\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) expandedCollation.get(\"collationQuery\"));\n\t\t      \t\t\t\tcoll.setHits((Integer) expandedCollation.get(\"hits\"));\n\t\t      \t\t\t\tif(maxCollationTries>0)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank((Integer) expandedCollation.get(\"collationInternalRank\"));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcoll.setMisspellingsAndCorrections((NamedList) expandedCollation.get(\"misspellingsAndCorrections\"));\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setHits(coll.getHits() + priorColl.getHits());\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t}\n\t\t      \t\t}\n\t      \t\t}\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = collations.values().toArray(new SpellCheckCollation[collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5","date":1320922486,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }    \n    \n    SpellCheckMergeData mergeData = new SpellCheckMergeData();     \n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \tmergeData.totalNumberShardResponses++;\n        \tcollectShardSuggestions(nl, mergeData);          \n          collectShardCollations(mergeData, nl, maxCollationTries);\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());    \n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = mergeData.collations.values().toArray(new SpellCheckCollation[mergeData.collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    float min = 0.5f;\n    StringDistance sd = null;\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    if (checker instanceof AbstractLuceneSpellChecker) {\n      AbstractLuceneSpellChecker spellChecker = (AbstractLuceneSpellChecker) checker;\n      min = spellChecker.getAccuracy();\n      sd = spellChecker.getStringDistance();\n    }\n    if (sd == null)\n      sd = new LevensteinDistance();\n\n    Collection<Token> tokens = null;\n    try {\n      tokens = getTokens(origQuery, checker.getQueryAnalyzer());\n    } catch (IOException e) {\n      LOG.error(\"Could not get tokens (this should never happen)\", e);\n    }\n\n    // original token -> corresponding Suggestion object (keep track of start,end)\n    Map<String, SpellCheckResponse.Suggestion> origVsSuggestion = new HashMap<String, SpellCheckResponse.Suggestion>();\n    // original token string -> summed up frequency\n    Map<String, Integer> origVsFreq = new HashMap<String, Integer>();\n    // original token string -> # of shards reporting it as misspelled\n    Map<String, Integer> origVsShards = new HashMap<String, Integer>();\n    // original token string -> set of alternatives\n    // must preserve order because collation algorithm can only work in-order\n    Map<String, HashSet<String>> origVsSuggested = new LinkedHashMap<String, HashSet<String>>();\n    // alternative string -> corresponding SuggestWord object\n    Map<String, SuggestWord> suggestedVsWord = new HashMap<String, SuggestWord>();\n    Map<String, SpellCheckCollation> collations = new HashMap<String, SpellCheckCollation>();\n    \n    int totalNumberShardResponses = 0;\n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \ttotalNumberShardResponses++;\n          SpellCheckResponse spellCheckResp = new SpellCheckResponse(nl);\n          for (SpellCheckResponse.Suggestion suggestion : spellCheckResp.getSuggestions()) {\n            origVsSuggestion.put(suggestion.getToken(), suggestion);\n            HashSet<String> suggested = origVsSuggested.get(suggestion.getToken());\n            if (suggested == null) {\n              suggested = new HashSet<String>();\n              origVsSuggested.put(suggestion.getToken(), suggested);\n            }\n\n            // sum up original frequency          \n            int origFreq = 0;\n            Integer o = origVsFreq.get(suggestion.getToken());\n            if (o != null)  origFreq += o;\n            origFreq += suggestion.getOriginalFrequency();\n            origVsFreq.put(suggestion.getToken(), origFreq);\n            \n            //# shards reporting\n            Integer origShards = origVsShards.get(suggestion.getToken());\n            if(origShards==null) {\n            \torigVsShards.put(suggestion.getToken(), 1);\n            } else {\n            \torigVsShards.put(suggestion.getToken(), ++origShards);\n            }            \n\n            // find best suggestions\n            for (int i = 0; i < suggestion.getNumFound(); i++) {\n              String alternative = suggestion.getAlternatives().get(i);\n              suggested.add(alternative);\n              SuggestWord sug = suggestedVsWord.get(alternative);\n              if (sug == null)  {\n                sug = new SuggestWord();\n                suggestedVsWord.put(alternative, sug);\n              }\n              sug.string = alternative;\n              // alternative frequency is present only for extendedResults=true\n              if (suggestion.getAlternativeFrequencies() != null && suggestion.getAlternativeFrequencies().size() > 0) {\n                Integer freq = suggestion.getAlternativeFrequencies().get(i);\n                if (freq != null) sug.freq += freq;\n              }\n            }\n          }\n          NamedList suggestions = (NamedList) nl.get(\"suggestions\");\n          if(suggestions != null) {\n\t      \t\tList<Object> collationList = suggestions.getAll(\"collation\");\n\t      \t\tList<Object> collationRankList = suggestions.getAll(\"collationInternalRank\");\n\t      \t\tint i=0;\n\t      \t\tif(collationList != null) {\n\t\t      \t\tfor(Object o : collationList)\n\t\t      \t\t{\n\t\t      \t\t\tif(o instanceof String)\n\t\t      \t\t\t{\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) o);\n\t\t      \t\t\t\tif(collationRankList!= null && collationRankList.size()>0)\n\t\t      \t\t\t\t{\n\t\t\t      \t\t\t\tcoll.setInternalRank((Integer) collationRankList.get(i));\n\t\t\t      \t\t\t\ti++;\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t} else\n\t\t      \t\t\t{\n\t\t      \t\t\t\tNamedList expandedCollation = (NamedList) o;\t\t      \t\t\t\t\n\t\t      \t\t\t\tSpellCheckCollation coll = new SpellCheckCollation();\n\t\t      \t\t\t\tcoll.setCollationQuery((String) expandedCollation.get(\"collationQuery\"));\n\t\t      \t\t\t\tcoll.setHits((Integer) expandedCollation.get(\"hits\"));\n\t\t      \t\t\t\tif(maxCollationTries>0)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setInternalRank((Integer) expandedCollation.get(\"collationInternalRank\"));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcoll.setMisspellingsAndCorrections((NamedList) expandedCollation.get(\"misspellingsAndCorrections\"));\n\t\t      \t\t\t\tSpellCheckCollation priorColl = collations.get(coll.getCollationQuery());\n\t\t      \t\t\t\tif(priorColl != null)\n\t\t      \t\t\t\t{\n\t\t      \t\t\t\t\tcoll.setHits(coll.getHits() + priorColl.getHits());\n\t\t      \t\t\t\t\tcoll.setInternalRank(Math.max(coll.getInternalRank(),priorColl.getInternalRank()));\n\t\t      \t\t\t\t}\n\t\t      \t\t\t\tcollations.put(coll.getCollationQuery(), coll);\n\t\t      \t\t\t}\n\t\t      \t\t}\n\t      \t\t}\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SpellingResult result = new SpellingResult(tokens); //todo: investigate, why does it need tokens beforehand?\n    for (Map.Entry<String, HashSet<String>> entry : origVsSuggested.entrySet()) {\n      String original = entry.getKey();\n      \n      //Only use this suggestion if all shards reported it as misspelled.\n      Integer numShards = origVsShards.get(original);\n      if(numShards<totalNumberShardResponses) {\n      \tcontinue;\n      }\n      \n      HashSet<String> suggested = entry.getValue();\n      SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);\n      for (String suggestion : suggested) {\n        SuggestWord sug = suggestedVsWord.get(suggestion);\n        sug.score = sd.getDistance(original, sug.string);\n        if (sug.score < min) continue;\n        sugQueue.insertWithOverflow(sug);\n        if (sugQueue.size() == numSug) {\n          // if queue full, maintain the minScore score\n          min = sugQueue.top().score;\n        }\n      }\n\n      // create token\n      SpellCheckResponse.Suggestion suggestion = origVsSuggestion.get(original);\n      Token token = new Token(original, suggestion.getStartOffset(), suggestion.getEndOffset());\n\n      // get top 'count' suggestions out of 'sugQueue.size()' candidates\n      SuggestWord[] suggestions = new SuggestWord[Math.min(count, sugQueue.size())];\n      // skip the first sugQueue.size() - count elements\n      for (int k=0; k < sugQueue.size() - count; k++) sugQueue.pop();\n      // now collect the top 'count' responses\n      for (int k = Math.min(count, sugQueue.size()) - 1; k >= 0; k--)  {\n        suggestions[k] = sugQueue.pop();\n      }\n\n      if (extendedResults) {\n        Integer o = origVsFreq.get(original);\n        if (o != null) result.addFrequency(token, o);\n        for (SuggestWord word : suggestions)\n          result.add(token, word.string, word.freq);\n      } else {\n        List<String> words = new ArrayList<String>(sugQueue.size());\n        for (SuggestWord word : suggestions) words.add(word.string);\n        result.add(token, words);\n      }\n    }\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = collations.values().toArray(new SpellCheckCollation[collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"541f6605a29362fa8a42f33b69069e7da5178034","date":1337786849,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = params.getInt(SpellingParams.SPELLCHECK_MAX_RESULTS_FOR_SUGGEST); \n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n    \n    SpellCheckMergeData mergeData = new SpellCheckMergeData();  \n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n          \tmergeData.totalNumberShardResponses++;\n          \tcollectShardSuggestions(nl, mergeData);          \n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());    \n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n    \n    NamedList response = new SimpleOrderedMap();\n    NamedList suggestions = toNamedList(false, result, origQuery,\n        extendedResults, collate, isCorrectlySpelled);\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }    \n    \n    SpellCheckMergeData mergeData = new SpellCheckMergeData();     \n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \tmergeData.totalNumberShardResponses++;\n        \tcollectShardSuggestions(nl, mergeData);          \n          collectShardCollations(mergeData, nl, maxCollationTries);\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());    \n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = mergeData.collations.values().toArray(new SpellCheckCollation[mergeData.collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":["0d9835c6ddd23dd02eefd5adfc0e5d1e89075fbe","9f53e30d1a17e72299f6e7a149cd1ca6d90b554c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3599646b4d4c346cf74d334813488b8b337b5bf5","date":1337790261,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = params.getInt(SpellingParams.SPELLCHECK_MAX_RESULTS_FOR_SUGGEST); \n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n    \n    SpellCheckMergeData mergeData = new SpellCheckMergeData();  \n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n          \tmergeData.totalNumberShardResponses++;\n          \tcollectShardSuggestions(nl, mergeData);          \n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());    \n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n    \n    NamedList response = new SimpleOrderedMap();\n    NamedList suggestions = toNamedList(false, result, origQuery,\n        extendedResults, collate, isCorrectlySpelled);\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }    \n    \n    SpellCheckMergeData mergeData = new SpellCheckMergeData();     \n    for (ShardRequest sreq : rb.finished) {\n      for (ShardResponse srsp : sreq.responses) {\n        NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n        LOG.info(srsp.getShard() + \" \" + nl);\n        if (nl != null) {\n        \tmergeData.totalNumberShardResponses++;\n        \tcollectShardSuggestions(nl, mergeData);          \n          collectShardCollations(mergeData, nl, maxCollationTries);\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());    \n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n    \n    NamedList response = new SimpleOrderedMap();\n\t\tNamedList suggestions = toNamedList(false, result, origQuery, extendedResults, collate);\n\t\tif (collate) {\n\t\t\tSpellCheckCollation[] sortedCollations = mergeData.collations.values().toArray(new SpellCheckCollation[mergeData.collations.size()]);\n\t\t\tArrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4093b270ba337f9c25a4c0e6cb2ae2c07f697376","date":1347897716,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = params.getInt(SpellingParams.SPELLCHECK_MAX_RESULTS_FOR_SUGGEST); \n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n    \n    SpellCheckMergeData mergeData = new SpellCheckMergeData();  \n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());    \n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n    \n    NamedList response = new SimpleOrderedMap();\n    NamedList suggestions = toNamedList(false, result, origQuery,\n        extendedResults, collate, isCorrectlySpelled);\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          NamedList extendedResult = new NamedList();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          suggestions.add(\"collation\", extendedResult);\n        } else {\n          suggestions.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n    }\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = params.getInt(SpellingParams.SPELLCHECK_MAX_RESULTS_FOR_SUGGEST); \n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n    \n    SpellCheckMergeData mergeData = new SpellCheckMergeData();  \n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n          \tmergeData.totalNumberShardResponses++;\n          \tcollectShardSuggestions(nl, mergeData);          \n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());    \n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n    \n    NamedList response = new SimpleOrderedMap();\n    NamedList suggestions = toNamedList(false, result, origQuery,\n        extendedResults, collate, isCorrectlySpelled);\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\t\t\tint i = 0;\n\t\t\twhile (i < maxCollations && i < sortedCollations.length) {\n\t\t\t\tSpellCheckCollation collation = sortedCollations[i];\n\t\t\t\ti++;\n\t\t\t\tif (collationExtendedResults) {\n\t\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation\n\t\t\t\t\t\t\t.getMisspellingsAndCorrections());\n\t\t\t\t\tsuggestions.add(\"collation\", extendedResult);\n\t\t\t\t} else {\n\t\t\t\t\tsuggestions.add(\"collation\", collation.getCollationQuery());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9f53e30d1a17e72299f6e7a149cd1ca6d90b554c","date":1364838207,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = params.getInt(SpellingParams.SPELLCHECK_MAX_RESULTS_FOR_SUGGEST); \n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n    \n    SpellCheckMergeData mergeData = new SpellCheckMergeData();  \n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());    \n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n    \n    NamedList response = new SimpleOrderedMap();\n    NamedList suggestions = toNamedList(false, result, origQuery,\n        extendedResults, collate, isCorrectlySpelled);\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          NamedList extendedResult = new NamedList();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          suggestions.add(\"collation\", extendedResult);\n        } else {\n          suggestions.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n    }\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = params.getInt(SpellingParams.SPELLCHECK_MAX_RESULTS_FOR_SUGGEST); \n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n    \n    SpellCheckMergeData mergeData = new SpellCheckMergeData();  \n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());    \n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n    \n    NamedList response = new SimpleOrderedMap();\n    NamedList suggestions = toNamedList(false, result, origQuery,\n        extendedResults, collate, isCorrectlySpelled);\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          NamedList extendedResult = new NamedList();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          suggestions.add(\"collation\", extendedResult);\n        } else {\n          suggestions.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n    }\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":["541f6605a29362fa8a42f33b69069e7da5178034"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d9835c6ddd23dd02eefd5adfc0e5d1e89075fbe","date":1385910402,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = params.getInt(SpellingParams.SPELLCHECK_MAX_RESULTS_FOR_SUGGEST); \n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n    \n    SpellCheckMergeData mergeData = new SpellCheckMergeData();  \n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false)) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());    \n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n    \n    NamedList response = new SimpleOrderedMap();\n    NamedList suggestions = toNamedList(false, result, origQuery,\n        extendedResults, collate, isCorrectlySpelled);\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          NamedList extendedResult = new NamedList();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          suggestions.add(\"collation\", extendedResult);\n        } else {\n          suggestions.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n    }\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = params.getInt(SpellingParams.SPELLCHECK_MAX_RESULTS_FOR_SUGGEST); \n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n    \n    SpellCheckMergeData mergeData = new SpellCheckMergeData();  \n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());    \n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n    \n    NamedList response = new SimpleOrderedMap();\n    NamedList suggestions = toNamedList(false, result, origQuery,\n        extendedResults, collate, isCorrectlySpelled);\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          NamedList extendedResult = new NamedList();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          suggestions.add(\"collation\", extendedResult);\n        } else {\n          suggestions.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n    }\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":["541f6605a29362fa8a42f33b69069e7da5178034"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = params.getInt(SpellingParams.SPELLCHECK_MAX_RESULTS_FOR_SUGGEST); \n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n    \n    SpellCheckMergeData mergeData = new SpellCheckMergeData();  \n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false)) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());    \n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n    \n    NamedList response = new SimpleOrderedMap();\n    NamedList suggestions = toNamedList(false, result, origQuery,\n        extendedResults, collate, isCorrectlySpelled);\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          NamedList extendedResult = new NamedList();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          suggestions.add(\"collation\", extendedResult);\n        } else {\n          suggestions.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n    }\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = params.getInt(SpellingParams.SPELLCHECK_MAX_RESULTS_FOR_SUGGEST); \n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n    \n    SpellCheckMergeData mergeData = new SpellCheckMergeData();  \n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());    \n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n    \n    NamedList response = new SimpleOrderedMap();\n    NamedList suggestions = toNamedList(false, result, origQuery,\n        extendedResults, collate, isCorrectlySpelled);\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          NamedList extendedResult = new NamedList();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          suggestions.add(\"collation\", extendedResult);\n        } else {\n          suggestions.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n    }\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"343d2d9477b299075fa3a19a46e654b6c3bf552b","date":1407872410,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = params.getInt(SpellingParams.SPELLCHECK_MAX_RESULTS_FOR_SUGGEST); \n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n    \n    SpellCheckMergeData mergeData = new SpellCheckMergeData();  \n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false)) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());    \n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n    \n    NamedList response = new SimpleOrderedMap();\n    \n    NamedList suggestions = toNamedList(false, result, origQuery, extendedResults);\n    response.add(\"suggestions\", suggestions);\n\n    if (extendedResults) {\n      response.add(\"correctlySpelled\", isCorrectlySpelled);     \n    }\n    \n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n      \n      NamedList collations = new NamedList();\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          SimpleOrderedMap extendedResult = new SimpleOrderedMap();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          collations.add(\"collation\", extendedResult);\n        } else {\n          collations.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n      \n      response.add(\"collations\", collations);\n    }\n    \n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = params.getInt(SpellingParams.SPELLCHECK_MAX_RESULTS_FOR_SUGGEST); \n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n    \n    SpellCheckMergeData mergeData = new SpellCheckMergeData();  \n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false)) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());    \n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n    \n    NamedList response = new SimpleOrderedMap();\n    NamedList suggestions = toNamedList(false, result, origQuery,\n        extendedResults, collate, isCorrectlySpelled);\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          NamedList extendedResult = new NamedList();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          suggestions.add(\"collation\", extendedResult);\n        } else {\n          suggestions.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n    }\n    \n    response.add(\"suggestions\", suggestions);\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ba46b57f67b4eb7246bdc86cfdeb15b78306b90","date":1443533495,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = params.getInt(SpellingParams.SPELLCHECK_MAX_RESULTS_FOR_SUGGEST);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n\n    SpellCheckMergeData mergeData = new SpellCheckMergeData();\n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false)) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n\n    NamedList response = new SimpleOrderedMap();\n\n    NamedList suggestions = toNamedList(false, result, origQuery, extendedResults);\n    response.add(\"suggestions\", suggestions);\n\n    if (extendedResults) {\n      response.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\n      NamedList collations = new NamedList();\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          SimpleOrderedMap extendedResult = new SimpleOrderedMap();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          collations.add(\"collation\", extendedResult);\n        } else {\n          collations.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n\n      response.add(\"collations\", collations);\n    }\n\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = params.getInt(SpellingParams.SPELLCHECK_MAX_RESULTS_FOR_SUGGEST); \n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n    \n    SpellCheckMergeData mergeData = new SpellCheckMergeData();  \n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false)) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());    \n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n    \n    NamedList response = new SimpleOrderedMap();\n    \n    NamedList suggestions = toNamedList(false, result, origQuery, extendedResults);\n    response.add(\"suggestions\", suggestions);\n\n    if (extendedResults) {\n      response.add(\"correctlySpelled\", isCorrectlySpelled);     \n    }\n    \n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n      \n      NamedList collations = new NamedList();\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          SimpleOrderedMap extendedResult = new SimpleOrderedMap();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          collations.add(\"collation\", extendedResult);\n        } else {\n          collations.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n      \n      response.add(\"collations\", collations);\n    }\n    \n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51f6eb2e42e0de57b9d737aa322902b2d3029149","date":1450381224,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = maxResultsForSuggest(rb);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n\n    SpellCheckMergeData mergeData = new SpellCheckMergeData();\n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false)) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n\n    NamedList response = new SimpleOrderedMap();\n\n    NamedList suggestions = toNamedList(false, result, origQuery, extendedResults);\n    response.add(\"suggestions\", suggestions);\n\n    if (extendedResults) {\n      response.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\n      NamedList collations = new NamedList();\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          SimpleOrderedMap extendedResult = new SimpleOrderedMap();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          collations.add(\"collation\", extendedResult);\n        } else {\n          collations.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n\n      response.add(\"collations\", collations);\n    }\n\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = params.getInt(SpellingParams.SPELLCHECK_MAX_RESULTS_FOR_SUGGEST);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n\n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n\n    SpellCheckMergeData mergeData = new SpellCheckMergeData();\n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false)) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n\n    NamedList response = new SimpleOrderedMap();\n\n    NamedList suggestions = toNamedList(false, result, origQuery, extendedResults);\n    response.add(\"suggestions\", suggestions);\n\n    if (extendedResults) {\n      response.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\n      NamedList collations = new NamedList();\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          SimpleOrderedMap extendedResult = new SimpleOrderedMap();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          collations.add(\"collation\", extendedResult);\n        } else {\n          collations.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n\n      response.add(\"collations\", collations);\n    }\n\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"862753d1e2f4853f389dcb115747661e7bc0e384","date":1485438193,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = maxResultsForSuggest(rb);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n\n    SpellCheckMergeData mergeData = new SpellCheckMergeData();\n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false)) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n\n    NamedList response = new SimpleOrderedMap();\n\n    response.add(\"suggestions\", toNamedList(false, result, origQuery, extendedResults));\n\n    if (extendedResults) {\n      response.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\n      NamedList collations = new SimpleOrderedMap();\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          SimpleOrderedMap extendedResult = new SimpleOrderedMap();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          collations.add(\"collation\", extendedResult);\n        } else {\n          collations.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n\n      response.add(\"collations\", collations);\n    }\n\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = maxResultsForSuggest(rb);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n\n    SpellCheckMergeData mergeData = new SpellCheckMergeData();\n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false)) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n\n    NamedList response = new SimpleOrderedMap();\n\n    NamedList suggestions = toNamedList(false, result, origQuery, extendedResults);\n    response.add(\"suggestions\", suggestions);\n\n    if (extendedResults) {\n      response.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\n      NamedList collations = new NamedList();\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          SimpleOrderedMap extendedResult = new SimpleOrderedMap();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          collations.add(\"collation\", extendedResult);\n        } else {\n          collations.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n\n      response.add(\"collations\", collations);\n    }\n\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = maxResultsForSuggest(rb);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n\n    SpellCheckMergeData mergeData = new SpellCheckMergeData();\n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false)) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n\n    NamedList response = new SimpleOrderedMap();\n\n    response.add(\"suggestions\", toNamedList(false, result, origQuery, extendedResults));\n\n    if (extendedResults) {\n      response.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\n      NamedList collations = new SimpleOrderedMap();\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          SimpleOrderedMap extendedResult = new SimpleOrderedMap();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          collations.add(\"collation\", extendedResult);\n        } else {\n          collations.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n\n      response.add(\"collations\", collations);\n    }\n\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = maxResultsForSuggest(rb);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n\n    SpellCheckMergeData mergeData = new SpellCheckMergeData();\n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false)) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n\n    NamedList response = new SimpleOrderedMap();\n\n    NamedList suggestions = toNamedList(false, result, origQuery, extendedResults);\n    response.add(\"suggestions\", suggestions);\n\n    if (extendedResults) {\n      response.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\n      NamedList collations = new NamedList();\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          SimpleOrderedMap extendedResult = new SimpleOrderedMap();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          collations.add(\"collation\", extendedResult);\n        } else {\n          collations.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n\n      response.add(\"collations\", collations);\n    }\n\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"374570062523b2011ca513a2276525ff3ddf222d","date":1494268002,"type":3,"author":"jdyer1","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = maxResultsForSuggest(rb);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n\n    SpellCheckMergeData mergeData = new SpellCheckMergeData();\n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false)) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n\n    NamedList response = new SimpleOrderedMap();\n\n    NamedList suggestions = toNamedList(false, result, origQuery, extendedResults);\n    response.add(\"suggestions\", suggestions);\n\n    if (extendedResults) {\n      response.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\n      NamedList collations = new NamedList();\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          SimpleOrderedMap extendedResult = new SimpleOrderedMap();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          collations.add(\"collation\", extendedResult);\n        } else {\n          collations.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n\n      response.add(\"collations\", collations);\n    }\n\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = maxResultsForSuggest(rb);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n\n    SpellCheckMergeData mergeData = new SpellCheckMergeData();\n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false)) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n\n    NamedList response = new SimpleOrderedMap();\n\n    response.add(\"suggestions\", toNamedList(false, result, origQuery, extendedResults));\n\n    if (extendedResults) {\n      response.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\n      NamedList collations = new SimpleOrderedMap();\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          SimpleOrderedMap extendedResult = new SimpleOrderedMap();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          collations.add(\"collation\", extendedResult);\n        } else {\n          collations.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n\n      response.add(\"collations\", collations);\n    }\n\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = maxResultsForSuggest(rb);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n\n    SpellCheckMergeData mergeData = new SpellCheckMergeData();\n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false)) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n\n    NamedList response = new SimpleOrderedMap();\n\n    NamedList suggestions = toNamedList(false, result, origQuery, extendedResults);\n    response.add(\"suggestions\", suggestions);\n\n    if (extendedResults) {\n      response.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\n      NamedList collations = new NamedList();\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          SimpleOrderedMap extendedResult = new SimpleOrderedMap();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          collations.add(\"collation\", extendedResult);\n        } else {\n          collations.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n\n      response.add(\"collations\", collations);\n    }\n\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = maxResultsForSuggest(rb);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n\n    SpellCheckMergeData mergeData = new SpellCheckMergeData();\n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false)) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n\n    NamedList response = new SimpleOrderedMap();\n\n    response.add(\"suggestions\", toNamedList(false, result, origQuery, extendedResults));\n\n    if (extendedResults) {\n      response.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\n      NamedList collations = new SimpleOrderedMap();\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          SimpleOrderedMap extendedResult = new SimpleOrderedMap();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          collations.add(\"collation\", extendedResult);\n        } else {\n          collations.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n\n      response.add(\"collations\", collations);\n    }\n\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd22dcd3ba035a1626face7319c94be45ae07172","date":1527224634,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = maxResultsForSuggest(rb);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n\n    SpellCheckMergeData mergeData = new SpellCheckMergeData();\n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (ShardParams.getShardsTolerantAsBool(rb.req.getParams())) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n\n    NamedList response = new SimpleOrderedMap();\n\n    NamedList suggestions = toNamedList(false, result, origQuery, extendedResults);\n    response.add(\"suggestions\", suggestions);\n\n    if (extendedResults) {\n      response.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\n      NamedList collations = new NamedList();\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          SimpleOrderedMap extendedResult = new SimpleOrderedMap();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          collations.add(\"collation\", extendedResult);\n        } else {\n          collations.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n\n      response.add(\"collations\", collations);\n    }\n\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = maxResultsForSuggest(rb);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n\n    SpellCheckMergeData mergeData = new SpellCheckMergeData();\n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT, false)) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n\n    NamedList response = new SimpleOrderedMap();\n\n    NamedList suggestions = toNamedList(false, result, origQuery, extendedResults);\n    response.add(\"suggestions\", suggestions);\n\n    if (extendedResults) {\n      response.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\n      NamedList collations = new NamedList();\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          SimpleOrderedMap extendedResult = new SimpleOrderedMap();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          collations.add(\"collation\", extendedResult);\n        } else {\n          collations.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n\n      response.add(\"collations\", collations);\n    }\n\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = maxResultsForSuggest(rb);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n\n    SpellCheckMergeData mergeData = new SpellCheckMergeData();\n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (ShardParams.getShardsTolerantAsBool(rb.req.getParams())) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          log.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n\n    NamedList response = new SimpleOrderedMap();\n\n    NamedList suggestions = toNamedList(false, result, origQuery, extendedResults);\n    response.add(\"suggestions\", suggestions);\n\n    if (extendedResults) {\n      response.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\n      NamedList collations = new NamedList();\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          SimpleOrderedMap extendedResult = new SimpleOrderedMap();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          collations.add(\"collation\", extendedResult);\n        } else {\n          collations.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n\n      response.add(\"collations\", collations);\n    }\n\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = maxResultsForSuggest(rb);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n\n    SpellCheckMergeData mergeData = new SpellCheckMergeData();\n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (ShardParams.getShardsTolerantAsBool(rb.req.getParams())) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          LOG.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n\n    NamedList response = new SimpleOrderedMap();\n\n    NamedList suggestions = toNamedList(false, result, origQuery, extendedResults);\n    response.add(\"suggestions\", suggestions);\n\n    if (extendedResults) {\n      response.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\n      NamedList collations = new NamedList();\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          SimpleOrderedMap extendedResult = new SimpleOrderedMap();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          collations.add(\"collation\", extendedResult);\n        } else {\n          collations.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n\n      response.add(\"collations\", collations);\n    }\n\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = maxResultsForSuggest(rb);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n\n    SpellCheckMergeData mergeData = new SpellCheckMergeData();\n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (ShardParams.getShardsTolerantAsBool(rb.req.getParams())) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          if (log.isInfoEnabled()) {\n            log.info(\"{} {}\", srsp.getShard(), nl);\n          }\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n\n    NamedList response = new SimpleOrderedMap();\n\n    NamedList suggestions = toNamedList(false, result, origQuery, extendedResults);\n    response.add(\"suggestions\", suggestions);\n\n    if (extendedResults) {\n      response.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\n      NamedList collations = new NamedList();\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          SimpleOrderedMap extendedResult = new SimpleOrderedMap();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          collations.add(\"collation\", extendedResult);\n        } else {\n          collations.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n\n      response.add(\"collations\", collations);\n    }\n\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = maxResultsForSuggest(rb);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n\n    SpellCheckMergeData mergeData = new SpellCheckMergeData();\n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (ShardParams.getShardsTolerantAsBool(rb.req.getParams())) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          log.info(srsp.getShard() + \" \" + nl);\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n\n    NamedList response = new SimpleOrderedMap();\n\n    NamedList suggestions = toNamedList(false, result, origQuery, extendedResults);\n    response.add(\"suggestions\", suggestions);\n\n    if (extendedResults) {\n      response.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\n      NamedList collations = new NamedList();\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          SimpleOrderedMap extendedResult = new SimpleOrderedMap();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          collations.add(\"collation\", extendedResult);\n        } else {\n          collations.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n\n      response.add(\"collations\", collations);\n    }\n\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8582f07e9350eaeb33bf6c4617b8c9895d99c839","date":1591307386,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#finishStage(ResponseBuilder).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = maxResultsForSuggest(rb);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n\n    SpellCheckMergeData mergeData = new SpellCheckMergeData();\n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          @SuppressWarnings({\"rawtypes\"})\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (ShardParams.getShardsTolerantAsBool(rb.req.getParams())) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          if (log.isInfoEnabled()) {\n            log.info(\"{} {}\", srsp.getShard(), nl);\n          }\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList response = new SimpleOrderedMap();\n\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList suggestions = toNamedList(false, result, origQuery, extendedResults);\n    response.add(\"suggestions\", suggestions);\n\n    if (extendedResults) {\n      response.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList collations = new NamedList();\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          @SuppressWarnings({\"rawtypes\"})\n          SimpleOrderedMap extendedResult = new SimpleOrderedMap();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          collations.add(\"collation\", extendedResult);\n        } else {\n          collations.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n\n      response.add(\"collations\", collations);\n    }\n\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"deprecation\"})\n  public void finishStage(ResponseBuilder rb) {\n    SolrParams params = rb.req.getParams();\n    if (!params.getBool(COMPONENT_NAME, false) || rb.stage != ResponseBuilder.STAGE_GET_FIELDS)\n      return;\n\n    boolean extendedResults = params.getBool(SPELLCHECK_EXTENDED_RESULTS, false);\n    boolean collate = params.getBool(SPELLCHECK_COLLATE, false);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    Integer maxResultsForSuggest = maxResultsForSuggest(rb);\n    int count = rb.req.getParams().getInt(SPELLCHECK_COUNT, 1);\n    int numSug = Math.max(count, AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT);\n\n    String origQuery = params.get(SPELLCHECK_Q);\n    if (origQuery == null) {\n      origQuery = rb.getQueryString();\n      if (origQuery == null) {\n        origQuery = params.get(CommonParams.Q);\n      }\n    }\n    \n    long hits = rb.grouping() ? rb.totalHitCount : rb.getNumberDocumentsFound();\n    boolean isCorrectlySpelled = hits > (maxResultsForSuggest==null ? 0 : maxResultsForSuggest);\n\n    SpellCheckMergeData mergeData = new SpellCheckMergeData();\n    if (maxResultsForSuggest==null || !isCorrectlySpelled) {\n      for (ShardRequest sreq : rb.finished) {\n        for (ShardResponse srsp : sreq.responses) {\n          NamedList nl = null;\n          try {\n            nl = (NamedList) srsp.getSolrResponse().getResponse().get(\"spellcheck\");\n          } catch (Exception e) {\n            if (ShardParams.getShardsTolerantAsBool(rb.req.getParams())) {\n              continue; // looks like a shard did not return anything\n            }\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Unable to read spelling info for shard: \" + srsp.getShard(), e);\n          }\n          if (log.isInfoEnabled()) {\n            log.info(\"{} {}\", srsp.getShard(), nl);\n          }\n          if (nl != null) {\n            mergeData.totalNumberShardResponses++;\n            collectShardSuggestions(nl, mergeData);\n            collectShardCollations(mergeData, nl, maxCollationTries);\n          }\n        }\n      }\n    }\n\n    // all shard responses have been collected\n    // create token and get top suggestions\n    SolrSpellChecker checker = getSpellChecker(rb.req.getParams());\n    SpellingResult result = checker.mergeSuggestions(mergeData, numSug, count, extendedResults);\n\n    NamedList response = new SimpleOrderedMap();\n\n    NamedList suggestions = toNamedList(false, result, origQuery, extendedResults);\n    response.add(\"suggestions\", suggestions);\n\n    if (extendedResults) {\n      response.add(\"correctlySpelled\", isCorrectlySpelled);\n    }\n\n    if (collate) {\n      SpellCheckCollation[] sortedCollations = mergeData.collations.values()\n          .toArray(new SpellCheckCollation[mergeData.collations.size()]);\n      Arrays.sort(sortedCollations);\n\n      NamedList collations = new NamedList();\n      int i = 0;\n      while (i < maxCollations && i < sortedCollations.length) {\n        SpellCheckCollation collation = sortedCollations[i];\n        i++;\n        if (collationExtendedResults) {\n          SimpleOrderedMap extendedResult = new SimpleOrderedMap();\n          extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n          extendedResult.add(\"hits\", collation.getHits());\n          extendedResult.add(\"misspellingsAndCorrections\", collation\n              .getMisspellingsAndCorrections());\n          collations.add(\"collation\", extendedResult);\n        } else {\n          collations.add(\"collation\", collation.getCollationQuery());\n        }\n      }\n\n      response.add(\"collations\", collations);\n    }\n\n    rb.rsp.add(\"spellcheck\", response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"51f6eb2e42e0de57b9d737aa322902b2d3029149":["5ba46b57f67b4eb7246bdc86cfdeb15b78306b90"],"862753d1e2f4853f389dcb115747661e7bc0e384":["51f6eb2e42e0de57b9d737aa322902b2d3029149"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["51f6eb2e42e0de57b9d737aa322902b2d3029149","862753d1e2f4853f389dcb115747661e7bc0e384"],"343d2d9477b299075fa3a19a46e654b6c3bf552b":["0d9835c6ddd23dd02eefd5adfc0e5d1e89075fbe"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"9f53e30d1a17e72299f6e7a149cd1ca6d90b554c":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"575e66bd4b2349209027f6801184da7fc3cba13f":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"5ba46b57f67b4eb7246bdc86cfdeb15b78306b90":["343d2d9477b299075fa3a19a46e654b6c3bf552b"],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["575e66bd4b2349209027f6801184da7fc3cba13f"],"541f6605a29362fa8a42f33b69069e7da5178034":["51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5"],"374570062523b2011ca513a2276525ff3ddf222d":["862753d1e2f4853f389dcb115747661e7bc0e384"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["862753d1e2f4853f389dcb115747661e7bc0e384","374570062523b2011ca513a2276525ff3ddf222d"],"0d9835c6ddd23dd02eefd5adfc0e5d1e89075fbe":["9f53e30d1a17e72299f6e7a149cd1ca6d90b554c"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bd22dcd3ba035a1626face7319c94be45ae07172":["374570062523b2011ca513a2276525ff3ddf222d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3599646b4d4c346cf74d334813488b8b337b5bf5":["51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5","541f6605a29362fa8a42f33b69069e7da5178034"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["9f53e30d1a17e72299f6e7a149cd1ca6d90b554c","0d9835c6ddd23dd02eefd5adfc0e5d1e89075fbe"],"51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5":["c26f00b574427b55127e869b935845554afde1fa"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["bd22dcd3ba035a1626face7319c94be45ae07172"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["541f6605a29362fa8a42f33b69069e7da5178034"]},"commit2Childs":{"51f6eb2e42e0de57b9d737aa322902b2d3029149":["862753d1e2f4853f389dcb115747661e7bc0e384","598b5d23aa7c9732bf473c21a9cd309c44599394"],"862753d1e2f4853f389dcb115747661e7bc0e384":["598b5d23aa7c9732bf473c21a9cd309c44599394","374570062523b2011ca513a2276525ff3ddf222d","e9017cf144952056066919f1ebc7897ff9bd71b1"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"343d2d9477b299075fa3a19a46e654b6c3bf552b":["5ba46b57f67b4eb7246bdc86cfdeb15b78306b90"],"c26f00b574427b55127e869b935845554afde1fa":["51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5"],"9f53e30d1a17e72299f6e7a149cd1ca6d90b554c":["0d9835c6ddd23dd02eefd5adfc0e5d1e89075fbe","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"575e66bd4b2349209027f6801184da7fc3cba13f":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"5ba46b57f67b4eb7246bdc86cfdeb15b78306b90":["51f6eb2e42e0de57b9d737aa322902b2d3029149"],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"541f6605a29362fa8a42f33b69069e7da5178034":["3599646b4d4c346cf74d334813488b8b337b5bf5","4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"374570062523b2011ca513a2276525ff3ddf222d":["e9017cf144952056066919f1ebc7897ff9bd71b1","bd22dcd3ba035a1626face7319c94be45ae07172"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"0d9835c6ddd23dd02eefd5adfc0e5d1e89075fbe":["343d2d9477b299075fa3a19a46e654b6c3bf552b","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"bd22dcd3ba035a1626face7319c94be45ae07172":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"3599646b4d4c346cf74d334813488b8b337b5bf5":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"51338b5fe0f5d865f3d3ce9ed83d94ae4733a8c5":["541f6605a29362fa8a42f33b69069e7da5178034","3599646b4d4c346cf74d334813488b8b337b5bf5"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["9f53e30d1a17e72299f6e7a149cd1ca6d90b554c"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["575e66bd4b2349209027f6801184da7fc3cba13f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","e9017cf144952056066919f1ebc7897ff9bd71b1","3599646b4d4c346cf74d334813488b8b337b5bf5","74f45af4339b0daf7a95c820ab88c1aea74fbce0","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}