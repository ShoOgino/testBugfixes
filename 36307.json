{"path":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","commits":[{"id":"b54504c5305a6cc48f59c627c9c8dd727e2a8f0b","date":1491468518,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    String coll = \"movereplicatest_coll\";\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, 2);\n    create.setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    CollectionAdminRequest.MoveReplica moveReplica = new CollectionAdminRequest.MoveReplica(coll, replica.getName(), targetNode);\n    moveReplica.processAsync(\"000\", cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(\"000\");\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(50);\n    }\n    assertTrue(success);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 0);\n    checkNumOfCores(cloudClient, targetNode, 2);\n\n    moveReplica = new CollectionAdminRequest.MoveReplica(coll, shardId, targetNode, replica.getNodeName());\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 1);\n    checkNumOfCores(cloudClient, targetNode, 1);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["76f2f6f3c2e485c3114e415c8253c2e208c7f909","587637d2d2a2c50503511d5b626fdc366b4fd3d4","65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    String coll = \"movereplicatest_coll\";\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, 2);\n    create.setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    CollectionAdminRequest.MoveReplica moveReplica = new CollectionAdminRequest.MoveReplica(coll, replica.getName(), targetNode);\n    moveReplica.processAsync(\"000\", cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(\"000\");\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(50);\n    }\n    assertTrue(success);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 0);\n    checkNumOfCores(cloudClient, targetNode, 2);\n\n    moveReplica = new CollectionAdminRequest.MoveReplica(coll, shardId, targetNode, replica.getNodeName());\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 1);\n    checkNumOfCores(cloudClient, targetNode, 1);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ecb39e783dd104116a9502e8b0ab3df89f35ac19","date":1499167547,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    String coll = \"movereplicatest_coll\";\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    CollectionAdminRequest.MoveReplica moveReplica = new CollectionAdminRequest.MoveReplica(coll, replica.getName(), targetNode);\n    moveReplica.processAsync(\"000\", cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(\"000\");\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 0);\n    assertTrue(\"should be at least one core on target node!\", getNumOfCores(cloudClient, targetNode) > 0);\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    moveReplica = new CollectionAdminRequest.MoveReplica(coll, shardId, targetNode, replica.getNodeName());\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 1);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    String coll = \"movereplicatest_coll\";\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, 2);\n    create.setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    CollectionAdminRequest.MoveReplica moveReplica = new CollectionAdminRequest.MoveReplica(coll, replica.getName(), targetNode);\n    moveReplica.processAsync(\"000\", cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(\"000\");\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(50);\n    }\n    assertTrue(success);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 0);\n    checkNumOfCores(cloudClient, targetNode, 2);\n\n    moveReplica = new CollectionAdminRequest.MoveReplica(coll, shardId, targetNode, replica.getNodeName());\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 1);\n    checkNumOfCores(cloudClient, targetNode, 1);\n  }\n\n","bugFix":null,"bugIntro":["587637d2d2a2c50503511d5b626fdc366b4fd3d4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2ea161f828a3a7a6eb9410a431aecda6d7ab1065","date":1499213384,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    String coll = \"movereplicatest_coll\";\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    CollectionAdminRequest.MoveReplica moveReplica = new CollectionAdminRequest.MoveReplica(coll, replica.getName(), targetNode);\n    moveReplica.processAsync(\"000\", cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(\"000\");\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 0);\n    assertTrue(\"should be at least one core on target node!\", getNumOfCores(cloudClient, targetNode) > 0);\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    moveReplica = new CollectionAdminRequest.MoveReplica(coll, shardId, targetNode, replica.getNodeName());\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 1);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    String coll = \"movereplicatest_coll\";\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, 2);\n    create.setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    CollectionAdminRequest.MoveReplica moveReplica = new CollectionAdminRequest.MoveReplica(coll, replica.getName(), targetNode);\n    moveReplica.processAsync(\"000\", cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(\"000\");\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(50);\n    }\n    assertTrue(success);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 0);\n    checkNumOfCores(cloudClient, targetNode, 2);\n\n    moveReplica = new CollectionAdminRequest.MoveReplica(coll, shardId, targetNode, replica.getNodeName());\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 1);\n    checkNumOfCores(cloudClient, targetNode, 1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"541d16fbfc627e2eeecfb3eb40fe384fa8c75b4e","date":1500089733,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    String coll = \"movereplicatest_coll\";\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.processAsync(\"000\", cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(\"000\");\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 0);\n    assertTrue(\"should be at least one core on target node!\", getNumOfCores(cloudClient, targetNode) > 0);\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 1);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    String coll = \"movereplicatest_coll\";\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    CollectionAdminRequest.MoveReplica moveReplica = new CollectionAdminRequest.MoveReplica(coll, replica.getName(), targetNode);\n    moveReplica.processAsync(\"000\", cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(\"000\");\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 0);\n    assertTrue(\"should be at least one core on target node!\", getNumOfCores(cloudClient, targetNode) > 0);\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    moveReplica = new CollectionAdminRequest.MoveReplica(coll, shardId, targetNode, replica.getNodeName());\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 1);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aaf90fc29510e72665ac7934f34c3d1c25efad64","date":1500354819,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    String coll = \"movereplicatest_coll\";\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.processAsync(\"000\", cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(\"000\");\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 0);\n    assertTrue(\"should be at least one core on target node!\", getNumOfCores(cloudClient, targetNode) > 0);\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 1);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    String coll = \"movereplicatest_coll\";\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    CollectionAdminRequest.MoveReplica moveReplica = new CollectionAdminRequest.MoveReplica(coll, replica.getName(), targetNode);\n    moveReplica.processAsync(\"000\", cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(\"000\");\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 0);\n    assertTrue(\"should be at least one core on target node!\", getNumOfCores(cloudClient, targetNode) > 0);\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    moveReplica = new CollectionAdminRequest.MoveReplica(coll, shardId, targetNode, replica.getNodeName());\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 1);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"587637d2d2a2c50503511d5b626fdc366b4fd3d4","date":1507632212,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    String coll = \"movereplicatest_coll\";\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    Set<CollectionStateWatcher> watchers = new HashSet<>(accessor.getStateWatchers(coll));\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll);\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll);\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.processAsync(\"000\", cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(\"000\");\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    Set<CollectionStateWatcher> newWatchers = new HashSet<>(accessor.getStateWatchers(coll));\n    assertEquals(watchers, newWatchers);\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n    newWatchers = new HashSet<>(accessor.getStateWatchers(coll));\n    assertEquals(watchers, newWatchers);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    String coll = \"movereplicatest_coll\";\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.processAsync(\"000\", cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(\"000\");\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 0);\n    assertTrue(\"should be at least one core on target node!\", getNumOfCores(cloudClient, targetNode) > 0);\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), 1);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n  }\n\n","bugFix":["ecb39e783dd104116a9502e8b0ab3df89f35ac19","b54504c5305a6cc48f59c627c9c8dd727e2a8f0b"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0509730ae61bc3e3cf168e6ea74600163f67a3eb","date":1510654599,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    String coll = \"movereplicatest_coll\";\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    addDocs(coll, 100);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    Set<CollectionStateWatcher> watchers = new HashSet<>(accessor.getStateWatchers(coll));\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll);\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll);\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.processAsync(\"000\", cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(\"000\");\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    Set<CollectionStateWatcher> newWatchers = new HashSet<>(accessor.getStateWatchers(coll));\n    assertEquals(watchers, newWatchers);\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n    newWatchers = new HashSet<>(accessor.getStateWatchers(coll));\n    assertEquals(watchers, newWatchers);\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    String coll = \"movereplicatest_coll\";\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    Set<CollectionStateWatcher> watchers = new HashSet<>(accessor.getStateWatchers(coll));\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll);\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll);\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.processAsync(\"000\", cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(\"000\");\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    Set<CollectionStateWatcher> newWatchers = new HashSet<>(accessor.getStateWatchers(coll));\n    assertEquals(watchers, newWatchers);\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n    newWatchers = new HashSet<>(accessor.getStateWatchers(coll));\n    assertEquals(watchers, newWatchers);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c","date":1512481565,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    String coll = getTestClass().getSimpleName() + \"_coll_\" + inPlaceMove;\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    create.setAutoAddReplicas(false);\n    cloudClient.request(create);\n\n    addDocs(coll, 100);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    Set<CollectionStateWatcher> watchers = new HashSet<>(accessor.getStateWatchers(coll));\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll);\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll);\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    String asyncId = IdUtils.randomId();\n    moveReplica.processAsync(asyncId, cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(asyncId);\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    Set<CollectionStateWatcher> newWatchers = new HashSet<>(accessor.getStateWatchers(coll));\n    assertEquals(watchers, newWatchers);\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n    newWatchers = new HashSet<>(accessor.getStateWatchers(coll));\n    assertEquals(watchers, newWatchers);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    cluster.waitForAllNodes(5000);\n    String coll = \"movereplicatest_coll\";\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    cloudClient.request(create);\n\n    addDocs(coll, 100);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    Set<CollectionStateWatcher> watchers = new HashSet<>(accessor.getStateWatchers(coll));\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll);\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll);\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.processAsync(\"000\", cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(\"000\");\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    Set<CollectionStateWatcher> newWatchers = new HashSet<>(accessor.getStateWatchers(coll));\n    assertEquals(watchers, newWatchers);\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n    newWatchers = new HashSet<>(accessor.getStateWatchers(coll));\n    assertEquals(watchers, newWatchers);\n  }\n\n","bugFix":["b54504c5305a6cc48f59c627c9c8dd727e2a8f0b"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28ba172425e443e0f08a49de6d73586c418d7251","date":1523970991,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    String coll = getTestClass().getSimpleName() + \"_coll_\" + inPlaceMove;\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    create.setAutoAddReplicas(false);\n    cloudClient.request(create);\n\n    addDocs(coll, 100);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll);\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll);\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    String asyncId = IdUtils.randomId();\n    moveReplica.processAsync(asyncId, cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(asyncId);\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    String coll = getTestClass().getSimpleName() + \"_coll_\" + inPlaceMove;\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    create.setAutoAddReplicas(false);\n    cloudClient.request(create);\n\n    addDocs(coll, 100);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    Set<CollectionStateWatcher> watchers = new HashSet<>(accessor.getStateWatchers(coll));\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll);\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll);\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    String asyncId = IdUtils.randomId();\n    moveReplica.processAsync(asyncId, cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(asyncId);\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    Set<CollectionStateWatcher> newWatchers = new HashSet<>(accessor.getStateWatchers(coll));\n    assertEquals(watchers, newWatchers);\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n    newWatchers = new HashSet<>(accessor.getStateWatchers(coll));\n    assertEquals(watchers, newWatchers);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8d35c84fdef07284c122012ca4000d3b7285a66e","date":1545962630,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void test() throws Exception {\n    String coll = getTestClass().getSimpleName() + \"_coll_\" + inPlaceMove;\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    create.setAutoAddReplicas(false);\n    cloudClient.request(create);\n\n    addDocs(coll, 100);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll);\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll);\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    String asyncId = IdUtils.randomId();\n    moveReplica.processAsync(asyncId, cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(asyncId);\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    String coll = getTestClass().getSimpleName() + \"_coll_\" + inPlaceMove;\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    create.setAutoAddReplicas(false);\n    cloudClient.request(create);\n\n    addDocs(coll, 100);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll);\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll);\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    String asyncId = IdUtils.randomId();\n    moveReplica.processAsync(asyncId, cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(asyncId);\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b5c929d2716fa79d443b93a82adb1da5b578ebd8","date":1550428858,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","sourceNew":"  @Test\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void test() throws Exception {\n    String coll = getTestClass().getSimpleName() + \"_coll_\" + inPlaceMove;\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    create.setAutoAddReplicas(false);\n    cloudClient.request(create);\n\n    addDocs(coll, 100);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll);\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll);\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    String asyncId = IdUtils.randomId();\n    moveReplica.processAsync(asyncId, cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(asyncId);\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void test() throws Exception {\n    String coll = getTestClass().getSimpleName() + \"_coll_\" + inPlaceMove;\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    create.setAutoAddReplicas(false);\n    cloudClient.request(create);\n\n    addDocs(coll, 100);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll);\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll);\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    String asyncId = IdUtils.randomId();\n    moveReplica.processAsync(asyncId, cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(asyncId);\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"76f2f6f3c2e485c3114e415c8253c2e208c7f909","date":1551210527,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","sourceNew":"  @Test\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void test() throws Exception {\n    String coll = getTestClass().getSimpleName() + \"_coll_\" + inPlaceMove;\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    create.setAutoAddReplicas(false);\n    cloudClient.request(create);\n\n    addDocs(coll, 100);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll);\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll);\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    String asyncId = IdUtils.randomId();\n    moveReplica.processAsync(asyncId, cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(asyncId);\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertNotSame(rsp.getRequestStatus(), RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","sourceOld":"  @Test\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void test() throws Exception {\n    String coll = getTestClass().getSimpleName() + \"_coll_\" + inPlaceMove;\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    create.setAutoAddReplicas(false);\n    cloudClient.request(create);\n\n    addDocs(coll, 100);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll);\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll);\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    String asyncId = IdUtils.randomId();\n    moveReplica.processAsync(asyncId, cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(asyncId);\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","bugFix":["b54504c5305a6cc48f59c627c9c8dd727e2a8f0b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"accbc347dd28993a84ae51e9e6f01e31a26a7184","date":1551252530,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","sourceNew":"  @Test\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void test() throws Exception {\n    String coll = getTestClass().getSimpleName() + \"_coll_\" + inPlaceMove;\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    create.setAutoAddReplicas(false);\n    cloudClient.request(create);\n\n    addDocs(coll, 100);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll);\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll);\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    String asyncId = IdUtils.randomId();\n    moveReplica.processAsync(asyncId, cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(asyncId);\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertNotSame(rsp.getRequestStatus(), RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","sourceOld":"  @Test\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void test() throws Exception {\n    String coll = getTestClass().getSimpleName() + \"_coll_\" + inPlaceMove;\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    create.setAutoAddReplicas(false);\n    cloudClient.request(create);\n\n    addDocs(coll, 100);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll);\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll);\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    String asyncId = IdUtils.randomId();\n    moveReplica.processAsync(asyncId, cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(asyncId);\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertFalse(rsp.getRequestStatus() == RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"13566d7393ca95d9897baf67f5e9c87dca82a253","date":1571390317,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","sourceNew":"  @Test\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void test() throws Exception {\n    String coll = getTestClass().getSimpleName() + \"_coll_\" + inPlaceMove;\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    // random create tlog or pull type replicas with nrt\n    boolean isTlog = random().nextBoolean();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, 1, isTlog ? 1 : 0, !isTlog ? 1 : 0);\n    create.setMaxShardsPerNode(2);\n    create.setAutoAddReplicas(false);\n    cloudClient.request(create);\n\n    addDocs(coll, 100);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll, replica.getType().name());\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll, replica.getType().name());\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    String asyncId = IdUtils.randomId();\n    moveReplica.processAsync(asyncId, cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(asyncId);\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertNotSame(rsp.getRequestStatus(), RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll, replica.getType().name()));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll, replica.getType().name()));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","sourceOld":"  @Test\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void test() throws Exception {\n    String coll = getTestClass().getSimpleName() + \"_coll_\" + inPlaceMove;\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, REPLICATION);\n    create.setMaxShardsPerNode(2);\n    create.setAutoAddReplicas(false);\n    cloudClient.request(create);\n\n    addDocs(coll, 100);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll);\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll);\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    String asyncId = IdUtils.randomId();\n    moveReplica.processAsync(asyncId, cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(asyncId);\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertNotSame(rsp.getRequestStatus(), RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","sourceNew":"  @Test\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void test() throws Exception {\n    String coll = getTestClass().getSimpleName() + \"_coll_\" + inPlaceMove;\n    if (log.isInfoEnabled()) {\n      log.info(\"total_jettys: {}\", cluster.getJettySolrRunners().size());\n    }\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    // random create tlog or pull type replicas with nrt\n    boolean isTlog = random().nextBoolean();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, 1, isTlog ? 1 : 0, !isTlog ? 1 : 0);\n    create.setMaxShardsPerNode(2);\n    create.setAutoAddReplicas(false);\n    cloudClient.request(create);\n\n    addDocs(coll, 100);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll, replica.getType().name());\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll, replica.getType().name());\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    String asyncId = IdUtils.randomId();\n    moveReplica.processAsync(asyncId, cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(asyncId);\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertNotSame(rsp.getRequestStatus(), RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll, replica.getType().name()));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll, replica.getType().name()));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### {}\", collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: {}\", r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive={}, hasLeaders={}\", allActive, hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### {}\", collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: {}\", r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","sourceOld":"  @Test\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void test() throws Exception {\n    String coll = getTestClass().getSimpleName() + \"_coll_\" + inPlaceMove;\n    log.info(\"total_jettys: \" + cluster.getJettySolrRunners().size());\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    // random create tlog or pull type replicas with nrt\n    boolean isTlog = random().nextBoolean();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, 1, isTlog ? 1 : 0, !isTlog ? 1 : 0);\n    create.setMaxShardsPerNode(2);\n    create.setAutoAddReplicas(false);\n    cloudClient.request(create);\n\n    addDocs(coll, 100);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll, replica.getType().name());\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll, replica.getType().name());\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    String asyncId = IdUtils.randomId();\n    moveReplica.processAsync(asyncId, cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(asyncId);\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertNotSame(rsp.getRequestStatus(), RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll, replica.getType().name()));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll, replica.getType().name()));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive=\" + allActive + \", hasLeaders=\" + hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### \" + collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: \" + r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","sourceNew":"  @Test\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void test() throws Exception {\n    String coll = getTestClass().getSimpleName() + \"_coll_\" + inPlaceMove;\n    if (log.isInfoEnabled()) {\n      log.info(\"total_jettys: {}\", cluster.getJettySolrRunners().size());\n    }\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    // random create tlog or pull type replicas with nrt\n    boolean isTlog = random().nextBoolean();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, 1, isTlog ? 1 : 0, !isTlog ? 1 : 0);\n    create.setAutoAddReplicas(false);\n    cloudClient.request(create);\n\n    addDocs(coll, 100);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll, replica.getType().name());\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll, replica.getType().name());\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    String asyncId = IdUtils.randomId();\n    moveReplica.processAsync(asyncId, cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(asyncId);\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertNotSame(rsp.getRequestStatus(), RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll, replica.getType().name()));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll, replica.getType().name()));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### {}\", collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: {}\", r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive={}, hasLeaders={}\", allActive, hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### {}\", collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: {}\", r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","sourceOld":"  @Test\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void test() throws Exception {\n    String coll = getTestClass().getSimpleName() + \"_coll_\" + inPlaceMove;\n    if (log.isInfoEnabled()) {\n      log.info(\"total_jettys: {}\", cluster.getJettySolrRunners().size());\n    }\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    // random create tlog or pull type replicas with nrt\n    boolean isTlog = random().nextBoolean();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, 1, isTlog ? 1 : 0, !isTlog ? 1 : 0);\n    create.setMaxShardsPerNode(2);\n    create.setAutoAddReplicas(false);\n    cloudClient.request(create);\n\n    addDocs(coll, 100);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll, replica.getType().name());\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll, replica.getType().name());\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    String asyncId = IdUtils.randomId();\n    moveReplica.processAsync(asyncId, cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(asyncId);\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertNotSame(rsp.getRequestStatus(), RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll, replica.getType().name()));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll, replica.getType().name()));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### {}\", collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: {}\", r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive={}, hasLeaders={}\", allActive, hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### {}\", collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: {}\", r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/MoveReplicaTest#test().mjava","sourceNew":"  @Test\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void test() throws Exception {\n    String coll = getTestClass().getSimpleName() + \"_coll_\" + inPlaceMove;\n    if (log.isInfoEnabled()) {\n      log.info(\"total_jettys: {}\", cluster.getJettySolrRunners().size());\n    }\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    // random create tlog or pull type replicas with nrt\n    boolean isTlog = random().nextBoolean();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, 1, isTlog ? 1 : 0, !isTlog ? 1 : 0);\n    cloudClient.request(create);\n\n    addDocs(coll, 100);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll, replica.getType().name());\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll, replica.getType().name());\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    String asyncId = IdUtils.randomId();\n    moveReplica.processAsync(asyncId, cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(asyncId);\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertNotSame(rsp.getRequestStatus(), RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll, replica.getType().name()));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll, replica.getType().name()));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### {}\", collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: {}\", r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive={}, hasLeaders={}\", allActive, hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### {}\", collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: {}\", r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","sourceOld":"  @Test\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void test() throws Exception {\n    String coll = getTestClass().getSimpleName() + \"_coll_\" + inPlaceMove;\n    if (log.isInfoEnabled()) {\n      log.info(\"total_jettys: {}\", cluster.getJettySolrRunners().size());\n    }\n    int REPLICATION = 2;\n\n    CloudSolrClient cloudClient = cluster.getSolrClient();\n\n    // random create tlog or pull type replicas with nrt\n    boolean isTlog = random().nextBoolean();\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(coll, \"conf1\", 2, 1, isTlog ? 1 : 0, !isTlog ? 1 : 0);\n    create.setAutoAddReplicas(false);\n    cloudClient.request(create);\n\n    addDocs(coll, 100);\n\n    Replica replica = getRandomReplica(coll, cloudClient);\n    Set<String> liveNodes = cloudClient.getZkStateReader().getClusterState().getLiveNodes();\n    ArrayList<String> l = new ArrayList<>(liveNodes);\n    Collections.shuffle(l, random());\n    String targetNode = null;\n    for (String node : liveNodes) {\n      if (!replica.getNodeName().equals(node)) {\n        targetNode = node;\n        break;\n      }\n    }\n    assertNotNull(targetNode);\n    String shardId = null;\n    for (Slice slice : cloudClient.getZkStateReader().getClusterState().getCollection(coll).getSlices()) {\n      if (slice.getReplicas().contains(replica)) {\n        shardId = slice.getName();\n      }\n    }\n\n    int sourceNumCores = getNumOfCores(cloudClient, replica.getNodeName(), coll, replica.getType().name());\n    int targetNumCores = getNumOfCores(cloudClient, targetNode, coll, replica.getType().name());\n\n    CollectionAdminRequest.MoveReplica moveReplica = createMoveReplicaRequest(coll, replica, targetNode);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    String asyncId = IdUtils.randomId();\n    moveReplica.processAsync(asyncId, cloudClient);\n    CollectionAdminRequest.RequestStatus requestStatus = CollectionAdminRequest.requestStatus(asyncId);\n    // wait for async request success\n    boolean success = false;\n    for (int i = 0; i < 200; i++) {\n      CollectionAdminRequest.RequestStatusResponse rsp = requestStatus.process(cloudClient);\n      if (rsp.getRequestStatus() == RequestStatusState.COMPLETED) {\n        success = true;\n        break;\n      }\n      assertNotSame(rsp.getRequestStatus(), RequestStatusState.FAILED);\n      Thread.sleep(500);\n    }\n    assertTrue(success);\n    assertEquals(\"should be one less core on the source node!\", sourceNumCores - 1, getNumOfCores(cloudClient, replica.getNodeName(), coll, replica.getType().name()));\n    assertEquals(\"should be one more core on target node!\", targetNumCores + 1, getNumOfCores(cloudClient, targetNode, coll, replica.getType().name()));\n    // wait for recovery\n    boolean recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### {}\", collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(targetNode)) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(targetNode))) {\n            log.info(\"Not active: {}\", r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        // check the number of active replicas\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        log.info(\"--- waiting, allActive={}, hasLeaders={}\", allActive, hasLeaders);\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n\n    moveReplica = createMoveReplicaRequest(coll, replica, targetNode, shardId);\n    moveReplica.setInPlaceMove(inPlaceMove);\n    moveReplica.process(cloudClient);\n    checkNumOfCores(cloudClient, replica.getNodeName(), coll, sourceNumCores);\n    // wait for recovery\n    recovered = false;\n    for (int i = 0; i < 300; i++) {\n      DocCollection collState = getCollectionState(coll);\n      log.debug(\"###### {}\", collState);\n      Collection<Replica> replicas = collState.getSlice(shardId).getReplicas();\n      boolean allActive = true;\n      boolean hasLeaders = true;\n      if (replicas != null && !replicas.isEmpty()) {\n        for (Replica r : replicas) {\n          if (!r.getNodeName().equals(replica.getNodeName())) {\n            continue;\n          }\n          if (!r.isActive(Collections.singleton(replica.getNodeName()))) {\n            log.info(\"Not active yet: {}\", r);\n            allActive = false;\n          }\n        }\n      } else {\n        allActive = false;\n      }\n      for (Slice slice : collState.getSlices()) {\n        if (slice.getLeader() == null) {\n          hasLeaders = false;\n        }\n      }\n      if (allActive && hasLeaders) {\n        assertEquals(\"total number of replicas\", REPLICATION, replicas.size());\n        recovered = true;\n        break;\n      } else {\n        Thread.sleep(1000);\n      }\n    }\n    assertTrue(\"replica never fully recovered\", recovered);\n\n    assertEquals(100, cluster.getSolrClient().query(coll, new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b54504c5305a6cc48f59c627c9c8dd727e2a8f0b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0509730ae61bc3e3cf168e6ea74600163f67a3eb":["587637d2d2a2c50503511d5b626fdc366b4fd3d4"],"3f504512a03d978990cbff30db0522b354e846db":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"541d16fbfc627e2eeecfb3eb40fe384fa8c75b4e":["ecb39e783dd104116a9502e8b0ab3df89f35ac19"],"b5c929d2716fa79d443b93a82adb1da5b578ebd8":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["13566d7393ca95d9897baf67f5e9c87dca82a253"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["28ba172425e443e0f08a49de6d73586c418d7251"],"ecb39e783dd104116a9502e8b0ab3df89f35ac19":["b54504c5305a6cc48f59c627c9c8dd727e2a8f0b"],"13566d7393ca95d9897baf67f5e9c87dca82a253":["accbc347dd28993a84ae51e9e6f01e31a26a7184"],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","ecb39e783dd104116a9502e8b0ab3df89f35ac19"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":["2ea161f828a3a7a6eb9410a431aecda6d7ab1065","541d16fbfc627e2eeecfb3eb40fe384fa8c75b4e"],"76f2f6f3c2e485c3114e415c8253c2e208c7f909":["b5c929d2716fa79d443b93a82adb1da5b578ebd8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"587637d2d2a2c50503511d5b626fdc366b4fd3d4":["541d16fbfc627e2eeecfb3eb40fe384fa8c75b4e"],"28ba172425e443e0f08a49de6d73586c418d7251":["65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c"],"65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c":["0509730ae61bc3e3cf168e6ea74600163f67a3eb"],"accbc347dd28993a84ae51e9e6f01e31a26a7184":["b5c929d2716fa79d443b93a82adb1da5b578ebd8","76f2f6f3c2e485c3114e415c8253c2e208c7f909"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"b54504c5305a6cc48f59c627c9c8dd727e2a8f0b":["ecb39e783dd104116a9502e8b0ab3df89f35ac19"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["2ea161f828a3a7a6eb9410a431aecda6d7ab1065"],"0509730ae61bc3e3cf168e6ea74600163f67a3eb":["65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"541d16fbfc627e2eeecfb3eb40fe384fa8c75b4e":["aaf90fc29510e72665ac7934f34c3d1c25efad64","587637d2d2a2c50503511d5b626fdc366b4fd3d4"],"b5c929d2716fa79d443b93a82adb1da5b578ebd8":["76f2f6f3c2e485c3114e415c8253c2e208c7f909","accbc347dd28993a84ae51e9e6f01e31a26a7184"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["3f504512a03d978990cbff30db0522b354e846db"],"ecb39e783dd104116a9502e8b0ab3df89f35ac19":["541d16fbfc627e2eeecfb3eb40fe384fa8c75b4e","2ea161f828a3a7a6eb9410a431aecda6d7ab1065"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["b5c929d2716fa79d443b93a82adb1da5b578ebd8"],"13566d7393ca95d9897baf67f5e9c87dca82a253":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":["aaf90fc29510e72665ac7934f34c3d1c25efad64"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":[],"76f2f6f3c2e485c3114e415c8253c2e208c7f909":["accbc347dd28993a84ae51e9e6f01e31a26a7184"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b54504c5305a6cc48f59c627c9c8dd727e2a8f0b","54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"587637d2d2a2c50503511d5b626fdc366b4fd3d4":["0509730ae61bc3e3cf168e6ea74600163f67a3eb"],"28ba172425e443e0f08a49de6d73586c418d7251":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"accbc347dd28993a84ae51e9e6f01e31a26a7184":["13566d7393ca95d9897baf67f5e9c87dca82a253"],"65a78c7aebe6b174f02f7c7a1b4e8647ed5ed73c":["28ba172425e443e0f08a49de6d73586c418d7251"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aaf90fc29510e72665ac7934f34c3d1c25efad64","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}