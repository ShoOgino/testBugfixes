{"path":"lucene/src/java/org/apache/lucene/index/IndexWriter#addFlushedSegment(SegmentInfo,BitVector).mjava","commits":[{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":1,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#addFlushedSegment(SegmentInfo,BitVector).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#addFlushedSegment(SegmentInfo).mjava","sourceNew":"  void addFlushedSegment(SegmentInfo newSegment, BitVector deletedDocs) throws IOException {\n    assert newSegment != null;\n\n    setDiagnostics(newSegment, \"flush\");\n\n    if (useCompoundFile(newSegment)) {\n      String compoundFileName = IndexFileNames.segmentFileName(newSegment.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION);\n      message(\"creating compound file \" + compoundFileName);\n      // Now build compound file\n      boolean success = false;\n      try {\n        CompoundFileWriter cfsWriter = new CompoundFileWriter(directory, compoundFileName);\n        for(String fileName : newSegment.files()) {\n          cfsWriter.addFile(fileName);\n        }\n\n        // Perform the merge\n        cfsWriter.close();\n        synchronized(this) {\n          deleter.deleteNewFiles(newSegment.files());\n        }\n\n        newSegment.setUseCompoundFile(true);\n\n        // Must write deleted docs after the CFS so we don't\n        // slurp the del file into CFS:\n        if (deletedDocs != null) {\n          final int delCount = deletedDocs.count();\n          assert delCount > 0;\n          newSegment.setDelCount(delCount);\n          newSegment.advanceDelGen();\n          final String delFileName = newSegment.getDelFileName();\n          if (infoStream != null) {\n            message(\"flush: write \" + delCount + \" deletes to \" + delFileName);\n          }\n          boolean success2 = false;\n          try {\n            // TODO: in the NRT case it'd be better to hand\n            // this del vector over to the\n            // shortly-to-be-opened SegmentReader and let it\n            // carry the changes; there's no reason to use\n            // filesystem as intermediary here.\n            deletedDocs.write(directory, delFileName);\n            success2 = true;\n          } finally {\n            if (!success2) {\n              try {\n                directory.deleteFile(delFileName);\n              } catch (Throwable t) {\n                // suppress this so we keep throwing the\n                // original exception\n              }\n            }\n          }\n        }\n\n        success = true;\n      } finally {\n        if (!success) {\n          if (infoStream != null) {\n            message(\"hit exception \" +\n                \"reating compound file for newly flushed segment \" + newSegment.name);\n          }\n\n          synchronized(this) {\n            deleter.refresh(newSegment.name);\n          }\n        }\n      }\n\n\n    }\n\n    synchronized(this) {\n      segmentInfos.add(newSegment);\n      checkpoint();\n    }\n  }\n\n","sourceOld":"  void addFlushedSegment(SegmentInfo newSegment) throws IOException {\n    assert newSegment != null;\n\n    setDiagnostics(newSegment, \"flush\");\n\n    if (useCompoundFile(newSegment)) {\n      String compoundFileName = IndexFileNames.segmentFileName(newSegment.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION);\n      message(\"creating compound file \" + compoundFileName);\n      // Now build compound file\n      boolean success = false;\n      try {\n        CompoundFileWriter cfsWriter = new CompoundFileWriter(directory, compoundFileName);\n        for(String fileName : newSegment.files()) {\n          cfsWriter.addFile(fileName);\n        }\n\n        // Perform the merge\n        cfsWriter.close();\n        synchronized(this) {\n          deleter.deleteNewFiles(newSegment.files());\n        }\n\n        newSegment.setUseCompoundFile(true);\n\n        success = true;\n      } finally {\n        if (!success) {\n          if (infoStream != null) {\n            message(\"hit exception \" +\n                \"reating compound file for newly flushed segment \" + newSegment.name);\n          }\n\n          synchronized(this) {\n            deleter.refresh(newSegment.name);\n          }\n        }\n      }\n\n\n    }\n\n    synchronized(this) {\n      segmentInfos.add(newSegment);\n      checkpoint();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd79381ea87492f240d7d50a92fd5365e95588fb","date":1298446142,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#addFlushedSegment(SegmentInfo,BitVector).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#addFlushedSegment(SegmentInfo,BitVector).mjava","sourceNew":"  void addFlushedSegment(SegmentInfo newSegment, BitVector deletedDocs) throws IOException {\n    assert newSegment != null;\n\n    setDiagnostics(newSegment, \"flush\");\n\n    boolean success = false;\n    try {\n      if (useCompoundFile(newSegment)) {\n        String compoundFileName = IndexFileNames.segmentFileName(newSegment.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION);\n        message(\"creating compound file \" + compoundFileName);\n      // Now build compound file\n        CompoundFileWriter cfsWriter = new CompoundFileWriter(directory, compoundFileName);\n        for(String fileName : newSegment.files()) {\n          cfsWriter.addFile(fileName);\n        }\n\n        // Perform the merge\n        cfsWriter.close();\n        synchronized(this) {\n          deleter.deleteNewFiles(newSegment.files());\n        }\n\n        newSegment.setUseCompoundFile(true);\n      }\n\n      // Must write deleted docs after the CFS so we don't\n      // slurp the del file into CFS:\n      if (deletedDocs != null) {\n        final int delCount = deletedDocs.count();\n        assert delCount > 0;\n        newSegment.setDelCount(delCount);\n        newSegment.advanceDelGen();\n        final String delFileName = newSegment.getDelFileName();\n        if (infoStream != null) {\n          message(\"flush: write \" + delCount + \" deletes to \" + delFileName);\n        }\n        boolean success2 = false;\n        try {\n          // TODO: in the NRT case it'd be better to hand\n          // this del vector over to the\n          // shortly-to-be-opened SegmentReader and let it\n          // carry the changes; there's no reason to use\n          // filesystem as intermediary here.\n          deletedDocs.write(directory, delFileName);\n          success2 = true;\n        } finally {\n          if (!success2) {\n            try {\n              directory.deleteFile(delFileName);\n            } catch (Throwable t) {\n              // suppress this so we keep throwing the\n              // original exception\n            }\n          }\n        }\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"hit exception \" +\n              \"reating compound file for newly flushed segment \" + newSegment.name);\n        }\n\n        synchronized(this) {\n          deleter.refresh(newSegment.name);\n        }\n      }\n    }\n\n\n    synchronized(this) {\n      segmentInfos.add(newSegment);\n      checkpoint();\n    }\n  }\n\n","sourceOld":"  void addFlushedSegment(SegmentInfo newSegment, BitVector deletedDocs) throws IOException {\n    assert newSegment != null;\n\n    setDiagnostics(newSegment, \"flush\");\n\n    if (useCompoundFile(newSegment)) {\n      String compoundFileName = IndexFileNames.segmentFileName(newSegment.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION);\n      message(\"creating compound file \" + compoundFileName);\n      // Now build compound file\n      boolean success = false;\n      try {\n        CompoundFileWriter cfsWriter = new CompoundFileWriter(directory, compoundFileName);\n        for(String fileName : newSegment.files()) {\n          cfsWriter.addFile(fileName);\n        }\n\n        // Perform the merge\n        cfsWriter.close();\n        synchronized(this) {\n          deleter.deleteNewFiles(newSegment.files());\n        }\n\n        newSegment.setUseCompoundFile(true);\n\n        // Must write deleted docs after the CFS so we don't\n        // slurp the del file into CFS:\n        if (deletedDocs != null) {\n          final int delCount = deletedDocs.count();\n          assert delCount > 0;\n          newSegment.setDelCount(delCount);\n          newSegment.advanceDelGen();\n          final String delFileName = newSegment.getDelFileName();\n          if (infoStream != null) {\n            message(\"flush: write \" + delCount + \" deletes to \" + delFileName);\n          }\n          boolean success2 = false;\n          try {\n            // TODO: in the NRT case it'd be better to hand\n            // this del vector over to the\n            // shortly-to-be-opened SegmentReader and let it\n            // carry the changes; there's no reason to use\n            // filesystem as intermediary here.\n            deletedDocs.write(directory, delFileName);\n            success2 = true;\n          } finally {\n            if (!success2) {\n              try {\n                directory.deleteFile(delFileName);\n              } catch (Throwable t) {\n                // suppress this so we keep throwing the\n                // original exception\n              }\n            }\n          }\n        }\n\n        success = true;\n      } finally {\n        if (!success) {\n          if (infoStream != null) {\n            message(\"hit exception \" +\n                \"reating compound file for newly flushed segment \" + newSegment.name);\n          }\n\n          synchronized(this) {\n            deleter.refresh(newSegment.name);\n          }\n        }\n      }\n\n\n    }\n\n    synchronized(this) {\n      segmentInfos.add(newSegment);\n      checkpoint();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf","date":1298618128,"type":5,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#addFlushedSegment(FlushedSegment).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#addFlushedSegment(SegmentInfo,BitVector).mjava","sourceNew":"  void addFlushedSegment(FlushedSegment flushedSegment) throws IOException {\n    assert flushedSegment != null;\n\n    SegmentInfo newSegment = flushedSegment.segmentInfo;\n\n    setDiagnostics(newSegment, \"flush\");\n\n    boolean success = false;\n    try {\n      if (useCompoundFile(newSegment)) {\n        String compoundFileName = IndexFileNames.segmentFileName(newSegment.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION);\n        message(\"creating compound file \" + compoundFileName);\n      // Now build compound file\n        CompoundFileWriter cfsWriter = new CompoundFileWriter(directory, compoundFileName);\n        for(String fileName : newSegment.files()) {\n          cfsWriter.addFile(fileName);\n        }\n\n        // Perform the merge\n        cfsWriter.close();\n        synchronized(this) {\n          deleter.deleteNewFiles(newSegment.files());\n        }\n\n        newSegment.setUseCompoundFile(true);\n      }\n\n      // Must write deleted docs after the CFS so we don't\n      // slurp the del file into CFS:\n      if (flushedSegment.deletedDocuments != null) {\n        final int delCount = flushedSegment.deletedDocuments.count();\n        assert delCount > 0;\n        newSegment.setDelCount(delCount);\n        newSegment.advanceDelGen();\n        final String delFileName = newSegment.getDelFileName();\n        if (infoStream != null) {\n          message(\"flush: write \" + delCount + \" deletes to \" + delFileName);\n        }\n        boolean success2 = false;\n        try {\n          // TODO: in the NRT case it'd be better to hand\n          // this del vector over to the\n          // shortly-to-be-opened SegmentReader and let it\n          // carry the changes; there's no reason to use\n          // filesystem as intermediary here.\n          flushedSegment.deletedDocuments.write(directory, delFileName);\n          success2 = true;\n        } finally {\n          if (!success2) {\n            try {\n              directory.deleteFile(delFileName);\n            } catch (Throwable t) {\n              // suppress this so we keep throwing the\n              // original exception\n            }\n          }\n        }\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"hit exception \" +\n              \"reating compound file for newly flushed segment \" + newSegment.name);\n        }\n\n        synchronized(this) {\n          deleter.refresh(newSegment.name);\n        }\n      }\n    }\n\n\n    synchronized(this) {\n      segmentInfos.add(newSegment);\n      checkpoint();\n    }\n  }\n\n","sourceOld":"  void addFlushedSegment(SegmentInfo newSegment, BitVector deletedDocs) throws IOException {\n    assert newSegment != null;\n\n    setDiagnostics(newSegment, \"flush\");\n\n    boolean success = false;\n    try {\n      if (useCompoundFile(newSegment)) {\n        String compoundFileName = IndexFileNames.segmentFileName(newSegment.name, \"\", IndexFileNames.COMPOUND_FILE_EXTENSION);\n        message(\"creating compound file \" + compoundFileName);\n      // Now build compound file\n        CompoundFileWriter cfsWriter = new CompoundFileWriter(directory, compoundFileName);\n        for(String fileName : newSegment.files()) {\n          cfsWriter.addFile(fileName);\n        }\n\n        // Perform the merge\n        cfsWriter.close();\n        synchronized(this) {\n          deleter.deleteNewFiles(newSegment.files());\n        }\n\n        newSegment.setUseCompoundFile(true);\n      }\n\n      // Must write deleted docs after the CFS so we don't\n      // slurp the del file into CFS:\n      if (deletedDocs != null) {\n        final int delCount = deletedDocs.count();\n        assert delCount > 0;\n        newSegment.setDelCount(delCount);\n        newSegment.advanceDelGen();\n        final String delFileName = newSegment.getDelFileName();\n        if (infoStream != null) {\n          message(\"flush: write \" + delCount + \" deletes to \" + delFileName);\n        }\n        boolean success2 = false;\n        try {\n          // TODO: in the NRT case it'd be better to hand\n          // this del vector over to the\n          // shortly-to-be-opened SegmentReader and let it\n          // carry the changes; there's no reason to use\n          // filesystem as intermediary here.\n          deletedDocs.write(directory, delFileName);\n          success2 = true;\n        } finally {\n          if (!success2) {\n            try {\n              directory.deleteFile(delFileName);\n            } catch (Throwable t) {\n              // suppress this so we keep throwing the\n              // original exception\n            }\n          }\n        }\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"hit exception \" +\n              \"reating compound file for newly flushed segment \" + newSegment.name);\n        }\n\n        synchronized(this) {\n          deleter.refresh(newSegment.name);\n        }\n      }\n    }\n\n\n    synchronized(this) {\n      segmentInfos.add(newSegment);\n      checkpoint();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dd79381ea87492f240d7d50a92fd5365e95588fb":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf":["dd79381ea87492f240d7d50a92fd5365e95588fb"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"dd79381ea87492f240d7d50a92fd5365e95588fb":["bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf"],"bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf":[],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["dd79381ea87492f240d7d50a92fd5365e95588fb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["bfaa69f5e3b29a90ec41762bfbfa166a9e52eccf","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}