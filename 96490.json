{"path":"lucene/misc/src/test/org/apache/lucene/index/sorter/SorterTestBase#testDocsAndPositionsEnum().mjava","commits":[{"id":"cb767289784b682dea51f9e6d7222add811edb77","date":1362902138,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/index/sorter/SorterTestBase#testDocsAndPositionsEnum().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testDocsAndPositionsEnum() throws Exception {\n    Term term = new Term(DOC_POSITIONS_FIELD, DOC_POSITIONS_TERM);\n    DocsAndPositionsEnum sortedPositions = reader.termPositionsEnum(term);\n    int doc;\n    \n    // test nextDoc()\n    while ((doc = sortedPositions.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        if (!doesntSupportOffsets.contains(_TestUtil.getPostingsFormat(DOC_POSITIONS_FIELD))) {\n          assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n          assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        }\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n    \n    // test advance()\n    sortedPositions = reader.termPositionsEnum(term);\n    doc = 0;\n    while ((doc = sortedPositions.advance(doc)) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        if (!doesntSupportOffsets.contains(_TestUtil.getPostingsFormat(DOC_POSITIONS_FIELD))) {\n          assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n          assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        }\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["07c6861cb029cd251d930aa4c4578c8ca21aa957"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a260e1fefced66a58d52044266f9fa20d81ae74b","date":1363613778,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/index/sorter/SorterTestBase#testDocsAndPositionsEnum().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/index/sorter/SorterTestBase#testDocsAndPositionsEnum().mjava","sourceNew":"  @Test\n  public void testDocsAndPositionsEnum() throws Exception {\n    TermsEnum termsEnum = reader.terms(DOC_POSITIONS_FIELD).iterator(null);\n    assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(DOC_POSITIONS_TERM)));\n    DocsAndPositionsEnum sortedPositions = termsEnum.docsAndPositions(null, null);\n    int doc;\n    \n    // test nextDoc()\n    while ((doc = sortedPositions.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        if (!doesntSupportOffsets.contains(_TestUtil.getPostingsFormat(DOC_POSITIONS_FIELD))) {\n          assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n          assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        }\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n    \n    // test advance()\n    final DocsAndPositionsEnum reuse = sortedPositions;\n    sortedPositions = termsEnum.docsAndPositions(null, reuse);\n    if (sortedPositions instanceof SortingDocsAndPositionsEnum) {\n      assertTrue(((SortingDocsAndPositionsEnum) sortedPositions).reused(reuse)); // make sure reuse worked\n    }\n    doc = 0;\n    while ((doc = sortedPositions.advance(doc)) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        if (!doesntSupportOffsets.contains(_TestUtil.getPostingsFormat(DOC_POSITIONS_FIELD))) {\n          assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n          assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        }\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testDocsAndPositionsEnum() throws Exception {\n    Term term = new Term(DOC_POSITIONS_FIELD, DOC_POSITIONS_TERM);\n    DocsAndPositionsEnum sortedPositions = reader.termPositionsEnum(term);\n    int doc;\n    \n    // test nextDoc()\n    while ((doc = sortedPositions.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        if (!doesntSupportOffsets.contains(_TestUtil.getPostingsFormat(DOC_POSITIONS_FIELD))) {\n          assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n          assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        }\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n    \n    // test advance()\n    sortedPositions = reader.termPositionsEnum(term);\n    doc = 0;\n    while ((doc = sortedPositions.advance(doc)) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        if (!doesntSupportOffsets.contains(_TestUtil.getPostingsFormat(DOC_POSITIONS_FIELD))) {\n          assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n          assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        }\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"07c6861cb029cd251d930aa4c4578c8ca21aa957","date":1364984125,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/index/sorter/SorterTestBase#testDocsAndPositionsEnum().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/index/sorter/SorterTestBase#testDocsAndPositionsEnum().mjava","sourceNew":"  @Test\n  public void testDocsAndPositionsEnum() throws Exception {\n    TermsEnum termsEnum = reader.terms(DOC_POSITIONS_FIELD).iterator(null);\n    assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(DOC_POSITIONS_TERM)));\n    DocsAndPositionsEnum sortedPositions = termsEnum.docsAndPositions(null, null);\n    int doc;\n    \n    // test nextDoc()\n    while ((doc = sortedPositions.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        if (!doesntSupportOffsets.contains(_TestUtil.getPostingsFormat(DOC_POSITIONS_FIELD))) {\n          assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n          assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        }\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n    \n    // test advance()\n    final DocsAndPositionsEnum reuse = sortedPositions;\n    sortedPositions = termsEnum.docsAndPositions(null, reuse);\n    if (sortedPositions instanceof SortingDocsAndPositionsEnum) {\n      assertTrue(((SortingDocsAndPositionsEnum) sortedPositions).reused(reuse)); // make sure reuse worked\n    }\n    doc = 0;\n    while ((doc = sortedPositions.advance(doc + _TestUtil.nextInt(random(), 1, 5))) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        if (!doesntSupportOffsets.contains(_TestUtil.getPostingsFormat(DOC_POSITIONS_FIELD))) {\n          assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n          assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        }\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testDocsAndPositionsEnum() throws Exception {\n    TermsEnum termsEnum = reader.terms(DOC_POSITIONS_FIELD).iterator(null);\n    assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(DOC_POSITIONS_TERM)));\n    DocsAndPositionsEnum sortedPositions = termsEnum.docsAndPositions(null, null);\n    int doc;\n    \n    // test nextDoc()\n    while ((doc = sortedPositions.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        if (!doesntSupportOffsets.contains(_TestUtil.getPostingsFormat(DOC_POSITIONS_FIELD))) {\n          assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n          assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        }\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n    \n    // test advance()\n    final DocsAndPositionsEnum reuse = sortedPositions;\n    sortedPositions = termsEnum.docsAndPositions(null, reuse);\n    if (sortedPositions instanceof SortingDocsAndPositionsEnum) {\n      assertTrue(((SortingDocsAndPositionsEnum) sortedPositions).reused(reuse)); // make sure reuse worked\n    }\n    doc = 0;\n    while ((doc = sortedPositions.advance(doc)) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        if (!doesntSupportOffsets.contains(_TestUtil.getPostingsFormat(DOC_POSITIONS_FIELD))) {\n          assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n          assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        }\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n  }\n\n","bugFix":["cb767289784b682dea51f9e6d7222add811edb77"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/index/sorter/SorterTestBase#testDocsAndPositionsEnum().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/index/sorter/SorterTestBase#testDocsAndPositionsEnum().mjava","sourceNew":"  @Test\n  public void testDocsAndPositionsEnum() throws Exception {\n    TermsEnum termsEnum = reader.terms(DOC_POSITIONS_FIELD).iterator(null);\n    assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(DOC_POSITIONS_TERM)));\n    DocsAndPositionsEnum sortedPositions = termsEnum.docsAndPositions(null, null);\n    int doc;\n    \n    // test nextDoc()\n    while ((doc = sortedPositions.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        if (!doesntSupportOffsets.contains(TestUtil.getPostingsFormat(DOC_POSITIONS_FIELD))) {\n          assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n          assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        }\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n    \n    // test advance()\n    final DocsAndPositionsEnum reuse = sortedPositions;\n    sortedPositions = termsEnum.docsAndPositions(null, reuse);\n    if (sortedPositions instanceof SortingDocsAndPositionsEnum) {\n      assertTrue(((SortingDocsAndPositionsEnum) sortedPositions).reused(reuse)); // make sure reuse worked\n    }\n    doc = 0;\n    while ((doc = sortedPositions.advance(doc + TestUtil.nextInt(random(), 1, 5))) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        if (!doesntSupportOffsets.contains(TestUtil.getPostingsFormat(DOC_POSITIONS_FIELD))) {\n          assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n          assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        }\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testDocsAndPositionsEnum() throws Exception {\n    TermsEnum termsEnum = reader.terms(DOC_POSITIONS_FIELD).iterator(null);\n    assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(DOC_POSITIONS_TERM)));\n    DocsAndPositionsEnum sortedPositions = termsEnum.docsAndPositions(null, null);\n    int doc;\n    \n    // test nextDoc()\n    while ((doc = sortedPositions.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        if (!doesntSupportOffsets.contains(_TestUtil.getPostingsFormat(DOC_POSITIONS_FIELD))) {\n          assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n          assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        }\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n    \n    // test advance()\n    final DocsAndPositionsEnum reuse = sortedPositions;\n    sortedPositions = termsEnum.docsAndPositions(null, reuse);\n    if (sortedPositions instanceof SortingDocsAndPositionsEnum) {\n      assertTrue(((SortingDocsAndPositionsEnum) sortedPositions).reused(reuse)); // make sure reuse worked\n    }\n    doc = 0;\n    while ((doc = sortedPositions.advance(doc + _TestUtil.nextInt(random(), 1, 5))) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        if (!doesntSupportOffsets.contains(_TestUtil.getPostingsFormat(DOC_POSITIONS_FIELD))) {\n          assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n          assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        }\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91d86ebcdb45ce6a1b2584e2603f76db47523d0a","date":1396466913,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/index/sorter/SorterTestBase#testDocsAndPositionsEnum().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/index/sorter/SorterTestBase#testDocsAndPositionsEnum().mjava","sourceNew":"  @Test\n  public void testDocsAndPositionsEnum() throws Exception {\n    TermsEnum termsEnum = reader.terms(DOC_POSITIONS_FIELD).iterator(null);\n    assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(DOC_POSITIONS_TERM)));\n    DocsAndPositionsEnum sortedPositions = termsEnum.docsAndPositions(null, null);\n    int doc;\n    \n    // test nextDoc()\n    while ((doc = sortedPositions.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n        assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n    \n    // test advance()\n    final DocsAndPositionsEnum reuse = sortedPositions;\n    sortedPositions = termsEnum.docsAndPositions(null, reuse);\n    if (sortedPositions instanceof SortingDocsAndPositionsEnum) {\n      assertTrue(((SortingDocsAndPositionsEnum) sortedPositions).reused(reuse)); // make sure reuse worked\n    }\n    doc = 0;\n    while ((doc = sortedPositions.advance(doc + TestUtil.nextInt(random(), 1, 5))) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n        assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testDocsAndPositionsEnum() throws Exception {\n    TermsEnum termsEnum = reader.terms(DOC_POSITIONS_FIELD).iterator(null);\n    assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(DOC_POSITIONS_TERM)));\n    DocsAndPositionsEnum sortedPositions = termsEnum.docsAndPositions(null, null);\n    int doc;\n    \n    // test nextDoc()\n    while ((doc = sortedPositions.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        if (!doesntSupportOffsets.contains(TestUtil.getPostingsFormat(DOC_POSITIONS_FIELD))) {\n          assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n          assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        }\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n    \n    // test advance()\n    final DocsAndPositionsEnum reuse = sortedPositions;\n    sortedPositions = termsEnum.docsAndPositions(null, reuse);\n    if (sortedPositions instanceof SortingDocsAndPositionsEnum) {\n      assertTrue(((SortingDocsAndPositionsEnum) sortedPositions).reused(reuse)); // make sure reuse worked\n    }\n    doc = 0;\n    while ((doc = sortedPositions.advance(doc + TestUtil.nextInt(random(), 1, 5))) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        if (!doesntSupportOffsets.contains(TestUtil.getPostingsFormat(DOC_POSITIONS_FIELD))) {\n          assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n          assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        }\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/misc/src/test/org/apache/lucene/index/sorter/SorterTestBase#testDocsAndPositionsEnum().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/index/sorter/SorterTestBase#testDocsAndPositionsEnum().mjava","sourceNew":"  @Test\n  public void testDocsAndPositionsEnum() throws Exception {\n    TermsEnum termsEnum = reader.terms(DOC_POSITIONS_FIELD).iterator(null);\n    assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(DOC_POSITIONS_TERM)));\n    DocsAndPositionsEnum sortedPositions = termsEnum.docsAndPositions(null, null);\n    int doc;\n    \n    // test nextDoc()\n    while ((doc = sortedPositions.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n        assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n    \n    // test advance()\n    final DocsAndPositionsEnum reuse = sortedPositions;\n    sortedPositions = termsEnum.docsAndPositions(null, reuse);\n    if (sortedPositions instanceof SortingDocsAndPositionsEnum) {\n      assertTrue(((SortingDocsAndPositionsEnum) sortedPositions).reused(reuse)); // make sure reuse worked\n    }\n    doc = 0;\n    while ((doc = sortedPositions.advance(doc + TestUtil.nextInt(random(), 1, 5))) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n        assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testDocsAndPositionsEnum() throws Exception {\n    TermsEnum termsEnum = reader.terms(DOC_POSITIONS_FIELD).iterator(null);\n    assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(DOC_POSITIONS_TERM)));\n    DocsAndPositionsEnum sortedPositions = termsEnum.docsAndPositions(null, null);\n    int doc;\n    \n    // test nextDoc()\n    while ((doc = sortedPositions.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        if (!doesntSupportOffsets.contains(TestUtil.getPostingsFormat(DOC_POSITIONS_FIELD))) {\n          assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n          assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        }\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n    \n    // test advance()\n    final DocsAndPositionsEnum reuse = sortedPositions;\n    sortedPositions = termsEnum.docsAndPositions(null, reuse);\n    if (sortedPositions instanceof SortingDocsAndPositionsEnum) {\n      assertTrue(((SortingDocsAndPositionsEnum) sortedPositions).reused(reuse)); // make sure reuse worked\n    }\n    doc = 0;\n    while ((doc = sortedPositions.advance(doc + TestUtil.nextInt(random(), 1, 5))) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        if (!doesntSupportOffsets.contains(TestUtil.getPostingsFormat(DOC_POSITIONS_FIELD))) {\n          assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n          assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        }\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c17ec76fa103f80e80ed20ee425dbc357fb1356f","date":1414420673,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/index/sorter/SorterTestBase#testDocsAndPositionsEnum().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/index/sorter/SorterTestBase#testDocsAndPositionsEnum().mjava","sourceNew":"  @Test\n  public void testDocsAndPositionsEnum() throws Exception {\n    TermsEnum termsEnum = sortedReader.terms(DOC_POSITIONS_FIELD).iterator(null);\n    assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(DOC_POSITIONS_TERM)));\n    DocsAndPositionsEnum sortedPositions = termsEnum.docsAndPositions(null, null);\n    int doc;\n    \n    // test nextDoc()\n    while ((doc = sortedPositions.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n        assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n    \n    // test advance()\n    final DocsAndPositionsEnum reuse = sortedPositions;\n    sortedPositions = termsEnum.docsAndPositions(null, reuse);\n    if (sortedPositions instanceof SortingDocsAndPositionsEnum) {\n      assertTrue(((SortingDocsAndPositionsEnum) sortedPositions).reused(reuse)); // make sure reuse worked\n    }\n    doc = 0;\n    while ((doc = sortedPositions.advance(doc + TestUtil.nextInt(random(), 1, 5))) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n        assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testDocsAndPositionsEnum() throws Exception {\n    TermsEnum termsEnum = reader.terms(DOC_POSITIONS_FIELD).iterator(null);\n    assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(DOC_POSITIONS_TERM)));\n    DocsAndPositionsEnum sortedPositions = termsEnum.docsAndPositions(null, null);\n    int doc;\n    \n    // test nextDoc()\n    while ((doc = sortedPositions.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n        assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n    \n    // test advance()\n    final DocsAndPositionsEnum reuse = sortedPositions;\n    sortedPositions = termsEnum.docsAndPositions(null, reuse);\n    if (sortedPositions instanceof SortingDocsAndPositionsEnum) {\n      assertTrue(((SortingDocsAndPositionsEnum) sortedPositions).reused(reuse)); // make sure reuse worked\n    }\n    doc = 0;\n    while ((doc = sortedPositions.advance(doc + TestUtil.nextInt(random(), 1, 5))) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n        assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"82dc51e5dcd7a80b71e40ebe8959b1c43b63f95e","date":1419346542,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/misc/src/test/org/apache/lucene/index/SorterTestBase#testDocsAndPositionsEnum().mjava","pathOld":"lucene/misc/src/test/org/apache/lucene/index/sorter/SorterTestBase#testDocsAndPositionsEnum().mjava","sourceNew":"  @Test\n  public void testDocsAndPositionsEnum() throws Exception {\n    TermsEnum termsEnum = sortedReader.terms(DOC_POSITIONS_FIELD).iterator(null);\n    assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(DOC_POSITIONS_TERM)));\n    DocsAndPositionsEnum sortedPositions = termsEnum.docsAndPositions(null, null);\n    int doc;\n    \n    // test nextDoc()\n    while ((doc = sortedPositions.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n        assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n    \n    // test advance()\n    final DocsAndPositionsEnum reuse = sortedPositions;\n    sortedPositions = termsEnum.docsAndPositions(null, reuse);\n    if (sortedPositions instanceof SortingDocsAndPositionsEnum) {\n      assertTrue(((SortingDocsAndPositionsEnum) sortedPositions).reused(reuse)); // make sure reuse worked\n    }\n    doc = 0;\n    while ((doc = sortedPositions.advance(doc + TestUtil.nextInt(random(), 1, 5))) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n        assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testDocsAndPositionsEnum() throws Exception {\n    TermsEnum termsEnum = sortedReader.terms(DOC_POSITIONS_FIELD).iterator(null);\n    assertEquals(SeekStatus.FOUND, termsEnum.seekCeil(new BytesRef(DOC_POSITIONS_TERM)));\n    DocsAndPositionsEnum sortedPositions = termsEnum.docsAndPositions(null, null);\n    int doc;\n    \n    // test nextDoc()\n    while ((doc = sortedPositions.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n        assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n    \n    // test advance()\n    final DocsAndPositionsEnum reuse = sortedPositions;\n    sortedPositions = termsEnum.docsAndPositions(null, reuse);\n    if (sortedPositions instanceof SortingDocsAndPositionsEnum) {\n      assertTrue(((SortingDocsAndPositionsEnum) sortedPositions).reused(reuse)); // make sure reuse worked\n    }\n    doc = 0;\n    while ((doc = sortedPositions.advance(doc + TestUtil.nextInt(random(), 1, 5))) != DocIdSetIterator.NO_MORE_DOCS) {\n      int freq = sortedPositions.freq();\n      assertEquals(\"incorrect freq for doc=\" + doc, sortedValues[doc].intValue() / 10 + 1, freq);\n      for (int i = 0; i < freq; i++) {\n        assertEquals(\"incorrect position for doc=\" + doc, i, sortedPositions.nextPosition());\n        assertEquals(\"incorrect startOffset for doc=\" + doc, i, sortedPositions.startOffset());\n        assertEquals(\"incorrect endOffset for doc=\" + doc, i, sortedPositions.endOffset());\n        assertEquals(\"incorrect payload for doc=\" + doc, freq - i, Integer.parseInt(sortedPositions.getPayload().utf8ToString()));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["6613659748fe4411a7dcf85266e55db1f95f7315","91d86ebcdb45ce6a1b2584e2603f76db47523d0a"],"a260e1fefced66a58d52044266f9fa20d81ae74b":["cb767289784b682dea51f9e6d7222add811edb77"],"91d86ebcdb45ce6a1b2584e2603f76db47523d0a":["6613659748fe4411a7dcf85266e55db1f95f7315"],"6613659748fe4411a7dcf85266e55db1f95f7315":["07c6861cb029cd251d930aa4c4578c8ca21aa957"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c17ec76fa103f80e80ed20ee425dbc357fb1356f":["91d86ebcdb45ce6a1b2584e2603f76db47523d0a"],"82dc51e5dcd7a80b71e40ebe8959b1c43b63f95e":["c17ec76fa103f80e80ed20ee425dbc357fb1356f"],"cb767289784b682dea51f9e6d7222add811edb77":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"07c6861cb029cd251d930aa4c4578c8ca21aa957":["a260e1fefced66a58d52044266f9fa20d81ae74b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["82dc51e5dcd7a80b71e40ebe8959b1c43b63f95e"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"a260e1fefced66a58d52044266f9fa20d81ae74b":["07c6861cb029cd251d930aa4c4578c8ca21aa957"],"91d86ebcdb45ce6a1b2584e2603f76db47523d0a":["5eb2511ababf862ea11e10761c70ee560cd84510","c17ec76fa103f80e80ed20ee425dbc357fb1356f"],"6613659748fe4411a7dcf85266e55db1f95f7315":["5eb2511ababf862ea11e10761c70ee560cd84510","91d86ebcdb45ce6a1b2584e2603f76db47523d0a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cb767289784b682dea51f9e6d7222add811edb77"],"c17ec76fa103f80e80ed20ee425dbc357fb1356f":["82dc51e5dcd7a80b71e40ebe8959b1c43b63f95e"],"cb767289784b682dea51f9e6d7222add811edb77":["a260e1fefced66a58d52044266f9fa20d81ae74b"],"82dc51e5dcd7a80b71e40ebe8959b1c43b63f95e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"07c6861cb029cd251d930aa4c4578c8ca21aa957":["6613659748fe4411a7dcf85266e55db1f95f7315"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}