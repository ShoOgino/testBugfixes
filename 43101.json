{"path":"lucene/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","commits":[{"id":"a1c3710e755dc60691ac0d7fe23c9fcba0537bdc","date":1320437768,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","pathOld":"/dev/null","sourceNew":"    public void run() {\n      IndexReader currentReader = null;\n      try {\n        Document doc = new Document();\n        doc.add(new Field(\"id\", \"1\", TextField.TYPE_UNSTORED));\n        writer.addDocument(doc);\n        holder.reader = currentReader = writer.getReader(true);\n        Term term = new Term(\"id\");\n        for (int i = 0; i < numOps && !holder.stop; i++) {\n          float nextOp = random.nextFloat();\n          if (nextOp < 0.3) {\n            term.set(\"id\", \"1\");\n            writer.updateDocument(term, doc);\n          } else if (nextOp < 0.5) {\n            writer.addDocument(doc);\n          } else {\n            term.set(\"id\", \"1\");\n            writer.deleteDocuments(term);\n          }\n          if (holder.reader != currentReader) {\n            holder.reader = currentReader;\n            if (countdown) {\n              countdown = false;\n              latch.countDown();\n            }\n          }\n          if (random.nextBoolean()) {\n            writer.commit();\n            final IndexReader newReader = IndexReader\n                .openIfChanged(currentReader);\n            if (newReader != null) { \n              currentReader.decRef();\n              currentReader = newReader;\n            }\n            if (currentReader.numDocs() == 0) {\n              writer.addDocument(doc);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        failed = e;\n      } finally {\n        holder.reader = null;\n        if (countdown) {\n          latch.countDown();\n        }\n        if (currentReader != null) {\n          try {\n            currentReader.decRef();\n          } catch (IOException e) {\n          }\n        }\n      }\n      if (VERBOSE) {\n        System.out.println(\"writer stopped - forced by reader: \" + holder.stop);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2b44c56524a285c571d8e31d61e26b4e11ac6689","date":1322320368,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","sourceNew":"    public void run() {\n      IndexReader currentReader = null;\n      try {\n        Document doc = new Document();\n        doc.add(new Field(\"id\", \"1\", TextField.TYPE_UNSTORED));\n        writer.addDocument(doc);\n        holder.reader = currentReader = writer.getReader(true);\n        Term term = new Term(\"id\");\n        for (int i = 0; i < numOps && !holder.stop; i++) {\n          float nextOp = random.nextFloat();\n          if (nextOp < 0.3) {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.updateDocument(term, doc);\n          } else if (nextOp < 0.5) {\n            writer.addDocument(doc);\n          } else {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.deleteDocuments(term);\n          }\n          if (holder.reader != currentReader) {\n            holder.reader = currentReader;\n            if (countdown) {\n              countdown = false;\n              latch.countDown();\n            }\n          }\n          if (random.nextBoolean()) {\n            writer.commit();\n            final IndexReader newReader = IndexReader\n                .openIfChanged(currentReader);\n            if (newReader != null) { \n              currentReader.decRef();\n              currentReader = newReader;\n            }\n            if (currentReader.numDocs() == 0) {\n              writer.addDocument(doc);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        failed = e;\n      } finally {\n        holder.reader = null;\n        if (countdown) {\n          latch.countDown();\n        }\n        if (currentReader != null) {\n          try {\n            currentReader.decRef();\n          } catch (IOException e) {\n          }\n        }\n      }\n      if (VERBOSE) {\n        System.out.println(\"writer stopped - forced by reader: \" + holder.stop);\n      }\n    }\n\n","sourceOld":"    public void run() {\n      IndexReader currentReader = null;\n      try {\n        Document doc = new Document();\n        doc.add(new Field(\"id\", \"1\", TextField.TYPE_UNSTORED));\n        writer.addDocument(doc);\n        holder.reader = currentReader = writer.getReader(true);\n        Term term = new Term(\"id\");\n        for (int i = 0; i < numOps && !holder.stop; i++) {\n          float nextOp = random.nextFloat();\n          if (nextOp < 0.3) {\n            term.set(\"id\", \"1\");\n            writer.updateDocument(term, doc);\n          } else if (nextOp < 0.5) {\n            writer.addDocument(doc);\n          } else {\n            term.set(\"id\", \"1\");\n            writer.deleteDocuments(term);\n          }\n          if (holder.reader != currentReader) {\n            holder.reader = currentReader;\n            if (countdown) {\n              countdown = false;\n              latch.countDown();\n            }\n          }\n          if (random.nextBoolean()) {\n            writer.commit();\n            final IndexReader newReader = IndexReader\n                .openIfChanged(currentReader);\n            if (newReader != null) { \n              currentReader.decRef();\n              currentReader = newReader;\n            }\n            if (currentReader.numDocs() == 0) {\n              writer.addDocument(doc);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        failed = e;\n      } finally {\n        holder.reader = null;\n        if (countdown) {\n          latch.countDown();\n        }\n        if (currentReader != null) {\n          try {\n            currentReader.decRef();\n          } catch (IOException e) {\n          }\n        }\n      }\n      if (VERBOSE) {\n        System.out.println(\"writer stopped - forced by reader: \" + holder.stop);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bd328b3cdb3f944c5c765d81bb246545f85932dd","date":1327857991,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","sourceNew":"    public void run() {\n      DirectoryReader currentReader = null;\n      try {\n        Document doc = new Document();\n        doc.add(new Field(\"id\", \"1\", TextField.TYPE_UNSTORED));\n        writer.addDocument(doc);\n        holder.reader = currentReader = writer.getReader(true);\n        Term term = new Term(\"id\");\n        for (int i = 0; i < numOps && !holder.stop; i++) {\n          float nextOp = random.nextFloat();\n          if (nextOp < 0.3) {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.updateDocument(term, doc);\n          } else if (nextOp < 0.5) {\n            writer.addDocument(doc);\n          } else {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.deleteDocuments(term);\n          }\n          if (holder.reader != currentReader) {\n            holder.reader = currentReader;\n            if (countdown) {\n              countdown = false;\n              latch.countDown();\n            }\n          }\n          if (random.nextBoolean()) {\n            writer.commit();\n            final DirectoryReader newReader = DirectoryReader\n                .openIfChanged(currentReader);\n            if (newReader != null) { \n              currentReader.decRef();\n              currentReader = newReader;\n            }\n            if (currentReader.numDocs() == 0) {\n              writer.addDocument(doc);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        failed = e;\n      } finally {\n        holder.reader = null;\n        if (countdown) {\n          latch.countDown();\n        }\n        if (currentReader != null) {\n          try {\n            currentReader.decRef();\n          } catch (IOException e) {\n          }\n        }\n      }\n      if (VERBOSE) {\n        System.out.println(\"writer stopped - forced by reader: \" + holder.stop);\n      }\n    }\n\n","sourceOld":"    public void run() {\n      IndexReader currentReader = null;\n      try {\n        Document doc = new Document();\n        doc.add(new Field(\"id\", \"1\", TextField.TYPE_UNSTORED));\n        writer.addDocument(doc);\n        holder.reader = currentReader = writer.getReader(true);\n        Term term = new Term(\"id\");\n        for (int i = 0; i < numOps && !holder.stop; i++) {\n          float nextOp = random.nextFloat();\n          if (nextOp < 0.3) {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.updateDocument(term, doc);\n          } else if (nextOp < 0.5) {\n            writer.addDocument(doc);\n          } else {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.deleteDocuments(term);\n          }\n          if (holder.reader != currentReader) {\n            holder.reader = currentReader;\n            if (countdown) {\n              countdown = false;\n              latch.countDown();\n            }\n          }\n          if (random.nextBoolean()) {\n            writer.commit();\n            final IndexReader newReader = IndexReader\n                .openIfChanged(currentReader);\n            if (newReader != null) { \n              currentReader.decRef();\n              currentReader = newReader;\n            }\n            if (currentReader.numDocs() == 0) {\n              writer.addDocument(doc);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        failed = e;\n      } finally {\n        holder.reader = null;\n        if (countdown) {\n          latch.countDown();\n        }\n        if (currentReader != null) {\n          try {\n            currentReader.decRef();\n          } catch (IOException e) {\n          }\n        }\n      }\n      if (VERBOSE) {\n        System.out.println(\"writer stopped - forced by reader: \" + holder.stop);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","sourceNew":"    public void run() {\n      DirectoryReader currentReader = null;\n      try {\n        Document doc = new Document();\n        doc.add(new Field(\"id\", \"1\", TextField.TYPE_UNSTORED));\n        writer.addDocument(doc);\n        holder.reader = currentReader = writer.getReader(true);\n        Term term = new Term(\"id\");\n        for (int i = 0; i < numOps && !holder.stop; i++) {\n          float nextOp = random.nextFloat();\n          if (nextOp < 0.3) {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.updateDocument(term, doc);\n          } else if (nextOp < 0.5) {\n            writer.addDocument(doc);\n          } else {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.deleteDocuments(term);\n          }\n          if (holder.reader != currentReader) {\n            holder.reader = currentReader;\n            if (countdown) {\n              countdown = false;\n              latch.countDown();\n            }\n          }\n          if (random.nextBoolean()) {\n            writer.commit();\n            final DirectoryReader newReader = DirectoryReader\n                .openIfChanged(currentReader);\n            if (newReader != null) { \n              currentReader.decRef();\n              currentReader = newReader;\n            }\n            if (currentReader.numDocs() == 0) {\n              writer.addDocument(doc);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        failed = e;\n      } finally {\n        holder.reader = null;\n        if (countdown) {\n          latch.countDown();\n        }\n        if (currentReader != null) {\n          try {\n            currentReader.decRef();\n          } catch (IOException e) {\n          }\n        }\n      }\n      if (VERBOSE) {\n        System.out.println(\"writer stopped - forced by reader: \" + holder.stop);\n      }\n    }\n\n","sourceOld":"    public void run() {\n      IndexReader currentReader = null;\n      try {\n        Document doc = new Document();\n        doc.add(new Field(\"id\", \"1\", TextField.TYPE_UNSTORED));\n        writer.addDocument(doc);\n        holder.reader = currentReader = writer.getReader(true);\n        Term term = new Term(\"id\");\n        for (int i = 0; i < numOps && !holder.stop; i++) {\n          float nextOp = random.nextFloat();\n          if (nextOp < 0.3) {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.updateDocument(term, doc);\n          } else if (nextOp < 0.5) {\n            writer.addDocument(doc);\n          } else {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.deleteDocuments(term);\n          }\n          if (holder.reader != currentReader) {\n            holder.reader = currentReader;\n            if (countdown) {\n              countdown = false;\n              latch.countDown();\n            }\n          }\n          if (random.nextBoolean()) {\n            writer.commit();\n            final IndexReader newReader = IndexReader\n                .openIfChanged(currentReader);\n            if (newReader != null) { \n              currentReader.decRef();\n              currentReader = newReader;\n            }\n            if (currentReader.numDocs() == 0) {\n              writer.addDocument(doc);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        failed = e;\n      } finally {\n        holder.reader = null;\n        if (countdown) {\n          latch.countDown();\n        }\n        if (currentReader != null) {\n          try {\n            currentReader.decRef();\n          } catch (IOException e) {\n          }\n        }\n      }\n      if (VERBOSE) {\n        System.out.println(\"writer stopped - forced by reader: \" + holder.stop);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","sourceNew":"    public void run() {\n      DirectoryReader currentReader = null;\n      try {\n        Document doc = new Document();\n        doc.add(new Field(\"id\", \"1\", TextField.TYPE_UNSTORED));\n        writer.addDocument(doc);\n        holder.reader = currentReader = writer.getReader(true);\n        Term term = new Term(\"id\");\n        for (int i = 0; i < numOps && !holder.stop; i++) {\n          float nextOp = random.nextFloat();\n          if (nextOp < 0.3) {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.updateDocument(term, doc);\n          } else if (nextOp < 0.5) {\n            writer.addDocument(doc);\n          } else {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.deleteDocuments(term);\n          }\n          if (holder.reader != currentReader) {\n            holder.reader = currentReader;\n            if (countdown) {\n              countdown = false;\n              latch.countDown();\n            }\n          }\n          if (random.nextBoolean()) {\n            writer.commit();\n            final DirectoryReader newReader = DirectoryReader\n                .openIfChanged(currentReader);\n            if (newReader != null) { \n              currentReader.decRef();\n              currentReader = newReader;\n            }\n            if (currentReader.numDocs() == 0) {\n              writer.addDocument(doc);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        failed = e;\n      } finally {\n        holder.reader = null;\n        if (countdown) {\n          latch.countDown();\n        }\n        if (currentReader != null) {\n          try {\n            currentReader.decRef();\n          } catch (IOException e) {\n          }\n        }\n      }\n      if (VERBOSE) {\n        System.out.println(\"writer stopped - forced by reader: \" + holder.stop);\n      }\n    }\n\n","sourceOld":"    public void run() {\n      DirectoryReader currentReader = null;\n      try {\n        Document doc = new Document();\n        doc.add(new Field(\"id\", \"1\", TextField.TYPE_UNSTORED));\n        writer.addDocument(doc);\n        holder.reader = currentReader = writer.getReader(true);\n        Term term = new Term(\"id\");\n        for (int i = 0; i < numOps && !holder.stop; i++) {\n          float nextOp = random.nextFloat();\n          if (nextOp < 0.3) {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.updateDocument(term, doc);\n          } else if (nextOp < 0.5) {\n            writer.addDocument(doc);\n          } else {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.deleteDocuments(term);\n          }\n          if (holder.reader != currentReader) {\n            holder.reader = currentReader;\n            if (countdown) {\n              countdown = false;\n              latch.countDown();\n            }\n          }\n          if (random.nextBoolean()) {\n            writer.commit();\n            final DirectoryReader newReader = DirectoryReader\n                .openIfChanged(currentReader);\n            if (newReader != null) { \n              currentReader.decRef();\n              currentReader = newReader;\n            }\n            if (currentReader.numDocs() == 0) {\n              writer.addDocument(doc);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        failed = e;\n      } finally {\n        holder.reader = null;\n        if (countdown) {\n          latch.countDown();\n        }\n        if (currentReader != null) {\n          try {\n            currentReader.decRef();\n          } catch (IOException e) {\n          }\n        }\n      }\n      if (VERBOSE) {\n        System.out.println(\"writer stopped - forced by reader: \" + holder.stop);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"bd328b3cdb3f944c5c765d81bb246545f85932dd":["2b44c56524a285c571d8e31d61e26b4e11ac6689"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"a1c3710e755dc60691ac0d7fe23c9fcba0537bdc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2b44c56524a285c571d8e31d61e26b4e11ac6689":["a1c3710e755dc60691ac0d7fe23c9fcba0537bdc"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["2b44c56524a285c571d8e31d61e26b4e11ac6689","bd328b3cdb3f944c5c765d81bb246545f85932dd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"bd328b3cdb3f944c5c765d81bb246545f85932dd":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a1c3710e755dc60691ac0d7fe23c9fcba0537bdc":["2b44c56524a285c571d8e31d61e26b4e11ac6689"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a1c3710e755dc60691ac0d7fe23c9fcba0537bdc"],"2b44c56524a285c571d8e31d61e26b4e11ac6689":["bd328b3cdb3f944c5c765d81bb246545f85932dd","5cab9a86bd67202d20b6adc463008c8e982b070a"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}