{"path":"lucene/core/src/test/org/apache/lucene/index/TestMixedDocValuesUpdates#testTryUpdateMultiThreaded().mjava","commits":[{"id":"c0d5f8ee8ea79c9827f54a6484c70bb02f9857dd","date":1525696559,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestMixedDocValuesUpdates#testTryUpdateMultiThreaded().mjava","pathOld":"/dev/null","sourceNew":"  public void testTryUpdateMultiThreaded() throws IOException, BrokenBarrierException, InterruptedException {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig();\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ReentrantLock[] locks = new ReentrantLock[25 + random().nextInt(50)];\n    int[] values = new int[locks.length];\n    for (int i = 0; i < locks.length; i++) {\n      locks[i] = new ReentrantLock();\n      Document doc = new Document();\n      values[i] = random().nextInt();\n      doc.add(new StringField(\"id\", Integer.toString(i), Store.NO));\n      doc.add(new NumericDocValuesField(\"value\", values[i]));\n      writer.addDocument(doc);\n    }\n\n    Thread[] threads = new Thread[2 + random().nextInt(3)];\n    CyclicBarrier barrier = new CyclicBarrier(threads.length + 1);\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new Thread(() -> {\n        try {\n          barrier.await();\n          for (int doc = 0; doc < 1000; doc++) {\n            int docId = random().nextInt(locks.length);\n            locks[docId].lock();\n            try {\n              int value = random().nextInt();\n              if (random().nextBoolean()) {\n                writer.updateDocValues(new Term(\"id\", docId + \"\"), new NumericDocValuesField(\"value\", value));\n              } else {\n                doUpdate(new Term(\"id\", docId + \"\"), writer, new NumericDocValuesField(\"value\", value));\n              }\n              values[docId] = value;\n            } catch (IOException e) {\n              throw new AssertionError(e);\n            } finally {\n              locks[docId].unlock();\n            }\n\n            if (rarely()) {\n              writer.flush();\n            }\n          }\n        } catch (Exception e) {\n          throw new AssertionError(e);\n        }\n      });\n      threads[i].start();\n    }\n\n    barrier.await();\n    for (Thread t : threads) {\n      t.join();\n    }\n    try (DirectoryReader reader = writer.getReader()) {\n      for (int i = 0; i < locks.length; i++) {\n        locks[i].lock();\n        try {\n          int value = values[i];\n          TopDocs topDocs = new IndexSearcher(reader).search(new TermQuery(new Term(\"id\", \"\" + i)), 10);\n          assertEquals(topDocs.totalHits, 1);\n          int docID = topDocs.scoreDocs[0].doc;\n          List<LeafReaderContext> leaves = reader.leaves();\n          int subIndex = ReaderUtil.subIndex(docID, leaves);\n          LeafReader leafReader = leaves.get(subIndex).reader();\n          docID -= leaves.get(subIndex).docBase;\n          NumericDocValues numericDocValues = leafReader.getNumericDocValues(\"value\");\n          assertEquals(docID, numericDocValues.advance(docID));\n          assertEquals(numericDocValues.longValue(), value);\n        } finally {\n          locks[i].unlock();\n        }\n\n      }\n    }\n\n    IOUtils.close(writer, dir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"33adea025f43af3243278587a46b8d9fd2e8ccf9","date":1525885077,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestMixedDocValuesUpdates#testTryUpdateMultiThreaded().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestMixedDocValuesUpdates#testTryUpdateMultiThreaded().mjava","sourceNew":"  public void testTryUpdateMultiThreaded() throws IOException, BrokenBarrierException, InterruptedException {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig();\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ReentrantLock[] locks = new ReentrantLock[25 + random().nextInt(50)];\n    Long[] values = new Long[locks.length];\n\n    for (int i = 0; i < locks.length; i++) {\n      locks[i] = new ReentrantLock();\n      Document doc = new Document();\n      values[i] = random().nextLong();\n      doc.add(new StringField(\"id\", Integer.toString(i), Store.NO));\n      doc.add(new NumericDocValuesField(\"value\", values[i]));\n      writer.addDocument(doc);\n    }\n\n    Thread[] threads = new Thread[2 + random().nextInt(3)];\n    CyclicBarrier barrier = new CyclicBarrier(threads.length + 1);\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new Thread(() -> {\n        try {\n          barrier.await();\n          for (int doc = 0; doc < 1000; doc++) {\n            int docId = random().nextInt(locks.length);\n            locks[docId].lock();\n            try {\n              Long value = rarely() ? null : random().nextLong(); // sometimes reset it\n              if (random().nextBoolean()) {\n                writer.updateDocValues(new Term(\"id\", docId + \"\"), new NumericDocValuesField(\"value\", value));\n              } else {\n                doUpdate(new Term(\"id\", docId + \"\"), writer, new NumericDocValuesField(\"value\", value));\n              }\n              values[docId] = value;\n            } catch (IOException e) {\n              throw new AssertionError(e);\n            } finally {\n              locks[docId].unlock();\n            }\n            if (rarely()) {\n              writer.flush();\n            }\n          }\n        } catch (Exception e) {\n          throw new AssertionError(e);\n        }\n      });\n      threads[i].start();\n    }\n\n    barrier.await();\n    for (Thread t : threads) {\n      t.join();\n    }\n    try (DirectoryReader reader = writer.getReader()) {\n      for (int i = 0; i < locks.length; i++) {\n        locks[i].lock();\n        try {\n          Long value = values[i];\n          TopDocs topDocs = new IndexSearcher(reader).search(new TermQuery(new Term(\"id\", \"\" + i)), 10);\n          assertEquals(topDocs.totalHits, 1);\n          int docID = topDocs.scoreDocs[0].doc;\n          List<LeafReaderContext> leaves = reader.leaves();\n          int subIndex = ReaderUtil.subIndex(docID, leaves);\n          LeafReader leafReader = leaves.get(subIndex).reader();\n          docID -= leaves.get(subIndex).docBase;\n          NumericDocValues numericDocValues = leafReader.getNumericDocValues(\"value\");\n          if (value == null) {\n            assertFalse(\"docID: \" + docID, numericDocValues.advanceExact(docID));\n          } else {\n            assertTrue(\"docID: \" + docID, numericDocValues.advanceExact(docID));\n            assertEquals(numericDocValues.longValue(), value.longValue());\n          }\n        } finally {\n          locks[i].unlock();\n        }\n      }\n    }\n\n    IOUtils.close(writer, dir);\n  }\n\n","sourceOld":"  public void testTryUpdateMultiThreaded() throws IOException, BrokenBarrierException, InterruptedException {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig();\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ReentrantLock[] locks = new ReentrantLock[25 + random().nextInt(50)];\n    int[] values = new int[locks.length];\n    for (int i = 0; i < locks.length; i++) {\n      locks[i] = new ReentrantLock();\n      Document doc = new Document();\n      values[i] = random().nextInt();\n      doc.add(new StringField(\"id\", Integer.toString(i), Store.NO));\n      doc.add(new NumericDocValuesField(\"value\", values[i]));\n      writer.addDocument(doc);\n    }\n\n    Thread[] threads = new Thread[2 + random().nextInt(3)];\n    CyclicBarrier barrier = new CyclicBarrier(threads.length + 1);\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new Thread(() -> {\n        try {\n          barrier.await();\n          for (int doc = 0; doc < 1000; doc++) {\n            int docId = random().nextInt(locks.length);\n            locks[docId].lock();\n            try {\n              int value = random().nextInt();\n              if (random().nextBoolean()) {\n                writer.updateDocValues(new Term(\"id\", docId + \"\"), new NumericDocValuesField(\"value\", value));\n              } else {\n                doUpdate(new Term(\"id\", docId + \"\"), writer, new NumericDocValuesField(\"value\", value));\n              }\n              values[docId] = value;\n            } catch (IOException e) {\n              throw new AssertionError(e);\n            } finally {\n              locks[docId].unlock();\n            }\n\n            if (rarely()) {\n              writer.flush();\n            }\n          }\n        } catch (Exception e) {\n          throw new AssertionError(e);\n        }\n      });\n      threads[i].start();\n    }\n\n    barrier.await();\n    for (Thread t : threads) {\n      t.join();\n    }\n    try (DirectoryReader reader = writer.getReader()) {\n      for (int i = 0; i < locks.length; i++) {\n        locks[i].lock();\n        try {\n          int value = values[i];\n          TopDocs topDocs = new IndexSearcher(reader).search(new TermQuery(new Term(\"id\", \"\" + i)), 10);\n          assertEquals(topDocs.totalHits, 1);\n          int docID = topDocs.scoreDocs[0].doc;\n          List<LeafReaderContext> leaves = reader.leaves();\n          int subIndex = ReaderUtil.subIndex(docID, leaves);\n          LeafReader leafReader = leaves.get(subIndex).reader();\n          docID -= leaves.get(subIndex).docBase;\n          NumericDocValues numericDocValues = leafReader.getNumericDocValues(\"value\");\n          assertEquals(docID, numericDocValues.advance(docID));\n          assertEquals(numericDocValues.longValue(), value);\n        } finally {\n          locks[i].unlock();\n        }\n\n      }\n    }\n\n    IOUtils.close(writer, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestMixedDocValuesUpdates#testTryUpdateMultiThreaded().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestMixedDocValuesUpdates#testTryUpdateMultiThreaded().mjava","sourceNew":"  public void testTryUpdateMultiThreaded() throws IOException, BrokenBarrierException, InterruptedException {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig();\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ReentrantLock[] locks = new ReentrantLock[25 + random().nextInt(50)];\n    Long[] values = new Long[locks.length];\n\n    for (int i = 0; i < locks.length; i++) {\n      locks[i] = new ReentrantLock();\n      Document doc = new Document();\n      values[i] = random().nextLong();\n      doc.add(new StringField(\"id\", Integer.toString(i), Store.NO));\n      doc.add(new NumericDocValuesField(\"value\", values[i]));\n      writer.addDocument(doc);\n    }\n\n    Thread[] threads = new Thread[2 + random().nextInt(3)];\n    CyclicBarrier barrier = new CyclicBarrier(threads.length + 1);\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new Thread(() -> {\n        try {\n          barrier.await();\n          for (int doc = 0; doc < 1000; doc++) {\n            int docId = random().nextInt(locks.length);\n            locks[docId].lock();\n            try {\n              Long value = rarely() ? null : random().nextLong(); // sometimes reset it\n              if (random().nextBoolean()) {\n                writer.updateDocValues(new Term(\"id\", docId + \"\"), new NumericDocValuesField(\"value\", value));\n              } else {\n                doUpdate(new Term(\"id\", docId + \"\"), writer, new NumericDocValuesField(\"value\", value));\n              }\n              values[docId] = value;\n            } catch (IOException e) {\n              throw new AssertionError(e);\n            } finally {\n              locks[docId].unlock();\n            }\n            if (rarely()) {\n              writer.flush();\n            }\n          }\n        } catch (Exception e) {\n          throw new AssertionError(e);\n        }\n      });\n      threads[i].start();\n    }\n\n    barrier.await();\n    for (Thread t : threads) {\n      t.join();\n    }\n    try (DirectoryReader reader = writer.getReader()) {\n      for (int i = 0; i < locks.length; i++) {\n        locks[i].lock();\n        try {\n          Long value = values[i];\n          TopDocs topDocs = new IndexSearcher(reader).search(new TermQuery(new Term(\"id\", \"\" + i)), 10);\n          assertEquals(topDocs.totalHits.value, 1);\n          int docID = topDocs.scoreDocs[0].doc;\n          List<LeafReaderContext> leaves = reader.leaves();\n          int subIndex = ReaderUtil.subIndex(docID, leaves);\n          LeafReader leafReader = leaves.get(subIndex).reader();\n          docID -= leaves.get(subIndex).docBase;\n          NumericDocValues numericDocValues = leafReader.getNumericDocValues(\"value\");\n          if (value == null) {\n            assertFalse(\"docID: \" + docID, numericDocValues.advanceExact(docID));\n          } else {\n            assertTrue(\"docID: \" + docID, numericDocValues.advanceExact(docID));\n            assertEquals(numericDocValues.longValue(), value.longValue());\n          }\n        } finally {\n          locks[i].unlock();\n        }\n      }\n    }\n\n    IOUtils.close(writer, dir);\n  }\n\n","sourceOld":"  public void testTryUpdateMultiThreaded() throws IOException, BrokenBarrierException, InterruptedException {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig();\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ReentrantLock[] locks = new ReentrantLock[25 + random().nextInt(50)];\n    Long[] values = new Long[locks.length];\n\n    for (int i = 0; i < locks.length; i++) {\n      locks[i] = new ReentrantLock();\n      Document doc = new Document();\n      values[i] = random().nextLong();\n      doc.add(new StringField(\"id\", Integer.toString(i), Store.NO));\n      doc.add(new NumericDocValuesField(\"value\", values[i]));\n      writer.addDocument(doc);\n    }\n\n    Thread[] threads = new Thread[2 + random().nextInt(3)];\n    CyclicBarrier barrier = new CyclicBarrier(threads.length + 1);\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new Thread(() -> {\n        try {\n          barrier.await();\n          for (int doc = 0; doc < 1000; doc++) {\n            int docId = random().nextInt(locks.length);\n            locks[docId].lock();\n            try {\n              Long value = rarely() ? null : random().nextLong(); // sometimes reset it\n              if (random().nextBoolean()) {\n                writer.updateDocValues(new Term(\"id\", docId + \"\"), new NumericDocValuesField(\"value\", value));\n              } else {\n                doUpdate(new Term(\"id\", docId + \"\"), writer, new NumericDocValuesField(\"value\", value));\n              }\n              values[docId] = value;\n            } catch (IOException e) {\n              throw new AssertionError(e);\n            } finally {\n              locks[docId].unlock();\n            }\n            if (rarely()) {\n              writer.flush();\n            }\n          }\n        } catch (Exception e) {\n          throw new AssertionError(e);\n        }\n      });\n      threads[i].start();\n    }\n\n    barrier.await();\n    for (Thread t : threads) {\n      t.join();\n    }\n    try (DirectoryReader reader = writer.getReader()) {\n      for (int i = 0; i < locks.length; i++) {\n        locks[i].lock();\n        try {\n          Long value = values[i];\n          TopDocs topDocs = new IndexSearcher(reader).search(new TermQuery(new Term(\"id\", \"\" + i)), 10);\n          assertEquals(topDocs.totalHits, 1);\n          int docID = topDocs.scoreDocs[0].doc;\n          List<LeafReaderContext> leaves = reader.leaves();\n          int subIndex = ReaderUtil.subIndex(docID, leaves);\n          LeafReader leafReader = leaves.get(subIndex).reader();\n          docID -= leaves.get(subIndex).docBase;\n          NumericDocValues numericDocValues = leafReader.getNumericDocValues(\"value\");\n          if (value == null) {\n            assertFalse(\"docID: \" + docID, numericDocValues.advanceExact(docID));\n          } else {\n            assertTrue(\"docID: \" + docID, numericDocValues.advanceExact(docID));\n            assertEquals(numericDocValues.longValue(), value.longValue());\n          }\n        } finally {\n          locks[i].unlock();\n        }\n      }\n    }\n\n    IOUtils.close(writer, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4208ed8e426ae5f75a41d8b4ae53f4587e413061","date":1580475454,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestMixedDocValuesUpdates#testTryUpdateMultiThreaded().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestMixedDocValuesUpdates#testTryUpdateMultiThreaded().mjava","sourceNew":"  public void testTryUpdateMultiThreaded() throws IOException, BrokenBarrierException, InterruptedException {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig();\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ReentrantLock[] locks = new ReentrantLock[25 + random().nextInt(50)];\n    Long[] values = new Long[locks.length];\n\n    for (int i = 0; i < locks.length; i++) {\n      locks[i] = new ReentrantLock();\n      Document doc = new Document();\n      values[i] = random().nextLong();\n      doc.add(new StringField(\"id\", Integer.toString(i), Store.NO));\n      doc.add(new NumericDocValuesField(\"value\", values[i]));\n      writer.addDocument(doc);\n    }\n\n    int numThreads = TEST_NIGHTLY ? 2 + random().nextInt(3) : 2;\n    Thread[] threads = new Thread[numThreads];\n    CyclicBarrier barrier = new CyclicBarrier(threads.length + 1);\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new Thread(() -> {\n        try {\n          barrier.await();\n          for (int doc = 0; doc < 1000; doc++) {\n            int docId = random().nextInt(locks.length);\n            locks[docId].lock();\n            try {\n              Long value = rarely() ? null : random().nextLong(); // sometimes reset it\n              if (random().nextBoolean()) {\n                writer.updateDocValues(new Term(\"id\", docId + \"\"), new NumericDocValuesField(\"value\", value));\n              } else {\n                doUpdate(new Term(\"id\", docId + \"\"), writer, new NumericDocValuesField(\"value\", value));\n              }\n              values[docId] = value;\n            } catch (IOException e) {\n              throw new AssertionError(e);\n            } finally {\n              locks[docId].unlock();\n            }\n            if (rarely()) {\n              writer.flush();\n            }\n          }\n        } catch (Exception e) {\n          throw new AssertionError(e);\n        }\n      });\n      threads[i].start();\n    }\n\n    barrier.await();\n    for (Thread t : threads) {\n      t.join();\n    }\n    try (DirectoryReader reader = writer.getReader()) {\n      for (int i = 0; i < locks.length; i++) {\n        locks[i].lock();\n        try {\n          Long value = values[i];\n          TopDocs topDocs = new IndexSearcher(reader).search(new TermQuery(new Term(\"id\", \"\" + i)), 10);\n          assertEquals(topDocs.totalHits.value, 1);\n          int docID = topDocs.scoreDocs[0].doc;\n          List<LeafReaderContext> leaves = reader.leaves();\n          int subIndex = ReaderUtil.subIndex(docID, leaves);\n          LeafReader leafReader = leaves.get(subIndex).reader();\n          docID -= leaves.get(subIndex).docBase;\n          NumericDocValues numericDocValues = leafReader.getNumericDocValues(\"value\");\n          if (value == null) {\n            assertFalse(\"docID: \" + docID, numericDocValues.advanceExact(docID));\n          } else {\n            assertTrue(\"docID: \" + docID, numericDocValues.advanceExact(docID));\n            assertEquals(numericDocValues.longValue(), value.longValue());\n          }\n        } finally {\n          locks[i].unlock();\n        }\n      }\n    }\n\n    IOUtils.close(writer, dir);\n  }\n\n","sourceOld":"  public void testTryUpdateMultiThreaded() throws IOException, BrokenBarrierException, InterruptedException {\n    Directory dir = newDirectory();\n    IndexWriterConfig conf = newIndexWriterConfig();\n    IndexWriter writer = new IndexWriter(dir, conf);\n    ReentrantLock[] locks = new ReentrantLock[25 + random().nextInt(50)];\n    Long[] values = new Long[locks.length];\n\n    for (int i = 0; i < locks.length; i++) {\n      locks[i] = new ReentrantLock();\n      Document doc = new Document();\n      values[i] = random().nextLong();\n      doc.add(new StringField(\"id\", Integer.toString(i), Store.NO));\n      doc.add(new NumericDocValuesField(\"value\", values[i]));\n      writer.addDocument(doc);\n    }\n\n    Thread[] threads = new Thread[2 + random().nextInt(3)];\n    CyclicBarrier barrier = new CyclicBarrier(threads.length + 1);\n    for (int i = 0; i < threads.length; i++) {\n      threads[i] = new Thread(() -> {\n        try {\n          barrier.await();\n          for (int doc = 0; doc < 1000; doc++) {\n            int docId = random().nextInt(locks.length);\n            locks[docId].lock();\n            try {\n              Long value = rarely() ? null : random().nextLong(); // sometimes reset it\n              if (random().nextBoolean()) {\n                writer.updateDocValues(new Term(\"id\", docId + \"\"), new NumericDocValuesField(\"value\", value));\n              } else {\n                doUpdate(new Term(\"id\", docId + \"\"), writer, new NumericDocValuesField(\"value\", value));\n              }\n              values[docId] = value;\n            } catch (IOException e) {\n              throw new AssertionError(e);\n            } finally {\n              locks[docId].unlock();\n            }\n            if (rarely()) {\n              writer.flush();\n            }\n          }\n        } catch (Exception e) {\n          throw new AssertionError(e);\n        }\n      });\n      threads[i].start();\n    }\n\n    barrier.await();\n    for (Thread t : threads) {\n      t.join();\n    }\n    try (DirectoryReader reader = writer.getReader()) {\n      for (int i = 0; i < locks.length; i++) {\n        locks[i].lock();\n        try {\n          Long value = values[i];\n          TopDocs topDocs = new IndexSearcher(reader).search(new TermQuery(new Term(\"id\", \"\" + i)), 10);\n          assertEquals(topDocs.totalHits.value, 1);\n          int docID = topDocs.scoreDocs[0].doc;\n          List<LeafReaderContext> leaves = reader.leaves();\n          int subIndex = ReaderUtil.subIndex(docID, leaves);\n          LeafReader leafReader = leaves.get(subIndex).reader();\n          docID -= leaves.get(subIndex).docBase;\n          NumericDocValues numericDocValues = leafReader.getNumericDocValues(\"value\");\n          if (value == null) {\n            assertFalse(\"docID: \" + docID, numericDocValues.advanceExact(docID));\n          } else {\n            assertTrue(\"docID: \" + docID, numericDocValues.advanceExact(docID));\n            assertEquals(numericDocValues.longValue(), value.longValue());\n          }\n        } finally {\n          locks[i].unlock();\n        }\n      }\n    }\n\n    IOUtils.close(writer, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c0d5f8ee8ea79c9827f54a6484c70bb02f9857dd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"33adea025f43af3243278587a46b8d9fd2e8ccf9":["c0d5f8ee8ea79c9827f54a6484c70bb02f9857dd"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["33adea025f43af3243278587a46b8d9fd2e8ccf9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4208ed8e426ae5f75a41d8b4ae53f4587e413061"]},"commit2Childs":{"c0d5f8ee8ea79c9827f54a6484c70bb02f9857dd":["33adea025f43af3243278587a46b8d9fd2e8ccf9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c0d5f8ee8ea79c9827f54a6484c70bb02f9857dd"],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"33adea025f43af3243278587a46b8d9fd2e8ccf9":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["4208ed8e426ae5f75a41d8b4ae53f4587e413061"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}