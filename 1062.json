{"path":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#verifyUnPruned(int,FST[T]).mjava","commits":[{"id":"5ebe14aae60589c9bb6423f3cce02d5f599e1540","date":1348361556,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#verifyUnPruned(int,FST[T]).mjava","pathOld":"/dev/null","sourceNew":"  // FST is complete\n  private void verifyUnPruned(int inputMode, FST<T> fst) throws IOException {\n\n    final FST<Long> fstLong;\n    final Set<Long> validOutputs;\n    long minLong = Long.MAX_VALUE;\n    long maxLong = Long.MIN_VALUE;\n\n    if (doReverseLookup) {\n      @SuppressWarnings(\"unchecked\") FST<Long> fstLong0 = (FST<Long>) fst;\n      fstLong = fstLong0;\n      validOutputs = new HashSet<Long>();\n      for(InputOutput<T> pair: pairs) {\n        Long output = (Long) pair.output;\n        maxLong = Math.max(maxLong, output);\n        minLong = Math.min(minLong, output);\n        validOutputs.add(output);\n      }\n    } else {\n      fstLong = null;\n      validOutputs = null;\n    }\n\n    if (pairs.size() == 0) {\n      assertNull(fst);\n      return;\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now verify \" + pairs.size() + \" terms\");\n      for(InputOutput<T> pair : pairs) {\n        assertNotNull(pair);\n        assertNotNull(pair.input);\n        assertNotNull(pair.output);\n        System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n      }\n    }\n\n    assertNotNull(fst);\n\n    // visit valid pairs in order -- make sure all words\n    // are accepted, and FSTEnum's next() steps through\n    // them correctly\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: check valid terms/next()\");\n    }\n    {\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      for(InputOutput<T> pair : pairs) {\n        IntsRef term = pair.input;\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: check term=\" + inputToString(inputMode, term) + \" output=\" + fst.outputs.outputToString(pair.output));\n        }\n        T output = run(fst, term, null);\n        assertNotNull(\"term \" + inputToString(inputMode, term) + \" is not accepted\", output);\n        assertTrue(outputsEqual(pair.output, output));\n\n        // verify enum's next\n        IntsRefFSTEnum.InputOutput<T> t = fstEnum.next();\n        assertNotNull(t);\n        assertEquals(\"expected input=\" + inputToString(inputMode, term) + \" but fstEnum returned \" + inputToString(inputMode, t.input), term, t.input);\n        assertTrue(outputsEqual(pair.output, t.output));\n      }\n      assertNull(fstEnum.next());\n    }\n\n    final Map<IntsRef,T> termsMap = new HashMap<IntsRef,T>();\n    for(InputOutput<T> pair : pairs) {\n      termsMap.put(pair.input, pair.output);\n    }\n\n    if (doReverseLookup && maxLong > minLong) {\n      // Do random lookups so we test null (output doesn't\n      // exist) case:\n      assertNull(Util.getByOutput(fstLong, minLong-7));\n      assertNull(Util.getByOutput(fstLong, maxLong+7));\n\n      final int num = LuceneTestCase.atLeast(random, 100);\n      for(int iter=0;iter<num;iter++) {\n        Long v = _TestUtil.nextLong(random, minLong, maxLong);\n        IntsRef input = Util.getByOutput(fstLong, v);\n        assertTrue(validOutputs.contains(v) || input == null);\n      }\n    }\n\n    // find random matching word and make sure it's valid\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify random accepted terms\");\n    }\n    final IntsRef scratch = new IntsRef(10);\n    int num = LuceneTestCase.atLeast(random, 500);\n    for(int iter=0;iter<num;iter++) {\n      T output = randomAcceptedWord(fst, scratch);\n      assertTrue(\"accepted word \" + inputToString(inputMode, scratch) + \" is not valid\", termsMap.containsKey(scratch));\n      assertTrue(outputsEqual(termsMap.get(scratch), output));\n\n      if (doReverseLookup) {\n        //System.out.println(\"lookup output=\" + output + \" outs=\" + fst.outputs);\n        IntsRef input = Util.getByOutput(fstLong, (Long) output);\n        assertNotNull(input);\n        //System.out.println(\"  got \" + Util.toBytesRef(input, new BytesRef()).utf8ToString());\n        assertEquals(scratch, input);\n      }\n    }\n    \n    // test IntsRefFSTEnum.seek:\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify seek\");\n    }\n    IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  iter=\" + iter);\n      }\n      if (random.nextBoolean()) {\n        // seek to term that doesn't exist:\n        while(true) {\n          final IntsRef term = toIntsRef(getRandomString(random), inputMode);\n          int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n          if (pos < 0) {\n            pos = -(pos+1);\n            // ok doesn't exist\n            //System.out.println(\"  seek \" + inputToString(inputMode, term));\n            final IntsRefFSTEnum.InputOutput<T> seekResult;\n            if (random.nextInt(3) == 0) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekExact term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekExact(term);\n              pos = -1;\n            } else if (random.nextBoolean()) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekFloor term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekFloor(term);\n              pos--;\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekCeil term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekCeil(term);\n            }\n\n            if (pos != -1 && pos < pairs.size()) {\n              //System.out.println(\"    got \" + inputToString(inputMode,seekResult.input) + \" output=\" + fst.outputs.outputToString(seekResult.output));\n              assertNotNull(\"got null but expected term=\" + inputToString(inputMode, pairs.get(pos).input), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got \" + inputToString(inputMode, seekResult.input));\n              }\n              assertEquals(\"expected \" + inputToString(inputMode, pairs.get(pos).input) + \" but got \" + inputToString(inputMode, seekResult.input), pairs.get(pos).input, seekResult.input);\n              assertTrue(outputsEqual(pairs.get(pos).output, seekResult.output));\n            } else {\n              // seeked before start or beyond end\n              //System.out.println(\"seek=\" + seekTerm);\n              assertNull(\"expected null but got \" + (seekResult==null ? \"null\" : inputToString(inputMode, seekResult.input)), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got null\");\n              }\n            }\n\n            break;\n          }\n        }\n      } else {\n        // seek to term that does exist:\n        InputOutput<T> pair = pairs.get(random.nextInt(pairs.size()));\n        final IntsRefFSTEnum.InputOutput<T> seekResult;\n        if (random.nextInt(3) == 2) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekExact term=\" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekExact(pair.input);\n        } else if (random.nextBoolean()) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekFloor \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekFloor(pair.input);\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekCeil \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekCeil(pair.input);\n        }\n        assertNotNull(seekResult);\n        assertEquals(\"got \" + inputToString(inputMode, seekResult.input) + \" but expected \" + inputToString(inputMode, pair.input), pair.input, seekResult.input);\n        assertTrue(outputsEqual(pair.output, seekResult.output));\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: mixed next/seek\");\n    }\n\n    // test mixed next/seek\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: iter \" + iter);\n      }\n      // reset:\n      fstEnum = new IntsRefFSTEnum<T>(fst);\n      int upto = -1;\n      while(true) {\n        boolean isDone = false;\n        if (upto == pairs.size()-1 || random.nextBoolean()) {\n          // next\n          upto++;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do next\");\n          }\n          isDone = fstEnum.next() == null;\n        } else if (upto != -1 && upto < 0.75 * pairs.size() && random.nextBoolean()) {\n          int attempt = 0;\n          for(;attempt<10;attempt++) {\n            IntsRef term = toIntsRef(getRandomString(random), inputMode);\n            if (!termsMap.containsKey(term) && term.compareTo(pairs.get(upto).input) > 0) {\n              int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n              assert pos < 0;\n              upto = -(pos+1);\n\n              if (random.nextBoolean()) {\n                upto--;\n                assertTrue(upto != -1);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekFloor(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekFloor(term) == null;\n              } else {\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekCeil(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekCeil(term) == null;\n              }\n\n              break;\n            }\n          }\n          if (attempt == 10) {\n            continue;\n          }\n            \n        } else {\n          final int inc = random.nextInt(pairs.size() - upto - 1);\n          upto += inc;\n          if (upto == -1) {\n            upto = 0;\n          }\n\n          if (random.nextBoolean()) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekCeil(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekCeil(pairs.get(upto).input) == null;\n          } else {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekFloor(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekFloor(pairs.get(upto).input) == null;\n          }\n        }\n        if (LuceneTestCase.VERBOSE) {\n          if (!isDone) {\n            System.out.println(\"    got \" + inputToString(inputMode, fstEnum.current().input));\n          } else {\n            System.out.println(\"    got null\");\n          }\n        }\n\n        if (upto == pairs.size()) {\n          assertTrue(isDone);\n          break;\n        } else {\n          assertFalse(isDone);\n          assertEquals(pairs.get(upto).input, fstEnum.current().input);\n          assertTrue(outputsEqual(pairs.get(upto).output, fstEnum.current().output));\n\n          /*\n            if (upto < pairs.size()-1) {\n            int tryCount = 0;\n            while(tryCount < 10) {\n            final IntsRef t = toIntsRef(getRandomString(), inputMode);\n            if (pairs.get(upto).input.compareTo(t) < 0) {\n            final boolean expected = t.compareTo(pairs.get(upto+1).input) < 0;\n            if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"TEST: call beforeNext(\" + inputToString(inputMode, t) + \"); current=\" + inputToString(inputMode, pairs.get(upto).input) + \" next=\" + inputToString(inputMode, pairs.get(upto+1).input) + \" expected=\" + expected);\n            }\n            assertEquals(expected, fstEnum.beforeNext(t));\n            break;\n            }\n            tryCount++;\n            }\n            }\n          */\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#verifyUnPruned(int,FST[T]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#verifyUnPruned(int,FST[T]).mjava","sourceNew":"  // FST is complete\n  private void verifyUnPruned(int inputMode, FST<T> fst) throws IOException {\n\n    final FST<Long> fstLong;\n    final Set<Long> validOutputs;\n    long minLong = Long.MAX_VALUE;\n    long maxLong = Long.MIN_VALUE;\n\n    if (doReverseLookup) {\n      @SuppressWarnings(\"unchecked\") FST<Long> fstLong0 = (FST<Long>) fst;\n      fstLong = fstLong0;\n      validOutputs = new HashSet<Long>();\n      for(InputOutput<T> pair: pairs) {\n        Long output = (Long) pair.output;\n        maxLong = Math.max(maxLong, output);\n        minLong = Math.min(minLong, output);\n        validOutputs.add(output);\n      }\n    } else {\n      fstLong = null;\n      validOutputs = null;\n    }\n\n    if (pairs.size() == 0) {\n      assertNull(fst);\n      return;\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now verify \" + pairs.size() + \" terms\");\n      for(InputOutput<T> pair : pairs) {\n        assertNotNull(pair);\n        assertNotNull(pair.input);\n        assertNotNull(pair.output);\n        System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n      }\n    }\n\n    assertNotNull(fst);\n\n    // visit valid pairs in order -- make sure all words\n    // are accepted, and FSTEnum's next() steps through\n    // them correctly\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: check valid terms/next()\");\n    }\n    {\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      for(InputOutput<T> pair : pairs) {\n        IntsRef term = pair.input;\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: check term=\" + inputToString(inputMode, term) + \" output=\" + fst.outputs.outputToString(pair.output));\n        }\n        T output = run(fst, term, null);\n        assertNotNull(\"term \" + inputToString(inputMode, term) + \" is not accepted\", output);\n        assertTrue(outputsEqual(pair.output, output));\n\n        // verify enum's next\n        IntsRefFSTEnum.InputOutput<T> t = fstEnum.next();\n        assertNotNull(t);\n        assertEquals(\"expected input=\" + inputToString(inputMode, term) + \" but fstEnum returned \" + inputToString(inputMode, t.input), term, t.input);\n        assertTrue(outputsEqual(pair.output, t.output));\n      }\n      assertNull(fstEnum.next());\n    }\n\n    final Map<IntsRef,T> termsMap = new HashMap<IntsRef,T>();\n    for(InputOutput<T> pair : pairs) {\n      termsMap.put(pair.input, pair.output);\n    }\n\n    if (doReverseLookup && maxLong > minLong) {\n      // Do random lookups so we test null (output doesn't\n      // exist) case:\n      assertNull(Util.getByOutput(fstLong, minLong-7));\n      assertNull(Util.getByOutput(fstLong, maxLong+7));\n\n      final int num = LuceneTestCase.atLeast(random, 100);\n      for(int iter=0;iter<num;iter++) {\n        Long v = TestUtil.nextLong(random, minLong, maxLong);\n        IntsRef input = Util.getByOutput(fstLong, v);\n        assertTrue(validOutputs.contains(v) || input == null);\n      }\n    }\n\n    // find random matching word and make sure it's valid\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify random accepted terms\");\n    }\n    final IntsRef scratch = new IntsRef(10);\n    int num = LuceneTestCase.atLeast(random, 500);\n    for(int iter=0;iter<num;iter++) {\n      T output = randomAcceptedWord(fst, scratch);\n      assertTrue(\"accepted word \" + inputToString(inputMode, scratch) + \" is not valid\", termsMap.containsKey(scratch));\n      assertTrue(outputsEqual(termsMap.get(scratch), output));\n\n      if (doReverseLookup) {\n        //System.out.println(\"lookup output=\" + output + \" outs=\" + fst.outputs);\n        IntsRef input = Util.getByOutput(fstLong, (Long) output);\n        assertNotNull(input);\n        //System.out.println(\"  got \" + Util.toBytesRef(input, new BytesRef()).utf8ToString());\n        assertEquals(scratch, input);\n      }\n    }\n    \n    // test IntsRefFSTEnum.seek:\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify seek\");\n    }\n    IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  iter=\" + iter);\n      }\n      if (random.nextBoolean()) {\n        // seek to term that doesn't exist:\n        while(true) {\n          final IntsRef term = toIntsRef(getRandomString(random), inputMode);\n          int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n          if (pos < 0) {\n            pos = -(pos+1);\n            // ok doesn't exist\n            //System.out.println(\"  seek \" + inputToString(inputMode, term));\n            final IntsRefFSTEnum.InputOutput<T> seekResult;\n            if (random.nextInt(3) == 0) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekExact term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekExact(term);\n              pos = -1;\n            } else if (random.nextBoolean()) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekFloor term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekFloor(term);\n              pos--;\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekCeil term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekCeil(term);\n            }\n\n            if (pos != -1 && pos < pairs.size()) {\n              //System.out.println(\"    got \" + inputToString(inputMode,seekResult.input) + \" output=\" + fst.outputs.outputToString(seekResult.output));\n              assertNotNull(\"got null but expected term=\" + inputToString(inputMode, pairs.get(pos).input), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got \" + inputToString(inputMode, seekResult.input));\n              }\n              assertEquals(\"expected \" + inputToString(inputMode, pairs.get(pos).input) + \" but got \" + inputToString(inputMode, seekResult.input), pairs.get(pos).input, seekResult.input);\n              assertTrue(outputsEqual(pairs.get(pos).output, seekResult.output));\n            } else {\n              // seeked before start or beyond end\n              //System.out.println(\"seek=\" + seekTerm);\n              assertNull(\"expected null but got \" + (seekResult==null ? \"null\" : inputToString(inputMode, seekResult.input)), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got null\");\n              }\n            }\n\n            break;\n          }\n        }\n      } else {\n        // seek to term that does exist:\n        InputOutput<T> pair = pairs.get(random.nextInt(pairs.size()));\n        final IntsRefFSTEnum.InputOutput<T> seekResult;\n        if (random.nextInt(3) == 2) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekExact term=\" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekExact(pair.input);\n        } else if (random.nextBoolean()) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekFloor \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekFloor(pair.input);\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekCeil \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekCeil(pair.input);\n        }\n        assertNotNull(seekResult);\n        assertEquals(\"got \" + inputToString(inputMode, seekResult.input) + \" but expected \" + inputToString(inputMode, pair.input), pair.input, seekResult.input);\n        assertTrue(outputsEqual(pair.output, seekResult.output));\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: mixed next/seek\");\n    }\n\n    // test mixed next/seek\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: iter \" + iter);\n      }\n      // reset:\n      fstEnum = new IntsRefFSTEnum<T>(fst);\n      int upto = -1;\n      while(true) {\n        boolean isDone = false;\n        if (upto == pairs.size()-1 || random.nextBoolean()) {\n          // next\n          upto++;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do next\");\n          }\n          isDone = fstEnum.next() == null;\n        } else if (upto != -1 && upto < 0.75 * pairs.size() && random.nextBoolean()) {\n          int attempt = 0;\n          for(;attempt<10;attempt++) {\n            IntsRef term = toIntsRef(getRandomString(random), inputMode);\n            if (!termsMap.containsKey(term) && term.compareTo(pairs.get(upto).input) > 0) {\n              int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n              assert pos < 0;\n              upto = -(pos+1);\n\n              if (random.nextBoolean()) {\n                upto--;\n                assertTrue(upto != -1);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekFloor(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekFloor(term) == null;\n              } else {\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekCeil(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekCeil(term) == null;\n              }\n\n              break;\n            }\n          }\n          if (attempt == 10) {\n            continue;\n          }\n            \n        } else {\n          final int inc = random.nextInt(pairs.size() - upto - 1);\n          upto += inc;\n          if (upto == -1) {\n            upto = 0;\n          }\n\n          if (random.nextBoolean()) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekCeil(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekCeil(pairs.get(upto).input) == null;\n          } else {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekFloor(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekFloor(pairs.get(upto).input) == null;\n          }\n        }\n        if (LuceneTestCase.VERBOSE) {\n          if (!isDone) {\n            System.out.println(\"    got \" + inputToString(inputMode, fstEnum.current().input));\n          } else {\n            System.out.println(\"    got null\");\n          }\n        }\n\n        if (upto == pairs.size()) {\n          assertTrue(isDone);\n          break;\n        } else {\n          assertFalse(isDone);\n          assertEquals(pairs.get(upto).input, fstEnum.current().input);\n          assertTrue(outputsEqual(pairs.get(upto).output, fstEnum.current().output));\n\n          /*\n            if (upto < pairs.size()-1) {\n            int tryCount = 0;\n            while(tryCount < 10) {\n            final IntsRef t = toIntsRef(getRandomString(), inputMode);\n            if (pairs.get(upto).input.compareTo(t) < 0) {\n            final boolean expected = t.compareTo(pairs.get(upto+1).input) < 0;\n            if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"TEST: call beforeNext(\" + inputToString(inputMode, t) + \"); current=\" + inputToString(inputMode, pairs.get(upto).input) + \" next=\" + inputToString(inputMode, pairs.get(upto+1).input) + \" expected=\" + expected);\n            }\n            assertEquals(expected, fstEnum.beforeNext(t));\n            break;\n            }\n            tryCount++;\n            }\n            }\n          */\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // FST is complete\n  private void verifyUnPruned(int inputMode, FST<T> fst) throws IOException {\n\n    final FST<Long> fstLong;\n    final Set<Long> validOutputs;\n    long minLong = Long.MAX_VALUE;\n    long maxLong = Long.MIN_VALUE;\n\n    if (doReverseLookup) {\n      @SuppressWarnings(\"unchecked\") FST<Long> fstLong0 = (FST<Long>) fst;\n      fstLong = fstLong0;\n      validOutputs = new HashSet<Long>();\n      for(InputOutput<T> pair: pairs) {\n        Long output = (Long) pair.output;\n        maxLong = Math.max(maxLong, output);\n        minLong = Math.min(minLong, output);\n        validOutputs.add(output);\n      }\n    } else {\n      fstLong = null;\n      validOutputs = null;\n    }\n\n    if (pairs.size() == 0) {\n      assertNull(fst);\n      return;\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now verify \" + pairs.size() + \" terms\");\n      for(InputOutput<T> pair : pairs) {\n        assertNotNull(pair);\n        assertNotNull(pair.input);\n        assertNotNull(pair.output);\n        System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n      }\n    }\n\n    assertNotNull(fst);\n\n    // visit valid pairs in order -- make sure all words\n    // are accepted, and FSTEnum's next() steps through\n    // them correctly\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: check valid terms/next()\");\n    }\n    {\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      for(InputOutput<T> pair : pairs) {\n        IntsRef term = pair.input;\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: check term=\" + inputToString(inputMode, term) + \" output=\" + fst.outputs.outputToString(pair.output));\n        }\n        T output = run(fst, term, null);\n        assertNotNull(\"term \" + inputToString(inputMode, term) + \" is not accepted\", output);\n        assertTrue(outputsEqual(pair.output, output));\n\n        // verify enum's next\n        IntsRefFSTEnum.InputOutput<T> t = fstEnum.next();\n        assertNotNull(t);\n        assertEquals(\"expected input=\" + inputToString(inputMode, term) + \" but fstEnum returned \" + inputToString(inputMode, t.input), term, t.input);\n        assertTrue(outputsEqual(pair.output, t.output));\n      }\n      assertNull(fstEnum.next());\n    }\n\n    final Map<IntsRef,T> termsMap = new HashMap<IntsRef,T>();\n    for(InputOutput<T> pair : pairs) {\n      termsMap.put(pair.input, pair.output);\n    }\n\n    if (doReverseLookup && maxLong > minLong) {\n      // Do random lookups so we test null (output doesn't\n      // exist) case:\n      assertNull(Util.getByOutput(fstLong, minLong-7));\n      assertNull(Util.getByOutput(fstLong, maxLong+7));\n\n      final int num = LuceneTestCase.atLeast(random, 100);\n      for(int iter=0;iter<num;iter++) {\n        Long v = _TestUtil.nextLong(random, minLong, maxLong);\n        IntsRef input = Util.getByOutput(fstLong, v);\n        assertTrue(validOutputs.contains(v) || input == null);\n      }\n    }\n\n    // find random matching word and make sure it's valid\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify random accepted terms\");\n    }\n    final IntsRef scratch = new IntsRef(10);\n    int num = LuceneTestCase.atLeast(random, 500);\n    for(int iter=0;iter<num;iter++) {\n      T output = randomAcceptedWord(fst, scratch);\n      assertTrue(\"accepted word \" + inputToString(inputMode, scratch) + \" is not valid\", termsMap.containsKey(scratch));\n      assertTrue(outputsEqual(termsMap.get(scratch), output));\n\n      if (doReverseLookup) {\n        //System.out.println(\"lookup output=\" + output + \" outs=\" + fst.outputs);\n        IntsRef input = Util.getByOutput(fstLong, (Long) output);\n        assertNotNull(input);\n        //System.out.println(\"  got \" + Util.toBytesRef(input, new BytesRef()).utf8ToString());\n        assertEquals(scratch, input);\n      }\n    }\n    \n    // test IntsRefFSTEnum.seek:\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify seek\");\n    }\n    IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  iter=\" + iter);\n      }\n      if (random.nextBoolean()) {\n        // seek to term that doesn't exist:\n        while(true) {\n          final IntsRef term = toIntsRef(getRandomString(random), inputMode);\n          int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n          if (pos < 0) {\n            pos = -(pos+1);\n            // ok doesn't exist\n            //System.out.println(\"  seek \" + inputToString(inputMode, term));\n            final IntsRefFSTEnum.InputOutput<T> seekResult;\n            if (random.nextInt(3) == 0) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekExact term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekExact(term);\n              pos = -1;\n            } else if (random.nextBoolean()) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekFloor term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekFloor(term);\n              pos--;\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekCeil term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekCeil(term);\n            }\n\n            if (pos != -1 && pos < pairs.size()) {\n              //System.out.println(\"    got \" + inputToString(inputMode,seekResult.input) + \" output=\" + fst.outputs.outputToString(seekResult.output));\n              assertNotNull(\"got null but expected term=\" + inputToString(inputMode, pairs.get(pos).input), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got \" + inputToString(inputMode, seekResult.input));\n              }\n              assertEquals(\"expected \" + inputToString(inputMode, pairs.get(pos).input) + \" but got \" + inputToString(inputMode, seekResult.input), pairs.get(pos).input, seekResult.input);\n              assertTrue(outputsEqual(pairs.get(pos).output, seekResult.output));\n            } else {\n              // seeked before start or beyond end\n              //System.out.println(\"seek=\" + seekTerm);\n              assertNull(\"expected null but got \" + (seekResult==null ? \"null\" : inputToString(inputMode, seekResult.input)), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got null\");\n              }\n            }\n\n            break;\n          }\n        }\n      } else {\n        // seek to term that does exist:\n        InputOutput<T> pair = pairs.get(random.nextInt(pairs.size()));\n        final IntsRefFSTEnum.InputOutput<T> seekResult;\n        if (random.nextInt(3) == 2) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekExact term=\" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekExact(pair.input);\n        } else if (random.nextBoolean()) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekFloor \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekFloor(pair.input);\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekCeil \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekCeil(pair.input);\n        }\n        assertNotNull(seekResult);\n        assertEquals(\"got \" + inputToString(inputMode, seekResult.input) + \" but expected \" + inputToString(inputMode, pair.input), pair.input, seekResult.input);\n        assertTrue(outputsEqual(pair.output, seekResult.output));\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: mixed next/seek\");\n    }\n\n    // test mixed next/seek\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: iter \" + iter);\n      }\n      // reset:\n      fstEnum = new IntsRefFSTEnum<T>(fst);\n      int upto = -1;\n      while(true) {\n        boolean isDone = false;\n        if (upto == pairs.size()-1 || random.nextBoolean()) {\n          // next\n          upto++;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do next\");\n          }\n          isDone = fstEnum.next() == null;\n        } else if (upto != -1 && upto < 0.75 * pairs.size() && random.nextBoolean()) {\n          int attempt = 0;\n          for(;attempt<10;attempt++) {\n            IntsRef term = toIntsRef(getRandomString(random), inputMode);\n            if (!termsMap.containsKey(term) && term.compareTo(pairs.get(upto).input) > 0) {\n              int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n              assert pos < 0;\n              upto = -(pos+1);\n\n              if (random.nextBoolean()) {\n                upto--;\n                assertTrue(upto != -1);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekFloor(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekFloor(term) == null;\n              } else {\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekCeil(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekCeil(term) == null;\n              }\n\n              break;\n            }\n          }\n          if (attempt == 10) {\n            continue;\n          }\n            \n        } else {\n          final int inc = random.nextInt(pairs.size() - upto - 1);\n          upto += inc;\n          if (upto == -1) {\n            upto = 0;\n          }\n\n          if (random.nextBoolean()) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekCeil(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekCeil(pairs.get(upto).input) == null;\n          } else {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekFloor(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekFloor(pairs.get(upto).input) == null;\n          }\n        }\n        if (LuceneTestCase.VERBOSE) {\n          if (!isDone) {\n            System.out.println(\"    got \" + inputToString(inputMode, fstEnum.current().input));\n          } else {\n            System.out.println(\"    got null\");\n          }\n        }\n\n        if (upto == pairs.size()) {\n          assertTrue(isDone);\n          break;\n        } else {\n          assertFalse(isDone);\n          assertEquals(pairs.get(upto).input, fstEnum.current().input);\n          assertTrue(outputsEqual(pairs.get(upto).output, fstEnum.current().output));\n\n          /*\n            if (upto < pairs.size()-1) {\n            int tryCount = 0;\n            while(tryCount < 10) {\n            final IntsRef t = toIntsRef(getRandomString(), inputMode);\n            if (pairs.get(upto).input.compareTo(t) < 0) {\n            final boolean expected = t.compareTo(pairs.get(upto+1).input) < 0;\n            if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"TEST: call beforeNext(\" + inputToString(inputMode, t) + \"); current=\" + inputToString(inputMode, pairs.get(upto).input) + \" next=\" + inputToString(inputMode, pairs.get(upto+1).input) + \" expected=\" + expected);\n            }\n            assertEquals(expected, fstEnum.beforeNext(t));\n            break;\n            }\n            tryCount++;\n            }\n            }\n          */\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#verifyUnPruned(int,FST[T]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#verifyUnPruned(int,FST[T]).mjava","sourceNew":"  // FST is complete\n  private void verifyUnPruned(int inputMode, FST<T> fst) throws IOException {\n\n    final FST<Long> fstLong;\n    final Set<Long> validOutputs;\n    long minLong = Long.MAX_VALUE;\n    long maxLong = Long.MIN_VALUE;\n\n    if (doReverseLookup) {\n      @SuppressWarnings(\"unchecked\") FST<Long> fstLong0 = (FST<Long>) fst;\n      fstLong = fstLong0;\n      validOutputs = new HashSet<>();\n      for(InputOutput<T> pair: pairs) {\n        Long output = (Long) pair.output;\n        maxLong = Math.max(maxLong, output);\n        minLong = Math.min(minLong, output);\n        validOutputs.add(output);\n      }\n    } else {\n      fstLong = null;\n      validOutputs = null;\n    }\n\n    if (pairs.size() == 0) {\n      assertNull(fst);\n      return;\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now verify \" + pairs.size() + \" terms\");\n      for(InputOutput<T> pair : pairs) {\n        assertNotNull(pair);\n        assertNotNull(pair.input);\n        assertNotNull(pair.output);\n        System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n      }\n    }\n\n    assertNotNull(fst);\n\n    // visit valid pairs in order -- make sure all words\n    // are accepted, and FSTEnum's next() steps through\n    // them correctly\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: check valid terms/next()\");\n    }\n    {\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<>(fst);\n      for(InputOutput<T> pair : pairs) {\n        IntsRef term = pair.input;\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: check term=\" + inputToString(inputMode, term) + \" output=\" + fst.outputs.outputToString(pair.output));\n        }\n        T output = run(fst, term, null);\n        assertNotNull(\"term \" + inputToString(inputMode, term) + \" is not accepted\", output);\n        assertTrue(outputsEqual(pair.output, output));\n\n        // verify enum's next\n        IntsRefFSTEnum.InputOutput<T> t = fstEnum.next();\n        assertNotNull(t);\n        assertEquals(\"expected input=\" + inputToString(inputMode, term) + \" but fstEnum returned \" + inputToString(inputMode, t.input), term, t.input);\n        assertTrue(outputsEqual(pair.output, t.output));\n      }\n      assertNull(fstEnum.next());\n    }\n\n    final Map<IntsRef,T> termsMap = new HashMap<>();\n    for(InputOutput<T> pair : pairs) {\n      termsMap.put(pair.input, pair.output);\n    }\n\n    if (doReverseLookup && maxLong > minLong) {\n      // Do random lookups so we test null (output doesn't\n      // exist) case:\n      assertNull(Util.getByOutput(fstLong, minLong-7));\n      assertNull(Util.getByOutput(fstLong, maxLong+7));\n\n      final int num = LuceneTestCase.atLeast(random, 100);\n      for(int iter=0;iter<num;iter++) {\n        Long v = TestUtil.nextLong(random, minLong, maxLong);\n        IntsRef input = Util.getByOutput(fstLong, v);\n        assertTrue(validOutputs.contains(v) || input == null);\n      }\n    }\n\n    // find random matching word and make sure it's valid\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify random accepted terms\");\n    }\n    final IntsRef scratch = new IntsRef(10);\n    int num = LuceneTestCase.atLeast(random, 500);\n    for(int iter=0;iter<num;iter++) {\n      T output = randomAcceptedWord(fst, scratch);\n      assertTrue(\"accepted word \" + inputToString(inputMode, scratch) + \" is not valid\", termsMap.containsKey(scratch));\n      assertTrue(outputsEqual(termsMap.get(scratch), output));\n\n      if (doReverseLookup) {\n        //System.out.println(\"lookup output=\" + output + \" outs=\" + fst.outputs);\n        IntsRef input = Util.getByOutput(fstLong, (Long) output);\n        assertNotNull(input);\n        //System.out.println(\"  got \" + Util.toBytesRef(input, new BytesRef()).utf8ToString());\n        assertEquals(scratch, input);\n      }\n    }\n    \n    // test IntsRefFSTEnum.seek:\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify seek\");\n    }\n    IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<>(fst);\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  iter=\" + iter);\n      }\n      if (random.nextBoolean()) {\n        // seek to term that doesn't exist:\n        while(true) {\n          final IntsRef term = toIntsRef(getRandomString(random), inputMode);\n          int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n          if (pos < 0) {\n            pos = -(pos+1);\n            // ok doesn't exist\n            //System.out.println(\"  seek \" + inputToString(inputMode, term));\n            final IntsRefFSTEnum.InputOutput<T> seekResult;\n            if (random.nextInt(3) == 0) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekExact term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekExact(term);\n              pos = -1;\n            } else if (random.nextBoolean()) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekFloor term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekFloor(term);\n              pos--;\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekCeil term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekCeil(term);\n            }\n\n            if (pos != -1 && pos < pairs.size()) {\n              //System.out.println(\"    got \" + inputToString(inputMode,seekResult.input) + \" output=\" + fst.outputs.outputToString(seekResult.output));\n              assertNotNull(\"got null but expected term=\" + inputToString(inputMode, pairs.get(pos).input), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got \" + inputToString(inputMode, seekResult.input));\n              }\n              assertEquals(\"expected \" + inputToString(inputMode, pairs.get(pos).input) + \" but got \" + inputToString(inputMode, seekResult.input), pairs.get(pos).input, seekResult.input);\n              assertTrue(outputsEqual(pairs.get(pos).output, seekResult.output));\n            } else {\n              // seeked before start or beyond end\n              //System.out.println(\"seek=\" + seekTerm);\n              assertNull(\"expected null but got \" + (seekResult==null ? \"null\" : inputToString(inputMode, seekResult.input)), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got null\");\n              }\n            }\n\n            break;\n          }\n        }\n      } else {\n        // seek to term that does exist:\n        InputOutput<T> pair = pairs.get(random.nextInt(pairs.size()));\n        final IntsRefFSTEnum.InputOutput<T> seekResult;\n        if (random.nextInt(3) == 2) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekExact term=\" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekExact(pair.input);\n        } else if (random.nextBoolean()) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekFloor \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekFloor(pair.input);\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekCeil \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekCeil(pair.input);\n        }\n        assertNotNull(seekResult);\n        assertEquals(\"got \" + inputToString(inputMode, seekResult.input) + \" but expected \" + inputToString(inputMode, pair.input), pair.input, seekResult.input);\n        assertTrue(outputsEqual(pair.output, seekResult.output));\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: mixed next/seek\");\n    }\n\n    // test mixed next/seek\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: iter \" + iter);\n      }\n      // reset:\n      fstEnum = new IntsRefFSTEnum<>(fst);\n      int upto = -1;\n      while(true) {\n        boolean isDone = false;\n        if (upto == pairs.size()-1 || random.nextBoolean()) {\n          // next\n          upto++;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do next\");\n          }\n          isDone = fstEnum.next() == null;\n        } else if (upto != -1 && upto < 0.75 * pairs.size() && random.nextBoolean()) {\n          int attempt = 0;\n          for(;attempt<10;attempt++) {\n            IntsRef term = toIntsRef(getRandomString(random), inputMode);\n            if (!termsMap.containsKey(term) && term.compareTo(pairs.get(upto).input) > 0) {\n              int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n              assert pos < 0;\n              upto = -(pos+1);\n\n              if (random.nextBoolean()) {\n                upto--;\n                assertTrue(upto != -1);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekFloor(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekFloor(term) == null;\n              } else {\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekCeil(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekCeil(term) == null;\n              }\n\n              break;\n            }\n          }\n          if (attempt == 10) {\n            continue;\n          }\n            \n        } else {\n          final int inc = random.nextInt(pairs.size() - upto - 1);\n          upto += inc;\n          if (upto == -1) {\n            upto = 0;\n          }\n\n          if (random.nextBoolean()) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekCeil(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekCeil(pairs.get(upto).input) == null;\n          } else {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekFloor(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekFloor(pairs.get(upto).input) == null;\n          }\n        }\n        if (LuceneTestCase.VERBOSE) {\n          if (!isDone) {\n            System.out.println(\"    got \" + inputToString(inputMode, fstEnum.current().input));\n          } else {\n            System.out.println(\"    got null\");\n          }\n        }\n\n        if (upto == pairs.size()) {\n          assertTrue(isDone);\n          break;\n        } else {\n          assertFalse(isDone);\n          assertEquals(pairs.get(upto).input, fstEnum.current().input);\n          assertTrue(outputsEqual(pairs.get(upto).output, fstEnum.current().output));\n\n          /*\n            if (upto < pairs.size()-1) {\n            int tryCount = 0;\n            while(tryCount < 10) {\n            final IntsRef t = toIntsRef(getRandomString(), inputMode);\n            if (pairs.get(upto).input.compareTo(t) < 0) {\n            final boolean expected = t.compareTo(pairs.get(upto+1).input) < 0;\n            if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"TEST: call beforeNext(\" + inputToString(inputMode, t) + \"); current=\" + inputToString(inputMode, pairs.get(upto).input) + \" next=\" + inputToString(inputMode, pairs.get(upto+1).input) + \" expected=\" + expected);\n            }\n            assertEquals(expected, fstEnum.beforeNext(t));\n            break;\n            }\n            tryCount++;\n            }\n            }\n          */\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // FST is complete\n  private void verifyUnPruned(int inputMode, FST<T> fst) throws IOException {\n\n    final FST<Long> fstLong;\n    final Set<Long> validOutputs;\n    long minLong = Long.MAX_VALUE;\n    long maxLong = Long.MIN_VALUE;\n\n    if (doReverseLookup) {\n      @SuppressWarnings(\"unchecked\") FST<Long> fstLong0 = (FST<Long>) fst;\n      fstLong = fstLong0;\n      validOutputs = new HashSet<Long>();\n      for(InputOutput<T> pair: pairs) {\n        Long output = (Long) pair.output;\n        maxLong = Math.max(maxLong, output);\n        minLong = Math.min(minLong, output);\n        validOutputs.add(output);\n      }\n    } else {\n      fstLong = null;\n      validOutputs = null;\n    }\n\n    if (pairs.size() == 0) {\n      assertNull(fst);\n      return;\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now verify \" + pairs.size() + \" terms\");\n      for(InputOutput<T> pair : pairs) {\n        assertNotNull(pair);\n        assertNotNull(pair.input);\n        assertNotNull(pair.output);\n        System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n      }\n    }\n\n    assertNotNull(fst);\n\n    // visit valid pairs in order -- make sure all words\n    // are accepted, and FSTEnum's next() steps through\n    // them correctly\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: check valid terms/next()\");\n    }\n    {\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      for(InputOutput<T> pair : pairs) {\n        IntsRef term = pair.input;\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: check term=\" + inputToString(inputMode, term) + \" output=\" + fst.outputs.outputToString(pair.output));\n        }\n        T output = run(fst, term, null);\n        assertNotNull(\"term \" + inputToString(inputMode, term) + \" is not accepted\", output);\n        assertTrue(outputsEqual(pair.output, output));\n\n        // verify enum's next\n        IntsRefFSTEnum.InputOutput<T> t = fstEnum.next();\n        assertNotNull(t);\n        assertEquals(\"expected input=\" + inputToString(inputMode, term) + \" but fstEnum returned \" + inputToString(inputMode, t.input), term, t.input);\n        assertTrue(outputsEqual(pair.output, t.output));\n      }\n      assertNull(fstEnum.next());\n    }\n\n    final Map<IntsRef,T> termsMap = new HashMap<IntsRef,T>();\n    for(InputOutput<T> pair : pairs) {\n      termsMap.put(pair.input, pair.output);\n    }\n\n    if (doReverseLookup && maxLong > minLong) {\n      // Do random lookups so we test null (output doesn't\n      // exist) case:\n      assertNull(Util.getByOutput(fstLong, minLong-7));\n      assertNull(Util.getByOutput(fstLong, maxLong+7));\n\n      final int num = LuceneTestCase.atLeast(random, 100);\n      for(int iter=0;iter<num;iter++) {\n        Long v = TestUtil.nextLong(random, minLong, maxLong);\n        IntsRef input = Util.getByOutput(fstLong, v);\n        assertTrue(validOutputs.contains(v) || input == null);\n      }\n    }\n\n    // find random matching word and make sure it's valid\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify random accepted terms\");\n    }\n    final IntsRef scratch = new IntsRef(10);\n    int num = LuceneTestCase.atLeast(random, 500);\n    for(int iter=0;iter<num;iter++) {\n      T output = randomAcceptedWord(fst, scratch);\n      assertTrue(\"accepted word \" + inputToString(inputMode, scratch) + \" is not valid\", termsMap.containsKey(scratch));\n      assertTrue(outputsEqual(termsMap.get(scratch), output));\n\n      if (doReverseLookup) {\n        //System.out.println(\"lookup output=\" + output + \" outs=\" + fst.outputs);\n        IntsRef input = Util.getByOutput(fstLong, (Long) output);\n        assertNotNull(input);\n        //System.out.println(\"  got \" + Util.toBytesRef(input, new BytesRef()).utf8ToString());\n        assertEquals(scratch, input);\n      }\n    }\n    \n    // test IntsRefFSTEnum.seek:\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify seek\");\n    }\n    IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  iter=\" + iter);\n      }\n      if (random.nextBoolean()) {\n        // seek to term that doesn't exist:\n        while(true) {\n          final IntsRef term = toIntsRef(getRandomString(random), inputMode);\n          int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n          if (pos < 0) {\n            pos = -(pos+1);\n            // ok doesn't exist\n            //System.out.println(\"  seek \" + inputToString(inputMode, term));\n            final IntsRefFSTEnum.InputOutput<T> seekResult;\n            if (random.nextInt(3) == 0) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekExact term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekExact(term);\n              pos = -1;\n            } else if (random.nextBoolean()) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekFloor term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekFloor(term);\n              pos--;\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekCeil term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekCeil(term);\n            }\n\n            if (pos != -1 && pos < pairs.size()) {\n              //System.out.println(\"    got \" + inputToString(inputMode,seekResult.input) + \" output=\" + fst.outputs.outputToString(seekResult.output));\n              assertNotNull(\"got null but expected term=\" + inputToString(inputMode, pairs.get(pos).input), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got \" + inputToString(inputMode, seekResult.input));\n              }\n              assertEquals(\"expected \" + inputToString(inputMode, pairs.get(pos).input) + \" but got \" + inputToString(inputMode, seekResult.input), pairs.get(pos).input, seekResult.input);\n              assertTrue(outputsEqual(pairs.get(pos).output, seekResult.output));\n            } else {\n              // seeked before start or beyond end\n              //System.out.println(\"seek=\" + seekTerm);\n              assertNull(\"expected null but got \" + (seekResult==null ? \"null\" : inputToString(inputMode, seekResult.input)), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got null\");\n              }\n            }\n\n            break;\n          }\n        }\n      } else {\n        // seek to term that does exist:\n        InputOutput<T> pair = pairs.get(random.nextInt(pairs.size()));\n        final IntsRefFSTEnum.InputOutput<T> seekResult;\n        if (random.nextInt(3) == 2) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekExact term=\" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekExact(pair.input);\n        } else if (random.nextBoolean()) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekFloor \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekFloor(pair.input);\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekCeil \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekCeil(pair.input);\n        }\n        assertNotNull(seekResult);\n        assertEquals(\"got \" + inputToString(inputMode, seekResult.input) + \" but expected \" + inputToString(inputMode, pair.input), pair.input, seekResult.input);\n        assertTrue(outputsEqual(pair.output, seekResult.output));\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: mixed next/seek\");\n    }\n\n    // test mixed next/seek\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: iter \" + iter);\n      }\n      // reset:\n      fstEnum = new IntsRefFSTEnum<T>(fst);\n      int upto = -1;\n      while(true) {\n        boolean isDone = false;\n        if (upto == pairs.size()-1 || random.nextBoolean()) {\n          // next\n          upto++;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do next\");\n          }\n          isDone = fstEnum.next() == null;\n        } else if (upto != -1 && upto < 0.75 * pairs.size() && random.nextBoolean()) {\n          int attempt = 0;\n          for(;attempt<10;attempt++) {\n            IntsRef term = toIntsRef(getRandomString(random), inputMode);\n            if (!termsMap.containsKey(term) && term.compareTo(pairs.get(upto).input) > 0) {\n              int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n              assert pos < 0;\n              upto = -(pos+1);\n\n              if (random.nextBoolean()) {\n                upto--;\n                assertTrue(upto != -1);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekFloor(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekFloor(term) == null;\n              } else {\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekCeil(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekCeil(term) == null;\n              }\n\n              break;\n            }\n          }\n          if (attempt == 10) {\n            continue;\n          }\n            \n        } else {\n          final int inc = random.nextInt(pairs.size() - upto - 1);\n          upto += inc;\n          if (upto == -1) {\n            upto = 0;\n          }\n\n          if (random.nextBoolean()) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekCeil(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekCeil(pairs.get(upto).input) == null;\n          } else {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekFloor(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekFloor(pairs.get(upto).input) == null;\n          }\n        }\n        if (LuceneTestCase.VERBOSE) {\n          if (!isDone) {\n            System.out.println(\"    got \" + inputToString(inputMode, fstEnum.current().input));\n          } else {\n            System.out.println(\"    got null\");\n          }\n        }\n\n        if (upto == pairs.size()) {\n          assertTrue(isDone);\n          break;\n        } else {\n          assertFalse(isDone);\n          assertEquals(pairs.get(upto).input, fstEnum.current().input);\n          assertTrue(outputsEqual(pairs.get(upto).output, fstEnum.current().output));\n\n          /*\n            if (upto < pairs.size()-1) {\n            int tryCount = 0;\n            while(tryCount < 10) {\n            final IntsRef t = toIntsRef(getRandomString(), inputMode);\n            if (pairs.get(upto).input.compareTo(t) < 0) {\n            final boolean expected = t.compareTo(pairs.get(upto+1).input) < 0;\n            if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"TEST: call beforeNext(\" + inputToString(inputMode, t) + \"); current=\" + inputToString(inputMode, pairs.get(upto).input) + \" next=\" + inputToString(inputMode, pairs.get(upto+1).input) + \" expected=\" + expected);\n            }\n            assertEquals(expected, fstEnum.beforeNext(t));\n            break;\n            }\n            tryCount++;\n            }\n            }\n          */\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#verifyUnPruned(int,FST[T]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#verifyUnPruned(int,FST[T]).mjava","sourceNew":"  // FST is complete\n  private void verifyUnPruned(int inputMode, FST<T> fst) throws IOException {\n\n    final FST<Long> fstLong;\n    final Set<Long> validOutputs;\n    long minLong = Long.MAX_VALUE;\n    long maxLong = Long.MIN_VALUE;\n\n    if (doReverseLookup) {\n      @SuppressWarnings(\"unchecked\") FST<Long> fstLong0 = (FST<Long>) fst;\n      fstLong = fstLong0;\n      validOutputs = new HashSet<>();\n      for(InputOutput<T> pair: pairs) {\n        Long output = (Long) pair.output;\n        maxLong = Math.max(maxLong, output);\n        minLong = Math.min(minLong, output);\n        validOutputs.add(output);\n      }\n    } else {\n      fstLong = null;\n      validOutputs = null;\n    }\n\n    if (pairs.size() == 0) {\n      assertNull(fst);\n      return;\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now verify \" + pairs.size() + \" terms\");\n      for(InputOutput<T> pair : pairs) {\n        assertNotNull(pair);\n        assertNotNull(pair.input);\n        assertNotNull(pair.output);\n        System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n      }\n    }\n\n    assertNotNull(fst);\n\n    // visit valid pairs in order -- make sure all words\n    // are accepted, and FSTEnum's next() steps through\n    // them correctly\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: check valid terms/next()\");\n    }\n    {\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<>(fst);\n      for(InputOutput<T> pair : pairs) {\n        IntsRef term = pair.input;\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: check term=\" + inputToString(inputMode, term) + \" output=\" + fst.outputs.outputToString(pair.output));\n        }\n        T output = run(fst, term, null);\n        assertNotNull(\"term \" + inputToString(inputMode, term) + \" is not accepted\", output);\n        assertTrue(outputsEqual(pair.output, output));\n\n        // verify enum's next\n        IntsRefFSTEnum.InputOutput<T> t = fstEnum.next();\n        assertNotNull(t);\n        assertEquals(\"expected input=\" + inputToString(inputMode, term) + \" but fstEnum returned \" + inputToString(inputMode, t.input), term, t.input);\n        assertTrue(outputsEqual(pair.output, t.output));\n      }\n      assertNull(fstEnum.next());\n    }\n\n    final Map<IntsRef,T> termsMap = new HashMap<>();\n    for(InputOutput<T> pair : pairs) {\n      termsMap.put(pair.input, pair.output);\n    }\n\n    if (doReverseLookup && maxLong > minLong) {\n      // Do random lookups so we test null (output doesn't\n      // exist) case:\n      assertNull(Util.getByOutput(fstLong, minLong-7));\n      assertNull(Util.getByOutput(fstLong, maxLong+7));\n\n      final int num = LuceneTestCase.atLeast(random, 100);\n      for(int iter=0;iter<num;iter++) {\n        Long v = TestUtil.nextLong(random, minLong, maxLong);\n        IntsRef input = Util.getByOutput(fstLong, v);\n        assertTrue(validOutputs.contains(v) || input == null);\n      }\n    }\n\n    // find random matching word and make sure it's valid\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify random accepted terms\");\n    }\n    final IntsRefBuilder scratch = new IntsRefBuilder();\n    int num = LuceneTestCase.atLeast(random, 500);\n    for(int iter=0;iter<num;iter++) {\n      T output = randomAcceptedWord(fst, scratch);\n      assertTrue(\"accepted word \" + inputToString(inputMode, scratch.get()) + \" is not valid\", termsMap.containsKey(scratch.get()));\n      assertTrue(outputsEqual(termsMap.get(scratch.get()), output));\n\n      if (doReverseLookup) {\n        //System.out.println(\"lookup output=\" + output + \" outs=\" + fst.outputs);\n        IntsRef input = Util.getByOutput(fstLong, (Long) output);\n        assertNotNull(input);\n        //System.out.println(\"  got \" + Util.toBytesRef(input, new BytesRef()).utf8ToString());\n        assertEquals(scratch.get(), input);\n      }\n    }\n    \n    // test IntsRefFSTEnum.seek:\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify seek\");\n    }\n    IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<>(fst);\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  iter=\" + iter);\n      }\n      if (random.nextBoolean()) {\n        // seek to term that doesn't exist:\n        while(true) {\n          final IntsRef term = toIntsRef(getRandomString(random), inputMode);\n          int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n          if (pos < 0) {\n            pos = -(pos+1);\n            // ok doesn't exist\n            //System.out.println(\"  seek \" + inputToString(inputMode, term));\n            final IntsRefFSTEnum.InputOutput<T> seekResult;\n            if (random.nextInt(3) == 0) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekExact term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekExact(term);\n              pos = -1;\n            } else if (random.nextBoolean()) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekFloor term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekFloor(term);\n              pos--;\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekCeil term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekCeil(term);\n            }\n\n            if (pos != -1 && pos < pairs.size()) {\n              //System.out.println(\"    got \" + inputToString(inputMode,seekResult.input) + \" output=\" + fst.outputs.outputToString(seekResult.output));\n              assertNotNull(\"got null but expected term=\" + inputToString(inputMode, pairs.get(pos).input), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got \" + inputToString(inputMode, seekResult.input));\n              }\n              assertEquals(\"expected \" + inputToString(inputMode, pairs.get(pos).input) + \" but got \" + inputToString(inputMode, seekResult.input), pairs.get(pos).input, seekResult.input);\n              assertTrue(outputsEqual(pairs.get(pos).output, seekResult.output));\n            } else {\n              // seeked before start or beyond end\n              //System.out.println(\"seek=\" + seekTerm);\n              assertNull(\"expected null but got \" + (seekResult==null ? \"null\" : inputToString(inputMode, seekResult.input)), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got null\");\n              }\n            }\n\n            break;\n          }\n        }\n      } else {\n        // seek to term that does exist:\n        InputOutput<T> pair = pairs.get(random.nextInt(pairs.size()));\n        final IntsRefFSTEnum.InputOutput<T> seekResult;\n        if (random.nextInt(3) == 2) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekExact term=\" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekExact(pair.input);\n        } else if (random.nextBoolean()) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekFloor \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekFloor(pair.input);\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekCeil \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekCeil(pair.input);\n        }\n        assertNotNull(seekResult);\n        assertEquals(\"got \" + inputToString(inputMode, seekResult.input) + \" but expected \" + inputToString(inputMode, pair.input), pair.input, seekResult.input);\n        assertTrue(outputsEqual(pair.output, seekResult.output));\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: mixed next/seek\");\n    }\n\n    // test mixed next/seek\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: iter \" + iter);\n      }\n      // reset:\n      fstEnum = new IntsRefFSTEnum<>(fst);\n      int upto = -1;\n      while(true) {\n        boolean isDone = false;\n        if (upto == pairs.size()-1 || random.nextBoolean()) {\n          // next\n          upto++;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do next\");\n          }\n          isDone = fstEnum.next() == null;\n        } else if (upto != -1 && upto < 0.75 * pairs.size() && random.nextBoolean()) {\n          int attempt = 0;\n          for(;attempt<10;attempt++) {\n            IntsRef term = toIntsRef(getRandomString(random), inputMode);\n            if (!termsMap.containsKey(term) && term.compareTo(pairs.get(upto).input) > 0) {\n              int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n              assert pos < 0;\n              upto = -(pos+1);\n\n              if (random.nextBoolean()) {\n                upto--;\n                assertTrue(upto != -1);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekFloor(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekFloor(term) == null;\n              } else {\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekCeil(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekCeil(term) == null;\n              }\n\n              break;\n            }\n          }\n          if (attempt == 10) {\n            continue;\n          }\n            \n        } else {\n          final int inc = random.nextInt(pairs.size() - upto - 1);\n          upto += inc;\n          if (upto == -1) {\n            upto = 0;\n          }\n\n          if (random.nextBoolean()) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekCeil(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekCeil(pairs.get(upto).input) == null;\n          } else {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekFloor(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekFloor(pairs.get(upto).input) == null;\n          }\n        }\n        if (LuceneTestCase.VERBOSE) {\n          if (!isDone) {\n            System.out.println(\"    got \" + inputToString(inputMode, fstEnum.current().input));\n          } else {\n            System.out.println(\"    got null\");\n          }\n        }\n\n        if (upto == pairs.size()) {\n          assertTrue(isDone);\n          break;\n        } else {\n          assertFalse(isDone);\n          assertEquals(pairs.get(upto).input, fstEnum.current().input);\n          assertTrue(outputsEqual(pairs.get(upto).output, fstEnum.current().output));\n\n          /*\n            if (upto < pairs.size()-1) {\n            int tryCount = 0;\n            while(tryCount < 10) {\n            final IntsRef t = toIntsRef(getRandomString(), inputMode);\n            if (pairs.get(upto).input.compareTo(t) < 0) {\n            final boolean expected = t.compareTo(pairs.get(upto+1).input) < 0;\n            if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"TEST: call beforeNext(\" + inputToString(inputMode, t) + \"); current=\" + inputToString(inputMode, pairs.get(upto).input) + \" next=\" + inputToString(inputMode, pairs.get(upto+1).input) + \" expected=\" + expected);\n            }\n            assertEquals(expected, fstEnum.beforeNext(t));\n            break;\n            }\n            tryCount++;\n            }\n            }\n          */\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // FST is complete\n  private void verifyUnPruned(int inputMode, FST<T> fst) throws IOException {\n\n    final FST<Long> fstLong;\n    final Set<Long> validOutputs;\n    long minLong = Long.MAX_VALUE;\n    long maxLong = Long.MIN_VALUE;\n\n    if (doReverseLookup) {\n      @SuppressWarnings(\"unchecked\") FST<Long> fstLong0 = (FST<Long>) fst;\n      fstLong = fstLong0;\n      validOutputs = new HashSet<>();\n      for(InputOutput<T> pair: pairs) {\n        Long output = (Long) pair.output;\n        maxLong = Math.max(maxLong, output);\n        minLong = Math.min(minLong, output);\n        validOutputs.add(output);\n      }\n    } else {\n      fstLong = null;\n      validOutputs = null;\n    }\n\n    if (pairs.size() == 0) {\n      assertNull(fst);\n      return;\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now verify \" + pairs.size() + \" terms\");\n      for(InputOutput<T> pair : pairs) {\n        assertNotNull(pair);\n        assertNotNull(pair.input);\n        assertNotNull(pair.output);\n        System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n      }\n    }\n\n    assertNotNull(fst);\n\n    // visit valid pairs in order -- make sure all words\n    // are accepted, and FSTEnum's next() steps through\n    // them correctly\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: check valid terms/next()\");\n    }\n    {\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<>(fst);\n      for(InputOutput<T> pair : pairs) {\n        IntsRef term = pair.input;\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: check term=\" + inputToString(inputMode, term) + \" output=\" + fst.outputs.outputToString(pair.output));\n        }\n        T output = run(fst, term, null);\n        assertNotNull(\"term \" + inputToString(inputMode, term) + \" is not accepted\", output);\n        assertTrue(outputsEqual(pair.output, output));\n\n        // verify enum's next\n        IntsRefFSTEnum.InputOutput<T> t = fstEnum.next();\n        assertNotNull(t);\n        assertEquals(\"expected input=\" + inputToString(inputMode, term) + \" but fstEnum returned \" + inputToString(inputMode, t.input), term, t.input);\n        assertTrue(outputsEqual(pair.output, t.output));\n      }\n      assertNull(fstEnum.next());\n    }\n\n    final Map<IntsRef,T> termsMap = new HashMap<>();\n    for(InputOutput<T> pair : pairs) {\n      termsMap.put(pair.input, pair.output);\n    }\n\n    if (doReverseLookup && maxLong > minLong) {\n      // Do random lookups so we test null (output doesn't\n      // exist) case:\n      assertNull(Util.getByOutput(fstLong, minLong-7));\n      assertNull(Util.getByOutput(fstLong, maxLong+7));\n\n      final int num = LuceneTestCase.atLeast(random, 100);\n      for(int iter=0;iter<num;iter++) {\n        Long v = TestUtil.nextLong(random, minLong, maxLong);\n        IntsRef input = Util.getByOutput(fstLong, v);\n        assertTrue(validOutputs.contains(v) || input == null);\n      }\n    }\n\n    // find random matching word and make sure it's valid\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify random accepted terms\");\n    }\n    final IntsRef scratch = new IntsRef(10);\n    int num = LuceneTestCase.atLeast(random, 500);\n    for(int iter=0;iter<num;iter++) {\n      T output = randomAcceptedWord(fst, scratch);\n      assertTrue(\"accepted word \" + inputToString(inputMode, scratch) + \" is not valid\", termsMap.containsKey(scratch));\n      assertTrue(outputsEqual(termsMap.get(scratch), output));\n\n      if (doReverseLookup) {\n        //System.out.println(\"lookup output=\" + output + \" outs=\" + fst.outputs);\n        IntsRef input = Util.getByOutput(fstLong, (Long) output);\n        assertNotNull(input);\n        //System.out.println(\"  got \" + Util.toBytesRef(input, new BytesRef()).utf8ToString());\n        assertEquals(scratch, input);\n      }\n    }\n    \n    // test IntsRefFSTEnum.seek:\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify seek\");\n    }\n    IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<>(fst);\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  iter=\" + iter);\n      }\n      if (random.nextBoolean()) {\n        // seek to term that doesn't exist:\n        while(true) {\n          final IntsRef term = toIntsRef(getRandomString(random), inputMode);\n          int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n          if (pos < 0) {\n            pos = -(pos+1);\n            // ok doesn't exist\n            //System.out.println(\"  seek \" + inputToString(inputMode, term));\n            final IntsRefFSTEnum.InputOutput<T> seekResult;\n            if (random.nextInt(3) == 0) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekExact term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekExact(term);\n              pos = -1;\n            } else if (random.nextBoolean()) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekFloor term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekFloor(term);\n              pos--;\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekCeil term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekCeil(term);\n            }\n\n            if (pos != -1 && pos < pairs.size()) {\n              //System.out.println(\"    got \" + inputToString(inputMode,seekResult.input) + \" output=\" + fst.outputs.outputToString(seekResult.output));\n              assertNotNull(\"got null but expected term=\" + inputToString(inputMode, pairs.get(pos).input), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got \" + inputToString(inputMode, seekResult.input));\n              }\n              assertEquals(\"expected \" + inputToString(inputMode, pairs.get(pos).input) + \" but got \" + inputToString(inputMode, seekResult.input), pairs.get(pos).input, seekResult.input);\n              assertTrue(outputsEqual(pairs.get(pos).output, seekResult.output));\n            } else {\n              // seeked before start or beyond end\n              //System.out.println(\"seek=\" + seekTerm);\n              assertNull(\"expected null but got \" + (seekResult==null ? \"null\" : inputToString(inputMode, seekResult.input)), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got null\");\n              }\n            }\n\n            break;\n          }\n        }\n      } else {\n        // seek to term that does exist:\n        InputOutput<T> pair = pairs.get(random.nextInt(pairs.size()));\n        final IntsRefFSTEnum.InputOutput<T> seekResult;\n        if (random.nextInt(3) == 2) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekExact term=\" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekExact(pair.input);\n        } else if (random.nextBoolean()) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekFloor \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekFloor(pair.input);\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekCeil \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekCeil(pair.input);\n        }\n        assertNotNull(seekResult);\n        assertEquals(\"got \" + inputToString(inputMode, seekResult.input) + \" but expected \" + inputToString(inputMode, pair.input), pair.input, seekResult.input);\n        assertTrue(outputsEqual(pair.output, seekResult.output));\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: mixed next/seek\");\n    }\n\n    // test mixed next/seek\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: iter \" + iter);\n      }\n      // reset:\n      fstEnum = new IntsRefFSTEnum<>(fst);\n      int upto = -1;\n      while(true) {\n        boolean isDone = false;\n        if (upto == pairs.size()-1 || random.nextBoolean()) {\n          // next\n          upto++;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do next\");\n          }\n          isDone = fstEnum.next() == null;\n        } else if (upto != -1 && upto < 0.75 * pairs.size() && random.nextBoolean()) {\n          int attempt = 0;\n          for(;attempt<10;attempt++) {\n            IntsRef term = toIntsRef(getRandomString(random), inputMode);\n            if (!termsMap.containsKey(term) && term.compareTo(pairs.get(upto).input) > 0) {\n              int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n              assert pos < 0;\n              upto = -(pos+1);\n\n              if (random.nextBoolean()) {\n                upto--;\n                assertTrue(upto != -1);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekFloor(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekFloor(term) == null;\n              } else {\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekCeil(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekCeil(term) == null;\n              }\n\n              break;\n            }\n          }\n          if (attempt == 10) {\n            continue;\n          }\n            \n        } else {\n          final int inc = random.nextInt(pairs.size() - upto - 1);\n          upto += inc;\n          if (upto == -1) {\n            upto = 0;\n          }\n\n          if (random.nextBoolean()) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekCeil(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekCeil(pairs.get(upto).input) == null;\n          } else {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekFloor(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekFloor(pairs.get(upto).input) == null;\n          }\n        }\n        if (LuceneTestCase.VERBOSE) {\n          if (!isDone) {\n            System.out.println(\"    got \" + inputToString(inputMode, fstEnum.current().input));\n          } else {\n            System.out.println(\"    got null\");\n          }\n        }\n\n        if (upto == pairs.size()) {\n          assertTrue(isDone);\n          break;\n        } else {\n          assertFalse(isDone);\n          assertEquals(pairs.get(upto).input, fstEnum.current().input);\n          assertTrue(outputsEqual(pairs.get(upto).output, fstEnum.current().output));\n\n          /*\n            if (upto < pairs.size()-1) {\n            int tryCount = 0;\n            while(tryCount < 10) {\n            final IntsRef t = toIntsRef(getRandomString(), inputMode);\n            if (pairs.get(upto).input.compareTo(t) < 0) {\n            final boolean expected = t.compareTo(pairs.get(upto+1).input) < 0;\n            if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"TEST: call beforeNext(\" + inputToString(inputMode, t) + \"); current=\" + inputToString(inputMode, pairs.get(upto).input) + \" next=\" + inputToString(inputMode, pairs.get(upto+1).input) + \" expected=\" + expected);\n            }\n            assertEquals(expected, fstEnum.beforeNext(t));\n            break;\n            }\n            tryCount++;\n            }\n            }\n          */\n        }\n      }\n    }\n  }\n\n","bugFix":["5ebe14aae60589c9bb6423f3cce02d5f599e1540"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9","date":1574619880,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#verifyUnPruned(int,FST[T]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#verifyUnPruned(int,FST[T]).mjava","sourceNew":"  // FST is complete\n  @SuppressWarnings(\"deprecation\")\n  private void verifyUnPruned(int inputMode, FST<T> fst) throws IOException {\n\n    final FST<Long> fstLong;\n    final Set<Long> validOutputs;\n    long minLong = Long.MAX_VALUE;\n    long maxLong = Long.MIN_VALUE;\n\n    if (doReverseLookup) {\n      @SuppressWarnings(\"unchecked\") FST<Long> fstLong0 = (FST<Long>) fst;\n      fstLong = fstLong0;\n      validOutputs = new HashSet<>();\n      for(InputOutput<T> pair: pairs) {\n        Long output = (Long) pair.output;\n        maxLong = Math.max(maxLong, output);\n        minLong = Math.min(minLong, output);\n        validOutputs.add(output);\n      }\n    } else {\n      fstLong = null;\n      validOutputs = null;\n    }\n\n    if (pairs.size() == 0) {\n      assertNull(fst);\n      return;\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now verify \" + pairs.size() + \" terms\");\n      for(InputOutput<T> pair : pairs) {\n        assertNotNull(pair);\n        assertNotNull(pair.input);\n        assertNotNull(pair.output);\n        System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n      }\n    }\n\n    assertNotNull(fst);\n\n    // visit valid pairs in order -- make sure all words\n    // are accepted, and FSTEnum's next() steps through\n    // them correctly\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: check valid terms/next()\");\n    }\n    {\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<>(fst);\n      for(InputOutput<T> pair : pairs) {\n        IntsRef term = pair.input;\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: check term=\" + inputToString(inputMode, term) + \" output=\" + fst.outputs.outputToString(pair.output));\n        }\n        T output = run(fst, term, null);\n        assertNotNull(\"term \" + inputToString(inputMode, term) + \" is not accepted\", output);\n        assertTrue(outputsEqual(pair.output, output));\n\n        // verify enum's next\n        IntsRefFSTEnum.InputOutput<T> t = fstEnum.next();\n        assertNotNull(t);\n        assertEquals(\"expected input=\" + inputToString(inputMode, term) + \" but fstEnum returned \" + inputToString(inputMode, t.input), term, t.input);\n        assertTrue(outputsEqual(pair.output, t.output));\n      }\n      assertNull(fstEnum.next());\n    }\n\n    final Map<IntsRef,T> termsMap = new HashMap<>();\n    for(InputOutput<T> pair : pairs) {\n      termsMap.put(pair.input, pair.output);\n    }\n\n    if (doReverseLookup && maxLong > minLong) {\n      // Do random lookups so we test null (output doesn't\n      // exist) case:\n      assertNull(Util.getByOutput(fstLong, minLong-7));\n      assertNull(Util.getByOutput(fstLong, maxLong+7));\n\n      final int num = LuceneTestCase.atLeast(random, 100);\n      for(int iter=0;iter<num;iter++) {\n        Long v = TestUtil.nextLong(random, minLong, maxLong);\n        IntsRef input = Util.getByOutput(fstLong, v);\n        assertTrue(validOutputs.contains(v) || input == null);\n      }\n    }\n\n    // find random matching word and make sure it's valid\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify random accepted terms\");\n    }\n    final IntsRefBuilder scratch = new IntsRefBuilder();\n    int num = LuceneTestCase.atLeast(random, 500);\n    for(int iter=0;iter<num;iter++) {\n      T output = randomAcceptedWord(fst, scratch);\n      assertTrue(\"accepted word \" + inputToString(inputMode, scratch.get()) + \" is not valid\", termsMap.containsKey(scratch.get()));\n      assertTrue(outputsEqual(termsMap.get(scratch.get()), output));\n\n      if (doReverseLookup) {\n        //System.out.println(\"lookup output=\" + output + \" outs=\" + fst.outputs);\n        IntsRef input = Util.getByOutput(fstLong, (Long) output);\n        assertNotNull(input);\n        //System.out.println(\"  got \" + Util.toBytesRef(input, new BytesRef()).utf8ToString());\n        assertEquals(scratch.get(), input);\n      }\n    }\n    \n    // test IntsRefFSTEnum.seek:\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify seek\");\n    }\n    IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<>(fst);\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  iter=\" + iter);\n      }\n      if (random.nextBoolean()) {\n        // seek to term that doesn't exist:\n        while(true) {\n          final IntsRef term = toIntsRef(getRandomString(random), inputMode);\n          int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n          if (pos < 0) {\n            pos = -(pos+1);\n            // ok doesn't exist\n            //System.out.println(\"  seek \" + inputToString(inputMode, term));\n            final IntsRefFSTEnum.InputOutput<T> seekResult;\n            if (random.nextInt(3) == 0) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekExact term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekExact(term);\n              pos = -1;\n            } else if (random.nextBoolean()) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekFloor term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekFloor(term);\n              pos--;\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekCeil term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekCeil(term);\n            }\n\n            if (pos != -1 && pos < pairs.size()) {\n              //System.out.println(\"    got \" + inputToString(inputMode,seekResult.input) + \" output=\" + fst.outputs.outputToString(seekResult.output));\n              assertNotNull(\"got null but expected term=\" + inputToString(inputMode, pairs.get(pos).input), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got \" + inputToString(inputMode, seekResult.input));\n              }\n              assertEquals(\"expected \" + inputToString(inputMode, pairs.get(pos).input) + \" but got \" + inputToString(inputMode, seekResult.input), pairs.get(pos).input, seekResult.input);\n              assertTrue(outputsEqual(pairs.get(pos).output, seekResult.output));\n            } else {\n              // seeked before start or beyond end\n              //System.out.println(\"seek=\" + seekTerm);\n              assertNull(\"expected null but got \" + (seekResult==null ? \"null\" : inputToString(inputMode, seekResult.input)), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got null\");\n              }\n            }\n\n            break;\n          }\n        }\n      } else {\n        // seek to term that does exist:\n        InputOutput<T> pair = pairs.get(random.nextInt(pairs.size()));\n        final IntsRefFSTEnum.InputOutput<T> seekResult;\n        if (random.nextInt(3) == 2) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekExact term=\" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekExact(pair.input);\n        } else if (random.nextBoolean()) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekFloor \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekFloor(pair.input);\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekCeil \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekCeil(pair.input);\n        }\n        assertNotNull(seekResult);\n        assertEquals(\"got \" + inputToString(inputMode, seekResult.input) + \" but expected \" + inputToString(inputMode, pair.input), pair.input, seekResult.input);\n        assertTrue(outputsEqual(pair.output, seekResult.output));\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: mixed next/seek\");\n    }\n\n    // test mixed next/seek\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: iter \" + iter);\n      }\n      // reset:\n      fstEnum = new IntsRefFSTEnum<>(fst);\n      int upto = -1;\n      while(true) {\n        boolean isDone = false;\n        if (upto == pairs.size()-1 || random.nextBoolean()) {\n          // next\n          upto++;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do next\");\n          }\n          isDone = fstEnum.next() == null;\n        } else if (upto != -1 && upto < 0.75 * pairs.size() && random.nextBoolean()) {\n          int attempt = 0;\n          for(;attempt<10;attempt++) {\n            IntsRef term = toIntsRef(getRandomString(random), inputMode);\n            if (!termsMap.containsKey(term) && term.compareTo(pairs.get(upto).input) > 0) {\n              int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n              assert pos < 0;\n              upto = -(pos+1);\n\n              if (random.nextBoolean()) {\n                upto--;\n                assertTrue(upto != -1);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekFloor(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekFloor(term) == null;\n              } else {\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekCeil(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekCeil(term) == null;\n              }\n\n              break;\n            }\n          }\n          if (attempt == 10) {\n            continue;\n          }\n            \n        } else {\n          final int inc = random.nextInt(pairs.size() - upto - 1);\n          upto += inc;\n          if (upto == -1) {\n            upto = 0;\n          }\n\n          if (random.nextBoolean()) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekCeil(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekCeil(pairs.get(upto).input) == null;\n          } else {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekFloor(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekFloor(pairs.get(upto).input) == null;\n          }\n        }\n        if (LuceneTestCase.VERBOSE) {\n          if (!isDone) {\n            System.out.println(\"    got \" + inputToString(inputMode, fstEnum.current().input));\n          } else {\n            System.out.println(\"    got null\");\n          }\n        }\n\n        if (upto == pairs.size()) {\n          assertTrue(isDone);\n          break;\n        } else {\n          assertFalse(isDone);\n          assertEquals(pairs.get(upto).input, fstEnum.current().input);\n          assertTrue(outputsEqual(pairs.get(upto).output, fstEnum.current().output));\n\n          /*\n            if (upto < pairs.size()-1) {\n            int tryCount = 0;\n            while(tryCount < 10) {\n            final IntsRef t = toIntsRef(getRandomString(), inputMode);\n            if (pairs.get(upto).input.compareTo(t) < 0) {\n            final boolean expected = t.compareTo(pairs.get(upto+1).input) < 0;\n            if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"TEST: call beforeNext(\" + inputToString(inputMode, t) + \"); current=\" + inputToString(inputMode, pairs.get(upto).input) + \" next=\" + inputToString(inputMode, pairs.get(upto+1).input) + \" expected=\" + expected);\n            }\n            assertEquals(expected, fstEnum.beforeNext(t));\n            break;\n            }\n            tryCount++;\n            }\n            }\n          */\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // FST is complete\n  private void verifyUnPruned(int inputMode, FST<T> fst) throws IOException {\n\n    final FST<Long> fstLong;\n    final Set<Long> validOutputs;\n    long minLong = Long.MAX_VALUE;\n    long maxLong = Long.MIN_VALUE;\n\n    if (doReverseLookup) {\n      @SuppressWarnings(\"unchecked\") FST<Long> fstLong0 = (FST<Long>) fst;\n      fstLong = fstLong0;\n      validOutputs = new HashSet<>();\n      for(InputOutput<T> pair: pairs) {\n        Long output = (Long) pair.output;\n        maxLong = Math.max(maxLong, output);\n        minLong = Math.min(minLong, output);\n        validOutputs.add(output);\n      }\n    } else {\n      fstLong = null;\n      validOutputs = null;\n    }\n\n    if (pairs.size() == 0) {\n      assertNull(fst);\n      return;\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now verify \" + pairs.size() + \" terms\");\n      for(InputOutput<T> pair : pairs) {\n        assertNotNull(pair);\n        assertNotNull(pair.input);\n        assertNotNull(pair.output);\n        System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n      }\n    }\n\n    assertNotNull(fst);\n\n    // visit valid pairs in order -- make sure all words\n    // are accepted, and FSTEnum's next() steps through\n    // them correctly\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: check valid terms/next()\");\n    }\n    {\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<>(fst);\n      for(InputOutput<T> pair : pairs) {\n        IntsRef term = pair.input;\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: check term=\" + inputToString(inputMode, term) + \" output=\" + fst.outputs.outputToString(pair.output));\n        }\n        T output = run(fst, term, null);\n        assertNotNull(\"term \" + inputToString(inputMode, term) + \" is not accepted\", output);\n        assertTrue(outputsEqual(pair.output, output));\n\n        // verify enum's next\n        IntsRefFSTEnum.InputOutput<T> t = fstEnum.next();\n        assertNotNull(t);\n        assertEquals(\"expected input=\" + inputToString(inputMode, term) + \" but fstEnum returned \" + inputToString(inputMode, t.input), term, t.input);\n        assertTrue(outputsEqual(pair.output, t.output));\n      }\n      assertNull(fstEnum.next());\n    }\n\n    final Map<IntsRef,T> termsMap = new HashMap<>();\n    for(InputOutput<T> pair : pairs) {\n      termsMap.put(pair.input, pair.output);\n    }\n\n    if (doReverseLookup && maxLong > minLong) {\n      // Do random lookups so we test null (output doesn't\n      // exist) case:\n      assertNull(Util.getByOutput(fstLong, minLong-7));\n      assertNull(Util.getByOutput(fstLong, maxLong+7));\n\n      final int num = LuceneTestCase.atLeast(random, 100);\n      for(int iter=0;iter<num;iter++) {\n        Long v = TestUtil.nextLong(random, minLong, maxLong);\n        IntsRef input = Util.getByOutput(fstLong, v);\n        assertTrue(validOutputs.contains(v) || input == null);\n      }\n    }\n\n    // find random matching word and make sure it's valid\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify random accepted terms\");\n    }\n    final IntsRefBuilder scratch = new IntsRefBuilder();\n    int num = LuceneTestCase.atLeast(random, 500);\n    for(int iter=0;iter<num;iter++) {\n      T output = randomAcceptedWord(fst, scratch);\n      assertTrue(\"accepted word \" + inputToString(inputMode, scratch.get()) + \" is not valid\", termsMap.containsKey(scratch.get()));\n      assertTrue(outputsEqual(termsMap.get(scratch.get()), output));\n\n      if (doReverseLookup) {\n        //System.out.println(\"lookup output=\" + output + \" outs=\" + fst.outputs);\n        IntsRef input = Util.getByOutput(fstLong, (Long) output);\n        assertNotNull(input);\n        //System.out.println(\"  got \" + Util.toBytesRef(input, new BytesRef()).utf8ToString());\n        assertEquals(scratch.get(), input);\n      }\n    }\n    \n    // test IntsRefFSTEnum.seek:\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify seek\");\n    }\n    IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<>(fst);\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  iter=\" + iter);\n      }\n      if (random.nextBoolean()) {\n        // seek to term that doesn't exist:\n        while(true) {\n          final IntsRef term = toIntsRef(getRandomString(random), inputMode);\n          int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n          if (pos < 0) {\n            pos = -(pos+1);\n            // ok doesn't exist\n            //System.out.println(\"  seek \" + inputToString(inputMode, term));\n            final IntsRefFSTEnum.InputOutput<T> seekResult;\n            if (random.nextInt(3) == 0) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekExact term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekExact(term);\n              pos = -1;\n            } else if (random.nextBoolean()) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekFloor term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekFloor(term);\n              pos--;\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekCeil term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekCeil(term);\n            }\n\n            if (pos != -1 && pos < pairs.size()) {\n              //System.out.println(\"    got \" + inputToString(inputMode,seekResult.input) + \" output=\" + fst.outputs.outputToString(seekResult.output));\n              assertNotNull(\"got null but expected term=\" + inputToString(inputMode, pairs.get(pos).input), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got \" + inputToString(inputMode, seekResult.input));\n              }\n              assertEquals(\"expected \" + inputToString(inputMode, pairs.get(pos).input) + \" but got \" + inputToString(inputMode, seekResult.input), pairs.get(pos).input, seekResult.input);\n              assertTrue(outputsEqual(pairs.get(pos).output, seekResult.output));\n            } else {\n              // seeked before start or beyond end\n              //System.out.println(\"seek=\" + seekTerm);\n              assertNull(\"expected null but got \" + (seekResult==null ? \"null\" : inputToString(inputMode, seekResult.input)), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got null\");\n              }\n            }\n\n            break;\n          }\n        }\n      } else {\n        // seek to term that does exist:\n        InputOutput<T> pair = pairs.get(random.nextInt(pairs.size()));\n        final IntsRefFSTEnum.InputOutput<T> seekResult;\n        if (random.nextInt(3) == 2) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekExact term=\" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekExact(pair.input);\n        } else if (random.nextBoolean()) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekFloor \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekFloor(pair.input);\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekCeil \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekCeil(pair.input);\n        }\n        assertNotNull(seekResult);\n        assertEquals(\"got \" + inputToString(inputMode, seekResult.input) + \" but expected \" + inputToString(inputMode, pair.input), pair.input, seekResult.input);\n        assertTrue(outputsEqual(pair.output, seekResult.output));\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: mixed next/seek\");\n    }\n\n    // test mixed next/seek\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: iter \" + iter);\n      }\n      // reset:\n      fstEnum = new IntsRefFSTEnum<>(fst);\n      int upto = -1;\n      while(true) {\n        boolean isDone = false;\n        if (upto == pairs.size()-1 || random.nextBoolean()) {\n          // next\n          upto++;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do next\");\n          }\n          isDone = fstEnum.next() == null;\n        } else if (upto != -1 && upto < 0.75 * pairs.size() && random.nextBoolean()) {\n          int attempt = 0;\n          for(;attempt<10;attempt++) {\n            IntsRef term = toIntsRef(getRandomString(random), inputMode);\n            if (!termsMap.containsKey(term) && term.compareTo(pairs.get(upto).input) > 0) {\n              int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n              assert pos < 0;\n              upto = -(pos+1);\n\n              if (random.nextBoolean()) {\n                upto--;\n                assertTrue(upto != -1);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekFloor(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekFloor(term) == null;\n              } else {\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekCeil(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekCeil(term) == null;\n              }\n\n              break;\n            }\n          }\n          if (attempt == 10) {\n            continue;\n          }\n            \n        } else {\n          final int inc = random.nextInt(pairs.size() - upto - 1);\n          upto += inc;\n          if (upto == -1) {\n            upto = 0;\n          }\n\n          if (random.nextBoolean()) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekCeil(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekCeil(pairs.get(upto).input) == null;\n          } else {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekFloor(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekFloor(pairs.get(upto).input) == null;\n          }\n        }\n        if (LuceneTestCase.VERBOSE) {\n          if (!isDone) {\n            System.out.println(\"    got \" + inputToString(inputMode, fstEnum.current().input));\n          } else {\n            System.out.println(\"    got null\");\n          }\n        }\n\n        if (upto == pairs.size()) {\n          assertTrue(isDone);\n          break;\n        } else {\n          assertFalse(isDone);\n          assertEquals(pairs.get(upto).input, fstEnum.current().input);\n          assertTrue(outputsEqual(pairs.get(upto).output, fstEnum.current().output));\n\n          /*\n            if (upto < pairs.size()-1) {\n            int tryCount = 0;\n            while(tryCount < 10) {\n            final IntsRef t = toIntsRef(getRandomString(), inputMode);\n            if (pairs.get(upto).input.compareTo(t) < 0) {\n            final boolean expected = t.compareTo(pairs.get(upto+1).input) < 0;\n            if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"TEST: call beforeNext(\" + inputToString(inputMode, t) + \"); current=\" + inputToString(inputMode, pairs.get(upto).input) + \" next=\" + inputToString(inputMode, pairs.get(upto+1).input) + \" expected=\" + expected);\n            }\n            assertEquals(expected, fstEnum.beforeNext(t));\n            break;\n            }\n            tryCount++;\n            }\n            }\n          */\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb9c3baacabd473e8ecd6c4948aabacead49b88e","date":1574700980,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#verifyUnPruned(int,FST[T]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#verifyUnPruned(int,FST[T]).mjava","sourceNew":"  // FST is complete\n  private void verifyUnPruned(int inputMode, FST<T> fst) throws IOException {\n\n    final FST<Long> fstLong;\n    final Set<Long> validOutputs;\n    long minLong = Long.MAX_VALUE;\n    long maxLong = Long.MIN_VALUE;\n\n    if (doReverseLookup) {\n      @SuppressWarnings(\"unchecked\") FST<Long> fstLong0 = (FST<Long>) fst;\n      fstLong = fstLong0;\n      validOutputs = new HashSet<>();\n      for(InputOutput<T> pair: pairs) {\n        Long output = (Long) pair.output;\n        maxLong = Math.max(maxLong, output);\n        minLong = Math.min(minLong, output);\n        validOutputs.add(output);\n      }\n    } else {\n      fstLong = null;\n      validOutputs = null;\n    }\n\n    if (pairs.size() == 0) {\n      assertNull(fst);\n      return;\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now verify \" + pairs.size() + \" terms\");\n      for(InputOutput<T> pair : pairs) {\n        assertNotNull(pair);\n        assertNotNull(pair.input);\n        assertNotNull(pair.output);\n        System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n      }\n    }\n\n    assertNotNull(fst);\n\n    // visit valid pairs in order -- make sure all words\n    // are accepted, and FSTEnum's next() steps through\n    // them correctly\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: check valid terms/next()\");\n    }\n    {\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<>(fst);\n      for(InputOutput<T> pair : pairs) {\n        IntsRef term = pair.input;\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: check term=\" + inputToString(inputMode, term) + \" output=\" + fst.outputs.outputToString(pair.output));\n        }\n        T output = run(fst, term, null);\n        assertNotNull(\"term \" + inputToString(inputMode, term) + \" is not accepted\", output);\n        assertTrue(outputsEqual(pair.output, output));\n\n        // verify enum's next\n        IntsRefFSTEnum.InputOutput<T> t = fstEnum.next();\n        assertNotNull(t);\n        assertEquals(\"expected input=\" + inputToString(inputMode, term) + \" but fstEnum returned \" + inputToString(inputMode, t.input), term, t.input);\n        assertTrue(outputsEqual(pair.output, t.output));\n      }\n      assertNull(fstEnum.next());\n    }\n\n    final Map<IntsRef,T> termsMap = new HashMap<>();\n    for(InputOutput<T> pair : pairs) {\n      termsMap.put(pair.input, pair.output);\n    }\n\n    if (doReverseLookup && maxLong > minLong) {\n      // Do random lookups so we test null (output doesn't\n      // exist) case:\n      assertNull(Util.getByOutput(fstLong, minLong-7));\n      assertNull(Util.getByOutput(fstLong, maxLong+7));\n\n      final int num = LuceneTestCase.atLeast(random, 100);\n      for(int iter=0;iter<num;iter++) {\n        Long v = TestUtil.nextLong(random, minLong, maxLong);\n        IntsRef input = Util.getByOutput(fstLong, v);\n        assertTrue(validOutputs.contains(v) || input == null);\n      }\n    }\n\n    // find random matching word and make sure it's valid\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify random accepted terms\");\n    }\n    final IntsRefBuilder scratch = new IntsRefBuilder();\n    int num = LuceneTestCase.atLeast(random, 500);\n    for(int iter=0;iter<num;iter++) {\n      T output = randomAcceptedWord(fst, scratch);\n      assertTrue(\"accepted word \" + inputToString(inputMode, scratch.get()) + \" is not valid\", termsMap.containsKey(scratch.get()));\n      assertTrue(outputsEqual(termsMap.get(scratch.get()), output));\n\n      if (doReverseLookup) {\n        //System.out.println(\"lookup output=\" + output + \" outs=\" + fst.outputs);\n        IntsRef input = Util.getByOutput(fstLong, (Long) output);\n        assertNotNull(input);\n        //System.out.println(\"  got \" + Util.toBytesRef(input, new BytesRef()).utf8ToString());\n        assertEquals(scratch.get(), input);\n      }\n    }\n    \n    // test IntsRefFSTEnum.seek:\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify seek\");\n    }\n    IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<>(fst);\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  iter=\" + iter);\n      }\n      if (random.nextBoolean()) {\n        // seek to term that doesn't exist:\n        while(true) {\n          final IntsRef term = toIntsRef(getRandomString(random), inputMode);\n          int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n          if (pos < 0) {\n            pos = -(pos+1);\n            // ok doesn't exist\n            //System.out.println(\"  seek \" + inputToString(inputMode, term));\n            final IntsRefFSTEnum.InputOutput<T> seekResult;\n            if (random.nextInt(3) == 0) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekExact term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekExact(term);\n              pos = -1;\n            } else if (random.nextBoolean()) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekFloor term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekFloor(term);\n              pos--;\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekCeil term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekCeil(term);\n            }\n\n            if (pos != -1 && pos < pairs.size()) {\n              //System.out.println(\"    got \" + inputToString(inputMode,seekResult.input) + \" output=\" + fst.outputs.outputToString(seekResult.output));\n              assertNotNull(\"got null but expected term=\" + inputToString(inputMode, pairs.get(pos).input), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got \" + inputToString(inputMode, seekResult.input));\n              }\n              assertEquals(\"expected \" + inputToString(inputMode, pairs.get(pos).input) + \" but got \" + inputToString(inputMode, seekResult.input), pairs.get(pos).input, seekResult.input);\n              assertTrue(outputsEqual(pairs.get(pos).output, seekResult.output));\n            } else {\n              // seeked before start or beyond end\n              //System.out.println(\"seek=\" + seekTerm);\n              assertNull(\"expected null but got \" + (seekResult==null ? \"null\" : inputToString(inputMode, seekResult.input)), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got null\");\n              }\n            }\n\n            break;\n          }\n        }\n      } else {\n        // seek to term that does exist:\n        InputOutput<T> pair = pairs.get(random.nextInt(pairs.size()));\n        final IntsRefFSTEnum.InputOutput<T> seekResult;\n        if (random.nextInt(3) == 2) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekExact term=\" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekExact(pair.input);\n        } else if (random.nextBoolean()) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekFloor \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekFloor(pair.input);\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekCeil \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekCeil(pair.input);\n        }\n        assertNotNull(seekResult);\n        assertEquals(\"got \" + inputToString(inputMode, seekResult.input) + \" but expected \" + inputToString(inputMode, pair.input), pair.input, seekResult.input);\n        assertTrue(outputsEqual(pair.output, seekResult.output));\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: mixed next/seek\");\n    }\n\n    // test mixed next/seek\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: iter \" + iter);\n      }\n      // reset:\n      fstEnum = new IntsRefFSTEnum<>(fst);\n      int upto = -1;\n      while(true) {\n        boolean isDone = false;\n        if (upto == pairs.size()-1 || random.nextBoolean()) {\n          // next\n          upto++;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do next\");\n          }\n          isDone = fstEnum.next() == null;\n        } else if (upto != -1 && upto < 0.75 * pairs.size() && random.nextBoolean()) {\n          int attempt = 0;\n          for(;attempt<10;attempt++) {\n            IntsRef term = toIntsRef(getRandomString(random), inputMode);\n            if (!termsMap.containsKey(term) && term.compareTo(pairs.get(upto).input) > 0) {\n              int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n              assert pos < 0;\n              upto = -(pos+1);\n\n              if (random.nextBoolean()) {\n                upto--;\n                assertTrue(upto != -1);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekFloor(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekFloor(term) == null;\n              } else {\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekCeil(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekCeil(term) == null;\n              }\n\n              break;\n            }\n          }\n          if (attempt == 10) {\n            continue;\n          }\n            \n        } else {\n          final int inc = random.nextInt(pairs.size() - upto - 1);\n          upto += inc;\n          if (upto == -1) {\n            upto = 0;\n          }\n\n          if (random.nextBoolean()) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekCeil(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekCeil(pairs.get(upto).input) == null;\n          } else {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekFloor(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekFloor(pairs.get(upto).input) == null;\n          }\n        }\n        if (LuceneTestCase.VERBOSE) {\n          if (!isDone) {\n            System.out.println(\"    got \" + inputToString(inputMode, fstEnum.current().input));\n          } else {\n            System.out.println(\"    got null\");\n          }\n        }\n\n        if (upto == pairs.size()) {\n          assertTrue(isDone);\n          break;\n        } else {\n          assertFalse(isDone);\n          assertEquals(pairs.get(upto).input, fstEnum.current().input);\n          assertTrue(outputsEqual(pairs.get(upto).output, fstEnum.current().output));\n\n          /*\n            if (upto < pairs.size()-1) {\n            int tryCount = 0;\n            while(tryCount < 10) {\n            final IntsRef t = toIntsRef(getRandomString(), inputMode);\n            if (pairs.get(upto).input.compareTo(t) < 0) {\n            final boolean expected = t.compareTo(pairs.get(upto+1).input) < 0;\n            if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"TEST: call beforeNext(\" + inputToString(inputMode, t) + \"); current=\" + inputToString(inputMode, pairs.get(upto).input) + \" next=\" + inputToString(inputMode, pairs.get(upto+1).input) + \" expected=\" + expected);\n            }\n            assertEquals(expected, fstEnum.beforeNext(t));\n            break;\n            }\n            tryCount++;\n            }\n            }\n          */\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // FST is complete\n  @SuppressWarnings(\"deprecation\")\n  private void verifyUnPruned(int inputMode, FST<T> fst) throws IOException {\n\n    final FST<Long> fstLong;\n    final Set<Long> validOutputs;\n    long minLong = Long.MAX_VALUE;\n    long maxLong = Long.MIN_VALUE;\n\n    if (doReverseLookup) {\n      @SuppressWarnings(\"unchecked\") FST<Long> fstLong0 = (FST<Long>) fst;\n      fstLong = fstLong0;\n      validOutputs = new HashSet<>();\n      for(InputOutput<T> pair: pairs) {\n        Long output = (Long) pair.output;\n        maxLong = Math.max(maxLong, output);\n        minLong = Math.min(minLong, output);\n        validOutputs.add(output);\n      }\n    } else {\n      fstLong = null;\n      validOutputs = null;\n    }\n\n    if (pairs.size() == 0) {\n      assertNull(fst);\n      return;\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now verify \" + pairs.size() + \" terms\");\n      for(InputOutput<T> pair : pairs) {\n        assertNotNull(pair);\n        assertNotNull(pair.input);\n        assertNotNull(pair.output);\n        System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n      }\n    }\n\n    assertNotNull(fst);\n\n    // visit valid pairs in order -- make sure all words\n    // are accepted, and FSTEnum's next() steps through\n    // them correctly\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: check valid terms/next()\");\n    }\n    {\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<>(fst);\n      for(InputOutput<T> pair : pairs) {\n        IntsRef term = pair.input;\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: check term=\" + inputToString(inputMode, term) + \" output=\" + fst.outputs.outputToString(pair.output));\n        }\n        T output = run(fst, term, null);\n        assertNotNull(\"term \" + inputToString(inputMode, term) + \" is not accepted\", output);\n        assertTrue(outputsEqual(pair.output, output));\n\n        // verify enum's next\n        IntsRefFSTEnum.InputOutput<T> t = fstEnum.next();\n        assertNotNull(t);\n        assertEquals(\"expected input=\" + inputToString(inputMode, term) + \" but fstEnum returned \" + inputToString(inputMode, t.input), term, t.input);\n        assertTrue(outputsEqual(pair.output, t.output));\n      }\n      assertNull(fstEnum.next());\n    }\n\n    final Map<IntsRef,T> termsMap = new HashMap<>();\n    for(InputOutput<T> pair : pairs) {\n      termsMap.put(pair.input, pair.output);\n    }\n\n    if (doReverseLookup && maxLong > minLong) {\n      // Do random lookups so we test null (output doesn't\n      // exist) case:\n      assertNull(Util.getByOutput(fstLong, minLong-7));\n      assertNull(Util.getByOutput(fstLong, maxLong+7));\n\n      final int num = LuceneTestCase.atLeast(random, 100);\n      for(int iter=0;iter<num;iter++) {\n        Long v = TestUtil.nextLong(random, minLong, maxLong);\n        IntsRef input = Util.getByOutput(fstLong, v);\n        assertTrue(validOutputs.contains(v) || input == null);\n      }\n    }\n\n    // find random matching word and make sure it's valid\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify random accepted terms\");\n    }\n    final IntsRefBuilder scratch = new IntsRefBuilder();\n    int num = LuceneTestCase.atLeast(random, 500);\n    for(int iter=0;iter<num;iter++) {\n      T output = randomAcceptedWord(fst, scratch);\n      assertTrue(\"accepted word \" + inputToString(inputMode, scratch.get()) + \" is not valid\", termsMap.containsKey(scratch.get()));\n      assertTrue(outputsEqual(termsMap.get(scratch.get()), output));\n\n      if (doReverseLookup) {\n        //System.out.println(\"lookup output=\" + output + \" outs=\" + fst.outputs);\n        IntsRef input = Util.getByOutput(fstLong, (Long) output);\n        assertNotNull(input);\n        //System.out.println(\"  got \" + Util.toBytesRef(input, new BytesRef()).utf8ToString());\n        assertEquals(scratch.get(), input);\n      }\n    }\n    \n    // test IntsRefFSTEnum.seek:\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify seek\");\n    }\n    IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<>(fst);\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  iter=\" + iter);\n      }\n      if (random.nextBoolean()) {\n        // seek to term that doesn't exist:\n        while(true) {\n          final IntsRef term = toIntsRef(getRandomString(random), inputMode);\n          int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n          if (pos < 0) {\n            pos = -(pos+1);\n            // ok doesn't exist\n            //System.out.println(\"  seek \" + inputToString(inputMode, term));\n            final IntsRefFSTEnum.InputOutput<T> seekResult;\n            if (random.nextInt(3) == 0) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekExact term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekExact(term);\n              pos = -1;\n            } else if (random.nextBoolean()) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekFloor term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekFloor(term);\n              pos--;\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekCeil term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekCeil(term);\n            }\n\n            if (pos != -1 && pos < pairs.size()) {\n              //System.out.println(\"    got \" + inputToString(inputMode,seekResult.input) + \" output=\" + fst.outputs.outputToString(seekResult.output));\n              assertNotNull(\"got null but expected term=\" + inputToString(inputMode, pairs.get(pos).input), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got \" + inputToString(inputMode, seekResult.input));\n              }\n              assertEquals(\"expected \" + inputToString(inputMode, pairs.get(pos).input) + \" but got \" + inputToString(inputMode, seekResult.input), pairs.get(pos).input, seekResult.input);\n              assertTrue(outputsEqual(pairs.get(pos).output, seekResult.output));\n            } else {\n              // seeked before start or beyond end\n              //System.out.println(\"seek=\" + seekTerm);\n              assertNull(\"expected null but got \" + (seekResult==null ? \"null\" : inputToString(inputMode, seekResult.input)), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got null\");\n              }\n            }\n\n            break;\n          }\n        }\n      } else {\n        // seek to term that does exist:\n        InputOutput<T> pair = pairs.get(random.nextInt(pairs.size()));\n        final IntsRefFSTEnum.InputOutput<T> seekResult;\n        if (random.nextInt(3) == 2) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekExact term=\" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekExact(pair.input);\n        } else if (random.nextBoolean()) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekFloor \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekFloor(pair.input);\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekCeil \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekCeil(pair.input);\n        }\n        assertNotNull(seekResult);\n        assertEquals(\"got \" + inputToString(inputMode, seekResult.input) + \" but expected \" + inputToString(inputMode, pair.input), pair.input, seekResult.input);\n        assertTrue(outputsEqual(pair.output, seekResult.output));\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: mixed next/seek\");\n    }\n\n    // test mixed next/seek\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: iter \" + iter);\n      }\n      // reset:\n      fstEnum = new IntsRefFSTEnum<>(fst);\n      int upto = -1;\n      while(true) {\n        boolean isDone = false;\n        if (upto == pairs.size()-1 || random.nextBoolean()) {\n          // next\n          upto++;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do next\");\n          }\n          isDone = fstEnum.next() == null;\n        } else if (upto != -1 && upto < 0.75 * pairs.size() && random.nextBoolean()) {\n          int attempt = 0;\n          for(;attempt<10;attempt++) {\n            IntsRef term = toIntsRef(getRandomString(random), inputMode);\n            if (!termsMap.containsKey(term) && term.compareTo(pairs.get(upto).input) > 0) {\n              int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n              assert pos < 0;\n              upto = -(pos+1);\n\n              if (random.nextBoolean()) {\n                upto--;\n                assertTrue(upto != -1);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekFloor(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekFloor(term) == null;\n              } else {\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekCeil(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekCeil(term) == null;\n              }\n\n              break;\n            }\n          }\n          if (attempt == 10) {\n            continue;\n          }\n            \n        } else {\n          final int inc = random.nextInt(pairs.size() - upto - 1);\n          upto += inc;\n          if (upto == -1) {\n            upto = 0;\n          }\n\n          if (random.nextBoolean()) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekCeil(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekCeil(pairs.get(upto).input) == null;\n          } else {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekFloor(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekFloor(pairs.get(upto).input) == null;\n          }\n        }\n        if (LuceneTestCase.VERBOSE) {\n          if (!isDone) {\n            System.out.println(\"    got \" + inputToString(inputMode, fstEnum.current().input));\n          } else {\n            System.out.println(\"    got null\");\n          }\n        }\n\n        if (upto == pairs.size()) {\n          assertTrue(isDone);\n          break;\n        } else {\n          assertFalse(isDone);\n          assertEquals(pairs.get(upto).input, fstEnum.current().input);\n          assertTrue(outputsEqual(pairs.get(upto).output, fstEnum.current().output));\n\n          /*\n            if (upto < pairs.size()-1) {\n            int tryCount = 0;\n            while(tryCount < 10) {\n            final IntsRef t = toIntsRef(getRandomString(), inputMode);\n            if (pairs.get(upto).input.compareTo(t) < 0) {\n            final boolean expected = t.compareTo(pairs.get(upto+1).input) < 0;\n            if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"TEST: call beforeNext(\" + inputToString(inputMode, t) + \"); current=\" + inputToString(inputMode, pairs.get(upto).input) + \" next=\" + inputToString(inputMode, pairs.get(upto+1).input) + \" expected=\" + expected);\n            }\n            assertEquals(expected, fstEnum.beforeNext(t));\n            break;\n            }\n            tryCount++;\n            }\n            }\n          */\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2","date":1591961131,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#verifyUnPruned(int,FST[T]).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester#verifyUnPruned(int,FST[T]).mjava","sourceNew":"  // FST is complete\n  @SuppressWarnings(\"deprecation\")\n  private void verifyUnPruned(int inputMode, FST<T> fst) throws IOException {\n\n    final FST<Long> fstLong;\n    final Set<Long> validOutputs;\n    long minLong = Long.MAX_VALUE;\n    long maxLong = Long.MIN_VALUE;\n\n    if (doReverseLookup) {\n      @SuppressWarnings(\"unchecked\") FST<Long> fstLong0 = (FST<Long>) fst;\n      fstLong = fstLong0;\n      validOutputs = new HashSet<>();\n      for(InputOutput<T> pair: pairs) {\n        Long output = (Long) pair.output;\n        maxLong = Math.max(maxLong, output);\n        minLong = Math.min(minLong, output);\n        validOutputs.add(output);\n      }\n    } else {\n      fstLong = null;\n      validOutputs = null;\n    }\n\n    if (pairs.size() == 0) {\n      assertNull(fst);\n      return;\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now verify \" + pairs.size() + \" terms\");\n      for(InputOutput<T> pair : pairs) {\n        assertNotNull(pair);\n        assertNotNull(pair.input);\n        assertNotNull(pair.output);\n        System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n      }\n    }\n\n    assertNotNull(fst);\n\n    // visit valid pairs in order -- make sure all words\n    // are accepted, and FSTEnum's next() steps through\n    // them correctly\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: check valid terms/next()\");\n    }\n    {\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<>(fst);\n      for(InputOutput<T> pair : pairs) {\n        IntsRef term = pair.input;\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: check term=\" + inputToString(inputMode, term) + \" output=\" + fst.outputs.outputToString(pair.output));\n        }\n        T output = run(fst, term, null);\n        assertNotNull(\"term \" + inputToString(inputMode, term) + \" is not accepted\", output);\n        assertTrue(outputsEqual(pair.output, output));\n\n        // verify enum's next\n        IntsRefFSTEnum.InputOutput<T> t = fstEnum.next();\n        assertNotNull(t);\n        assertEquals(\"expected input=\" + inputToString(inputMode, term) + \" but fstEnum returned \" + inputToString(inputMode, t.input), term, t.input);\n        assertTrue(outputsEqual(pair.output, t.output));\n      }\n      assertNull(fstEnum.next());\n    }\n\n    final Map<IntsRef,T> termsMap = new HashMap<>();\n    for(InputOutput<T> pair : pairs) {\n      termsMap.put(pair.input, pair.output);\n    }\n\n    if (doReverseLookup && maxLong > minLong) {\n      // Do random lookups so we test null (output doesn't\n      // exist) case:\n      assertNull(Util.getByOutput(fstLong, minLong-7));\n      assertNull(Util.getByOutput(fstLong, maxLong+7));\n\n      final int num = LuceneTestCase.atLeast(random, 100);\n      for(int iter=0;iter<num;iter++) {\n        Long v = TestUtil.nextLong(random, minLong, maxLong);\n        IntsRef input = Util.getByOutput(fstLong, v);\n        assertTrue(validOutputs.contains(v) || input == null);\n      }\n    }\n\n    // find random matching word and make sure it's valid\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify random accepted terms\");\n    }\n    final IntsRefBuilder scratch = new IntsRefBuilder();\n    int num = LuceneTestCase.atLeast(random, 500);\n    for(int iter=0;iter<num;iter++) {\n      T output = randomAcceptedWord(fst, scratch);\n      assertTrue(\"accepted word \" + inputToString(inputMode, scratch.get()) + \" is not valid\", termsMap.containsKey(scratch.get()));\n      assertTrue(outputsEqual(termsMap.get(scratch.get()), output));\n\n      if (doReverseLookup) {\n        //System.out.println(\"lookup output=\" + output + \" outs=\" + fst.outputs);\n        IntsRef input = Util.getByOutput(fstLong, (Long) output);\n        assertNotNull(input);\n        //System.out.println(\"  got \" + Util.toBytesRef(input, new BytesRef()).utf8ToString());\n        assertEquals(scratch.get(), input);\n      }\n    }\n    \n    // test IntsRefFSTEnum.seek:\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify seek\");\n    }\n    IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<>(fst);\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  iter=\" + iter);\n      }\n      if (random.nextBoolean()) {\n        // seek to term that doesn't exist:\n        while(true) {\n          final IntsRef term = toIntsRef(getRandomString(random), inputMode);\n          int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n          if (pos < 0) {\n            pos = -(pos+1);\n            // ok doesn't exist\n            //System.out.println(\"  seek \" + inputToString(inputMode, term));\n            final IntsRefFSTEnum.InputOutput<T> seekResult;\n            if (random.nextInt(3) == 0) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekExact term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekExact(term);\n              pos = -1;\n            } else if (random.nextBoolean()) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekFloor term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekFloor(term);\n              pos--;\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekCeil term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekCeil(term);\n            }\n\n            if (pos != -1 && pos < pairs.size()) {\n              //System.out.println(\"    got \" + inputToString(inputMode,seekResult.input) + \" output=\" + fst.outputs.outputToString(seekResult.output));\n              assertNotNull(\"got null but expected term=\" + inputToString(inputMode, pairs.get(pos).input), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got \" + inputToString(inputMode, seekResult.input));\n              }\n              assertEquals(\"expected \" + inputToString(inputMode, pairs.get(pos).input) + \" but got \" + inputToString(inputMode, seekResult.input), pairs.get(pos).input, seekResult.input);\n              assertTrue(outputsEqual(pairs.get(pos).output, seekResult.output));\n            } else {\n              // seeked before start or beyond end\n              //System.out.println(\"seek=\" + seekTerm);\n              assertNull(\"expected null but got \" + (seekResult==null ? \"null\" : inputToString(inputMode, seekResult.input)), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got null\");\n              }\n            }\n\n            break;\n          }\n        }\n      } else {\n        // seek to term that does exist:\n        InputOutput<T> pair = pairs.get(random.nextInt(pairs.size()));\n        final IntsRefFSTEnum.InputOutput<T> seekResult;\n        if (random.nextInt(3) == 2) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekExact term=\" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekExact(pair.input);\n        } else if (random.nextBoolean()) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekFloor \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekFloor(pair.input);\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekCeil \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekCeil(pair.input);\n        }\n        assertNotNull(seekResult);\n        assertEquals(\"got \" + inputToString(inputMode, seekResult.input) + \" but expected \" + inputToString(inputMode, pair.input), pair.input, seekResult.input);\n        assertTrue(outputsEqual(pair.output, seekResult.output));\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: mixed next/seek\");\n    }\n\n    // test mixed next/seek\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: iter \" + iter);\n      }\n      // reset:\n      fstEnum = new IntsRefFSTEnum<>(fst);\n      int upto = -1;\n      while(true) {\n        boolean isDone = false;\n        if (upto == pairs.size()-1 || random.nextBoolean()) {\n          // next\n          upto++;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do next\");\n          }\n          isDone = fstEnum.next() == null;\n        } else if (upto != -1 && upto < 0.75 * pairs.size() && random.nextBoolean()) {\n          int attempt = 0;\n          for(;attempt<10;attempt++) {\n            IntsRef term = toIntsRef(getRandomString(random), inputMode);\n            if (!termsMap.containsKey(term) && term.compareTo(pairs.get(upto).input) > 0) {\n              int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n              assert pos < 0;\n              upto = -(pos+1);\n\n              if (random.nextBoolean()) {\n                upto--;\n                assertTrue(upto != -1);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekFloor(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekFloor(term) == null;\n              } else {\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekCeil(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekCeil(term) == null;\n              }\n\n              break;\n            }\n          }\n          if (attempt == 10) {\n            continue;\n          }\n            \n        } else {\n          final int inc = random.nextInt(pairs.size() - upto - 1);\n          upto += inc;\n          if (upto == -1) {\n            upto = 0;\n          }\n\n          if (random.nextBoolean()) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekCeil(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekCeil(pairs.get(upto).input) == null;\n          } else {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekFloor(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekFloor(pairs.get(upto).input) == null;\n          }\n        }\n        if (LuceneTestCase.VERBOSE) {\n          if (!isDone) {\n            System.out.println(\"    got \" + inputToString(inputMode, fstEnum.current().input));\n          } else {\n            System.out.println(\"    got null\");\n          }\n        }\n\n        if (upto == pairs.size()) {\n          assertTrue(isDone);\n          break;\n        } else {\n          assertFalse(isDone);\n          assertEquals(pairs.get(upto).input, fstEnum.current().input);\n          assertTrue(outputsEqual(pairs.get(upto).output, fstEnum.current().output));\n\n          /*\n            if (upto < pairs.size()-1) {\n            int tryCount = 0;\n            while(tryCount < 10) {\n            final IntsRef t = toIntsRef(getRandomString(), inputMode);\n            if (pairs.get(upto).input.compareTo(t) < 0) {\n            final boolean expected = t.compareTo(pairs.get(upto+1).input) < 0;\n            if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"TEST: call beforeNext(\" + inputToString(inputMode, t) + \"); current=\" + inputToString(inputMode, pairs.get(upto).input) + \" next=\" + inputToString(inputMode, pairs.get(upto+1).input) + \" expected=\" + expected);\n            }\n            assertEquals(expected, fstEnum.beforeNext(t));\n            break;\n            }\n            tryCount++;\n            }\n            }\n          */\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // FST is complete\n  private void verifyUnPruned(int inputMode, FST<T> fst) throws IOException {\n\n    final FST<Long> fstLong;\n    final Set<Long> validOutputs;\n    long minLong = Long.MAX_VALUE;\n    long maxLong = Long.MIN_VALUE;\n\n    if (doReverseLookup) {\n      @SuppressWarnings(\"unchecked\") FST<Long> fstLong0 = (FST<Long>) fst;\n      fstLong = fstLong0;\n      validOutputs = new HashSet<>();\n      for(InputOutput<T> pair: pairs) {\n        Long output = (Long) pair.output;\n        maxLong = Math.max(maxLong, output);\n        minLong = Math.min(minLong, output);\n        validOutputs.add(output);\n      }\n    } else {\n      fstLong = null;\n      validOutputs = null;\n    }\n\n    if (pairs.size() == 0) {\n      assertNull(fst);\n      return;\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: now verify \" + pairs.size() + \" terms\");\n      for(InputOutput<T> pair : pairs) {\n        assertNotNull(pair);\n        assertNotNull(pair.input);\n        assertNotNull(pair.output);\n        System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n      }\n    }\n\n    assertNotNull(fst);\n\n    // visit valid pairs in order -- make sure all words\n    // are accepted, and FSTEnum's next() steps through\n    // them correctly\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: check valid terms/next()\");\n    }\n    {\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<>(fst);\n      for(InputOutput<T> pair : pairs) {\n        IntsRef term = pair.input;\n        if (LuceneTestCase.VERBOSE) {\n          System.out.println(\"TEST: check term=\" + inputToString(inputMode, term) + \" output=\" + fst.outputs.outputToString(pair.output));\n        }\n        T output = run(fst, term, null);\n        assertNotNull(\"term \" + inputToString(inputMode, term) + \" is not accepted\", output);\n        assertTrue(outputsEqual(pair.output, output));\n\n        // verify enum's next\n        IntsRefFSTEnum.InputOutput<T> t = fstEnum.next();\n        assertNotNull(t);\n        assertEquals(\"expected input=\" + inputToString(inputMode, term) + \" but fstEnum returned \" + inputToString(inputMode, t.input), term, t.input);\n        assertTrue(outputsEqual(pair.output, t.output));\n      }\n      assertNull(fstEnum.next());\n    }\n\n    final Map<IntsRef,T> termsMap = new HashMap<>();\n    for(InputOutput<T> pair : pairs) {\n      termsMap.put(pair.input, pair.output);\n    }\n\n    if (doReverseLookup && maxLong > minLong) {\n      // Do random lookups so we test null (output doesn't\n      // exist) case:\n      assertNull(Util.getByOutput(fstLong, minLong-7));\n      assertNull(Util.getByOutput(fstLong, maxLong+7));\n\n      final int num = LuceneTestCase.atLeast(random, 100);\n      for(int iter=0;iter<num;iter++) {\n        Long v = TestUtil.nextLong(random, minLong, maxLong);\n        IntsRef input = Util.getByOutput(fstLong, v);\n        assertTrue(validOutputs.contains(v) || input == null);\n      }\n    }\n\n    // find random matching word and make sure it's valid\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify random accepted terms\");\n    }\n    final IntsRefBuilder scratch = new IntsRefBuilder();\n    int num = LuceneTestCase.atLeast(random, 500);\n    for(int iter=0;iter<num;iter++) {\n      T output = randomAcceptedWord(fst, scratch);\n      assertTrue(\"accepted word \" + inputToString(inputMode, scratch.get()) + \" is not valid\", termsMap.containsKey(scratch.get()));\n      assertTrue(outputsEqual(termsMap.get(scratch.get()), output));\n\n      if (doReverseLookup) {\n        //System.out.println(\"lookup output=\" + output + \" outs=\" + fst.outputs);\n        IntsRef input = Util.getByOutput(fstLong, (Long) output);\n        assertNotNull(input);\n        //System.out.println(\"  got \" + Util.toBytesRef(input, new BytesRef()).utf8ToString());\n        assertEquals(scratch.get(), input);\n      }\n    }\n    \n    // test IntsRefFSTEnum.seek:\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: verify seek\");\n    }\n    IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<>(fst);\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"  iter=\" + iter);\n      }\n      if (random.nextBoolean()) {\n        // seek to term that doesn't exist:\n        while(true) {\n          final IntsRef term = toIntsRef(getRandomString(random), inputMode);\n          int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n          if (pos < 0) {\n            pos = -(pos+1);\n            // ok doesn't exist\n            //System.out.println(\"  seek \" + inputToString(inputMode, term));\n            final IntsRefFSTEnum.InputOutput<T> seekResult;\n            if (random.nextInt(3) == 0) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekExact term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekExact(term);\n              pos = -1;\n            } else if (random.nextBoolean()) {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekFloor term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekFloor(term);\n              pos--;\n            } else {\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"  do non-exist seekCeil term=\" + inputToString(inputMode, term));\n              }\n              seekResult = fstEnum.seekCeil(term);\n            }\n\n            if (pos != -1 && pos < pairs.size()) {\n              //System.out.println(\"    got \" + inputToString(inputMode,seekResult.input) + \" output=\" + fst.outputs.outputToString(seekResult.output));\n              assertNotNull(\"got null but expected term=\" + inputToString(inputMode, pairs.get(pos).input), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got \" + inputToString(inputMode, seekResult.input));\n              }\n              assertEquals(\"expected \" + inputToString(inputMode, pairs.get(pos).input) + \" but got \" + inputToString(inputMode, seekResult.input), pairs.get(pos).input, seekResult.input);\n              assertTrue(outputsEqual(pairs.get(pos).output, seekResult.output));\n            } else {\n              // seeked before start or beyond end\n              //System.out.println(\"seek=\" + seekTerm);\n              assertNull(\"expected null but got \" + (seekResult==null ? \"null\" : inputToString(inputMode, seekResult.input)), seekResult);\n              if (LuceneTestCase.VERBOSE) {\n                System.out.println(\"    got null\");\n              }\n            }\n\n            break;\n          }\n        }\n      } else {\n        // seek to term that does exist:\n        InputOutput<T> pair = pairs.get(random.nextInt(pairs.size()));\n        final IntsRefFSTEnum.InputOutput<T> seekResult;\n        if (random.nextInt(3) == 2) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekExact term=\" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekExact(pair.input);\n        } else if (random.nextBoolean()) {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekFloor \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekFloor(pair.input);\n        } else {\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do exists seekCeil \" + inputToString(inputMode, pair.input));\n          }\n          seekResult = fstEnum.seekCeil(pair.input);\n        }\n        assertNotNull(seekResult);\n        assertEquals(\"got \" + inputToString(inputMode, seekResult.input) + \" but expected \" + inputToString(inputMode, pair.input), pair.input, seekResult.input);\n        assertTrue(outputsEqual(pair.output, seekResult.output));\n      }\n    }\n\n    if (LuceneTestCase.VERBOSE) {\n      System.out.println(\"TEST: mixed next/seek\");\n    }\n\n    // test mixed next/seek\n    num = LuceneTestCase.atLeast(random, 100);\n    for(int iter=0;iter<num;iter++) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"TEST: iter \" + iter);\n      }\n      // reset:\n      fstEnum = new IntsRefFSTEnum<>(fst);\n      int upto = -1;\n      while(true) {\n        boolean isDone = false;\n        if (upto == pairs.size()-1 || random.nextBoolean()) {\n          // next\n          upto++;\n          if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"  do next\");\n          }\n          isDone = fstEnum.next() == null;\n        } else if (upto != -1 && upto < 0.75 * pairs.size() && random.nextBoolean()) {\n          int attempt = 0;\n          for(;attempt<10;attempt++) {\n            IntsRef term = toIntsRef(getRandomString(random), inputMode);\n            if (!termsMap.containsKey(term) && term.compareTo(pairs.get(upto).input) > 0) {\n              int pos = Collections.binarySearch(pairs, new InputOutput<T>(term, null));\n              assert pos < 0;\n              upto = -(pos+1);\n\n              if (random.nextBoolean()) {\n                upto--;\n                assertTrue(upto != -1);\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekFloor(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekFloor(term) == null;\n              } else {\n                if (LuceneTestCase.VERBOSE) {\n                  System.out.println(\"  do non-exist seekCeil(\" + inputToString(inputMode, term) + \")\");\n                }\n                isDone = fstEnum.seekCeil(term) == null;\n              }\n\n              break;\n            }\n          }\n          if (attempt == 10) {\n            continue;\n          }\n            \n        } else {\n          final int inc = random.nextInt(pairs.size() - upto - 1);\n          upto += inc;\n          if (upto == -1) {\n            upto = 0;\n          }\n\n          if (random.nextBoolean()) {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekCeil(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekCeil(pairs.get(upto).input) == null;\n          } else {\n            if (LuceneTestCase.VERBOSE) {\n              System.out.println(\"  do seekFloor(\" + inputToString(inputMode, pairs.get(upto).input) + \")\");\n            }\n            isDone = fstEnum.seekFloor(pairs.get(upto).input) == null;\n          }\n        }\n        if (LuceneTestCase.VERBOSE) {\n          if (!isDone) {\n            System.out.println(\"    got \" + inputToString(inputMode, fstEnum.current().input));\n          } else {\n            System.out.println(\"    got null\");\n          }\n        }\n\n        if (upto == pairs.size()) {\n          assertTrue(isDone);\n          break;\n        } else {\n          assertFalse(isDone);\n          assertEquals(pairs.get(upto).input, fstEnum.current().input);\n          assertTrue(outputsEqual(pairs.get(upto).output, fstEnum.current().output));\n\n          /*\n            if (upto < pairs.size()-1) {\n            int tryCount = 0;\n            while(tryCount < 10) {\n            final IntsRef t = toIntsRef(getRandomString(), inputMode);\n            if (pairs.get(upto).input.compareTo(t) < 0) {\n            final boolean expected = t.compareTo(pairs.get(upto+1).input) < 0;\n            if (LuceneTestCase.VERBOSE) {\n            System.out.println(\"TEST: call beforeNext(\" + inputToString(inputMode, t) + \"); current=\" + inputToString(inputMode, pairs.get(upto).input) + \" next=\" + inputToString(inputMode, pairs.get(upto+1).input) + \" expected=\" + expected);\n            }\n            assertEquals(expected, fstEnum.beforeNext(t));\n            break;\n            }\n            tryCount++;\n            }\n            }\n          */\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"6613659748fe4411a7dcf85266e55db1f95f7315":["5ebe14aae60589c9bb6423f3cce02d5f599e1540"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"5ebe14aae60589c9bb6423f3cce02d5f599e1540":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9":["bb9c3baacabd473e8ecd6c4948aabacead49b88e"],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5ebe14aae60589c9bb6423f3cce02d5f599e1540"],"bb9c3baacabd473e8ecd6c4948aabacead49b88e":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["a5df378a6155dcc1f4d4ecdcbd8ea5bc058560e9"],"5ebe14aae60589c9bb6423f3cce02d5f599e1540":["6613659748fe4411a7dcf85266e55db1f95f7315"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}