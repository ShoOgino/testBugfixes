{"path":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","commits":[{"id":"be320990bdc77e643388fa801e75017f19289c42","date":1489477067,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","pathOld":"/dev/null","sourceNew":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) throws InterruptedException {\n    if (waitForReplicasInSync == null) return true;\n\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 100;\n    try {\n      for (int i = 0; i < pair.second(); i++) {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n\n          String localVersion = core.getDeletionPolicy().getLatestCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n          if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges()) return true;\n          if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n            return true;\n          } else {\n            Thread.sleep(500);\n          }\n        }\n      }\n\n    } catch (Exception e) {\n      log.error(\"Exception when wait for replicas in sync with master\");\n    }\n\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f996f8177b9204bdc92f7164460c6cefad9ac99a","date":1489482690,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","pathOld":"/dev/null","sourceNew":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) throws InterruptedException {\n    if (waitForReplicasInSync == null) return true;\n\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 100;\n    try {\n      for (int i = 0; i < pair.second(); i++) {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n\n          String localVersion = core.getDeletionPolicy().getLatestCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n          if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges()) return true;\n          if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n            return true;\n          } else {\n            Thread.sleep(500);\n          }\n        }\n      }\n\n    } catch (Exception e) {\n      log.error(\"Exception when wait for replicas in sync with master\");\n    }\n\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["08807474e48bac766abf10459c3c25e4a5e4d7cc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","pathOld":"/dev/null","sourceNew":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) throws InterruptedException {\n    if (waitForReplicasInSync == null) return true;\n\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 100;\n    try {\n      for (int i = 0; i < pair.second(); i++) {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n\n          String localVersion = core.getDeletionPolicy().getLatestCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n          if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges()) return true;\n          if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n            return true;\n          } else {\n            Thread.sleep(500);\n          }\n        }\n      }\n\n    } catch (Exception e) {\n      log.error(\"Exception when wait for replicas in sync with master\");\n    }\n\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"738b5f6e7b47489128e39bd1eccee9c3d58dec23","date":1490607862,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","sourceNew":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) throws InterruptedException {\n    if (waitForReplicasInSync == null) return true;\n    log.info(\"Start waiting for replica in sync with leader\");\n    long currentTime = System.currentTimeMillis();\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 100;\n    try {\n      for (int i = 0; i < pair.second(); i++) {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n          RefCounted<SolrIndexSearcher> searcher = core.getSearcher();\n          try {\n            String localVersion = searcher.get().getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n            if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges()) return true;\n            if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n              log.info(\"Waiting time for replica in sync with leader: {}\", System.currentTimeMillis()-currentTime);\n              return true;\n            } else {\n              Thread.sleep(500);\n            }\n          } finally {\n            searcher.decref();\n          }\n\n        }\n      }\n\n    } catch (Exception e) {\n      log.error(\"Exception when wait for replicas in sync with master\");\n    }\n\n    return false;\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) throws InterruptedException {\n    if (waitForReplicasInSync == null) return true;\n\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 100;\n    try {\n      for (int i = 0; i < pair.second(); i++) {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n\n          String localVersion = core.getDeletionPolicy().getLatestCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n          if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges()) return true;\n          if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n            return true;\n          } else {\n            Thread.sleep(500);\n          }\n        }\n      }\n\n    } catch (Exception e) {\n      log.error(\"Exception when wait for replicas in sync with master\");\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"02dfe884e3d07476d8a6a68ed8b3671d9258a4b0","date":1490749780,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","sourceNew":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) throws InterruptedException {\n    if (waitForReplicasInSync == null) return true;\n    log.info(\"Start waiting for replica in sync with leader\");\n    long currentTime = System.currentTimeMillis();\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 200;\n    try {\n      for (int i = 0; i < pair.second(); i++) {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n          RefCounted<SolrIndexSearcher> searcher = core.getSearcher();\n          try {\n            String localVersion = searcher.get().getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n            if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges()) return true;\n            if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n              log.info(\"Waiting time for replica in sync with leader: {}\", System.currentTimeMillis()-currentTime);\n              return true;\n            } else {\n              Thread.sleep(500);\n            }\n          } finally {\n            searcher.decref();\n          }\n\n        }\n      }\n\n    } catch (Exception e) {\n      log.error(\"Exception when wait for replicas in sync with master\");\n    }\n\n    return false;\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) throws InterruptedException {\n    if (waitForReplicasInSync == null) return true;\n    log.info(\"Start waiting for replica in sync with leader\");\n    long currentTime = System.currentTimeMillis();\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 100;\n    try {\n      for (int i = 0; i < pair.second(); i++) {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n          RefCounted<SolrIndexSearcher> searcher = core.getSearcher();\n          try {\n            String localVersion = searcher.get().getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n            if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges()) return true;\n            if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n              log.info(\"Waiting time for replica in sync with leader: {}\", System.currentTimeMillis()-currentTime);\n              return true;\n            } else {\n              Thread.sleep(500);\n            }\n          } finally {\n            searcher.decref();\n          }\n\n        }\n      }\n\n    } catch (Exception e) {\n      log.error(\"Exception when wait for replicas in sync with master\");\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"40ea78490b5566f38f959beed12bd02682885da3","date":1490873944,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","sourceNew":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) throws InterruptedException {\n    if (waitForReplicasInSync == null) return true;\n    log.info(\"Start waiting for replica in sync with leader\");\n    long currentTime = System.currentTimeMillis();\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 100;\n    try {\n      for (int i = 0; i < pair.second(); i++) {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n          RefCounted<SolrIndexSearcher> searcher = core.getSearcher();\n          try {\n            String localVersion = searcher.get().getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n            if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges()) return true;\n            if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n              log.info(\"Waiting time for replica in sync with leader: {}\", System.currentTimeMillis()-currentTime);\n              return true;\n            } else {\n              Thread.sleep(500);\n            }\n          } finally {\n            searcher.decref();\n          }\n\n        }\n      }\n\n    } catch (Exception e) {\n      log.error(\"Exception when wait for replicas in sync with master\");\n    }\n\n    return false;\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) throws InterruptedException {\n    if (waitForReplicasInSync == null) return true;\n\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 100;\n    try {\n      for (int i = 0; i < pair.second(); i++) {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n\n          String localVersion = core.getDeletionPolicy().getLatestCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n          if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges()) return true;\n          if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n            return true;\n          } else {\n            Thread.sleep(500);\n          }\n        }\n      }\n\n    } catch (Exception e) {\n      log.error(\"Exception when wait for replicas in sync with master\");\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"08807474e48bac766abf10459c3c25e4a5e4d7cc","date":1490873946,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","sourceNew":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) throws InterruptedException {\n    if (waitForReplicasInSync == null) return true;\n    log.info(\"Start waiting for replica in sync with leader\");\n    long currentTime = System.currentTimeMillis();\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 200;\n    try {\n      for (int i = 0; i < pair.second(); i++) {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n          RefCounted<SolrIndexSearcher> searcher = core.getSearcher();\n          try {\n            String localVersion = searcher.get().getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n            if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges()) return true;\n            if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n              log.info(\"Waiting time for replica in sync with leader: {}\", System.currentTimeMillis()-currentTime);\n              return true;\n            } else {\n              Thread.sleep(500);\n            }\n          } finally {\n            searcher.decref();\n          }\n\n        }\n      }\n\n    } catch (Exception e) {\n      log.error(\"Exception when wait for replicas in sync with master\");\n    }\n\n    return false;\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) throws InterruptedException {\n    if (waitForReplicasInSync == null) return true;\n    log.info(\"Start waiting for replica in sync with leader\");\n    long currentTime = System.currentTimeMillis();\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 100;\n    try {\n      for (int i = 0; i < pair.second(); i++) {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n          RefCounted<SolrIndexSearcher> searcher = core.getSearcher();\n          try {\n            String localVersion = searcher.get().getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n            if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges()) return true;\n            if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n              log.info(\"Waiting time for replica in sync with leader: {}\", System.currentTimeMillis()-currentTime);\n              return true;\n            } else {\n              Thread.sleep(500);\n            }\n          } finally {\n            searcher.decref();\n          }\n\n        }\n      }\n\n    } catch (Exception e) {\n      log.error(\"Exception when wait for replicas in sync with master\");\n    }\n\n    return false;\n  }\n\n","bugFix":["f996f8177b9204bdc92f7164460c6cefad9ac99a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","sourceNew":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) throws InterruptedException {\n    if (waitForReplicasInSync == null) return true;\n    log.info(\"Start waiting for replica in sync with leader\");\n    long currentTime = System.currentTimeMillis();\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 200;\n    try {\n      for (int i = 0; i < pair.second(); i++) {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n          RefCounted<SolrIndexSearcher> searcher = core.getSearcher();\n          try {\n            String localVersion = searcher.get().getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n            if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges()) return true;\n            if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n              log.info(\"Waiting time for tlog replica to be in sync with leader: {}\", System.currentTimeMillis()-currentTime);\n              return true;\n            } else {\n              log.debug(\"Tlog replica not in sync with leader yet. Attempt: {}. Local Version={}, leader Version={}\", i, localVersion, leaderVersion);\n              Thread.sleep(500);\n            }\n          } finally {\n            searcher.decref();\n          }\n\n        }\n      }\n\n    } catch (Exception e) {\n      log.error(\"Exception when wait for replicas in sync with master\");\n    }\n\n    return false;\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) throws InterruptedException {\n    if (waitForReplicasInSync == null) return true;\n    log.info(\"Start waiting for replica in sync with leader\");\n    long currentTime = System.currentTimeMillis();\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 200;\n    try {\n      for (int i = 0; i < pair.second(); i++) {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n          RefCounted<SolrIndexSearcher> searcher = core.getSearcher();\n          try {\n            String localVersion = searcher.get().getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n            if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges()) return true;\n            if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n              log.info(\"Waiting time for replica in sync with leader: {}\", System.currentTimeMillis()-currentTime);\n              return true;\n            } else {\n              Thread.sleep(500);\n            }\n          } finally {\n            searcher.decref();\n          }\n\n        }\n      }\n\n    } catch (Exception e) {\n      log.error(\"Exception when wait for replicas in sync with master\");\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","sourceNew":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) throws InterruptedException {\n    if (waitForReplicasInSync == null) return true;\n    log.info(\"Start waiting for replica in sync with leader\");\n    long currentTime = System.currentTimeMillis();\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 200;\n    try {\n      for (int i = 0; i < pair.second(); i++) {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n          RefCounted<SolrIndexSearcher> searcher = core.getSearcher();\n          try {\n            String localVersion = searcher.get().getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n            if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges()) return true;\n            if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n              log.info(\"Waiting time for tlog replica to be in sync with leader: {}\", System.currentTimeMillis()-currentTime);\n              return true;\n            } else {\n              log.debug(\"Tlog replica not in sync with leader yet. Attempt: {}. Local Version={}, leader Version={}\", i, localVersion, leaderVersion);\n              Thread.sleep(500);\n            }\n          } finally {\n            searcher.decref();\n          }\n\n        }\n      }\n\n    } catch (Exception e) {\n      log.error(\"Exception when wait for replicas in sync with master\");\n    }\n\n    return false;\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) throws InterruptedException {\n    if (waitForReplicasInSync == null) return true;\n    log.info(\"Start waiting for replica in sync with leader\");\n    long currentTime = System.currentTimeMillis();\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 200;\n    try {\n      for (int i = 0; i < pair.second(); i++) {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n          RefCounted<SolrIndexSearcher> searcher = core.getSearcher();\n          try {\n            String localVersion = searcher.get().getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n            if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges()) return true;\n            if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n              log.info(\"Waiting time for replica in sync with leader: {}\", System.currentTimeMillis()-currentTime);\n              return true;\n            } else {\n              Thread.sleep(500);\n            }\n          } finally {\n            searcher.decref();\n          }\n\n        }\n      }\n\n    } catch (Exception e) {\n      log.error(\"Exception when wait for replicas in sync with master\");\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ab833f2b623042c834458d4cbcad05073a93793","date":1527625631,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","sourceNew":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) throws InterruptedException {\n    if (waitForReplicasInSync == null) return true;\n    log.info(\"Start waiting for replica in sync with leader\");\n    long currentTime = System.currentTimeMillis();\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 200;\n    try {\n      for (int i = 0; i < pair.second(); i++) {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n          String localVersion = core.withSearcher(searcher ->\n              searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY));\n          if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges())\n            return true;\n          if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n            log.info(\"Waiting time for tlog replica to be in sync with leader: {}\", System.currentTimeMillis()-currentTime);\n            return true;\n          } else {\n            log.debug(\"Tlog replica not in sync with leader yet. Attempt: {}. Local Version={}, leader Version={}\", i, localVersion, leaderVersion);\n            Thread.sleep(500);\n          }\n\n        }\n      }\n\n    } catch (Exception e) {\n      log.error(\"Exception when wait for replicas in sync with master\");\n    }\n\n    return false;\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) throws InterruptedException {\n    if (waitForReplicasInSync == null) return true;\n    log.info(\"Start waiting for replica in sync with leader\");\n    long currentTime = System.currentTimeMillis();\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 200;\n    try {\n      for (int i = 0; i < pair.second(); i++) {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n          RefCounted<SolrIndexSearcher> searcher = core.getSearcher();\n          try {\n            String localVersion = searcher.get().getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n            if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges()) return true;\n            if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n              log.info(\"Waiting time for tlog replica to be in sync with leader: {}\", System.currentTimeMillis()-currentTime);\n              return true;\n            } else {\n              log.debug(\"Tlog replica not in sync with leader yet. Attempt: {}. Local Version={}, leader Version={}\", i, localVersion, leaderVersion);\n              Thread.sleep(500);\n            }\n          } finally {\n            searcher.decref();\n          }\n\n        }\n      }\n\n    } catch (Exception e) {\n      log.error(\"Exception when wait for replicas in sync with master\");\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2138c838f1c8052d94d61eb1e205dce7fa6932ef","date":1527642223,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","sourceNew":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) throws InterruptedException {\n    if (waitForReplicasInSync == null) return true;\n    log.info(\"Start waiting for replica in sync with leader\");\n    long currentTime = System.currentTimeMillis();\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 200;\n    try {\n      for (int i = 0; i < pair.second(); i++) {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n          String localVersion = core.withSearcher(searcher ->\n              searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY));\n          if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges())\n            return true;\n          if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n            log.info(\"Waiting time for tlog replica to be in sync with leader: {}\", System.currentTimeMillis()-currentTime);\n            return true;\n          } else {\n            log.debug(\"Tlog replica not in sync with leader yet. Attempt: {}. Local Version={}, leader Version={}\", i, localVersion, leaderVersion);\n            Thread.sleep(500);\n          }\n\n        }\n      }\n\n    } catch (Exception e) {\n      log.error(\"Exception when wait for replicas in sync with master\");\n    }\n\n    return false;\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) throws InterruptedException {\n    if (waitForReplicasInSync == null) return true;\n    log.info(\"Start waiting for replica in sync with leader\");\n    long currentTime = System.currentTimeMillis();\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 200;\n    try {\n      for (int i = 0; i < pair.second(); i++) {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n          RefCounted<SolrIndexSearcher> searcher = core.getSearcher();\n          try {\n            String localVersion = searcher.get().getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);\n            if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges()) return true;\n            if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n              log.info(\"Waiting time for tlog replica to be in sync with leader: {}\", System.currentTimeMillis()-currentTime);\n              return true;\n            } else {\n              log.debug(\"Tlog replica not in sync with leader yet. Attempt: {}. Local Version={}, leader Version={}\", i, localVersion, leaderVersion);\n              Thread.sleep(500);\n            }\n          } finally {\n            searcher.decref();\n          }\n\n        }\n      }\n\n    } catch (Exception e) {\n      log.error(\"Exception when wait for replicas in sync with master\");\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"47e92a2004df5b7a7a07776f7b7dd6402f1e953b","date":1533596365,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","sourceNew":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) {\n    if (waitForReplicasInSync == null) return true;\n    log.info(\"Start waiting for replica in sync with leader\");\n    long currentTime = System.currentTimeMillis();\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 200;\n    for (int i = 0; i < pair.second(); i++) {\n      try {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n  \n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n          String localVersion = core.withSearcher(searcher ->\n              searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY));\n          if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges())\n            return true;\n          if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n            log.info(\"Waiting time for tlog replica to be in sync with leader: {}\", System.currentTimeMillis()-currentTime);\n            return true;\n          } else {\n            log.debug(\"Tlog replica not in sync with leader yet. Attempt: {}. Local Version={}, leader Version={}\", i, localVersion, leaderVersion);\n            Thread.sleep(500);\n          }\n  \n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        if (core.isClosed()) return true;\n        log.error(\"Thread interrupted while waiting for core {} to be in sync with leader\", core.getName());\n        return false;\n      } catch (Exception e) {\n        if (core.isClosed()) return true;\n        log.error(\"Exception when wait for replicas in sync with master. Will retry until timeout.\", e);\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) throws InterruptedException {\n    if (waitForReplicasInSync == null) return true;\n    log.info(\"Start waiting for replica in sync with leader\");\n    long currentTime = System.currentTimeMillis();\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 200;\n    try {\n      for (int i = 0; i < pair.second(); i++) {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n          String localVersion = core.withSearcher(searcher ->\n              searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY));\n          if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges())\n            return true;\n          if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n            log.info(\"Waiting time for tlog replica to be in sync with leader: {}\", System.currentTimeMillis()-currentTime);\n            return true;\n          } else {\n            log.debug(\"Tlog replica not in sync with leader yet. Attempt: {}. Local Version={}, leader Version={}\", i, localVersion, leaderVersion);\n            Thread.sleep(500);\n          }\n\n        }\n      }\n\n    } catch (Exception e) {\n      log.error(\"Exception when wait for replicas in sync with master\");\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab85e957e6a6ff40d8dd4f42932789cd24fc8a62","date":1541503153,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","sourceNew":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) {\n    if (waitForReplicasInSync == null) return true;\n    log.info(\"Start waiting for replica in sync with leader\");\n    long currentTime = System.currentTimeMillis();\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 200;\n    int i = 0;\n    TimeOut timeOut = new TimeOut(pair.second(), TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n          String localVersion = core.withSearcher(searcher ->\n              searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY));\n          if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges())\n            return true;\n          if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n            log.info(\"Waiting time for tlog replica to be in sync with leader: {}\", System.currentTimeMillis()-currentTime);\n            return true;\n          } else {\n            log.debug(\"Tlog replica not in sync with leader yet. Attempt: {}. Local Version={}, leader Version={}\", i, localVersion, leaderVersion);\n            Thread.sleep(250);\n          }\n\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        if (core.isClosed()) return true;\n        log.error(\"Thread interrupted while waiting for core {} to be in sync with leader\", core.getName());\n        return false;\n      } catch (Exception e) {\n        if (core.isClosed()) return true;\n        log.error(\"Exception when wait for replicas in sync with master. Will retry until timeout.\", e);\n      }\n      i++;\n    }\n    return false;\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) {\n    if (waitForReplicasInSync == null) return true;\n    log.info(\"Start waiting for replica in sync with leader\");\n    long currentTime = System.currentTimeMillis();\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 200;\n    for (int i = 0; i < pair.second(); i++) {\n      try {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n  \n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n          String localVersion = core.withSearcher(searcher ->\n              searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY));\n          if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges())\n            return true;\n          if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n            log.info(\"Waiting time for tlog replica to be in sync with leader: {}\", System.currentTimeMillis()-currentTime);\n            return true;\n          } else {\n            log.debug(\"Tlog replica not in sync with leader yet. Attempt: {}. Local Version={}, leader Version={}\", i, localVersion, leaderVersion);\n            Thread.sleep(500);\n          }\n  \n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        if (core.isClosed()) return true;\n        log.error(\"Thread interrupted while waiting for core {} to be in sync with leader\", core.getName());\n        return false;\n      } catch (Exception e) {\n        if (core.isClosed()) return true;\n        log.error(\"Exception when wait for replicas in sync with master. Will retry until timeout.\", e);\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"de88bdad1b484951835198f75050e5f16fbb660c","date":1548456646,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","sourceNew":"  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) {\n    // NOTE: this method should do *NOTHING* unless LUCENE_TEST_CASE is non-null\n    \n    if (waitForReplicasInSync == null) return true;\n    \n    return true; // No-Op: see SOLR-12313\n  }\n\n","sourceOld":"  @SuppressForbidden(reason = \"Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value\")\n  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) {\n    if (waitForReplicasInSync == null) return true;\n    log.info(\"Start waiting for replica in sync with leader\");\n    long currentTime = System.currentTimeMillis();\n    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);\n    boolean enabled = pair.first();\n    if (!enabled) return true;\n    long t = System.currentTimeMillis() - 200;\n    int i = 0;\n    TimeOut timeOut = new TimeOut(pair.second(), TimeUnit.SECONDS, TimeSource.NANO_TIME);\n    while (!timeOut.hasTimedOut()) {\n      try {\n        if (core.isClosed()) return true;\n        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(\n            collection, shardId);\n        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {\n          ModifiableSolrParams params = new ModifiableSolrParams();\n          params.set(CommonParams.QT, ReplicationHandler.PATH);\n          params.set(COMMAND, CMD_DETAILS);\n\n          NamedList<Object> response = leaderClient.request(new QueryRequest(params));\n          long leaderVersion = (long) ((NamedList)response.get(\"details\")).get(\"indexVersion\");\n          String localVersion = core.withSearcher(searcher ->\n              searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY));\n          if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges())\n            return true;\n          if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {\n            log.info(\"Waiting time for tlog replica to be in sync with leader: {}\", System.currentTimeMillis()-currentTime);\n            return true;\n          } else {\n            log.debug(\"Tlog replica not in sync with leader yet. Attempt: {}. Local Version={}, leader Version={}\", i, localVersion, leaderVersion);\n            Thread.sleep(250);\n          }\n\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        if (core.isClosed()) return true;\n        log.error(\"Thread interrupted while waiting for core {} to be in sync with leader\", core.getName());\n        return false;\n      } catch (Exception e) {\n        if (core.isClosed()) return true;\n        log.error(\"Exception when wait for replicas in sync with master. Will retry until timeout.\", e);\n      }\n      i++;\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ea30eccc5df86149453ac5ce8ff85443cfe1b9f7","date":1551957932,"type":4,"author":"Cao Manh Dat","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/util/TestInjection#waitForInSyncWithLeader(SolrCore,ZkController,String,String).mjava","sourceNew":null,"sourceOld":"  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) {\n    // NOTE: this method should do *NOTHING* unless LUCENE_TEST_CASE is non-null\n    \n    if (waitForReplicasInSync == null) return true;\n    \n    return true; // No-Op: see SOLR-12313\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ea30eccc5df86149453ac5ce8ff85443cfe1b9f7":["de88bdad1b484951835198f75050e5f16fbb660c"],"47e92a2004df5b7a7a07776f7b7dd6402f1e953b":["2138c838f1c8052d94d61eb1e205dce7fa6932ef"],"61c45e99cf6676da48f19d7511c73712ad39402b":["02dfe884e3d07476d8a6a68ed8b3671d9258a4b0"],"02dfe884e3d07476d8a6a68ed8b3671d9258a4b0":["738b5f6e7b47489128e39bd1eccee9c3d58dec23"],"de88bdad1b484951835198f75050e5f16fbb660c":["ab85e957e6a6ff40d8dd4f42932789cd24fc8a62"],"4ab833f2b623042c834458d4cbcad05073a93793":["61c45e99cf6676da48f19d7511c73712ad39402b"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["08807474e48bac766abf10459c3c25e4a5e4d7cc","61c45e99cf6676da48f19d7511c73712ad39402b"],"ab85e957e6a6ff40d8dd4f42932789cd24fc8a62":["47e92a2004df5b7a7a07776f7b7dd6402f1e953b"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"08807474e48bac766abf10459c3c25e4a5e4d7cc":["40ea78490b5566f38f959beed12bd02682885da3"],"738b5f6e7b47489128e39bd1eccee9c3d58dec23":["be320990bdc77e643388fa801e75017f19289c42"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"40ea78490b5566f38f959beed12bd02682885da3":["ab68488225b6a6c357dda72ed11dedca9914a192"],"be320990bdc77e643388fa801e75017f19289c42":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ab68488225b6a6c357dda72ed11dedca9914a192":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ea30eccc5df86149453ac5ce8ff85443cfe1b9f7"],"2138c838f1c8052d94d61eb1e205dce7fa6932ef":["61c45e99cf6676da48f19d7511c73712ad39402b","4ab833f2b623042c834458d4cbcad05073a93793"]},"commit2Childs":{"ea30eccc5df86149453ac5ce8ff85443cfe1b9f7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"47e92a2004df5b7a7a07776f7b7dd6402f1e953b":["ab85e957e6a6ff40d8dd4f42932789cd24fc8a62"],"61c45e99cf6676da48f19d7511c73712ad39402b":["4ab833f2b623042c834458d4cbcad05073a93793","e9017cf144952056066919f1ebc7897ff9bd71b1","2138c838f1c8052d94d61eb1e205dce7fa6932ef"],"02dfe884e3d07476d8a6a68ed8b3671d9258a4b0":["61c45e99cf6676da48f19d7511c73712ad39402b"],"de88bdad1b484951835198f75050e5f16fbb660c":["ea30eccc5df86149453ac5ce8ff85443cfe1b9f7"],"4ab833f2b623042c834458d4cbcad05073a93793":["2138c838f1c8052d94d61eb1e205dce7fa6932ef"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"ab85e957e6a6ff40d8dd4f42932789cd24fc8a62":["de88bdad1b484951835198f75050e5f16fbb660c"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["ab68488225b6a6c357dda72ed11dedca9914a192"],"08807474e48bac766abf10459c3c25e4a5e4d7cc":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"738b5f6e7b47489128e39bd1eccee9c3d58dec23":["02dfe884e3d07476d8a6a68ed8b3671d9258a4b0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f996f8177b9204bdc92f7164460c6cefad9ac99a","be320990bdc77e643388fa801e75017f19289c42","ab68488225b6a6c357dda72ed11dedca9914a192"],"40ea78490b5566f38f959beed12bd02682885da3":["08807474e48bac766abf10459c3c25e4a5e4d7cc"],"be320990bdc77e643388fa801e75017f19289c42":["738b5f6e7b47489128e39bd1eccee9c3d58dec23"],"ab68488225b6a6c357dda72ed11dedca9914a192":["40ea78490b5566f38f959beed12bd02682885da3"],"2138c838f1c8052d94d61eb1e205dce7fa6932ef":["47e92a2004df5b7a7a07776f7b7dd6402f1e953b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}