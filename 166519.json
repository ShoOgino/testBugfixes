{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetHeatmap.Parser#parse(Object).mjava","commits":[{"id":"2ab027bdfe663227636ccbeda13ae82add302939","date":1529980633,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetHeatmap.Parser#parse(Object).mjava","pathOld":"/dev/null","sourceNew":"    public FacetHeatmap parse(Object argsObj) {\n      assert facet == null;\n\n      if (!(argsObj instanceof Map)) {\n        throw err(\"Missing heatmap arguments\");\n      }\n\n      @SuppressWarnings(\"unchecked\")\n      Map<String, Object> argsMap = (Map<String, Object>) argsObj;\n      String fieldName = getField(argsMap);\n\n      //get the strategy from the field type\n      final SchemaField schemaField = getSchema().getField(fieldName);\n      final FieldType type = schemaField.getType();\n\n      final PrefixTreeStrategy strategy;\n      final DistanceUnits distanceUnits;\n      // note: the two instanceof conditions is not ideal, versus one. If we start needing to add more then refactor.\n      if ((type instanceof AbstractSpatialPrefixTreeFieldType)) {\n        AbstractSpatialPrefixTreeFieldType rptType = (AbstractSpatialPrefixTreeFieldType) type;\n        strategy = (PrefixTreeStrategy) rptType.getStrategy(fieldName);\n        distanceUnits = rptType.getDistanceUnits();\n      } else if (type instanceof RptWithGeometrySpatialField) {\n        RptWithGeometrySpatialField rptSdvType  = (RptWithGeometrySpatialField) type;\n        strategy = rptSdvType.getStrategy(fieldName).getIndexStrategy();\n        distanceUnits = rptSdvType.getDistanceUnits();\n      } else {\n        //FYI we support the term query one too but few people use that one\n        throw err(\"heatmap field needs to be of type \" + SpatialRecursivePrefixTreeFieldType.class + \" or \" + RptWithGeometrySpatialField.class);\n      }\n\n      final SpatialContext ctx = strategy.getSpatialContext();\n\n      //get the bbox (query Rectangle)\n      String geomStr = getString(argsMap, GEOM_PARAM, null);\n      final Shape boundsShape = geomStr == null ? ctx.getWorldBounds() : SpatialUtils.parseGeomSolrException(geomStr, ctx);\n\n      //get the grid level (possibly indirectly via distErr or distErrPct)\n      final int gridLevel;\n      final Long gridLevelObj = getLongOrNull(argsMap, LEVEL_PARAM, false);\n      final int maxGridLevel = strategy.getGrid().getMaxLevels();\n      if (gridLevelObj != null) {\n        gridLevel = gridLevelObj.intValue();\n        if (gridLevel <= 0 || gridLevel > maxGridLevel) {\n          throw err(LEVEL_PARAM +\" should be > 0 and <= \" + maxGridLevel);\n        }\n      } else {\n        //SpatialArgs has utility methods to resolve a 'distErr' from optionally set distErr & distErrPct. Arguably that\n        // should be refactored to feel less weird than using it like this.\n        SpatialArgs spatialArgs = new SpatialArgs(SpatialOperation.Intersects/*ignored*/,\n            boundsShape == null ? ctx.getWorldBounds() : boundsShape);\n        final Double distErrObj = getDoubleOrNull(argsMap, DIST_ERR_PARAM, false);\n        if (distErrObj != null) {\n          // convert distErr units based on configured units\n          spatialArgs.setDistErr(distErrObj * distanceUnits.multiplierFromThisUnitToDegrees());\n        }\n        spatialArgs.setDistErrPct(getDoubleOrNull(argsMap, DIST_ERR_PCT_PARAM, false));\n        double distErr = spatialArgs.resolveDistErr(ctx, DEFAULT_DIST_ERR_PCT);\n        if (distErr <= 0) {\n          throw err(DIST_ERR_PCT_PARAM + \" or \" + DIST_ERR_PARAM\n                  + \" should be > 0 or instead provide \" + LEVEL_PARAM + \"=\" + maxGridLevel\n                  + \" if you insist on maximum detail\");\n        }\n        //The SPT (grid) can lookup a grid level satisfying an error distance constraint\n        gridLevel = strategy.getGrid().getLevelForDistance(distErr);\n      }\n\n      final int maxCells = (int) getLong(argsMap, MAX_CELLS_PARAM, 100_000);// will throw later if exceeded\n\n      final String format = getString(argsMap, FORMAT_PARAM, FORMAT_INTS2D);\n      if (!format.equals(FORMAT_INTS2D) && !format.equals(FORMAT_PNG)) {\n        throw err(\"format should be \" + FORMAT_INTS2D + \" or \" + FORMAT_PNG);\n      }\n\n      this.facet = new FacetHeatmap(argsMap, strategy, boundsShape, gridLevel, maxCells, format);\n\n      parseCommonParams(argsObj); // e.g. domain change\n\n      return this.facet;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":0,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetHeatmap.Parser#parse(Object).mjava","pathOld":"/dev/null","sourceNew":"    public FacetHeatmap parse(Object argsObj) {\n      assert facet == null;\n\n      if (!(argsObj instanceof Map)) {\n        throw err(\"Missing heatmap arguments\");\n      }\n\n      @SuppressWarnings(\"unchecked\")\n      Map<String, Object> argsMap = (Map<String, Object>) argsObj;\n      String fieldName = getField(argsMap);\n\n      //get the strategy from the field type\n      final SchemaField schemaField = getSchema().getField(fieldName);\n      final FieldType type = schemaField.getType();\n\n      final PrefixTreeStrategy strategy;\n      final DistanceUnits distanceUnits;\n      // note: the two instanceof conditions is not ideal, versus one. If we start needing to add more then refactor.\n      if ((type instanceof AbstractSpatialPrefixTreeFieldType)) {\n        AbstractSpatialPrefixTreeFieldType rptType = (AbstractSpatialPrefixTreeFieldType) type;\n        strategy = (PrefixTreeStrategy) rptType.getStrategy(fieldName);\n        distanceUnits = rptType.getDistanceUnits();\n      } else if (type instanceof RptWithGeometrySpatialField) {\n        RptWithGeometrySpatialField rptSdvType  = (RptWithGeometrySpatialField) type;\n        strategy = rptSdvType.getStrategy(fieldName).getIndexStrategy();\n        distanceUnits = rptSdvType.getDistanceUnits();\n      } else {\n        //FYI we support the term query one too but few people use that one\n        throw err(\"heatmap field needs to be of type \" + SpatialRecursivePrefixTreeFieldType.class + \" or \" + RptWithGeometrySpatialField.class);\n      }\n\n      final SpatialContext ctx = strategy.getSpatialContext();\n\n      //get the bbox (query Rectangle)\n      String geomStr = getString(argsMap, GEOM_PARAM, null);\n      final Shape boundsShape = geomStr == null ? ctx.getWorldBounds() : SpatialUtils.parseGeomSolrException(geomStr, ctx);\n\n      //get the grid level (possibly indirectly via distErr or distErrPct)\n      final int gridLevel;\n      final Long gridLevelObj = getLongOrNull(argsMap, LEVEL_PARAM, false);\n      final int maxGridLevel = strategy.getGrid().getMaxLevels();\n      if (gridLevelObj != null) {\n        gridLevel = gridLevelObj.intValue();\n        if (gridLevel <= 0 || gridLevel > maxGridLevel) {\n          throw err(LEVEL_PARAM +\" should be > 0 and <= \" + maxGridLevel);\n        }\n      } else {\n        //SpatialArgs has utility methods to resolve a 'distErr' from optionally set distErr & distErrPct. Arguably that\n        // should be refactored to feel less weird than using it like this.\n        SpatialArgs spatialArgs = new SpatialArgs(SpatialOperation.Intersects/*ignored*/,\n            boundsShape == null ? ctx.getWorldBounds() : boundsShape);\n        final Double distErrObj = getDoubleOrNull(argsMap, DIST_ERR_PARAM, false);\n        if (distErrObj != null) {\n          // convert distErr units based on configured units\n          spatialArgs.setDistErr(distErrObj * distanceUnits.multiplierFromThisUnitToDegrees());\n        }\n        spatialArgs.setDistErrPct(getDoubleOrNull(argsMap, DIST_ERR_PCT_PARAM, false));\n        double distErr = spatialArgs.resolveDistErr(ctx, DEFAULT_DIST_ERR_PCT);\n        if (distErr <= 0) {\n          throw err(DIST_ERR_PCT_PARAM + \" or \" + DIST_ERR_PARAM\n                  + \" should be > 0 or instead provide \" + LEVEL_PARAM + \"=\" + maxGridLevel\n                  + \" if you insist on maximum detail\");\n        }\n        //The SPT (grid) can lookup a grid level satisfying an error distance constraint\n        gridLevel = strategy.getGrid().getLevelForDistance(distErr);\n      }\n\n      final int maxCells = (int) getLong(argsMap, MAX_CELLS_PARAM, 100_000);// will throw later if exceeded\n\n      final String format = getString(argsMap, FORMAT_PARAM, FORMAT_INTS2D);\n      if (!format.equals(FORMAT_INTS2D) && !format.equals(FORMAT_PNG)) {\n        throw err(\"format should be \" + FORMAT_INTS2D + \" or \" + FORMAT_PNG);\n      }\n\n      this.facet = new FacetHeatmap(argsMap, strategy, boundsShape, gridLevel, maxCells, format);\n\n      parseCommonParams(argsObj); // e.g. domain change\n\n      return this.facet;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":0,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetHeatmap.Parser#parse(Object).mjava","pathOld":"/dev/null","sourceNew":"    public FacetHeatmap parse(Object argsObj) {\n      assert facet == null;\n\n      if (!(argsObj instanceof Map)) {\n        throw err(\"Missing heatmap arguments\");\n      }\n\n      @SuppressWarnings(\"unchecked\")\n      Map<String, Object> argsMap = (Map<String, Object>) argsObj;\n      String fieldName = getField(argsMap);\n\n      //get the strategy from the field type\n      final SchemaField schemaField = getSchema().getField(fieldName);\n      final FieldType type = schemaField.getType();\n\n      final PrefixTreeStrategy strategy;\n      final DistanceUnits distanceUnits;\n      // note: the two instanceof conditions is not ideal, versus one. If we start needing to add more then refactor.\n      if ((type instanceof AbstractSpatialPrefixTreeFieldType)) {\n        AbstractSpatialPrefixTreeFieldType rptType = (AbstractSpatialPrefixTreeFieldType) type;\n        strategy = (PrefixTreeStrategy) rptType.getStrategy(fieldName);\n        distanceUnits = rptType.getDistanceUnits();\n      } else if (type instanceof RptWithGeometrySpatialField) {\n        RptWithGeometrySpatialField rptSdvType  = (RptWithGeometrySpatialField) type;\n        strategy = rptSdvType.getStrategy(fieldName).getIndexStrategy();\n        distanceUnits = rptSdvType.getDistanceUnits();\n      } else {\n        //FYI we support the term query one too but few people use that one\n        throw err(\"heatmap field needs to be of type \" + SpatialRecursivePrefixTreeFieldType.class + \" or \" + RptWithGeometrySpatialField.class);\n      }\n\n      final SpatialContext ctx = strategy.getSpatialContext();\n\n      //get the bbox (query Rectangle)\n      String geomStr = getString(argsMap, GEOM_PARAM, null);\n      final Shape boundsShape = geomStr == null ? ctx.getWorldBounds() : SpatialUtils.parseGeomSolrException(geomStr, ctx);\n\n      //get the grid level (possibly indirectly via distErr or distErrPct)\n      final int gridLevel;\n      final Long gridLevelObj = getLongOrNull(argsMap, LEVEL_PARAM, false);\n      final int maxGridLevel = strategy.getGrid().getMaxLevels();\n      if (gridLevelObj != null) {\n        gridLevel = gridLevelObj.intValue();\n        if (gridLevel <= 0 || gridLevel > maxGridLevel) {\n          throw err(LEVEL_PARAM +\" should be > 0 and <= \" + maxGridLevel);\n        }\n      } else {\n        //SpatialArgs has utility methods to resolve a 'distErr' from optionally set distErr & distErrPct. Arguably that\n        // should be refactored to feel less weird than using it like this.\n        SpatialArgs spatialArgs = new SpatialArgs(SpatialOperation.Intersects/*ignored*/,\n            boundsShape == null ? ctx.getWorldBounds() : boundsShape);\n        final Double distErrObj = getDoubleOrNull(argsMap, DIST_ERR_PARAM, false);\n        if (distErrObj != null) {\n          // convert distErr units based on configured units\n          spatialArgs.setDistErr(distErrObj * distanceUnits.multiplierFromThisUnitToDegrees());\n        }\n        spatialArgs.setDistErrPct(getDoubleOrNull(argsMap, DIST_ERR_PCT_PARAM, false));\n        double distErr = spatialArgs.resolveDistErr(ctx, DEFAULT_DIST_ERR_PCT);\n        if (distErr <= 0) {\n          throw err(DIST_ERR_PCT_PARAM + \" or \" + DIST_ERR_PARAM\n                  + \" should be > 0 or instead provide \" + LEVEL_PARAM + \"=\" + maxGridLevel\n                  + \" if you insist on maximum detail\");\n        }\n        //The SPT (grid) can lookup a grid level satisfying an error distance constraint\n        gridLevel = strategy.getGrid().getLevelForDistance(distErr);\n      }\n\n      final int maxCells = (int) getLong(argsMap, MAX_CELLS_PARAM, 100_000);// will throw later if exceeded\n\n      final String format = getString(argsMap, FORMAT_PARAM, FORMAT_INTS2D);\n      if (!format.equals(FORMAT_INTS2D) && !format.equals(FORMAT_PNG)) {\n        throw err(\"format should be \" + FORMAT_INTS2D + \" or \" + FORMAT_PNG);\n      }\n\n      this.facet = new FacetHeatmap(argsMap, strategy, boundsShape, gridLevel, maxCells, format);\n\n      parseCommonParams(argsObj); // e.g. domain change\n\n      return this.facet;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a56a9893014b284af4d1af451e6c02e7ffdf5b6e","date":1590065972,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetHeatmap.Parser#parse(Object).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetHeatmap.Parser#parse(Object).mjava","sourceNew":"    public FacetHeatmap parse(Object argsObj) {\n      assert facet == null;\n\n      if (!(argsObj instanceof Map)) {\n        throw err(\"Missing heatmap arguments\");\n      }\n\n      @SuppressWarnings(\"unchecked\")\n      Map<String, Object> argsMap = (Map<String, Object>) argsObj;\n      String fieldName = getField(argsMap);\n\n      //get the strategy from the field type\n      final SchemaField schemaField = getSchema().getField(fieldName);\n      final FieldType type = schemaField.getType();\n\n      final PrefixTreeStrategy strategy;\n      final DistanceUnits distanceUnits;\n      // note: the two instanceof conditions is not ideal, versus one. If we start needing to add more then refactor.\n      if ((type instanceof AbstractSpatialPrefixTreeFieldType)) {\n        @SuppressWarnings({\"rawtypes\"})\n        AbstractSpatialPrefixTreeFieldType rptType = (AbstractSpatialPrefixTreeFieldType) type;\n        strategy = (PrefixTreeStrategy) rptType.getStrategy(fieldName);\n        distanceUnits = rptType.getDistanceUnits();\n      } else if (type instanceof RptWithGeometrySpatialField) {\n        RptWithGeometrySpatialField rptSdvType  = (RptWithGeometrySpatialField) type;\n        strategy = rptSdvType.getStrategy(fieldName).getIndexStrategy();\n        distanceUnits = rptSdvType.getDistanceUnits();\n      } else {\n        //FYI we support the term query one too but few people use that one\n        throw err(\"heatmap field needs to be of type \" + SpatialRecursivePrefixTreeFieldType.class + \" or \" + RptWithGeometrySpatialField.class);\n      }\n\n      final SpatialContext ctx = strategy.getSpatialContext();\n\n      //get the bbox (query Rectangle)\n      String geomStr = getString(argsMap, GEOM_PARAM, null);\n      final Shape boundsShape = geomStr == null ? ctx.getWorldBounds() : SpatialUtils.parseGeomSolrException(geomStr, ctx);\n\n      //get the grid level (possibly indirectly via distErr or distErrPct)\n      final int gridLevel;\n      final Long gridLevelObj = getLongOrNull(argsMap, LEVEL_PARAM, false);\n      final int maxGridLevel = strategy.getGrid().getMaxLevels();\n      if (gridLevelObj != null) {\n        gridLevel = gridLevelObj.intValue();\n        if (gridLevel <= 0 || gridLevel > maxGridLevel) {\n          throw err(LEVEL_PARAM +\" should be > 0 and <= \" + maxGridLevel);\n        }\n      } else {\n        //SpatialArgs has utility methods to resolve a 'distErr' from optionally set distErr & distErrPct. Arguably that\n        // should be refactored to feel less weird than using it like this.\n        SpatialArgs spatialArgs = new SpatialArgs(SpatialOperation.Intersects/*ignored*/,\n            boundsShape == null ? ctx.getWorldBounds() : boundsShape);\n        final Double distErrObj = getDoubleOrNull(argsMap, DIST_ERR_PARAM, false);\n        if (distErrObj != null) {\n          // convert distErr units based on configured units\n          spatialArgs.setDistErr(distErrObj * distanceUnits.multiplierFromThisUnitToDegrees());\n        }\n        spatialArgs.setDistErrPct(getDoubleOrNull(argsMap, DIST_ERR_PCT_PARAM, false));\n        double distErr = spatialArgs.resolveDistErr(ctx, DEFAULT_DIST_ERR_PCT);\n        if (distErr <= 0) {\n          throw err(DIST_ERR_PCT_PARAM + \" or \" + DIST_ERR_PARAM\n                  + \" should be > 0 or instead provide \" + LEVEL_PARAM + \"=\" + maxGridLevel\n                  + \" if you insist on maximum detail\");\n        }\n        //The SPT (grid) can lookup a grid level satisfying an error distance constraint\n        gridLevel = strategy.getGrid().getLevelForDistance(distErr);\n      }\n\n      final int maxCells = (int) getLong(argsMap, MAX_CELLS_PARAM, 100_000);// will throw later if exceeded\n\n      final String format = getString(argsMap, FORMAT_PARAM, FORMAT_INTS2D);\n      if (!format.equals(FORMAT_INTS2D) && !format.equals(FORMAT_PNG)) {\n        throw err(\"format should be \" + FORMAT_INTS2D + \" or \" + FORMAT_PNG);\n      }\n\n      this.facet = new FacetHeatmap(argsMap, strategy, boundsShape, gridLevel, maxCells, format);\n\n      parseCommonParams(argsObj); // e.g. domain change\n\n      return this.facet;\n    }\n\n","sourceOld":"    public FacetHeatmap parse(Object argsObj) {\n      assert facet == null;\n\n      if (!(argsObj instanceof Map)) {\n        throw err(\"Missing heatmap arguments\");\n      }\n\n      @SuppressWarnings(\"unchecked\")\n      Map<String, Object> argsMap = (Map<String, Object>) argsObj;\n      String fieldName = getField(argsMap);\n\n      //get the strategy from the field type\n      final SchemaField schemaField = getSchema().getField(fieldName);\n      final FieldType type = schemaField.getType();\n\n      final PrefixTreeStrategy strategy;\n      final DistanceUnits distanceUnits;\n      // note: the two instanceof conditions is not ideal, versus one. If we start needing to add more then refactor.\n      if ((type instanceof AbstractSpatialPrefixTreeFieldType)) {\n        AbstractSpatialPrefixTreeFieldType rptType = (AbstractSpatialPrefixTreeFieldType) type;\n        strategy = (PrefixTreeStrategy) rptType.getStrategy(fieldName);\n        distanceUnits = rptType.getDistanceUnits();\n      } else if (type instanceof RptWithGeometrySpatialField) {\n        RptWithGeometrySpatialField rptSdvType  = (RptWithGeometrySpatialField) type;\n        strategy = rptSdvType.getStrategy(fieldName).getIndexStrategy();\n        distanceUnits = rptSdvType.getDistanceUnits();\n      } else {\n        //FYI we support the term query one too but few people use that one\n        throw err(\"heatmap field needs to be of type \" + SpatialRecursivePrefixTreeFieldType.class + \" or \" + RptWithGeometrySpatialField.class);\n      }\n\n      final SpatialContext ctx = strategy.getSpatialContext();\n\n      //get the bbox (query Rectangle)\n      String geomStr = getString(argsMap, GEOM_PARAM, null);\n      final Shape boundsShape = geomStr == null ? ctx.getWorldBounds() : SpatialUtils.parseGeomSolrException(geomStr, ctx);\n\n      //get the grid level (possibly indirectly via distErr or distErrPct)\n      final int gridLevel;\n      final Long gridLevelObj = getLongOrNull(argsMap, LEVEL_PARAM, false);\n      final int maxGridLevel = strategy.getGrid().getMaxLevels();\n      if (gridLevelObj != null) {\n        gridLevel = gridLevelObj.intValue();\n        if (gridLevel <= 0 || gridLevel > maxGridLevel) {\n          throw err(LEVEL_PARAM +\" should be > 0 and <= \" + maxGridLevel);\n        }\n      } else {\n        //SpatialArgs has utility methods to resolve a 'distErr' from optionally set distErr & distErrPct. Arguably that\n        // should be refactored to feel less weird than using it like this.\n        SpatialArgs spatialArgs = new SpatialArgs(SpatialOperation.Intersects/*ignored*/,\n            boundsShape == null ? ctx.getWorldBounds() : boundsShape);\n        final Double distErrObj = getDoubleOrNull(argsMap, DIST_ERR_PARAM, false);\n        if (distErrObj != null) {\n          // convert distErr units based on configured units\n          spatialArgs.setDistErr(distErrObj * distanceUnits.multiplierFromThisUnitToDegrees());\n        }\n        spatialArgs.setDistErrPct(getDoubleOrNull(argsMap, DIST_ERR_PCT_PARAM, false));\n        double distErr = spatialArgs.resolveDistErr(ctx, DEFAULT_DIST_ERR_PCT);\n        if (distErr <= 0) {\n          throw err(DIST_ERR_PCT_PARAM + \" or \" + DIST_ERR_PARAM\n                  + \" should be > 0 or instead provide \" + LEVEL_PARAM + \"=\" + maxGridLevel\n                  + \" if you insist on maximum detail\");\n        }\n        //The SPT (grid) can lookup a grid level satisfying an error distance constraint\n        gridLevel = strategy.getGrid().getLevelForDistance(distErr);\n      }\n\n      final int maxCells = (int) getLong(argsMap, MAX_CELLS_PARAM, 100_000);// will throw later if exceeded\n\n      final String format = getString(argsMap, FORMAT_PARAM, FORMAT_INTS2D);\n      if (!format.equals(FORMAT_INTS2D) && !format.equals(FORMAT_PNG)) {\n        throw err(\"format should be \" + FORMAT_INTS2D + \" or \" + FORMAT_PNG);\n      }\n\n      this.facet = new FacetHeatmap(argsMap, strategy, boundsShape, gridLevel, maxCells, format);\n\n      parseCommonParams(argsObj); // e.g. domain change\n\n      return this.facet;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2ab027bdfe663227636ccbeda13ae82add302939":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["2ab027bdfe663227636ccbeda13ae82add302939"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2ab027bdfe663227636ccbeda13ae82add302939"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2ab027bdfe663227636ccbeda13ae82add302939"]},"commit2Childs":{"2ab027bdfe663227636ccbeda13ae82add302939":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2ab027bdfe663227636ccbeda13ae82add302939","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}