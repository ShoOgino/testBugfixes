{"path":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","commits":[{"id":"7272013f8448f299f54112ec41cb3dc047cda543","date":1453483707,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Set[Node],Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser, final Set<Node> childrenFound,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, childrenFound, handler, values, stack, isRecordStarted, this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fd61945b522c69b4bdd1a107f06659c8fee30c3","date":1464716529,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b4e08e2b6886d78c91752d82ea2b436c4324cd55","date":1464786234,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"611f7ea4eee5babadf4129bfa5fbae964738cd7c","date":1464787051,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b8ee93140fd0efef7e101786e3ed5160a700b5f","date":1464820111,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77","date":1464821470,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"026b7e389cd847f6590f8783e6f9f1c8d2b80fcd","date":1472647322,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(values, splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc8f206328a706450934717bec7ccc22ad166fc0","date":1473142172,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(values, splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(values, splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(values, splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have deperted from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is chached in the HashMap decends. Then if the new tag is to be skipped,\n     * any inner chil tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occurr when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n              }\n            }\n          }\n\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(getDeepCopy(values), splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in  . skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8ca2a5b85f19f987ca3b1a0aafd41ab4b9e7bfd8","date":1493287267,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(values, splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n          values.remove(null);\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(values, splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(values, splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n          values.remove(null);\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(values, splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9440b5b1eec7788a0edd10385e4d7a614d1024d7","date":1528992889,"type":3,"author":"user","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                // if single item in array will still be added as array\n                if(!values.containsKey(name)) {\n                  values.put(name, new ArrayList<>());\n                }\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values, getPathSuffix(path)),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(values, splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n          values.remove(null);\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(values, splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n          values.remove(null);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"649e3bfe4ffa5e921ce7657ceec85e58b82d9c32","date":1529037977,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) {\n                // ensure that the value is of type List\n                final Object val = values.get(name);\n                if (val != null && !(val instanceof List)) {\n                  final ArrayList listVal = new ArrayList(1);\n                  listVal.add(val);\n                  values.put(name, listVal);\n                }\n                break;\n              }\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values, getPathSuffix(path)),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(values, splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                // if single item in array will still be added as array\n                if(!values.containsKey(name)) {\n                  values.put(name, new ArrayList<>());\n                }\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values, getPathSuffix(path)),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(values, splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n          values.remove(null);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) {\n                // ensure that the value is of type List\n                final Object val = values.get(name);\n                if (val != null && !(val instanceof List)) {\n                  final ArrayList listVal = new ArrayList(1);\n                  listVal.add(val);\n                  values.put(name, listVal);\n                }\n                break;\n              }\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values, getPathSuffix(path)),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(values, splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(values, splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n          values.remove(null);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) {\n                // ensure that the value is of type List\n                final Object val = values.get(name);\n                if (val != null && !(val instanceof List)) {\n                  final ArrayList listVal = new ArrayList(1);\n                  listVal.add(val);\n                  values.put(name, listVal);\n                }\n                break;\n              }\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values, getPathSuffix(path)),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(values, splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) break;\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(values, splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n          values.remove(null);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7dfea4f7c80813344b0152e37fc18b31369e8ff","date":1592136683,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/JsonRecordReader.Node#handleObjectStart(JSONParser,Handler,Map[String,Object],Stack[Set[String]],boolean,MethodFrameWrapper).mjava","sourceNew":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        @SuppressWarnings({\"unchecked\"})\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) {\n                // ensure that the value is of type List\n                final Object val = values.get(name);\n                if (val != null && !(val instanceof List)) {\n                  @SuppressWarnings({\"rawtypes\"})\n                  final ArrayList listVal = new ArrayList(1);\n                  listVal.add(val);\n                  values.put(name, listVal);\n                }\n                break;\n              }\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values, getPathSuffix(path)),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(values, splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * If a new tag is encountered, check if it is of interest or not by seeing\n     * if it matches against our node tree. If we have departed from the node\n     * tree then walk back though the tree's ancestor nodes checking to see if\n     * any // expressions exist for the node and compare them against the new\n     * tag. If matched then \"jump\" to that node, otherwise ignore the tag.\n     * <p>\n     * Note, the list of // expressions found while walking back up the tree\n     * is cached in the HashMap descendants. Then if the new tag is to be skipped,\n     * any inner child tags are compared against the cache and jumped to if\n     * matched.\n     */\n    private void handleObjectStart(final JSONParser parser,\n                                   final Handler handler, final Map<String, Object> values,\n                                   final Stack<Set<String>> stack, boolean recordStarted,\n                                   MethodFrameWrapper frameWrapper)\n        throws IOException {\n\n      final boolean isRecordStarted = recordStarted || isRecord;\n      Set<String> valuesAddedinThisFrame = null;\n      if (isRecord || !recordStarted) {\n        // This Node is a match for an PATH from a forEach attribute,\n        // prepare for the clean up that will occur when the record\n        // is emitted after its END_ELEMENT is matched\n        valuesAddedinThisFrame = new HashSet<>();\n        stack.push(valuesAddedinThisFrame);\n      } else if (recordStarted) {\n        // This node is a child of some parent which matched against forEach\n        // attribute. Continue to add values to an existing record.\n        valuesAddedinThisFrame = stack.peek();\n      }\n\n      class Wrapper extends MethodFrameWrapper {\n        Wrapper(Node node, MethodFrameWrapper parent, String name) {\n          this.node = node;\n          this.parent = parent;\n          this.name = name;\n        }\n\n        @Override\n        public void walk(int event) throws IOException {\n          if (event == OBJECT_START) {\n            walkObject();\n          } else if (event == ARRAY_START) {\n            for (; ; ) {\n              event = parser.nextEvent();\n              if (event == ARRAY_END) {\n                // ensure that the value is of type List\n                final Object val = values.get(name);\n                if (val != null && !(val instanceof List)) {\n                  final ArrayList listVal = new ArrayList(1);\n                  listVal.add(val);\n                  values.put(name, listVal);\n                }\n                break;\n              }\n              if (event == OBJECT_START) {\n                walkObject();\n              }\n            }\n          }\n        }\n\n        void walkObject() throws IOException {\n          if (node.isChildRecord) {\n            node.handleObjectStart(parser,\n                (record, path) -> addChildDoc2ParentDoc(record, values, getPathSuffix(path)),\n                new LinkedHashMap<>(),\n                new Stack<>(),\n                true,\n                this\n            );\n          } else {\n            node.handleObjectStart(parser, handler, values, stack, isRecordStarted, this);\n          }\n        }\n      }\n\n      try {\n        for (; ; ) {\n          int event = parser.nextEvent();\n          if (event == OBJECT_END) {\n            if (isRecord()) {\n              handler.handle(values, splitPath);\n            }\n            return;\n          }\n          assert event == STRING;\n          assert parser.wasKey();\n          String name = parser.getString();\n\n          Node node = childNodes.get(name);\n          if (node == null) node = wildCardChild;\n          if (node == null) node = recursiveWildCardChild;\n\n          if (node != null) {\n            if (node.isLeaf) {//this is a leaf. Collect data here\n              event = parser.nextEvent();\n              String nameInRecord = node.fieldName == null ? getNameInRecord(name, frameWrapper, node) : node.fieldName;\n              MethodFrameWrapper runnable = null;\n              if (event == OBJECT_START || event == ARRAY_START) {\n                if (node.recursiveWildCardChild != null) runnable = new Wrapper(node, frameWrapper, name);\n              }\n              Object val = parseSingleFieldValue(event, parser, runnable);\n              if (val != null) {\n                putValue(values, nameInRecord, val);\n                valuesAddedinThisFrame.add(nameInRecord);\n              }\n\n            } else {\n              event = parser.nextEvent();\n              new Wrapper(node, frameWrapper, name).walk(event);\n            }\n          } else {\n            //this is not something we are interested in. Skip it\n            event = parser.nextEvent();\n            if (event == STRING ||\n                event == LONG ||\n                event == NUMBER ||\n                event == BIGNUMBER ||\n                event == BOOLEAN ||\n                event == NULL) {\n              continue;\n            }\n            if (event == ARRAY_START) {\n              consumeTillMatchingEnd(parser, 0, 1);\n              continue;\n            }\n            if (event == OBJECT_START) {\n              consumeTillMatchingEnd(parser, 1, 0);\n              continue;\n            } else throw new RuntimeException(\"unexpected token \" + event);\n\n          }\n        }\n      } finally {\n        if ((isRecord() || !isRecordStarted)) {\n          for (String fld : valuesAddedinThisFrame) {\n            values.remove(fld);\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b4e08e2b6886d78c91752d82ea2b436c4324cd55":["9fd61945b522c69b4bdd1a107f06659c8fee30c3"],"7272013f8448f299f54112ec41cb3dc047cda543":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9440b5b1eec7788a0edd10385e4d7a614d1024d7":["8ca2a5b85f19f987ca3b1a0aafd41ab4b9e7bfd8"],"a7dfea4f7c80813344b0152e37fc18b31369e8ff":["649e3bfe4ffa5e921ce7657ceec85e58b82d9c32"],"8ca2a5b85f19f987ca3b1a0aafd41ab4b9e7bfd8":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"bc8f206328a706450934717bec7ccc22ad166fc0":["b4e08e2b6886d78c91752d82ea2b436c4324cd55","026b7e389cd847f6590f8783e6f9f1c8d2b80fcd"],"5b8ee93140fd0efef7e101786e3ed5160a700b5f":["7272013f8448f299f54112ec41cb3dc047cda543","611f7ea4eee5babadf4129bfa5fbae964738cd7c"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7272013f8448f299f54112ec41cb3dc047cda543","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77":["7272013f8448f299f54112ec41cb3dc047cda543","5b8ee93140fd0efef7e101786e3ed5160a700b5f"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","8ca2a5b85f19f987ca3b1a0aafd41ab4b9e7bfd8"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["8ca2a5b85f19f987ca3b1a0aafd41ab4b9e7bfd8","649e3bfe4ffa5e921ce7657ceec85e58b82d9c32"],"026b7e389cd847f6590f8783e6f9f1c8d2b80fcd":["b4e08e2b6886d78c91752d82ea2b436c4324cd55"],"9fd61945b522c69b4bdd1a107f06659c8fee30c3":["7272013f8448f299f54112ec41cb3dc047cda543"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["b4e08e2b6886d78c91752d82ea2b436c4324cd55","026b7e389cd847f6590f8783e6f9f1c8d2b80fcd"],"611f7ea4eee5babadf4129bfa5fbae964738cd7c":["9fd61945b522c69b4bdd1a107f06659c8fee30c3","b4e08e2b6886d78c91752d82ea2b436c4324cd55"],"649e3bfe4ffa5e921ce7657ceec85e58b82d9c32":["9440b5b1eec7788a0edd10385e4d7a614d1024d7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a7dfea4f7c80813344b0152e37fc18b31369e8ff"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["8ca2a5b85f19f987ca3b1a0aafd41ab4b9e7bfd8","649e3bfe4ffa5e921ce7657ceec85e58b82d9c32"]},"commit2Childs":{"b4e08e2b6886d78c91752d82ea2b436c4324cd55":["bc8f206328a706450934717bec7ccc22ad166fc0","026b7e389cd847f6590f8783e6f9f1c8d2b80fcd","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","611f7ea4eee5babadf4129bfa5fbae964738cd7c"],"7272013f8448f299f54112ec41cb3dc047cda543":["5b8ee93140fd0efef7e101786e3ed5160a700b5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77","9fd61945b522c69b4bdd1a107f06659c8fee30c3"],"9440b5b1eec7788a0edd10385e4d7a614d1024d7":["649e3bfe4ffa5e921ce7657ceec85e58b82d9c32"],"a7dfea4f7c80813344b0152e37fc18b31369e8ff":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8ca2a5b85f19f987ca3b1a0aafd41ab4b9e7bfd8":["9440b5b1eec7788a0edd10385e4d7a614d1024d7","e9017cf144952056066919f1ebc7897ff9bd71b1","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"bc8f206328a706450934717bec7ccc22ad166fc0":[],"5b8ee93140fd0efef7e101786e3ed5160a700b5f":["b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77":[],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"026b7e389cd847f6590f8783e6f9f1c8d2b80fcd":["bc8f206328a706450934717bec7ccc22ad166fc0","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"9fd61945b522c69b4bdd1a107f06659c8fee30c3":["b4e08e2b6886d78c91752d82ea2b436c4324cd55","611f7ea4eee5babadf4129bfa5fbae964738cd7c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7272013f8448f299f54112ec41cb3dc047cda543"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["8ca2a5b85f19f987ca3b1a0aafd41ab4b9e7bfd8","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e9017cf144952056066919f1ebc7897ff9bd71b1"],"611f7ea4eee5babadf4129bfa5fbae964738cd7c":["5b8ee93140fd0efef7e101786e3ed5160a700b5f"],"649e3bfe4ffa5e921ce7657ceec85e58b82d9c32":["a7dfea4f7c80813344b0152e37fc18b31369e8ff","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["bc8f206328a706450934717bec7ccc22ad166fc0","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77","e9017cf144952056066919f1ebc7897ff9bd71b1","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}