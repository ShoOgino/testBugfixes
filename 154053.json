{"path":"solr/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","commits":[{"id":"7a71a0b2d4be2299a163f60626729852d81a8e02","date":1309442399,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        }\n\n      } else {\n        IndexReader reader = getIndexReaderFactory().newReader(getDirectoryFactory().open(newIndexDir), true);\n        tmp = new SolrIndexSearcher(this, schema, \"main\", reader, true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe","7a0b8b7d237d61dcead2d98e45b3479941a41db8","7a0b8b7d237d61dcead2d98e45b3479941a41db8","7a0b8b7d237d61dcead2d98e45b3479941a41db8","e22ffe8cc51a892ae103df018822d7873e901c2a","e22ffe8cc51a892ae103df018822d7873e901c2a","e22ffe8cc51a892ae103df018822d7873e901c2a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        }\n\n      } else {\n        IndexReader reader = getIndexReaderFactory().newReader(getDirectoryFactory().open(newIndexDir), true);\n        tmp = new SolrIndexSearcher(this, schema, \"main\", reader, true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        }\n\n      } else {\n        IndexReader reader = getIndexReaderFactory().newReader(getDirectoryFactory().open(newIndexDir), true);\n        tmp = new SolrIndexSearcher(this, schema, \"main\", reader, true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        }\n\n      } else {\n        IndexReader reader = getIndexReaderFactory().newReader(getDirectoryFactory().open(newIndexDir), true);\n        tmp = new SolrIndexSearcher(this, schema, \"main\", reader, true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        }\n\n      } else {\n        IndexReader reader = getIndexReaderFactory().newReader(getDirectoryFactory().open(newIndexDir), true);\n        tmp = new SolrIndexSearcher(this, schema, \"main\", reader, true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        }\n\n      } else {\n        IndexReader reader = getIndexReaderFactory().newReader(getDirectoryFactory().open(newIndexDir), true);\n        tmp = new SolrIndexSearcher(this, schema, \"main\", reader, true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        }\n\n      } else {\n        IndexReader reader = getIndexReaderFactory().newReader(getDirectoryFactory().open(newIndexDir), true);\n        tmp = new SolrIndexSearcher(this, schema, \"main\", reader, true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#getSearcher(boolean,boolean,Future[],boolean).mjava","sourceNew":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        }\n\n      } else {\n        IndexReader reader = getIndexReaderFactory().newReader(getDirectoryFactory().open(newIndexDir), true);\n        tmp = new SolrIndexSearcher(this, schema, \"main\", reader, true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Get a {@link SolrIndexSearcher} or start the process of creating a new one.\n   * <p>\n   * The registered searcher is the default searcher used to service queries.\n   * A searcher will normally be registered after all of the warming\n   * and event handlers (newSearcher or firstSearcher events) have run.\n   * In the case where there is no registered searcher, the newly created searcher will\n   * be registered before running the event handlers (a slow searcher is better than no searcher).\n   *\n   * <p>\n   * These searchers contain read-only IndexReaders. To access a non read-only IndexReader,\n   * see newSearcher(String name, boolean readOnly).\n   *\n   * <p>\n   * If <tt>forceNew==true</tt> then\n   *  A new searcher will be opened and registered regardless of whether there is already\n   *    a registered searcher or other searchers in the process of being created.\n   * <p>\n   * If <tt>forceNew==false</tt> then:<ul>\n   *   <li>If a searcher is already registered, that searcher will be returned</li>\n   *   <li>If no searcher is currently registered, but at least one is in the process of being created, then\n   * this call will block until the first searcher is registered</li>\n   *   <li>If no searcher is currently registered, and no searchers in the process of being registered, a new\n   * searcher will be created.</li>\n   * </ul>\n   * <p>\n   * If <tt>returnSearcher==true</tt> then a {@link RefCounted}&lt;{@link SolrIndexSearcher}&gt; will be returned with\n   * the reference count incremented.  It <b>must</b> be decremented when no longer needed.\n   * <p>\n   * If <tt>waitSearcher!=null</tt> and a new {@link SolrIndexSearcher} was created,\n   * then it is filled in with a Future that will return after the searcher is registered.  The Future may be set to\n   * <tt>null</tt> in which case the SolrIndexSearcher created has already been registered at the time\n   * this method returned.\n   * <p>\n   * @param forceNew             if true, force the open of a new index searcher regardless if there is already one open.\n   * @param returnSearcher       if true, returns a {@link SolrIndexSearcher} holder with the refcount already incremented.\n   * @param waitSearcher         if non-null, will be filled in with a {@link Future} that will return after the new searcher is registered.\n   * @param updateHandlerReopens if true, the UpdateHandler will be used when reopening a {@link SolrIndexSearcher}.\n   * @throws IOException\n   */\n  public RefCounted<SolrIndexSearcher> getSearcher(boolean forceNew, boolean returnSearcher, final Future[] waitSearcher, boolean updateHandlerReopens) throws IOException {\n    // it may take some time to open an index.... we may need to make\n    // sure that two threads aren't trying to open one at the same time\n    // if it isn't necessary.\n\n    synchronized (searcherLock) {\n      // see if we can return the current searcher\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // check to see if we can wait for someone else's searcher to be set\n      if (onDeckSearchers>0 && !forceNew && _searcher==null) {\n        try {\n          searcherLock.wait();\n        } catch (InterruptedException e) {\n          log.info(SolrException.toStr(e));\n        }\n      }\n\n      // check again: see if we can return right now\n      if (_searcher!=null && !forceNew) {\n        if (returnSearcher) {\n          _searcher.incref();\n          return _searcher;\n        } else {\n          return null;\n        }\n      }\n\n      // At this point, we know we need to open a new searcher...\n      // first: increment count to signal other threads that we are\n      //        opening a new searcher.\n      onDeckSearchers++;\n      if (onDeckSearchers < 1) {\n        // should never happen... just a sanity check\n        log.error(logid+\"ERROR!!! onDeckSearchers is \" + onDeckSearchers);\n        onDeckSearchers=1;  // reset\n      } else if (onDeckSearchers > maxWarmingSearchers) {\n        onDeckSearchers--;\n        String msg=\"Error opening new searcher. exceeded limit of maxWarmingSearchers=\"+maxWarmingSearchers + \", try again later.\";\n        log.warn(logid+\"\"+ msg);\n        // HTTP 503==service unavailable, or 409==Conflict\n        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg,true);\n      } else if (onDeckSearchers > 1) {\n        log.info(logid+\"PERFORMANCE WARNING: Overlapping onDeckSearchers=\" + onDeckSearchers);\n      }\n    }\n\n    // open the index synchronously\n    // if this fails, we need to decrement onDeckSearchers again.\n    SolrIndexSearcher tmp;\n    RefCounted<SolrIndexSearcher> newestSearcher = null;\n\n    try {\n      newestSearcher = getNewestSearcher(false);\n      String newIndexDir = getNewIndexDir();\n      File indexDirFile = new File(getIndexDir()).getCanonicalFile();\n      File newIndexDirFile = new File(newIndexDir).getCanonicalFile();\n      \n      if (newestSearcher != null && solrConfig.reopenReaders\n          && indexDirFile.equals(newIndexDirFile)) {\n        \n        if (updateHandlerReopens) {\n          \n          tmp = getUpdateHandler().reopenSearcher(newestSearcher.get());\n          \n        } else {\n          \n          IndexReader currentReader = newestSearcher.get().getIndexReader();\n          IndexReader newReader;\n          \n          newReader = currentReader.reopen();\n          \n          if (newReader == currentReader) {\n            currentReader.incRef();\n          }\n          \n          tmp = new SolrIndexSearcher(this, schema, \"main\", newReader, true, true);\n        }\n\n      } else {\n        IndexReader reader = getIndexReaderFactory().newReader(getDirectoryFactory().open(newIndexDir), true);\n        tmp = new SolrIndexSearcher(this, schema, \"main\", reader, true, true);\n      }\n    } catch (Throwable th) {\n      synchronized(searcherLock) {\n        onDeckSearchers--;\n        // notify another waiter to continue... it may succeed\n        // and wake any others.\n        searcherLock.notify();\n      }\n      // need to close the searcher here??? we shouldn't have to.\n      throw new RuntimeException(th);\n    } finally {\n      if (newestSearcher != null) {\n        newestSearcher.decref();\n      }\n    }\n    \n    final SolrIndexSearcher newSearcher=tmp;\n\n    RefCounted<SolrIndexSearcher> currSearcherHolder=null;\n    final RefCounted<SolrIndexSearcher> newSearchHolder=newHolder(newSearcher);\n\n    if (returnSearcher) newSearchHolder.incref();\n\n    // a signal to decrement onDeckSearchers if something goes wrong.\n    final boolean[] decrementOnDeckCount=new boolean[1];\n    decrementOnDeckCount[0]=true;\n\n    try {\n\n      boolean alreadyRegistered = false;\n      synchronized (searcherLock) {\n        _searchers.add(newSearchHolder);\n\n        if (_searcher == null) {\n          // if there isn't a current searcher then we may\n          // want to register this one before warming is complete instead of waiting.\n          if (solrConfig.useColdSearcher) {\n            registerSearcher(newSearchHolder);\n            decrementOnDeckCount[0]=false;\n            alreadyRegistered=true;\n          }\n        } else {\n          // get a reference to the current searcher for purposes of autowarming.\n          currSearcherHolder=_searcher;\n          currSearcherHolder.incref();\n        }\n      }\n\n\n      final SolrIndexSearcher currSearcher = currSearcherHolder==null ? null : currSearcherHolder.get();\n\n      //\n      // Note! if we registered the new searcher (but didn't increment it's\n      // reference count because returnSearcher==false, it's possible for\n      // someone else to register another searcher, and thus cause newSearcher\n      // to close while we are warming.\n      //\n      // Should we protect against that by incrementing the reference count?\n      // Maybe we should just let it fail?   After all, if returnSearcher==false\n      // and newSearcher has been de-registered, what's the point of continuing?\n      //\n\n      Future future=null;\n\n      // warm the new searcher based on the current searcher.\n      // should this go before the other event handlers or after?\n      if (currSearcher != null) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      newSearcher.warm(currSearcher);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n      \n      if (currSearcher==null && firstSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : firstSearcherListeners) {\n                        listener.newSearcher(newSearcher,null);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (currSearcher!=null && newSearcherListeners.size() > 0) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      for (SolrEventListener listener : newSearcherListeners) {\n                        listener.newSearcher(newSearcher, currSearcher);\n                      }\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      // WARNING: this code assumes a single threaded executor (that all tasks\n      // queued will finish first).\n      final RefCounted<SolrIndexSearcher> currSearcherHolderF = currSearcherHolder;\n      if (!alreadyRegistered) {\n        future = searcherExecutor.submit(\n                new Callable() {\n                  public Object call() throws Exception {\n                    try {\n                      // signal that we no longer need to decrement\n                      // the count *before* registering the searcher since\n                      // registerSearcher will decrement even if it errors.\n                      decrementOnDeckCount[0]=false;\n                      registerSearcher(newSearchHolder);\n                    } catch (Throwable e) {\n                      SolrException.logOnce(log,null,e);\n                    } finally {\n                      // we are all done with the old searcher we used\n                      // for warming...\n                      if (currSearcherHolderF!=null) currSearcherHolderF.decref();\n                    }\n                    return null;\n                  }\n                }\n        );\n      }\n\n      if (waitSearcher != null) {\n        waitSearcher[0] = future;\n      }\n\n      // Return the searcher as the warming tasks run in parallel\n      // callers may wait on the waitSearcher future returned.\n      return returnSearcher ? newSearchHolder : null;\n\n    } catch (Exception e) {\n      SolrException.logOnce(log,null,e);\n      if (currSearcherHolder != null) currSearcherHolder.decref();\n\n      synchronized (searcherLock) {\n        if (decrementOnDeckCount[0]) {\n          onDeckSearchers--;\n        }\n        if (onDeckSearchers < 0) {\n          // sanity check... should never happen\n          log.error(logid+\"ERROR!!! onDeckSearchers after decrement=\" + onDeckSearchers);\n          onDeckSearchers=0; // try and recover\n        }\n        // if we failed, we need to wake up at least one waiter to continue the process\n        searcherLock.notify();\n      }\n\n      // since the indexreader was already opened, assume we can continue on\n      // even though we got an exception.\n      return returnSearcher ? newSearchHolder : null;\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["817d8435e9135b756f08ce6710ab0baac51bdf88"],"c26f00b574427b55127e869b935845554afde1fa":["7a71a0b2d4be2299a163f60626729852d81a8e02","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["7a71a0b2d4be2299a163f60626729852d81a8e02"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7a71a0b2d4be2299a163f60626729852d81a8e02"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7a71a0b2d4be2299a163f60626729852d81a8e02"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"],"7a71a0b2d4be2299a163f60626729852d81a8e02":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","7a71a0b2d4be2299a163f60626729852d81a8e02"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"817d8435e9135b756f08ce6710ab0baac51bdf88":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"7a71a0b2d4be2299a163f60626729852d81a8e02":["c26f00b574427b55127e869b935845554afde1fa","a258fbb26824fd104ed795e5d9033d2d040049ee","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a258fbb26824fd104ed795e5d9033d2d040049ee","d083e83f225b11e5fdd900e83d26ddb385b6955c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}