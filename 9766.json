{"path":"lucene/core/src/java/org/apache/lucene/search/DimensionalRangeQuery#createWeight(IndexSearcher,boolean).mjava","commits":[{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/DimensionalRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        DimensionalValues values = reader.getDimensionalValues();\n        if (values == null) {\n          // No docs in this segment indexed any field dimensionally\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != null && bytesPerDim.intValue() != fieldInfo.getDimensionNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getDimensionNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getDimensionNumBytes();\n\n        byte[] packedLowerIncl = new byte[numDims * bytesPerDim];\n        byte[] packedUpperIncl = new byte[numDims * bytesPerDim];\n\n        byte[] minValue = new byte[bytesPerDim];\n        byte[] maxValue = new byte[bytesPerDim];\n        Arrays.fill(maxValue, (byte) 0xff);\n\n        byte[] one = new byte[bytesPerDim];\n        one[bytesPerDim-1] = 1;\n\n        // Carefully pack lower and upper bounds, taking care of per-dim inclusive:\n        for(int dim=0;dim<numDims;dim++) {\n          if (lowerPoint[dim] != null) {\n            if (lowerInclusive[dim] == false) {\n              if (Arrays.equals(lowerPoint[dim], maxValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                BKDUtil.add(bytesPerDim, 0, lowerPoint[dim], one, value);\n                System.arraycopy(value, 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(lowerPoint[dim], 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: we just leave 0s in this packed dim for the lower value\n          }\n\n          if (upperPoint[dim] != null) {\n            if (upperInclusive[dim] == false) {\n              if (Arrays.equals(upperPoint[dim], minValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                BKDUtil.subtract(bytesPerDim, 0, upperPoint[dim], one, value);\n                System.arraycopy(value, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(upperPoint[dim], 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: fill with max point for this dim:\n            System.arraycopy(maxValue, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n          }\n        }\n\n        // Now packedLowerIncl and packedUpperIncl are inclusive, and non-empty space:\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLowerIncl, offset) < 0) {\n                                 // Doc's value is too low, in this dimension\n                                 return;\n                               }\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpperIncl, offset) > 0) {\n                                 // Doc's value is too high, in this dimension\n                                 return;\n                               }\n                             }\n\n                             // Doc is in-bounds\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                             boolean crosses = false;\n\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n\n                               if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpperIncl, offset) > 0 ||\n                                   StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLowerIncl, offset) < 0) {\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n\n                               crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLowerIncl, offset) < 0 ||\n                                 StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpperIncl, offset) > 0;\n                             }\n\n                             if (crosses) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5839bca64b33c24668e37476ee168d00dc0bb96d","606ea169579957651185909e7264798e99e714f9","1800b996d8677670482a071dcb7a48b08c423ace"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/DimensionalRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/DimensionalRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        DimensionalValues values = reader.getDimensionalValues();\n        if (values == null) {\n          // No docs in this segment indexed any field dimensionally\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != null && bytesPerDim.intValue() != fieldInfo.getDimensionNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getDimensionNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getDimensionNumBytes();\n\n        byte[] packedLowerIncl = new byte[numDims * bytesPerDim];\n        byte[] packedUpperIncl = new byte[numDims * bytesPerDim];\n\n        byte[] minValue = new byte[bytesPerDim];\n        byte[] maxValue = new byte[bytesPerDim];\n        Arrays.fill(maxValue, (byte) 0xff);\n\n        byte[] one = new byte[bytesPerDim];\n        one[bytesPerDim-1] = 1;\n\n        // Carefully pack lower and upper bounds, taking care of per-dim inclusive:\n        for(int dim=0;dim<numDims;dim++) {\n          if (lowerPoint[dim] != null) {\n            if (lowerInclusive[dim] == false) {\n              if (Arrays.equals(lowerPoint[dim], maxValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.add(bytesPerDim, 0, lowerPoint[dim], one, value);\n                System.arraycopy(value, 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(lowerPoint[dim], 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: we just leave 0s in this packed dim for the lower value\n          }\n\n          if (upperPoint[dim] != null) {\n            if (upperInclusive[dim] == false) {\n              if (Arrays.equals(upperPoint[dim], minValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.subtract(bytesPerDim, 0, upperPoint[dim], one, value);\n                System.arraycopy(value, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(upperPoint[dim], 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: fill with max point for this dim:\n            System.arraycopy(maxValue, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n          }\n        }\n\n        // Now packedLowerIncl and packedUpperIncl are inclusive, and non-empty space:\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLowerIncl, offset) < 0) {\n                                 // Doc's value is too low, in this dimension\n                                 return;\n                               }\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpperIncl, offset) > 0) {\n                                 // Doc's value is too high, in this dimension\n                                 return;\n                               }\n                             }\n\n                             // Doc is in-bounds\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                             boolean crosses = false;\n\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n\n                               if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpperIncl, offset) > 0 ||\n                                   StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLowerIncl, offset) < 0) {\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n\n                               crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLowerIncl, offset) < 0 ||\n                                 StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpperIncl, offset) > 0;\n                             }\n\n                             if (crosses) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        DimensionalValues values = reader.getDimensionalValues();\n        if (values == null) {\n          // No docs in this segment indexed any field dimensionally\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != null && bytesPerDim.intValue() != fieldInfo.getDimensionNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getDimensionNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getDimensionNumBytes();\n\n        byte[] packedLowerIncl = new byte[numDims * bytesPerDim];\n        byte[] packedUpperIncl = new byte[numDims * bytesPerDim];\n\n        byte[] minValue = new byte[bytesPerDim];\n        byte[] maxValue = new byte[bytesPerDim];\n        Arrays.fill(maxValue, (byte) 0xff);\n\n        byte[] one = new byte[bytesPerDim];\n        one[bytesPerDim-1] = 1;\n\n        // Carefully pack lower and upper bounds, taking care of per-dim inclusive:\n        for(int dim=0;dim<numDims;dim++) {\n          if (lowerPoint[dim] != null) {\n            if (lowerInclusive[dim] == false) {\n              if (Arrays.equals(lowerPoint[dim], maxValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                BKDUtil.add(bytesPerDim, 0, lowerPoint[dim], one, value);\n                System.arraycopy(value, 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(lowerPoint[dim], 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: we just leave 0s in this packed dim for the lower value\n          }\n\n          if (upperPoint[dim] != null) {\n            if (upperInclusive[dim] == false) {\n              if (Arrays.equals(upperPoint[dim], minValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                BKDUtil.subtract(bytesPerDim, 0, upperPoint[dim], one, value);\n                System.arraycopy(value, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(upperPoint[dim], 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: fill with max point for this dim:\n            System.arraycopy(maxValue, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n          }\n        }\n\n        // Now packedLowerIncl and packedUpperIncl are inclusive, and non-empty space:\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLowerIncl, offset) < 0) {\n                                 // Doc's value is too low, in this dimension\n                                 return;\n                               }\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpperIncl, offset) > 0) {\n                                 // Doc's value is too high, in this dimension\n                                 return;\n                               }\n                             }\n\n                             // Doc is in-bounds\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                             boolean crosses = false;\n\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n\n                               if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpperIncl, offset) > 0 ||\n                                   StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLowerIncl, offset) < 0) {\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n\n                               crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLowerIncl, offset) < 0 ||\n                                 StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpperIncl, offset) > 0;\n                             }\n\n                             if (crosses) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["1800b996d8677670482a071dcb7a48b08c423ace"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cab7a79353f33d1a94cd307bf33aa5148601ebe6","date":1453391888,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointRangeQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/DimensionalRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment indexed any points\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getPointDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getPointDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != null && bytesPerDim.intValue() != fieldInfo.getPointNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getPointNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getPointNumBytes();\n\n        byte[] packedLowerIncl = new byte[numDims * bytesPerDim];\n        byte[] packedUpperIncl = new byte[numDims * bytesPerDim];\n\n        byte[] minValue = new byte[bytesPerDim];\n        byte[] maxValue = new byte[bytesPerDim];\n        Arrays.fill(maxValue, (byte) 0xff);\n\n        byte[] one = new byte[bytesPerDim];\n        one[bytesPerDim-1] = 1;\n\n        // Carefully pack lower and upper bounds, taking care of per-dim inclusive:\n        for(int dim=0;dim<numDims;dim++) {\n          if (lowerPoint[dim] != null) {\n            if (lowerInclusive[dim] == false) {\n              if (Arrays.equals(lowerPoint[dim], maxValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.add(bytesPerDim, 0, lowerPoint[dim], one, value);\n                System.arraycopy(value, 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(lowerPoint[dim], 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: we just leave 0s in this packed dim for the lower value\n          }\n\n          if (upperPoint[dim] != null) {\n            if (upperInclusive[dim] == false) {\n              if (Arrays.equals(upperPoint[dim], minValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.subtract(bytesPerDim, 0, upperPoint[dim], one, value);\n                System.arraycopy(value, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(upperPoint[dim], 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: fill with max point for this dim:\n            System.arraycopy(maxValue, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n          }\n        }\n\n        // Now packedLowerIncl and packedUpperIncl are inclusive, and non-empty space:\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLowerIncl, offset) < 0) {\n                                 // Doc's value is too low, in this dimension\n                                 return;\n                               }\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpperIncl, offset) > 0) {\n                                 // Doc's value is too high, in this dimension\n                                 return;\n                               }\n                             }\n\n                             // Doc is in-bounds\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                             boolean crosses = false;\n\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n\n                               if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpperIncl, offset) > 0 ||\n                                   StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLowerIncl, offset) < 0) {\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n\n                               crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLowerIncl, offset) < 0 ||\n                                 StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpperIncl, offset) > 0;\n                             }\n\n                             if (crosses) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // We don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\".\n    // This is an inverted structure and should be used in the first pass:\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        DimensionalValues values = reader.getDimensionalValues();\n        if (values == null) {\n          // No docs in this segment indexed any field dimensionally\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        if (fieldInfo.getDimensionCount() != numDims) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with numDims=\" + fieldInfo.getDimensionCount() + \" but this query has numDims=\" + numDims);\n        }\n        if (bytesPerDim != null && bytesPerDim.intValue() != fieldInfo.getDimensionNumBytes()) {\n          throw new IllegalArgumentException(\"field=\\\"\" + field + \"\\\" was indexed with bytesPerDim=\" + fieldInfo.getDimensionNumBytes() + \" but this query has bytesPerDim=\" + bytesPerDim);\n        }\n        int bytesPerDim = fieldInfo.getDimensionNumBytes();\n\n        byte[] packedLowerIncl = new byte[numDims * bytesPerDim];\n        byte[] packedUpperIncl = new byte[numDims * bytesPerDim];\n\n        byte[] minValue = new byte[bytesPerDim];\n        byte[] maxValue = new byte[bytesPerDim];\n        Arrays.fill(maxValue, (byte) 0xff);\n\n        byte[] one = new byte[bytesPerDim];\n        one[bytesPerDim-1] = 1;\n\n        // Carefully pack lower and upper bounds, taking care of per-dim inclusive:\n        for(int dim=0;dim<numDims;dim++) {\n          if (lowerPoint[dim] != null) {\n            if (lowerInclusive[dim] == false) {\n              if (Arrays.equals(lowerPoint[dim], maxValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.add(bytesPerDim, 0, lowerPoint[dim], one, value);\n                System.arraycopy(value, 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(lowerPoint[dim], 0, packedLowerIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: we just leave 0s in this packed dim for the lower value\n          }\n\n          if (upperPoint[dim] != null) {\n            if (upperInclusive[dim] == false) {\n              if (Arrays.equals(upperPoint[dim], minValue)) {\n                return null;\n              } else {\n                byte[] value = new byte[bytesPerDim];\n                NumericUtils.subtract(bytesPerDim, 0, upperPoint[dim], one, value);\n                System.arraycopy(value, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n              }\n            } else {\n              System.arraycopy(upperPoint[dim], 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n            }\n          } else {\n            // Open-ended range: fill with max point for this dim:\n            System.arraycopy(maxValue, 0, packedUpperIncl, dim*bytesPerDim, bytesPerDim);\n          }\n        }\n\n        // Now packedLowerIncl and packedUpperIncl are inclusive, and non-empty space:\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n\n                           @Override\n                           public void grow(int count) {\n                             result.grow(count);\n                           }\n\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedLowerIncl, offset) < 0) {\n                                 // Doc's value is too low, in this dimension\n                                 return;\n                               }\n                               if (StringHelper.compare(bytesPerDim, packedValue, offset, packedUpperIncl, offset) > 0) {\n                                 // Doc's value is too high, in this dimension\n                                 return;\n                               }\n                             }\n\n                             // Doc is in-bounds\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n\n                             boolean crosses = false;\n\n                             for(int dim=0;dim<numDims;dim++) {\n                               int offset = dim*bytesPerDim;\n\n                               if (StringHelper.compare(bytesPerDim, minPackedValue, offset, packedUpperIncl, offset) > 0 ||\n                                   StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedLowerIncl, offset) < 0) {\n                                 return Relation.CELL_OUTSIDE_QUERY;\n                               }\n\n                               crosses |= StringHelper.compare(bytesPerDim, minPackedValue, offset, packedLowerIncl, offset) < 0 ||\n                                 StringHelper.compare(bytesPerDim, maxPackedValue, offset, packedUpperIncl, offset) > 0;\n                             }\n\n                             if (crosses) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_INSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["606ea169579957651185909e7264798e99e714f9","1800b996d8677670482a071dcb7a48b08c423ace"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["770342641f7b505eaa8dccdc666158bff2419109"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1904709ea0185dc04e3d77ea01c79e909caf2796":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"770342641f7b505eaa8dccdc666158bff2419109":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"]},"commit2Childs":{"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["770342641f7b505eaa8dccdc666158bff2419109"],"770342641f7b505eaa8dccdc666158bff2419109":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}