{"path":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","commits":[{"id":"308eabc0d18aa58a75b0a130d08524e98661807b","date":1425056617,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","pathOld":"/dev/null","sourceNew":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link ExecutorService} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      boolean needsScores = false;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        needsScores |= collector.needsScores();\n      }\n\n      final Weight weight = createNormalizedWeight(query, needsScores);\n      final List<Future<C>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        topDocsFutures.add(executor.submit(new Callable<C>() {\n          @Override\n          public C call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector;\n          }\n        }));\n      }\n\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : topDocsFutures) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return collectorManager.reduce(collectors);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","pathOld":"/dev/null","sourceNew":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link ExecutorService} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      boolean needsScores = false;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        needsScores |= collector.needsScores();\n      }\n\n      final Weight weight = createNormalizedWeight(query, needsScores);\n      final List<Future<C>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        topDocsFutures.add(executor.submit(new Callable<C>() {\n          @Override\n          public C call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector;\n          }\n        }));\n      }\n\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : topDocsFutures) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return collectorManager.reduce(collectors);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","sourceNew":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link ExecutorService} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      ScoreMode scoreMode = null;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        if (scoreMode == null) {\n          scoreMode = collector.scoreMode();\n        } else if (scoreMode != collector.scoreMode()) {\n          throw new IllegalStateException(\"CollectorManager does not always produce collectors with the same score mode\");\n        }\n      }\n      if (scoreMode == null) {\n        // no segments\n        scoreMode = ScoreMode.COMPLETE;\n      }\n\n      final Weight weight = createNormalizedWeight(query, scoreMode);\n      final List<Future<C>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        topDocsFutures.add(executor.submit(new Callable<C>() {\n          @Override\n          public C call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector;\n          }\n        }));\n      }\n\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : topDocsFutures) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return collectorManager.reduce(collectors);\n    }\n  }\n\n","sourceOld":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link ExecutorService} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      boolean needsScores = false;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        needsScores |= collector.needsScores();\n      }\n\n      final Weight weight = createNormalizedWeight(query, needsScores);\n      final List<Future<C>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        topDocsFutures.add(executor.submit(new Callable<C>() {\n          @Override\n          public C call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector;\n          }\n        }));\n      }\n\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : topDocsFutures) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return collectorManager.reduce(collectors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","sourceNew":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link ExecutorService} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      ScoreMode scoreMode = null;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        if (scoreMode == null) {\n          scoreMode = collector.scoreMode();\n        } else if (scoreMode != collector.scoreMode()) {\n          throw new IllegalStateException(\"CollectorManager does not always produce collectors with the same score mode\");\n        }\n      }\n      if (scoreMode == null) {\n        // no segments\n        scoreMode = ScoreMode.COMPLETE;\n      }\n\n      final Weight weight = createNormalizedWeight(query, scoreMode);\n      final List<Future<C>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        topDocsFutures.add(executor.submit(new Callable<C>() {\n          @Override\n          public C call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector;\n          }\n        }));\n      }\n\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : topDocsFutures) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return collectorManager.reduce(collectors);\n    }\n  }\n\n","sourceOld":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link ExecutorService} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      boolean needsScores = false;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        needsScores |= collector.needsScores();\n      }\n\n      final Weight weight = createNormalizedWeight(query, needsScores);\n      final List<Future<C>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        topDocsFutures.add(executor.submit(new Callable<C>() {\n          @Override\n          public C call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector;\n          }\n        }));\n      }\n\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : topDocsFutures) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return collectorManager.reduce(collectors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"475584d5e08a22ad3fc7babefe006d77bc744567","date":1523282824,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","sourceNew":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link ExecutorService} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      ScoreMode scoreMode = null;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        if (scoreMode == null) {\n          scoreMode = collector.scoreMode();\n        } else if (scoreMode != collector.scoreMode()) {\n          throw new IllegalStateException(\"CollectorManager does not always produce collectors with the same score mode\");\n        }\n      }\n      if (scoreMode == null) {\n        // no segments\n        scoreMode = ScoreMode.COMPLETE;\n      }\n      query = rewrite(query);\n      final Weight weight = createWeight(query, scoreMode, 1);\n      final List<Future<C>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        topDocsFutures.add(executor.submit(new Callable<C>() {\n          @Override\n          public C call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector;\n          }\n        }));\n      }\n\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : topDocsFutures) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return collectorManager.reduce(collectors);\n    }\n  }\n\n","sourceOld":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link ExecutorService} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      ScoreMode scoreMode = null;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        if (scoreMode == null) {\n          scoreMode = collector.scoreMode();\n        } else if (scoreMode != collector.scoreMode()) {\n          throw new IllegalStateException(\"CollectorManager does not always produce collectors with the same score mode\");\n        }\n      }\n      if (scoreMode == null) {\n        // no segments\n        scoreMode = ScoreMode.COMPLETE;\n      }\n\n      final Weight weight = createNormalizedWeight(query, scoreMode);\n      final List<Future<C>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        topDocsFutures.add(executor.submit(new Callable<C>() {\n          @Override\n          public C call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector;\n          }\n        }));\n      }\n\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : topDocsFutures) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return collectorManager.reduce(collectors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d58e44159788900f4a2113b84463dc3fbbf80f20","date":1523319203,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","sourceNew":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link ExecutorService} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      ScoreMode scoreMode = null;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        if (scoreMode == null) {\n          scoreMode = collector.scoreMode();\n        } else if (scoreMode != collector.scoreMode()) {\n          throw new IllegalStateException(\"CollectorManager does not always produce collectors with the same score mode\");\n        }\n      }\n      if (scoreMode == null) {\n        // no segments\n        scoreMode = ScoreMode.COMPLETE;\n      }\n      query = rewrite(query);\n      final Weight weight = createWeight(query, scoreMode, 1);\n      final List<Future<C>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        topDocsFutures.add(executor.submit(new Callable<C>() {\n          @Override\n          public C call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector;\n          }\n        }));\n      }\n\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : topDocsFutures) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return collectorManager.reduce(collectors);\n    }\n  }\n\n","sourceOld":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link ExecutorService} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      ScoreMode scoreMode = null;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        if (scoreMode == null) {\n          scoreMode = collector.scoreMode();\n        } else if (scoreMode != collector.scoreMode()) {\n          throw new IllegalStateException(\"CollectorManager does not always produce collectors with the same score mode\");\n        }\n      }\n      if (scoreMode == null) {\n        // no segments\n        scoreMode = ScoreMode.COMPLETE;\n      }\n\n      final Weight weight = createNormalizedWeight(query, scoreMode);\n      final List<Future<C>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        topDocsFutures.add(executor.submit(new Callable<C>() {\n          @Override\n          public C call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector;\n          }\n        }));\n      }\n\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : topDocsFutures) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return collectorManager.reduce(collectors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3e760e1d4623ba387880bd23778ebac68db9e73","date":1560862611,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","sourceNew":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link ExecutorService} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null || leafSlices.length <= 1) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      ScoreMode scoreMode = null;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        if (scoreMode == null) {\n          scoreMode = collector.scoreMode();\n        } else if (scoreMode != collector.scoreMode()) {\n          throw new IllegalStateException(\"CollectorManager does not always produce collectors with the same score mode\");\n        }\n      }\n      if (scoreMode == null) {\n        // no segments\n        scoreMode = ScoreMode.COMPLETE;\n      }\n      query = rewrite(query);\n      final Weight weight = createWeight(query, scoreMode, 1);\n      final List<Future<C>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length - 1; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        topDocsFutures.add(executor.submit(() -> {\n          search(Arrays.asList(leaves), weight, collector);\n          return collector;\n        }));\n      }\n      final LeafReaderContext[] leaves = leafSlices[leafSlices.length - 1].leaves;\n      final C collector = collectors.get(leafSlices.length - 1);\n      // execute the last on the caller thread\n      search(Arrays.asList(leaves), weight, collector);\n      topDocsFutures.add(CompletableFuture.completedFuture(collector));\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : topDocsFutures) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return collectorManager.reduce(collectors);\n    }\n  }\n\n","sourceOld":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link ExecutorService} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      ScoreMode scoreMode = null;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        if (scoreMode == null) {\n          scoreMode = collector.scoreMode();\n        } else if (scoreMode != collector.scoreMode()) {\n          throw new IllegalStateException(\"CollectorManager does not always produce collectors with the same score mode\");\n        }\n      }\n      if (scoreMode == null) {\n        // no segments\n        scoreMode = ScoreMode.COMPLETE;\n      }\n      query = rewrite(query);\n      final Weight weight = createWeight(query, scoreMode, 1);\n      final List<Future<C>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        topDocsFutures.add(executor.submit(new Callable<C>() {\n          @Override\n          public C call() throws Exception {\n            search(Arrays.asList(leaves), weight, collector);\n            return collector;\n          }\n        }));\n      }\n\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : topDocsFutures) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      return collectorManager.reduce(collectors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"692c45378601dcea39367ca75ae7d34ceed0aae3","date":1561033600,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","sourceNew":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link Executor} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null || leafSlices.length <= 1) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      ScoreMode scoreMode = null;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        if (scoreMode == null) {\n          scoreMode = collector.scoreMode();\n        } else if (scoreMode != collector.scoreMode()) {\n          throw new IllegalStateException(\"CollectorManager does not always produce collectors with the same score mode\");\n        }\n      }\n      if (scoreMode == null) {\n        // no segments\n        scoreMode = ScoreMode.COMPLETE;\n      }\n      query = rewrite(query);\n      final Weight weight = createWeight(query, scoreMode, 1);\n      final List<Future<C>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length - 1; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        FutureTask<C> task = new FutureTask<>(() -> {\n          search(Arrays.asList(leaves), weight, collector);\n          return collector;\n        });\n        executor.execute(task);\n        topDocsFutures.add(task);\n      }\n      final LeafReaderContext[] leaves = leafSlices[leafSlices.length - 1].leaves;\n      final C collector = collectors.get(leafSlices.length - 1);\n      // execute the last on the caller thread\n      search(Arrays.asList(leaves), weight, collector);\n      topDocsFutures.add(CompletableFuture.completedFuture(collector));\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : topDocsFutures) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return collectorManager.reduce(collectors);\n    }\n  }\n\n","sourceOld":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link ExecutorService} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null || leafSlices.length <= 1) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      ScoreMode scoreMode = null;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        if (scoreMode == null) {\n          scoreMode = collector.scoreMode();\n        } else if (scoreMode != collector.scoreMode()) {\n          throw new IllegalStateException(\"CollectorManager does not always produce collectors with the same score mode\");\n        }\n      }\n      if (scoreMode == null) {\n        // no segments\n        scoreMode = ScoreMode.COMPLETE;\n      }\n      query = rewrite(query);\n      final Weight weight = createWeight(query, scoreMode, 1);\n      final List<Future<C>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length - 1; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        topDocsFutures.add(executor.submit(() -> {\n          search(Arrays.asList(leaves), weight, collector);\n          return collector;\n        }));\n      }\n      final LeafReaderContext[] leaves = leafSlices[leafSlices.length - 1].leaves;\n      final C collector = collectors.get(leafSlices.length - 1);\n      // execute the last on the caller thread\n      search(Arrays.asList(leaves), weight, collector);\n      topDocsFutures.add(CompletableFuture.completedFuture(collector));\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : topDocsFutures) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return collectorManager.reduce(collectors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9c92d00295a9f8cc365981d39aec46ab8c0835d6","date":1569560651,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","sourceNew":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link Executor} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null || leafSlices.length <= 1) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      ScoreMode scoreMode = null;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        if (scoreMode == null) {\n          scoreMode = collector.scoreMode();\n        } else if (scoreMode != collector.scoreMode()) {\n          throw new IllegalStateException(\"CollectorManager does not always produce collectors with the same score mode\");\n        }\n      }\n      if (scoreMode == null) {\n        // no segments\n        scoreMode = ScoreMode.COMPLETE;\n      }\n      query = rewrite(query);\n      final Weight weight = createWeight(query, scoreMode, 1);\n      final List<Future<C>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length - 1; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        FutureTask<C> task = new FutureTask<>(() -> {\n          search(Arrays.asList(leaves), weight, collector);\n          return collector;\n        });\n        try {\n          executor.execute(task);\n        } catch (RejectedExecutionException e) {\n          // Execute on caller thread\n          search(Arrays.asList(leaves), weight, collector);\n        }\n\n        topDocsFutures.add(task);\n      }\n      final LeafReaderContext[] leaves = leafSlices[leafSlices.length - 1].leaves;\n      final C collector = collectors.get(leafSlices.length - 1);\n      // execute the last on the caller thread\n      search(Arrays.asList(leaves), weight, collector);\n      topDocsFutures.add(CompletableFuture.completedFuture(collector));\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : topDocsFutures) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return collectorManager.reduce(collectors);\n    }\n  }\n\n","sourceOld":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link Executor} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null || leafSlices.length <= 1) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      ScoreMode scoreMode = null;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        if (scoreMode == null) {\n          scoreMode = collector.scoreMode();\n        } else if (scoreMode != collector.scoreMode()) {\n          throw new IllegalStateException(\"CollectorManager does not always produce collectors with the same score mode\");\n        }\n      }\n      if (scoreMode == null) {\n        // no segments\n        scoreMode = ScoreMode.COMPLETE;\n      }\n      query = rewrite(query);\n      final Weight weight = createWeight(query, scoreMode, 1);\n      final List<Future<C>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length - 1; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        FutureTask<C> task = new FutureTask<>(() -> {\n          search(Arrays.asList(leaves), weight, collector);\n          return collector;\n        });\n        executor.execute(task);\n        topDocsFutures.add(task);\n      }\n      final LeafReaderContext[] leaves = leafSlices[leafSlices.length - 1].leaves;\n      final C collector = collectors.get(leafSlices.length - 1);\n      // execute the last on the caller thread\n      search(Arrays.asList(leaves), weight, collector);\n      topDocsFutures.add(CompletableFuture.completedFuture(collector));\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : topDocsFutures) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return collectorManager.reduce(collectors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a47fe9268b8692055e78d5d88e5944da72204992","date":1569585581,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","sourceNew":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link Executor} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null || leafSlices.length <= 1) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      ScoreMode scoreMode = null;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        if (scoreMode == null) {\n          scoreMode = collector.scoreMode();\n        } else if (scoreMode != collector.scoreMode()) {\n          throw new IllegalStateException(\"CollectorManager does not always produce collectors with the same score mode\");\n        }\n      }\n      if (scoreMode == null) {\n        // no segments\n        scoreMode = ScoreMode.COMPLETE;\n      }\n      query = rewrite(query);\n      final Weight weight = createWeight(query, scoreMode, 1);\n      final List<Future<C>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length - 1; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        FutureTask<C> task = new FutureTask<>(() -> {\n          search(Arrays.asList(leaves), weight, collector);\n          return collector;\n        });\n        boolean executedOnCallerThread = false;\n        try {\n          executor.execute(task);\n        } catch (RejectedExecutionException e) {\n          // Execute on caller thread\n          search(Arrays.asList(leaves), weight, collector);\n          topDocsFutures.add(CompletableFuture.completedFuture(collector));\n          executedOnCallerThread = true;\n        }\n\n        // Do not add the task's future if it was not used\n        if (executedOnCallerThread == false) {\n          topDocsFutures.add(task);\n        }\n      }\n      final LeafReaderContext[] leaves = leafSlices[leafSlices.length - 1].leaves;\n      final C collector = collectors.get(leafSlices.length - 1);\n      // execute the last on the caller thread\n      search(Arrays.asList(leaves), weight, collector);\n      topDocsFutures.add(CompletableFuture.completedFuture(collector));\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : topDocsFutures) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return collectorManager.reduce(collectors);\n    }\n  }\n\n","sourceOld":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link Executor} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null || leafSlices.length <= 1) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      ScoreMode scoreMode = null;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        if (scoreMode == null) {\n          scoreMode = collector.scoreMode();\n        } else if (scoreMode != collector.scoreMode()) {\n          throw new IllegalStateException(\"CollectorManager does not always produce collectors with the same score mode\");\n        }\n      }\n      if (scoreMode == null) {\n        // no segments\n        scoreMode = ScoreMode.COMPLETE;\n      }\n      query = rewrite(query);\n      final Weight weight = createWeight(query, scoreMode, 1);\n      final List<Future<C>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length - 1; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        FutureTask<C> task = new FutureTask<>(() -> {\n          search(Arrays.asList(leaves), weight, collector);\n          return collector;\n        });\n        try {\n          executor.execute(task);\n        } catch (RejectedExecutionException e) {\n          // Execute on caller thread\n          search(Arrays.asList(leaves), weight, collector);\n        }\n\n        topDocsFutures.add(task);\n      }\n      final LeafReaderContext[] leaves = leafSlices[leafSlices.length - 1].leaves;\n      final C collector = collectors.get(leafSlices.length - 1);\n      // execute the last on the caller thread\n      search(Arrays.asList(leaves), weight, collector);\n      topDocsFutures.add(CompletableFuture.completedFuture(collector));\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : topDocsFutures) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return collectorManager.reduce(collectors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868410ef958ba78b7677a417f1fbfe03c47c034c","date":1585753946,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","sourceNew":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link Executor} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null || leafSlices.length <= 1) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      ScoreMode scoreMode = null;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        if (scoreMode == null) {\n          scoreMode = collector.scoreMode();\n        } else if (scoreMode != collector.scoreMode()) {\n          throw new IllegalStateException(\"CollectorManager does not always produce collectors with the same score mode\");\n        }\n      }\n      if (scoreMode == null) {\n        // no segments\n        scoreMode = ScoreMode.COMPLETE;\n      }\n      query = rewrite(query);\n      final Weight weight = createWeight(query, scoreMode, 1);\n      final List<FutureTask<C>> listTasks = new ArrayList<>();\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        FutureTask<C> task = new FutureTask<>(() -> {\n          search(Arrays.asList(leaves), weight, collector);\n          return collector;\n        });\n\n        listTasks.add(task);\n      }\n\n      sliceExecutor.invokeAll(listTasks);\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : listTasks) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return collectorManager.reduce(collectors);\n    }\n  }\n\n","sourceOld":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link Executor} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null || leafSlices.length <= 1) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      ScoreMode scoreMode = null;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        if (scoreMode == null) {\n          scoreMode = collector.scoreMode();\n        } else if (scoreMode != collector.scoreMode()) {\n          throw new IllegalStateException(\"CollectorManager does not always produce collectors with the same score mode\");\n        }\n      }\n      if (scoreMode == null) {\n        // no segments\n        scoreMode = ScoreMode.COMPLETE;\n      }\n      query = rewrite(query);\n      final Weight weight = createWeight(query, scoreMode, 1);\n      final List<Future<C>> topDocsFutures = new ArrayList<>(leafSlices.length);\n      for (int i = 0; i < leafSlices.length - 1; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        FutureTask<C> task = new FutureTask<>(() -> {\n          search(Arrays.asList(leaves), weight, collector);\n          return collector;\n        });\n        boolean executedOnCallerThread = false;\n        try {\n          executor.execute(task);\n        } catch (RejectedExecutionException e) {\n          // Execute on caller thread\n          search(Arrays.asList(leaves), weight, collector);\n          topDocsFutures.add(CompletableFuture.completedFuture(collector));\n          executedOnCallerThread = true;\n        }\n\n        // Do not add the task's future if it was not used\n        if (executedOnCallerThread == false) {\n          topDocsFutures.add(task);\n        }\n      }\n      final LeafReaderContext[] leaves = leafSlices[leafSlices.length - 1].leaves;\n      final C collector = collectors.get(leafSlices.length - 1);\n      // execute the last on the caller thread\n      search(Arrays.asList(leaves), weight, collector);\n      topDocsFutures.add(CompletableFuture.completedFuture(collector));\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : topDocsFutures) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return collectorManager.reduce(collectors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9f94c392daa8f5708186bede16c84eafad4cdd2","date":1599578873,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/IndexSearcher#[C-extends-Collector,T]_search(Query,CollectorManager[C,T]).mjava","sourceNew":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link Executor} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null || leafSlices.length <= 1) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      ScoreMode scoreMode = null;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        if (scoreMode == null) {\n          scoreMode = collector.scoreMode();\n        } else if (scoreMode != collector.scoreMode()) {\n          throw new IllegalStateException(\"CollectorManager does not always produce collectors with the same score mode\");\n        }\n      }\n      if (scoreMode == null) {\n        // no segments\n        scoreMode = ScoreMode.COMPLETE;\n      }\n      query = rewrite(query);\n      final Weight weight = createWeight(query, scoreMode, 1);\n      final List<FutureTask<C>> listTasks = new ArrayList<>();\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        FutureTask<C> task = new FutureTask<>(() -> {\n          search(Arrays.asList(leaves), weight, collector);\n          return collector;\n        });\n\n        listTasks.add(task);\n      }\n\n      sliceExecutor.invokeAll(listTasks);\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : listTasks) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return collectorManager.reduce(collectedCollectors);\n    }\n  }\n\n","sourceOld":" /**\n  * Lower-level search API.\n  * Search all leaves using the given {@link CollectorManager}. In contrast\n  * to {@link #search(Query, Collector)}, this method will use the searcher's\n  * {@link Executor} in order to parallelize execution of the collection\n  * on the configured {@link #leafSlices}.\n  * @see CollectorManager\n  * @lucene.experimental\n  */\n  public <C extends Collector, T> T search(Query query, CollectorManager<C, T> collectorManager) throws IOException {\n    if (executor == null || leafSlices.length <= 1) {\n      final C collector = collectorManager.newCollector();\n      search(query, collector);\n      return collectorManager.reduce(Collections.singletonList(collector));\n    } else {\n      final List<C> collectors = new ArrayList<>(leafSlices.length);\n      ScoreMode scoreMode = null;\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final C collector = collectorManager.newCollector();\n        collectors.add(collector);\n        if (scoreMode == null) {\n          scoreMode = collector.scoreMode();\n        } else if (scoreMode != collector.scoreMode()) {\n          throw new IllegalStateException(\"CollectorManager does not always produce collectors with the same score mode\");\n        }\n      }\n      if (scoreMode == null) {\n        // no segments\n        scoreMode = ScoreMode.COMPLETE;\n      }\n      query = rewrite(query);\n      final Weight weight = createWeight(query, scoreMode, 1);\n      final List<FutureTask<C>> listTasks = new ArrayList<>();\n      for (int i = 0; i < leafSlices.length; ++i) {\n        final LeafReaderContext[] leaves = leafSlices[i].leaves;\n        final C collector = collectors.get(i);\n        FutureTask<C> task = new FutureTask<>(() -> {\n          search(Arrays.asList(leaves), weight, collector);\n          return collector;\n        });\n\n        listTasks.add(task);\n      }\n\n      sliceExecutor.invokeAll(listTasks);\n      final List<C> collectedCollectors = new ArrayList<>();\n      for (Future<C> future : listTasks) {\n        try {\n          collectedCollectors.add(future.get());\n        } catch (InterruptedException e) {\n          throw new ThreadInterruptedException(e);\n        } catch (ExecutionException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return collectorManager.reduce(collectors);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"475584d5e08a22ad3fc7babefe006d77bc744567":["417142ff08fda9cf0b72d5133e63097a166c6458"],"c9f94c392daa8f5708186bede16c84eafad4cdd2":["868410ef958ba78b7677a417f1fbfe03c47c034c"],"308eabc0d18aa58a75b0a130d08524e98661807b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"868410ef958ba78b7677a417f1fbfe03c47c034c":["a47fe9268b8692055e78d5d88e5944da72204992"],"a3e760e1d4623ba387880bd23778ebac68db9e73":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"a47fe9268b8692055e78d5d88e5944da72204992":["9c92d00295a9f8cc365981d39aec46ab8c0835d6"],"692c45378601dcea39367ca75ae7d34ceed0aae3":["a3e760e1d4623ba387880bd23778ebac68db9e73"],"417142ff08fda9cf0b72d5133e63097a166c6458":["308eabc0d18aa58a75b0a130d08524e98661807b","9fc47cb7b4346802411bb432f501ed0673d7119e"],"9c92d00295a9f8cc365981d39aec46ab8c0835d6":["692c45378601dcea39367ca75ae7d34ceed0aae3"],"d58e44159788900f4a2113b84463dc3fbbf80f20":["417142ff08fda9cf0b72d5133e63097a166c6458","475584d5e08a22ad3fc7babefe006d77bc744567"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","308eabc0d18aa58a75b0a130d08524e98661807b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9fc47cb7b4346802411bb432f501ed0673d7119e":["308eabc0d18aa58a75b0a130d08524e98661807b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c9f94c392daa8f5708186bede16c84eafad4cdd2"]},"commit2Childs":{"475584d5e08a22ad3fc7babefe006d77bc744567":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"c9f94c392daa8f5708186bede16c84eafad4cdd2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"308eabc0d18aa58a75b0a130d08524e98661807b":["417142ff08fda9cf0b72d5133e63097a166c6458","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","9fc47cb7b4346802411bb432f501ed0673d7119e"],"868410ef958ba78b7677a417f1fbfe03c47c034c":["c9f94c392daa8f5708186bede16c84eafad4cdd2"],"a3e760e1d4623ba387880bd23778ebac68db9e73":["692c45378601dcea39367ca75ae7d34ceed0aae3"],"417142ff08fda9cf0b72d5133e63097a166c6458":["475584d5e08a22ad3fc7babefe006d77bc744567","d58e44159788900f4a2113b84463dc3fbbf80f20"],"a47fe9268b8692055e78d5d88e5944da72204992":["868410ef958ba78b7677a417f1fbfe03c47c034c"],"692c45378601dcea39367ca75ae7d34ceed0aae3":["9c92d00295a9f8cc365981d39aec46ab8c0835d6"],"d58e44159788900f4a2113b84463dc3fbbf80f20":["a3e760e1d4623ba387880bd23778ebac68db9e73"],"9c92d00295a9f8cc365981d39aec46ab8c0835d6":["a47fe9268b8692055e78d5d88e5944da72204992"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["308eabc0d18aa58a75b0a130d08524e98661807b","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}