{"path":"sandbox/contributions/WordNet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","commits":[{"id":"8201371f57d27f37d843ee6fe97bfd06811e1678","date":1037173420,"type":0,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"sandbox/contributions/WordNet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true);\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n                doc.add(Field.Keyword(\"word\", g));\n                if ((++row % mod) == 0)\n                {\n                    System.out.println(\"row=\" + row + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n        writer.optimize();\n        writer.close();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"447d4dabec4524dc2d3289ce9ca9604e4c8722da","date":1075138149,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"sandbox/contributions/WordNet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","pathOld":"sandbox/contributions/WordNet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true);\n        writer.setUseCompoundFile(true);\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n                doc.add(Field.Keyword(\"word\", g));\n                if ((++row % mod) == 0)\n                {\n                    System.out.println(\"row=\" + row + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n        writer.optimize();\n        writer.close();\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true);\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n                doc.add(Field.Keyword(\"word\", g));\n                if ((++row % mod) == 0)\n                {\n                    System.out.println(\"row=\" + row + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n        writer.optimize();\n        writer.close();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"936e2add654deb93cc249bc32492296b9c47ca20","date":1105474419,"type":3,"author":"David Spencer","isMerge":false,"pathNew":"sandbox/contributions/WordNet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","pathOld":"sandbox/contributions/WordNet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true);\n        writer.setUseCompoundFile(true);\n\t\twriter.mergeFactor *= 2;\n\t\twriter.minMergeDocs *= 2;\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n\t\t\t\tdoc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.UN_TOKENIZED));\n                if ((++row % mod) == 0)\n                {\n                    o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n\t\to.println( \"Optimizing..\");\n        writer.optimize();\n        writer.close();\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true);\n        writer.setUseCompoundFile(true);\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n                doc.add(Field.Keyword(\"word\", g));\n                if ((++row % mod) == 0)\n                {\n                    System.out.println(\"row=\" + row + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n        writer.optimize();\n        writer.close();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c66ea4e08d5b7e32ff205b48896a4da9bf70ac7a","date":1105477091,"type":3,"author":"David Spencer","isMerge":false,"pathNew":"sandbox/contributions/WordNet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","pathOld":"sandbox/contributions/WordNet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true);\n        writer.setUseCompoundFile(true); // why?\n\t\t// blindly up these parameters for speed\n\t\twriter.setMergeFactor( writer.getMergeFactor() * 2);\n\t\twriter.setMaxBufferedDocs( writer.getMaxBufferedDocs() * 2);\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n\t\t\t\tdoc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.UN_TOKENIZED));\n                if ((++row % mod) == 0)\n                {\n                    o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n\t\to.println( \"Optimizing..\");\n        writer.optimize();\n        writer.close();\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true);\n        writer.setUseCompoundFile(true);\n\t\twriter.mergeFactor *= 2;\n\t\twriter.minMergeDocs *= 2;\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n\t\t\t\tdoc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.UN_TOKENIZED));\n                if ((++row % mod) == 0)\n                {\n                    o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n\t\to.println( \"Optimizing..\");\n        writer.optimize();\n        writer.close();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"043c298cb215f13ba7b9b81d20760704e8f93d66","date":1107566743,"type":5,"author":"Erik Hatcher","isMerge":false,"pathNew":"contrib/WordNet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","pathOld":"sandbox/contributions/WordNet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map,Map).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true);\n        writer.setUseCompoundFile(true); // why?\n\t\t// blindly up these parameters for speed\n\t\twriter.setMergeFactor( writer.getMergeFactor() * 2);\n\t\twriter.setMaxBufferedDocs( writer.getMaxBufferedDocs() * 2);\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n\t\t\t\tdoc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.UN_TOKENIZED));\n                if ((++row % mod) == 0)\n                {\n                    o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n\t\to.println( \"Optimizing..\");\n        writer.optimize();\n        writer.close();\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the direcotry where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map word2Nums, Map num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n\n        // override the specific index if it already exists\n        IndexWriter writer = new IndexWriter(indexDir, ana, true);\n        writer.setUseCompoundFile(true); // why?\n\t\t// blindly up these parameters for speed\n\t\twriter.setMergeFactor( writer.getMergeFactor() * 2);\n\t\twriter.setMaxBufferedDocs( writer.getMaxBufferedDocs() * 2);\n        Iterator i1 = word2Nums.keySet().iterator();\n        while (i1.hasNext()) // for each word\n        {\n            String g = (String) i1.next();\n            Document doc = new Document();\n\n            int n = index(word2Nums, num2Words, g, doc);\n            if (n > 0)\n            {\n\t\t\t\tdoc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.UN_TOKENIZED));\n                if ((++row % mod) == 0)\n                {\n                    o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                    mod *= 2;\n                }\n                writer.addDocument(doc);\n            } // else degenerate\n        }\n\t\to.println( \"Optimizing..\");\n        writer.optimize();\n        writer.close();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"936e2add654deb93cc249bc32492296b9c47ca20":["447d4dabec4524dc2d3289ce9ca9604e4c8722da"],"447d4dabec4524dc2d3289ce9ca9604e4c8722da":["8201371f57d27f37d843ee6fe97bfd06811e1678"],"043c298cb215f13ba7b9b81d20760704e8f93d66":["c66ea4e08d5b7e32ff205b48896a4da9bf70ac7a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8201371f57d27f37d843ee6fe97bfd06811e1678":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c66ea4e08d5b7e32ff205b48896a4da9bf70ac7a":["936e2add654deb93cc249bc32492296b9c47ca20"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["043c298cb215f13ba7b9b81d20760704e8f93d66"]},"commit2Childs":{"936e2add654deb93cc249bc32492296b9c47ca20":["c66ea4e08d5b7e32ff205b48896a4da9bf70ac7a"],"447d4dabec4524dc2d3289ce9ca9604e4c8722da":["936e2add654deb93cc249bc32492296b9c47ca20"],"043c298cb215f13ba7b9b81d20760704e8f93d66":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8201371f57d27f37d843ee6fe97bfd06811e1678"],"8201371f57d27f37d843ee6fe97bfd06811e1678":["447d4dabec4524dc2d3289ce9ca9604e4c8722da"],"c66ea4e08d5b7e32ff205b48896a4da9bf70ac7a":["043c298cb215f13ba7b9b81d20760704e8f93d66"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}