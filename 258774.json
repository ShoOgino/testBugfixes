{"path":"contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityStats#average(QualityStats[]).mjava","commits":[{"id":"df2d68685a69bd82bf79243e28623c0775eb7bd8","date":1185567892,"type":0,"author":"Doron Cohen","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityStats#average(QualityStats[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a QualityStats object that is the average of the input QualityStats objects. \n   * @param stats array of input stats to be averaged.\n   * @return an average over the input stats.\n   */\n  public static QualityStats average(QualityStats[] stats) {\n    QualityStats avg = new QualityStats(0,0);\n    int m = 0; // queries with positive judgements\n    // aggregate\n    for (int i=0; i<stats.length; i++) {\n      avg.searchTime += stats[i].searchTime;\n      avg.docNamesExtractTime += stats[i].docNamesExtractTime;\n      if (stats[i].maxGoodPoints>0) {\n        m++;\n        avg.numGoodPoints += stats[i].numGoodPoints;\n        avg.numPoints += stats[i].numPoints;\n        avg.pReleventSum += stats[i].getAvp();\n        avg.recall += stats[i].recall;\n        avg.maxGoodPoints += stats[i].maxGoodPoints;\n        for (int j=1; j<avg.pAt.length; j++) {\n          avg.pAt[j] += stats[i].getPrecisionAt(j);\n        }\n      }\n    }\n    assert m>0 : \"Fishy: no \\\"good\\\" queries!\";\n    // take average: times go by all queries, other meassures go by \"good\" queries noly.\n    avg.searchTime /= stats.length;\n    avg.docNamesExtractTime /= stats.length;\n    avg.numGoodPoints /= m;\n    avg.numPoints /= m;\n    avg.recall /= m;\n    avg.maxGoodPoints /= m;\n    for (int j=1; j<avg.pAt.length; j++) {\n      avg.pAt[j] /= m;\n    }\n    avg.pReleventSum /= m;                 // this is actually avgp now \n    avg.pReleventSum *= avg.maxGoodPoints; // so that getAvgP() would be correct\n    \n    return avg;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05d64184e4c44205b1dfa1cdf3869230c4025dc9","date":1199346280,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityStats#average(QualityStats[]).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityStats#average(QualityStats[]).mjava","sourceNew":"  /**\n   * Create a QualityStats object that is the average of the input QualityStats objects. \n   * @param stats array of input stats to be averaged.\n   * @return an average over the input stats.\n   */\n  public static QualityStats average(QualityStats[] stats) {\n    QualityStats avg = new QualityStats(0,0);\n    if (stats.length==0) {\n      // weired, no stats to average!\n      return avg;\n    }\n    int m = 0; // queries with positive judgements\n    // aggregate\n    for (int i=0; i<stats.length; i++) {\n      avg.searchTime += stats[i].searchTime;\n      avg.docNamesExtractTime += stats[i].docNamesExtractTime;\n      if (stats[i].maxGoodPoints>0) {\n        m++;\n        avg.numGoodPoints += stats[i].numGoodPoints;\n        avg.numPoints += stats[i].numPoints;\n        avg.pReleventSum += stats[i].getAvp();\n        avg.recall += stats[i].recall;\n        avg.mrr += stats[i].getMRR();\n        avg.maxGoodPoints += stats[i].maxGoodPoints;\n        for (int j=1; j<avg.pAt.length; j++) {\n          avg.pAt[j] += stats[i].getPrecisionAt(j);\n        }\n      }\n    }\n    assert m>0 : \"Fishy: no \\\"good\\\" queries!\";\n    // take average: times go by all queries, other meassures go by \"good\" queries noly.\n    avg.searchTime /= stats.length;\n    avg.docNamesExtractTime /= stats.length;\n    avg.numGoodPoints /= m;\n    avg.numPoints /= m;\n    avg.recall /= m;\n    avg.mrr /= m;\n    avg.maxGoodPoints /= m;\n    for (int j=1; j<avg.pAt.length; j++) {\n      avg.pAt[j] /= m;\n    }\n    avg.pReleventSum /= m;                 // this is actually avgp now \n    avg.pReleventSum *= avg.maxGoodPoints; // so that getAvgP() would be correct\n    \n    return avg;\n  }\n\n","sourceOld":"  /**\n   * Create a QualityStats object that is the average of the input QualityStats objects. \n   * @param stats array of input stats to be averaged.\n   * @return an average over the input stats.\n   */\n  public static QualityStats average(QualityStats[] stats) {\n    QualityStats avg = new QualityStats(0,0);\n    int m = 0; // queries with positive judgements\n    // aggregate\n    for (int i=0; i<stats.length; i++) {\n      avg.searchTime += stats[i].searchTime;\n      avg.docNamesExtractTime += stats[i].docNamesExtractTime;\n      if (stats[i].maxGoodPoints>0) {\n        m++;\n        avg.numGoodPoints += stats[i].numGoodPoints;\n        avg.numPoints += stats[i].numPoints;\n        avg.pReleventSum += stats[i].getAvp();\n        avg.recall += stats[i].recall;\n        avg.maxGoodPoints += stats[i].maxGoodPoints;\n        for (int j=1; j<avg.pAt.length; j++) {\n          avg.pAt[j] += stats[i].getPrecisionAt(j);\n        }\n      }\n    }\n    assert m>0 : \"Fishy: no \\\"good\\\" queries!\";\n    // take average: times go by all queries, other meassures go by \"good\" queries noly.\n    avg.searchTime /= stats.length;\n    avg.docNamesExtractTime /= stats.length;\n    avg.numGoodPoints /= m;\n    avg.numPoints /= m;\n    avg.recall /= m;\n    avg.maxGoodPoints /= m;\n    for (int j=1; j<avg.pAt.length; j++) {\n      avg.pAt[j] /= m;\n    }\n    avg.pReleventSum /= m;                 // this is actually avgp now \n    avg.pReleventSum *= avg.maxGoodPoints; // so that getAvgP() would be correct\n    \n    return avg;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"add7d922e63099fbce8f0a1b31216df7ef5067f1","date":1252002701,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityStats#average(QualityStats[]).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityStats#average(QualityStats[]).mjava","sourceNew":"  /**\n   * Create a QualityStats object that is the average of the input QualityStats objects. \n   * @param stats array of input stats to be averaged.\n   * @return an average over the input stats.\n   */\n  public static QualityStats average(QualityStats[] stats) {\n    QualityStats avg = new QualityStats(0,0);\n    if (stats.length==0) {\n      // weired, no stats to average!\n      return avg;\n    }\n    int m = 0; // queries with positive judgements\n    // aggregate\n    for (int i=0; i<stats.length; i++) {\n      avg.searchTime += stats[i].searchTime;\n      avg.docNamesExtractTime += stats[i].docNamesExtractTime;\n      if (stats[i].maxGoodPoints>0) {\n        m++;\n        avg.numGoodPoints += stats[i].numGoodPoints;\n        avg.numPoints += stats[i].numPoints;\n        avg.pReleventSum += stats[i].getAvp();\n        avg.recall += stats[i].recall;\n        avg.mrr += stats[i].getMRR();\n        avg.maxGoodPoints += stats[i].maxGoodPoints;\n        for (int j=1; j<avg.pAt.length; j++) {\n          avg.pAt[j] += stats[i].getPrecisionAt(j);\n        }\n      }\n    }\n    assert m>0 : \"Fishy: no \\\"good\\\" queries!\";\n    // take average: times go by all queries, other measures go by \"good\" queries only.\n    avg.searchTime /= stats.length;\n    avg.docNamesExtractTime /= stats.length;\n    avg.numGoodPoints /= m;\n    avg.numPoints /= m;\n    avg.recall /= m;\n    avg.mrr /= m;\n    avg.maxGoodPoints /= m;\n    for (int j=1; j<avg.pAt.length; j++) {\n      avg.pAt[j] /= m;\n    }\n    avg.pReleventSum /= m;                 // this is actually avgp now \n    avg.pReleventSum *= avg.maxGoodPoints; // so that getAvgP() would be correct\n    \n    return avg;\n  }\n\n","sourceOld":"  /**\n   * Create a QualityStats object that is the average of the input QualityStats objects. \n   * @param stats array of input stats to be averaged.\n   * @return an average over the input stats.\n   */\n  public static QualityStats average(QualityStats[] stats) {\n    QualityStats avg = new QualityStats(0,0);\n    if (stats.length==0) {\n      // weired, no stats to average!\n      return avg;\n    }\n    int m = 0; // queries with positive judgements\n    // aggregate\n    for (int i=0; i<stats.length; i++) {\n      avg.searchTime += stats[i].searchTime;\n      avg.docNamesExtractTime += stats[i].docNamesExtractTime;\n      if (stats[i].maxGoodPoints>0) {\n        m++;\n        avg.numGoodPoints += stats[i].numGoodPoints;\n        avg.numPoints += stats[i].numPoints;\n        avg.pReleventSum += stats[i].getAvp();\n        avg.recall += stats[i].recall;\n        avg.mrr += stats[i].getMRR();\n        avg.maxGoodPoints += stats[i].maxGoodPoints;\n        for (int j=1; j<avg.pAt.length; j++) {\n          avg.pAt[j] += stats[i].getPrecisionAt(j);\n        }\n      }\n    }\n    assert m>0 : \"Fishy: no \\\"good\\\" queries!\";\n    // take average: times go by all queries, other meassures go by \"good\" queries noly.\n    avg.searchTime /= stats.length;\n    avg.docNamesExtractTime /= stats.length;\n    avg.numGoodPoints /= m;\n    avg.numPoints /= m;\n    avg.recall /= m;\n    avg.mrr /= m;\n    avg.maxGoodPoints /= m;\n    for (int j=1; j<avg.pAt.length; j++) {\n      avg.pAt[j] /= m;\n    }\n    avg.pReleventSum /= m;                 // this is actually avgp now \n    avg.pReleventSum *= avg.maxGoodPoints; // so that getAvgP() would be correct\n    \n    return avg;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityStats#average(QualityStats[]).mjava","pathOld":"contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityStats#average(QualityStats[]).mjava","sourceNew":"  /**\n   * Create a QualityStats object that is the average of the input QualityStats objects. \n   * @param stats array of input stats to be averaged.\n   * @return an average over the input stats.\n   */\n  public static QualityStats average(QualityStats[] stats) {\n    QualityStats avg = new QualityStats(0,0);\n    if (stats.length==0) {\n      // weired, no stats to average!\n      return avg;\n    }\n    int m = 0; // queries with positive judgements\n    // aggregate\n    for (int i=0; i<stats.length; i++) {\n      avg.searchTime += stats[i].searchTime;\n      avg.docNamesExtractTime += stats[i].docNamesExtractTime;\n      if (stats[i].maxGoodPoints>0) {\n        m++;\n        avg.numGoodPoints += stats[i].numGoodPoints;\n        avg.numPoints += stats[i].numPoints;\n        avg.pReleventSum += stats[i].getAvp();\n        avg.recall += stats[i].recall;\n        avg.mrr += stats[i].getMRR();\n        avg.maxGoodPoints += stats[i].maxGoodPoints;\n        for (int j=1; j<avg.pAt.length; j++) {\n          avg.pAt[j] += stats[i].getPrecisionAt(j);\n        }\n      }\n    }\n    assert m>0 : \"Fishy: no \\\"good\\\" queries!\";\n    // take average: times go by all queries, other measures go by \"good\" queries only.\n    avg.searchTime /= stats.length;\n    avg.docNamesExtractTime /= stats.length;\n    avg.numGoodPoints /= m;\n    avg.numPoints /= m;\n    avg.recall /= m;\n    avg.mrr /= m;\n    avg.maxGoodPoints /= m;\n    for (int j=1; j<avg.pAt.length; j++) {\n      avg.pAt[j] /= m;\n    }\n    avg.pReleventSum /= m;                 // this is actually avgp now \n    avg.pReleventSum *= avg.maxGoodPoints; // so that getAvgP() would be correct\n    \n    return avg;\n  }\n\n","sourceOld":"  /**\n   * Create a QualityStats object that is the average of the input QualityStats objects. \n   * @param stats array of input stats to be averaged.\n   * @return an average over the input stats.\n   */\n  public static QualityStats average(QualityStats[] stats) {\n    QualityStats avg = new QualityStats(0,0);\n    if (stats.length==0) {\n      // weired, no stats to average!\n      return avg;\n    }\n    int m = 0; // queries with positive judgements\n    // aggregate\n    for (int i=0; i<stats.length; i++) {\n      avg.searchTime += stats[i].searchTime;\n      avg.docNamesExtractTime += stats[i].docNamesExtractTime;\n      if (stats[i].maxGoodPoints>0) {\n        m++;\n        avg.numGoodPoints += stats[i].numGoodPoints;\n        avg.numPoints += stats[i].numPoints;\n        avg.pReleventSum += stats[i].getAvp();\n        avg.recall += stats[i].recall;\n        avg.mrr += stats[i].getMRR();\n        avg.maxGoodPoints += stats[i].maxGoodPoints;\n        for (int j=1; j<avg.pAt.length; j++) {\n          avg.pAt[j] += stats[i].getPrecisionAt(j);\n        }\n      }\n    }\n    assert m>0 : \"Fishy: no \\\"good\\\" queries!\";\n    // take average: times go by all queries, other measures go by \"good\" queries only.\n    avg.searchTime /= stats.length;\n    avg.docNamesExtractTime /= stats.length;\n    avg.numGoodPoints /= m;\n    avg.numPoints /= m;\n    avg.recall /= m;\n    avg.mrr /= m;\n    avg.maxGoodPoints /= m;\n    for (int j=1; j<avg.pAt.length; j++) {\n      avg.pAt[j] /= m;\n    }\n    avg.pReleventSum /= m;                 // this is actually avgp now \n    avg.pReleventSum *= avg.maxGoodPoints; // so that getAvgP() would be correct\n    \n    return avg;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"add7d922e63099fbce8f0a1b31216df7ef5067f1":["05d64184e4c44205b1dfa1cdf3869230c4025dc9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"df2d68685a69bd82bf79243e28623c0775eb7bd8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"05d64184e4c44205b1dfa1cdf3869230c4025dc9":["df2d68685a69bd82bf79243e28623c0775eb7bd8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["add7d922e63099fbce8f0a1b31216df7ef5067f1"]},"commit2Childs":{"add7d922e63099fbce8f0a1b31216df7ef5067f1":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["df2d68685a69bd82bf79243e28623c0775eb7bd8"],"df2d68685a69bd82bf79243e28623c0775eb7bd8":["05d64184e4c44205b1dfa1cdf3869230c4025dc9"],"05d64184e4c44205b1dfa1cdf3869230c4025dc9":["add7d922e63099fbce8f0a1b31216df7ef5067f1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}