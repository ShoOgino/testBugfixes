{"path":"solr/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"/dev/null","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":null,"sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"/dev/null","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"227a2cd43fc1affe16eb4c4ab4423fbc276bd81d","date":1292210954,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n              writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","pathOld":"solr/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter#doFilter(ServletRequest,ServletResponse,FilterChain).mjava","sourceNew":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","sourceOld":"  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    if( abortErrorMessage != null ) {\n      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );\n      return;\n    }\n\n    if( request instanceof HttpServletRequest) {\n      HttpServletRequest req = (HttpServletRequest)request;\n      HttpServletResponse resp = (HttpServletResponse)response;\n      SolrRequestHandler handler = null;\n      SolrQueryRequest solrReq = null;\n      SolrCore core = null;\n      String corename = \"\";\n      try {\n        // put the core container in request attribute\n        req.setAttribute(\"org.apache.solr.CoreContainer\", cores);\n        String path = req.getServletPath();\n        if( req.getPathInfo() != null ) {\n          // this lets you handle /update/commit when /update is a servlet\n          path += req.getPathInfo();\n        }\n        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {\n          path = path.substring( pathPrefix.length() );\n        }\n        // check for management path\n        String alternate = cores.getManagementPath();\n        if (alternate != null && path.startsWith(alternate)) {\n          path = path.substring(0, alternate.length());\n        }\n        // unused feature ?\n        int idx = path.indexOf( ':' );\n        if( idx > 0 ) {\n          // save the portion after the ':' for a 'handler' path parameter\n          path = path.substring( 0, idx );\n        }\n\n        // Check for the core admin page\n        if( path.equals( cores.getAdminPath() ) ) {\n          handler = cores.getMultiCoreHandler();\n          solrReq =  adminRequestParser.parse(null,path, req);\n          handleAdminRequest(req, response, handler, solrReq);\n          return;\n        }\n        else {\n          //otherwise, we should find a core from the path\n          idx = path.indexOf( \"/\", 1 );\n          if( idx > 1 ) {\n            // try to get the corename as a request parameter first\n            corename = path.substring( 1, idx );\n            core = cores.getCore(corename);\n            if (core != null) {\n              path = path.substring( idx );\n            }\n          }\n          if (core == null) {\n            corename = \"\";\n            core = cores.getCore(\"\");\n          }\n        }\n\n        // With a valid core...\n        if( core != null ) {\n          final SolrConfig config = core.getSolrConfig();\n          // get or create/cache the parser for the core\n          SolrRequestParsers parser = null;\n          parser = parsers.get(config);\n          if( parser == null ) {\n            parser = new SolrRequestParsers(config);\n            parsers.put(config, parser );\n          }\n\n          // Determine the handler from the url path if not set\n          // (we might already have selected the cores handler)\n          if( handler == null && path.length() > 1 ) { // don't match \"\" or \"/\" as valid path\n            handler = core.getRequestHandler( path );\n            // no handler yet but allowed to handle select; let's check\n            if( handler == null && parser.isHandleSelect() ) {\n              if( \"/select\".equals( path ) || \"/select/\".equals( path ) ) {\n                solrReq = parser.parse( core, path, req );\n                String qt = solrReq.getParams().get( CommonParams.QT );\n                handler = core.getRequestHandler( qt );\n                if( handler == null ) {\n                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"unknown handler: \"+qt);\n                }\n              }\n            }\n          }\n\n          // With a valid handler and a valid core...\n          if( handler != null ) {\n            // if not a /select, create the request\n            if( solrReq == null ) {\n              solrReq = parser.parse( core, path, req );\n            }\n\n            final Method reqMethod = Method.getMethod(req.getMethod());\n            HttpCacheHeaderUtil.setCacheControlHeader(config, resp, reqMethod);\n            // unless we have been explicitly told not to, do cache validation\n            // if we fail cache validation, execute the query\n            if (config.getHttpCachingConfig().isNever304() ||\n                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, reqMethod, resp)) {\n                SolrQueryResponse solrRsp = new SolrQueryResponse();\n                /* even for HEAD requests, we need to execute the handler to\n                 * ensure we don't get an error (and to make sure the correct\n                 * QueryResponseWriter is selected and we get the correct\n                 * Content-Type)\n                 */\n                SolrRequestInfo.setRequestInfo(new SolrRequestInfo(solrReq, solrRsp));\n                this.execute( req, handler, solrReq, solrRsp );\n                HttpCacheHeaderUtil.checkHttpCachingVeto(solrRsp, resp, reqMethod);\n              // add info to http headers\n              //TODO: See SOLR-232 and SOLR-267.  \n                /*try {\n                  NamedList solrRspHeader = solrRsp.getResponseHeader();\n                 for (int i=0; i<solrRspHeader.size(); i++) {\n                   ((javax.servlet.http.HttpServletResponse) response).addHeader((\"Solr-\" + solrRspHeader.getName(i)), String.valueOf(solrRspHeader.getVal(i)));\n                 }\n                } catch (ClassCastException cce) {\n                  log.log(Level.WARNING, \"exception adding response header log information\", cce);\n                }*/\n               QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);\n               writeResponse(solrRsp, response, responseWriter, solrReq, reqMethod);\n            }\n            return; // we are done with a valid handler\n          }\n          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so\n          // a servlet/jsp can retrieve it\n          else {\n            req.setAttribute(\"org.apache.solr.SolrCore\", core);\n            // Modify the request so each core gets its own /admin\n            if( path.startsWith( \"/admin\" ) ) {\n              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );\n              return;\n            }\n          }\n        }\n        log.debug(\"no handler or core retrieved for \" + path + \", follow through...\");\n      } \n      catch (Throwable ex) {\n        sendError( (HttpServletResponse)response, ex );\n        return;\n      } \n      finally {\n        if( solrReq != null ) {\n          solrReq.close();\n        }\n        if (core != null) {\n          core.close();\n        }\n        SolrRequestInfo.clearRequestInfo();        \n      }\n    }\n\n    // Otherwise let the webapp handle the request\n    chain.doFilter(request, response);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"c26f00b574427b55127e869b935845554afde1fa":["227a2cd43fc1affe16eb4c4ab4423fbc276bd81d","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["1da8d55113b689b06716246649de6f62430f15c0","227a2cd43fc1affe16eb4c4ab4423fbc276bd81d"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["1da8d55113b689b06716246649de6f62430f15c0","227a2cd43fc1affe16eb4c4ab4423fbc276bd81d"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["227a2cd43fc1affe16eb4c4ab4423fbc276bd81d"],"227a2cd43fc1affe16eb4c4ab4423fbc276bd81d":["1da8d55113b689b06716246649de6f62430f15c0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["227a2cd43fc1affe16eb4c4ab4423fbc276bd81d"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"1da8d55113b689b06716246649de6f62430f15c0":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","227a2cd43fc1affe16eb4c4ab4423fbc276bd81d"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"227a2cd43fc1affe16eb4c4ab4423fbc276bd81d":["c26f00b574427b55127e869b935845554afde1fa","ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}