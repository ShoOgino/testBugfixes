{"path":"contrib/wordnet/src/java/org/apache/lucene/wordnet/SynonymMap#read(byte[]).mjava","commits":[{"id":"d68e5c46e6a5ebdf4dafec4a123344092b915cc0","date":1256752193,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"contrib/wordnet/src/java/org/apache/lucene/wordnet/SynonymMap#read(byte[]).mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/SynonymMap#read(byte[]).mjava","sourceNew":"  private HashMap read(byte[] data) {\n    int WORDS  = (int) (76401 / 0.7); // presizing\n    int GROUPS = (int) (88022 / 0.7); // presizing\n    HashMap word2Groups = new HashMap(WORDS);  // Map<String word, int[] groups>\n    HashMap group2Words = new HashMap(GROUPS); // Map<int group, String[] words>\n    HashMap internedWords = new HashMap(WORDS);// Map<String word, String word>\n\n    Charset charset = Charset.forName(\"UTF-8\");\n    int lastNum = -1;\n    Integer lastGroup = null;\n    int len = data.length;\n    int i=0;\n    \n    while (i < len) { // until EOF\n      /* Part A: Parse a line */\n      \n      // scan to beginning of group\n      while (i < len && data[i] != '(') i++;\n      if (i >= len) break; // EOF\n      i++;\n      \n      // parse group\n      int num = 0;\n      while (i < len && data[i] != ',') {\n        num = 10*num + (data[i] - 48);\n        i++;\n      }\n      i++;\n//      if (DEBUG) System.err.println(\"num=\"+ num);\n      \n      // scan to beginning of word\n      while (i < len && data[i] != '\\'') i++;\n      i++;\n  \n      // scan to end of word\n      int start = i;\n      do {\n        while (i < len && data[i] != '\\'') i++;\n        i++;\n      } while (i < len && data[i] != ','); // word must end with \"',\"\n      \n      if (i >= len) break; // EOF\n      String word = charset.decode(ByteBuffer.wrap(data, start, i-start-1)).toString();\n//      String word = new String(data, 0, start, i-start-1); // ASCII\n      \n      /*\n       * Part B: ignore phrases (with spaces and hyphens) and\n       * non-alphabetic words, and let user customize word (e.g. do some\n       * stemming)\n       */\n      if (!isValid(word)) continue; // ignore\n      word = analyze(word);\n      if (word == null || word.length() == 0) continue; // ignore\n      \n      \n      /* Part C: Add (group,word) to tables */\n      \n      // ensure compact string representation, minimizing memory overhead\n      String w = (String) internedWords.get(word);\n      if (w == null) {\n        word = new String(word); // ensure compact string\n        internedWords.put(word, word);\n      } else {\n        word = w;\n      }\n      \n      Integer group = lastGroup;\n      if (num != lastNum) {\n        group = Integer.valueOf(num);\n        lastGroup = group;\n        lastNum = num;\n      }\n      \n      // add word --> group\n      ArrayList groups = (ArrayList) word2Groups.get(word);\n      if (groups == null) {\n        groups = new ArrayList(1);\n        word2Groups.put(word, groups);\n      }\n      groups.add(group);\n\n      // add group --> word\n      ArrayList words = (ArrayList) group2Words.get(group);\n      if (words == null) {\n        words = new ArrayList(1);\n        group2Words.put(group, words);\n      } \n      words.add(word);\n    }\n    \n    \n    /* Part D: compute index data structure */\n    HashMap word2Syns = createIndex(word2Groups, group2Words);    \n        \n    /* Part E: minimize memory consumption by a factor 3 (or so) */\n//    if (true) return word2Syns;\n    word2Groups = null; // help gc\n    group2Words = null; // help gc    \n    return optimize(word2Syns, internedWords);\n  }\n\n","sourceOld":"  private HashMap read(byte[] data) {\n    int WORDS  = (int) (76401 / 0.7); // presizing\n    int GROUPS = (int) (88022 / 0.7); // presizing\n    HashMap word2Groups = new HashMap(WORDS);  // Map<String word, int[] groups>\n    HashMap group2Words = new HashMap(GROUPS); // Map<int group, String[] words>\n    HashMap internedWords = new HashMap(WORDS);// Map<String word, String word>\n\n    Charset charset = Charset.forName(\"UTF-8\");\n    int lastNum = -1;\n    Integer lastGroup = null;\n    int len = data.length;\n    int i=0;\n    \n    while (i < len) { // until EOF\n      /* Part A: Parse a line */\n      \n      // scan to beginning of group\n      while (i < len && data[i] != '(') i++;\n      if (i >= len) break; // EOF\n      i++;\n      \n      // parse group\n      int num = 0;\n      while (i < len && data[i] != ',') {\n        num = 10*num + (data[i] - 48);\n        i++;\n      }\n      i++;\n//      if (DEBUG) System.err.println(\"num=\"+ num);\n      \n      // scan to beginning of word\n      while (i < len && data[i] != '\\'') i++;\n      i++;\n  \n      // scan to end of word\n      int start = i;\n      do {\n        while (i < len && data[i] != '\\'') i++;\n        i++;\n      } while (i < len && data[i] != ','); // word must end with \"',\"\n      \n      if (i >= len) break; // EOF\n      String word = charset.decode(ByteBuffer.wrap(data, start, i-start-1)).toString();\n//      String word = new String(data, 0, start, i-start-1); // ASCII\n      \n      /*\n       * Part B: ignore phrases (with spaces and hyphens) and\n       * non-alphabetic words, and let user customize word (e.g. do some\n       * stemming)\n       */\n      if (!isValid(word)) continue; // ignore\n      word = analyze(word);\n      if (word == null || word.length() == 0) continue; // ignore\n      \n      \n      /* Part C: Add (group,word) to tables */\n      \n      // ensure compact string representation, minimizing memory overhead\n      String w = (String) internedWords.get(word);\n      if (w == null) {\n        word = new String(word); // ensure compact string\n        internedWords.put(word, word);\n      } else {\n        word = w;\n      }\n      \n      Integer group = lastGroup;\n      if (num != lastNum) {\n        group = Integer.valueOf(num);\n        lastGroup = group;\n        lastNum = num;\n      }\n      \n      // add word --> group\n      ArrayList groups = (ArrayList) word2Groups.get(word);\n      if (groups == null) {\n        groups = new ArrayList(1);\n        word2Groups.put(word, groups);\n      }\n      groups.add(group);\n\n      // add group --> word\n      ArrayList words = (ArrayList) group2Words.get(group);\n      if (words == null) {\n        words = new ArrayList(1);\n        group2Words.put(group, words);\n      } \n      words.add(word);\n    }\n    \n    \n    /* Part D: compute index data structure */\n    HashMap word2Syns = createIndex(word2Groups, group2Words);    \n        \n    /* Part E: minimize memory consumption by a factor 3 (or so) */\n//    if (true) return word2Syns;\n    word2Groups = null; // help gc\n    group2Words = null; // help gc    \n    return optimize(word2Syns, internedWords);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f11899016a0460a7ea2e4b008d002e1e75c7d867","date":1256772085,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/wordnet/src/java/org/apache/lucene/wordnet/SynonymMap#read(byte[]).mjava","pathOld":"contrib/wordnet/src/java/org/apache/lucene/wordnet/SynonymMap#read(byte[]).mjava","sourceNew":"  private HashMap<String,String[]> read(byte[] data) {\n    int WORDS  = (int) (76401 / 0.7); // presizing\n    int GROUPS = (int) (88022 / 0.7); // presizing\n    HashMap<String,ArrayList<Integer>> word2Groups = new HashMap<String,ArrayList<Integer>>(WORDS);  // Map<String word, int[] groups>\n    HashMap<Integer,ArrayList<String>> group2Words = new HashMap<Integer,ArrayList<String>>(GROUPS); // Map<int group, String[] words>\n    HashMap<String,String> internedWords = new HashMap<String,String>(WORDS);// Map<String word, String word>\n\n    Charset charset = Charset.forName(\"UTF-8\");\n    int lastNum = -1;\n    Integer lastGroup = null;\n    int len = data.length;\n    int i=0;\n    \n    while (i < len) { // until EOF\n      /* Part A: Parse a line */\n      \n      // scan to beginning of group\n      while (i < len && data[i] != '(') i++;\n      if (i >= len) break; // EOF\n      i++;\n      \n      // parse group\n      int num = 0;\n      while (i < len && data[i] != ',') {\n        num = 10*num + (data[i] - 48);\n        i++;\n      }\n      i++;\n//      if (DEBUG) System.err.println(\"num=\"+ num);\n      \n      // scan to beginning of word\n      while (i < len && data[i] != '\\'') i++;\n      i++;\n  \n      // scan to end of word\n      int start = i;\n      do {\n        while (i < len && data[i] != '\\'') i++;\n        i++;\n      } while (i < len && data[i] != ','); // word must end with \"',\"\n      \n      if (i >= len) break; // EOF\n      String word = charset.decode(ByteBuffer.wrap(data, start, i-start-1)).toString();\n//      String word = new String(data, 0, start, i-start-1); // ASCII\n      \n      /*\n       * Part B: ignore phrases (with spaces and hyphens) and\n       * non-alphabetic words, and let user customize word (e.g. do some\n       * stemming)\n       */\n      if (!isValid(word)) continue; // ignore\n      word = analyze(word);\n      if (word == null || word.length() == 0) continue; // ignore\n      \n      \n      /* Part C: Add (group,word) to tables */\n      \n      // ensure compact string representation, minimizing memory overhead\n      String w = internedWords.get(word);\n      if (w == null) {\n        word = new String(word); // ensure compact string\n        internedWords.put(word, word);\n      } else {\n        word = w;\n      }\n      \n      Integer group = lastGroup;\n      if (num != lastNum) {\n        group = Integer.valueOf(num);\n        lastGroup = group;\n        lastNum = num;\n      }\n      \n      // add word --> group\n      ArrayList<Integer> groups =  word2Groups.get(word);\n      if (groups == null) {\n        groups = new ArrayList<Integer>(1);\n        word2Groups.put(word, groups);\n      }\n      groups.add(group);\n\n      // add group --> word\n      ArrayList<String> words = group2Words.get(group);\n      if (words == null) {\n        words = new ArrayList<String>(1);\n        group2Words.put(group, words);\n      } \n      words.add(word);\n    }\n    \n    \n    /* Part D: compute index data structure */\n    HashMap word2Syns = createIndex(word2Groups, group2Words);    \n        \n    /* Part E: minimize memory consumption by a factor 3 (or so) */\n//    if (true) return word2Syns;\n    word2Groups = null; // help gc\n    //TODO: word2Groups.clear(); would be more appropriate  ? \n    group2Words = null; // help gc\n    //TODO: group2Words.clear(); would be more appropriate  ? \n    \n    return optimize(word2Syns, internedWords);\n  }\n\n","sourceOld":"  private HashMap read(byte[] data) {\n    int WORDS  = (int) (76401 / 0.7); // presizing\n    int GROUPS = (int) (88022 / 0.7); // presizing\n    HashMap word2Groups = new HashMap(WORDS);  // Map<String word, int[] groups>\n    HashMap group2Words = new HashMap(GROUPS); // Map<int group, String[] words>\n    HashMap internedWords = new HashMap(WORDS);// Map<String word, String word>\n\n    Charset charset = Charset.forName(\"UTF-8\");\n    int lastNum = -1;\n    Integer lastGroup = null;\n    int len = data.length;\n    int i=0;\n    \n    while (i < len) { // until EOF\n      /* Part A: Parse a line */\n      \n      // scan to beginning of group\n      while (i < len && data[i] != '(') i++;\n      if (i >= len) break; // EOF\n      i++;\n      \n      // parse group\n      int num = 0;\n      while (i < len && data[i] != ',') {\n        num = 10*num + (data[i] - 48);\n        i++;\n      }\n      i++;\n//      if (DEBUG) System.err.println(\"num=\"+ num);\n      \n      // scan to beginning of word\n      while (i < len && data[i] != '\\'') i++;\n      i++;\n  \n      // scan to end of word\n      int start = i;\n      do {\n        while (i < len && data[i] != '\\'') i++;\n        i++;\n      } while (i < len && data[i] != ','); // word must end with \"',\"\n      \n      if (i >= len) break; // EOF\n      String word = charset.decode(ByteBuffer.wrap(data, start, i-start-1)).toString();\n//      String word = new String(data, 0, start, i-start-1); // ASCII\n      \n      /*\n       * Part B: ignore phrases (with spaces and hyphens) and\n       * non-alphabetic words, and let user customize word (e.g. do some\n       * stemming)\n       */\n      if (!isValid(word)) continue; // ignore\n      word = analyze(word);\n      if (word == null || word.length() == 0) continue; // ignore\n      \n      \n      /* Part C: Add (group,word) to tables */\n      \n      // ensure compact string representation, minimizing memory overhead\n      String w = (String) internedWords.get(word);\n      if (w == null) {\n        word = new String(word); // ensure compact string\n        internedWords.put(word, word);\n      } else {\n        word = w;\n      }\n      \n      Integer group = lastGroup;\n      if (num != lastNum) {\n        group = Integer.valueOf(num);\n        lastGroup = group;\n        lastNum = num;\n      }\n      \n      // add word --> group\n      ArrayList groups = (ArrayList) word2Groups.get(word);\n      if (groups == null) {\n        groups = new ArrayList(1);\n        word2Groups.put(word, groups);\n      }\n      groups.add(group);\n\n      // add group --> word\n      ArrayList words = (ArrayList) group2Words.get(group);\n      if (words == null) {\n        words = new ArrayList(1);\n        group2Words.put(group, words);\n      } \n      words.add(word);\n    }\n    \n    \n    /* Part D: compute index data structure */\n    HashMap word2Syns = createIndex(word2Groups, group2Words);    \n        \n    /* Part E: minimize memory consumption by a factor 3 (or so) */\n//    if (true) return word2Syns;\n    word2Groups = null; // help gc\n    group2Words = null; // help gc    \n    return optimize(word2Syns, internedWords);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c69d87d34a81230de56333f52f590caeb6d80667","date":1257848306,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/wordnet/src/java/org/apache/lucene/wordnet/SynonymMap#read(byte[]).mjava","pathOld":"contrib/wordnet/src/java/org/apache/lucene/wordnet/SynonymMap#read(byte[]).mjava","sourceNew":"  private HashMap<String,String[]> read(byte[] data) {\n    int WORDS  = (int) (76401 / 0.7); // presizing\n    int GROUPS = (int) (88022 / 0.7); // presizing\n    HashMap<String,ArrayList<Integer>> word2Groups = new HashMap<String,ArrayList<Integer>>(WORDS);  // Map<String word, int[] groups>\n    HashMap<Integer,ArrayList<String>> group2Words = new HashMap<Integer,ArrayList<String>>(GROUPS); // Map<int group, String[] words>\n    HashMap<String,String> internedWords = new HashMap<String,String>(WORDS);// Map<String word, String word>\n\n    Charset charset = Charset.forName(\"UTF-8\");\n    int lastNum = -1;\n    Integer lastGroup = null;\n    int len = data.length;\n    int i=0;\n    \n    while (i < len) { // until EOF\n      /* Part A: Parse a line */\n      \n      // scan to beginning of group\n      while (i < len && data[i] != '(') i++;\n      if (i >= len) break; // EOF\n      i++;\n      \n      // parse group\n      int num = 0;\n      while (i < len && data[i] != ',') {\n        num = 10*num + (data[i] - 48);\n        i++;\n      }\n      i++;\n//      if (DEBUG) System.err.println(\"num=\"+ num);\n      \n      // scan to beginning of word\n      while (i < len && data[i] != '\\'') i++;\n      i++;\n  \n      // scan to end of word\n      int start = i;\n      do {\n        while (i < len && data[i] != '\\'') i++;\n        i++;\n      } while (i < len && data[i] != ','); // word must end with \"',\"\n      \n      if (i >= len) break; // EOF\n      String word = charset.decode(ByteBuffer.wrap(data, start, i-start-1)).toString();\n//      String word = new String(data, 0, start, i-start-1); // ASCII\n      \n      /*\n       * Part B: ignore phrases (with spaces and hyphens) and\n       * non-alphabetic words, and let user customize word (e.g. do some\n       * stemming)\n       */\n      if (!isValid(word)) continue; // ignore\n      word = analyze(word);\n      if (word == null || word.length() == 0) continue; // ignore\n      \n      \n      /* Part C: Add (group,word) to tables */\n      \n      // ensure compact string representation, minimizing memory overhead\n      String w = internedWords.get(word);\n      if (w == null) {\n        word = new String(word); // ensure compact string\n        internedWords.put(word, word);\n      } else {\n        word = w;\n      }\n      \n      Integer group = lastGroup;\n      if (num != lastNum) {\n        group = Integer.valueOf(num);\n        lastGroup = group;\n        lastNum = num;\n      }\n      \n      // add word --> group\n      ArrayList<Integer> groups =  word2Groups.get(word);\n      if (groups == null) {\n        groups = new ArrayList<Integer>(1);\n        word2Groups.put(word, groups);\n      }\n      groups.add(group);\n\n      // add group --> word\n      ArrayList<String> words = group2Words.get(group);\n      if (words == null) {\n        words = new ArrayList<String>(1);\n        group2Words.put(group, words);\n      } \n      words.add(word);\n    }\n    \n    \n    /* Part D: compute index data structure */\n    HashMap<String,String[]> word2Syns = createIndex(word2Groups, group2Words);    \n        \n    /* Part E: minimize memory consumption by a factor 3 (or so) */\n//    if (true) return word2Syns;\n    word2Groups = null; // help gc\n    //TODO: word2Groups.clear(); would be more appropriate  ? \n    group2Words = null; // help gc\n    //TODO: group2Words.clear(); would be more appropriate  ? \n    \n    return optimize(word2Syns, internedWords);\n  }\n\n","sourceOld":"  private HashMap<String,String[]> read(byte[] data) {\n    int WORDS  = (int) (76401 / 0.7); // presizing\n    int GROUPS = (int) (88022 / 0.7); // presizing\n    HashMap<String,ArrayList<Integer>> word2Groups = new HashMap<String,ArrayList<Integer>>(WORDS);  // Map<String word, int[] groups>\n    HashMap<Integer,ArrayList<String>> group2Words = new HashMap<Integer,ArrayList<String>>(GROUPS); // Map<int group, String[] words>\n    HashMap<String,String> internedWords = new HashMap<String,String>(WORDS);// Map<String word, String word>\n\n    Charset charset = Charset.forName(\"UTF-8\");\n    int lastNum = -1;\n    Integer lastGroup = null;\n    int len = data.length;\n    int i=0;\n    \n    while (i < len) { // until EOF\n      /* Part A: Parse a line */\n      \n      // scan to beginning of group\n      while (i < len && data[i] != '(') i++;\n      if (i >= len) break; // EOF\n      i++;\n      \n      // parse group\n      int num = 0;\n      while (i < len && data[i] != ',') {\n        num = 10*num + (data[i] - 48);\n        i++;\n      }\n      i++;\n//      if (DEBUG) System.err.println(\"num=\"+ num);\n      \n      // scan to beginning of word\n      while (i < len && data[i] != '\\'') i++;\n      i++;\n  \n      // scan to end of word\n      int start = i;\n      do {\n        while (i < len && data[i] != '\\'') i++;\n        i++;\n      } while (i < len && data[i] != ','); // word must end with \"',\"\n      \n      if (i >= len) break; // EOF\n      String word = charset.decode(ByteBuffer.wrap(data, start, i-start-1)).toString();\n//      String word = new String(data, 0, start, i-start-1); // ASCII\n      \n      /*\n       * Part B: ignore phrases (with spaces and hyphens) and\n       * non-alphabetic words, and let user customize word (e.g. do some\n       * stemming)\n       */\n      if (!isValid(word)) continue; // ignore\n      word = analyze(word);\n      if (word == null || word.length() == 0) continue; // ignore\n      \n      \n      /* Part C: Add (group,word) to tables */\n      \n      // ensure compact string representation, minimizing memory overhead\n      String w = internedWords.get(word);\n      if (w == null) {\n        word = new String(word); // ensure compact string\n        internedWords.put(word, word);\n      } else {\n        word = w;\n      }\n      \n      Integer group = lastGroup;\n      if (num != lastNum) {\n        group = Integer.valueOf(num);\n        lastGroup = group;\n        lastNum = num;\n      }\n      \n      // add word --> group\n      ArrayList<Integer> groups =  word2Groups.get(word);\n      if (groups == null) {\n        groups = new ArrayList<Integer>(1);\n        word2Groups.put(word, groups);\n      }\n      groups.add(group);\n\n      // add group --> word\n      ArrayList<String> words = group2Words.get(group);\n      if (words == null) {\n        words = new ArrayList<String>(1);\n        group2Words.put(group, words);\n      } \n      words.add(word);\n    }\n    \n    \n    /* Part D: compute index data structure */\n    HashMap word2Syns = createIndex(word2Groups, group2Words);    \n        \n    /* Part E: minimize memory consumption by a factor 3 (or so) */\n//    if (true) return word2Syns;\n    word2Groups = null; // help gc\n    //TODO: word2Groups.clear(); would be more appropriate  ? \n    group2Words = null; // help gc\n    //TODO: group2Words.clear(); would be more appropriate  ? \n    \n    return optimize(word2Syns, internedWords);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/wordnet/src/java/org/apache/lucene/wordnet/SynonymMap#read(byte[]).mjava","pathOld":"contrib/wordnet/src/java/org/apache/lucene/wordnet/SynonymMap#read(byte[]).mjava","sourceNew":"  private HashMap<String,String[]> read(byte[] data) {\n    int WORDS  = (int) (76401 / 0.7); // presizing\n    int GROUPS = (int) (88022 / 0.7); // presizing\n    HashMap<String,ArrayList<Integer>> word2Groups = new HashMap<String,ArrayList<Integer>>(WORDS);  // Map<String word, int[] groups>\n    HashMap<Integer,ArrayList<String>> group2Words = new HashMap<Integer,ArrayList<String>>(GROUPS); // Map<int group, String[] words>\n    HashMap<String,String> internedWords = new HashMap<String,String>(WORDS);// Map<String word, String word>\n\n    Charset charset = Charset.forName(\"UTF-8\");\n    int lastNum = -1;\n    Integer lastGroup = null;\n    int len = data.length;\n    int i=0;\n    \n    while (i < len) { // until EOF\n      /* Part A: Parse a line */\n      \n      // scan to beginning of group\n      while (i < len && data[i] != '(') i++;\n      if (i >= len) break; // EOF\n      i++;\n      \n      // parse group\n      int num = 0;\n      while (i < len && data[i] != ',') {\n        num = 10*num + (data[i] - 48);\n        i++;\n      }\n      i++;\n//      if (DEBUG) System.err.println(\"num=\"+ num);\n      \n      // scan to beginning of word\n      while (i < len && data[i] != '\\'') i++;\n      i++;\n  \n      // scan to end of word\n      int start = i;\n      do {\n        while (i < len && data[i] != '\\'') i++;\n        i++;\n      } while (i < len && data[i] != ','); // word must end with \"',\"\n      \n      if (i >= len) break; // EOF\n      String word = charset.decode(ByteBuffer.wrap(data, start, i-start-1)).toString();\n//      String word = new String(data, 0, start, i-start-1); // ASCII\n      \n      /*\n       * Part B: ignore phrases (with spaces and hyphens) and\n       * non-alphabetic words, and let user customize word (e.g. do some\n       * stemming)\n       */\n      if (!isValid(word)) continue; // ignore\n      word = analyze(word);\n      if (word == null || word.length() == 0) continue; // ignore\n      \n      \n      /* Part C: Add (group,word) to tables */\n      \n      // ensure compact string representation, minimizing memory overhead\n      String w = internedWords.get(word);\n      if (w == null) {\n        word = new String(word); // ensure compact string\n        internedWords.put(word, word);\n      } else {\n        word = w;\n      }\n      \n      Integer group = lastGroup;\n      if (num != lastNum) {\n        group = Integer.valueOf(num);\n        lastGroup = group;\n        lastNum = num;\n      }\n      \n      // add word --> group\n      ArrayList<Integer> groups =  word2Groups.get(word);\n      if (groups == null) {\n        groups = new ArrayList<Integer>(1);\n        word2Groups.put(word, groups);\n      }\n      groups.add(group);\n\n      // add group --> word\n      ArrayList<String> words = group2Words.get(group);\n      if (words == null) {\n        words = new ArrayList<String>(1);\n        group2Words.put(group, words);\n      } \n      words.add(word);\n    }\n    \n    \n    /* Part D: compute index data structure */\n    HashMap<String,String[]> word2Syns = createIndex(word2Groups, group2Words);    \n        \n    /* Part E: minimize memory consumption by a factor 3 (or so) */\n//    if (true) return word2Syns;\n    word2Groups = null; // help gc\n    //TODO: word2Groups.clear(); would be more appropriate  ? \n    group2Words = null; // help gc\n    //TODO: group2Words.clear(); would be more appropriate  ? \n    \n    return optimize(word2Syns, internedWords);\n  }\n\n","sourceOld":"  private HashMap<String,String[]> read(byte[] data) {\n    int WORDS  = (int) (76401 / 0.7); // presizing\n    int GROUPS = (int) (88022 / 0.7); // presizing\n    HashMap<String,ArrayList<Integer>> word2Groups = new HashMap<String,ArrayList<Integer>>(WORDS);  // Map<String word, int[] groups>\n    HashMap<Integer,ArrayList<String>> group2Words = new HashMap<Integer,ArrayList<String>>(GROUPS); // Map<int group, String[] words>\n    HashMap<String,String> internedWords = new HashMap<String,String>(WORDS);// Map<String word, String word>\n\n    Charset charset = Charset.forName(\"UTF-8\");\n    int lastNum = -1;\n    Integer lastGroup = null;\n    int len = data.length;\n    int i=0;\n    \n    while (i < len) { // until EOF\n      /* Part A: Parse a line */\n      \n      // scan to beginning of group\n      while (i < len && data[i] != '(') i++;\n      if (i >= len) break; // EOF\n      i++;\n      \n      // parse group\n      int num = 0;\n      while (i < len && data[i] != ',') {\n        num = 10*num + (data[i] - 48);\n        i++;\n      }\n      i++;\n//      if (DEBUG) System.err.println(\"num=\"+ num);\n      \n      // scan to beginning of word\n      while (i < len && data[i] != '\\'') i++;\n      i++;\n  \n      // scan to end of word\n      int start = i;\n      do {\n        while (i < len && data[i] != '\\'') i++;\n        i++;\n      } while (i < len && data[i] != ','); // word must end with \"',\"\n      \n      if (i >= len) break; // EOF\n      String word = charset.decode(ByteBuffer.wrap(data, start, i-start-1)).toString();\n//      String word = new String(data, 0, start, i-start-1); // ASCII\n      \n      /*\n       * Part B: ignore phrases (with spaces and hyphens) and\n       * non-alphabetic words, and let user customize word (e.g. do some\n       * stemming)\n       */\n      if (!isValid(word)) continue; // ignore\n      word = analyze(word);\n      if (word == null || word.length() == 0) continue; // ignore\n      \n      \n      /* Part C: Add (group,word) to tables */\n      \n      // ensure compact string representation, minimizing memory overhead\n      String w = internedWords.get(word);\n      if (w == null) {\n        word = new String(word); // ensure compact string\n        internedWords.put(word, word);\n      } else {\n        word = w;\n      }\n      \n      Integer group = lastGroup;\n      if (num != lastNum) {\n        group = Integer.valueOf(num);\n        lastGroup = group;\n        lastNum = num;\n      }\n      \n      // add word --> group\n      ArrayList<Integer> groups =  word2Groups.get(word);\n      if (groups == null) {\n        groups = new ArrayList<Integer>(1);\n        word2Groups.put(word, groups);\n      }\n      groups.add(group);\n\n      // add group --> word\n      ArrayList<String> words = group2Words.get(group);\n      if (words == null) {\n        words = new ArrayList<String>(1);\n        group2Words.put(group, words);\n      } \n      words.add(word);\n    }\n    \n    \n    /* Part D: compute index data structure */\n    HashMap<String,String[]> word2Syns = createIndex(word2Groups, group2Words);    \n        \n    /* Part E: minimize memory consumption by a factor 3 (or so) */\n//    if (true) return word2Syns;\n    word2Groups = null; // help gc\n    //TODO: word2Groups.clear(); would be more appropriate  ? \n    group2Words = null; // help gc\n    //TODO: group2Words.clear(); would be more appropriate  ? \n    \n    return optimize(word2Syns, internedWords);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c69d87d34a81230de56333f52f590caeb6d80667":["f11899016a0460a7ea2e4b008d002e1e75c7d867"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["c69d87d34a81230de56333f52f590caeb6d80667"],"f11899016a0460a7ea2e4b008d002e1e75c7d867":["d68e5c46e6a5ebdf4dafec4a123344092b915cc0"],"d68e5c46e6a5ebdf4dafec4a123344092b915cc0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"c69d87d34a81230de56333f52f590caeb6d80667":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d68e5c46e6a5ebdf4dafec4a123344092b915cc0"],"f11899016a0460a7ea2e4b008d002e1e75c7d867":["c69d87d34a81230de56333f52f590caeb6d80667"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d68e5c46e6a5ebdf4dafec4a123344092b915cc0":["f11899016a0460a7ea2e4b008d002e1e75c7d867"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}