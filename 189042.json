{"path":"backwards/src/java/org/apache/lucene/search/FieldCacheImpl.StringIndexCache#createValue(IndexReader,Entry).mjava","commits":[{"id":"480d01e5b0ef8efb136d51670fec297ae5ae2c9c","date":1268821447,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"backwards/src/java/org/apache/lucene/search/FieldCacheImpl.StringIndexCache#createValue(IndexReader,Entry).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n      String field = StringHelper.intern(entryKey.field);\n      final int[] retArray = new int[reader.maxDoc()];\n      String[] mterms = new String[reader.maxDoc()+1];\n      TermDocs termDocs = reader.termDocs();\n      TermEnum termEnum = reader.terms (new Term (field));\n      int t = 0;  // current term number\n\n      // an entry for documents that have no terms in this field\n      // should a document with no terms be at top or bottom?\n      // this puts them at the top - if it is changed, FieldDocSortedHitQueue\n      // needs to change as well.\n      mterms[t++] = null;\n\n      try {\n        do {\n          Term term = termEnum.term();\n          if (term==null || term.field() != field) break;\n\n          // store term text\n          // we expect that there is at most one term per document\n          if (t >= mterms.length) throw new RuntimeException (\"there are more terms than \" +\n                  \"documents in field \\\"\" + field + \"\\\", but it's impossible to sort on \" +\n                  \"tokenized fields\");\n          mterms[t] = term.text();\n\n          termDocs.seek (termEnum);\n          while (termDocs.next()) {\n            retArray[termDocs.doc()] = t;\n          }\n\n          t++;\n        } while (termEnum.next());\n      } finally {\n        termDocs.close();\n        termEnum.close();\n      }\n\n      if (t == 0) {\n        // if there are no terms, make the term array\n        // have a single null entry\n        mterms = new String[1];\n      } else if (t < mterms.length) {\n        // if there are less terms than documents,\n        // trim off the dead array space\n        String[] terms = new String[t];\n        System.arraycopy (mterms, 0, terms, 0, t);\n        mterms = terms;\n      }\n\n      StringIndex value = new StringIndex (retArray, mterms);\n      return value;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/backwards/src/java/org/apache/lucene/search/FieldCacheImpl.StringIndexCache#createValue(IndexReader,Entry).mjava","pathOld":"backwards/src/java/org/apache/lucene/search/FieldCacheImpl.StringIndexCache#createValue(IndexReader,Entry).mjava","sourceNew":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n      String field = StringHelper.intern(entryKey.field);\n      final int[] retArray = new int[reader.maxDoc()];\n      String[] mterms = new String[reader.maxDoc()+1];\n      TermDocs termDocs = reader.termDocs();\n      TermEnum termEnum = reader.terms (new Term (field));\n      int t = 0;  // current term number\n\n      // an entry for documents that have no terms in this field\n      // should a document with no terms be at top or bottom?\n      // this puts them at the top - if it is changed, FieldDocSortedHitQueue\n      // needs to change as well.\n      mterms[t++] = null;\n\n      try {\n        do {\n          Term term = termEnum.term();\n          if (term==null || term.field() != field) break;\n\n          // store term text\n          // we expect that there is at most one term per document\n          if (t >= mterms.length) throw new RuntimeException (\"there are more terms than \" +\n                  \"documents in field \\\"\" + field + \"\\\", but it's impossible to sort on \" +\n                  \"tokenized fields\");\n          mterms[t] = term.text();\n\n          termDocs.seek (termEnum);\n          while (termDocs.next()) {\n            retArray[termDocs.doc()] = t;\n          }\n\n          t++;\n        } while (termEnum.next());\n      } finally {\n        termDocs.close();\n        termEnum.close();\n      }\n\n      if (t == 0) {\n        // if there are no terms, make the term array\n        // have a single null entry\n        mterms = new String[1];\n      } else if (t < mterms.length) {\n        // if there are less terms than documents,\n        // trim off the dead array space\n        String[] terms = new String[t];\n        System.arraycopy (mterms, 0, terms, 0, t);\n        mterms = terms;\n      }\n\n      StringIndex value = new StringIndex (retArray, mterms);\n      return value;\n    }\n\n","sourceOld":"    @Override\n    protected Object createValue(IndexReader reader, Entry entryKey)\n        throws IOException {\n      String field = StringHelper.intern(entryKey.field);\n      final int[] retArray = new int[reader.maxDoc()];\n      String[] mterms = new String[reader.maxDoc()+1];\n      TermDocs termDocs = reader.termDocs();\n      TermEnum termEnum = reader.terms (new Term (field));\n      int t = 0;  // current term number\n\n      // an entry for documents that have no terms in this field\n      // should a document with no terms be at top or bottom?\n      // this puts them at the top - if it is changed, FieldDocSortedHitQueue\n      // needs to change as well.\n      mterms[t++] = null;\n\n      try {\n        do {\n          Term term = termEnum.term();\n          if (term==null || term.field() != field) break;\n\n          // store term text\n          // we expect that there is at most one term per document\n          if (t >= mterms.length) throw new RuntimeException (\"there are more terms than \" +\n                  \"documents in field \\\"\" + field + \"\\\", but it's impossible to sort on \" +\n                  \"tokenized fields\");\n          mterms[t] = term.text();\n\n          termDocs.seek (termEnum);\n          while (termDocs.next()) {\n            retArray[termDocs.doc()] = t;\n          }\n\n          t++;\n        } while (termEnum.next());\n      } finally {\n        termDocs.close();\n        termEnum.close();\n      }\n\n      if (t == 0) {\n        // if there are no terms, make the term array\n        // have a single null entry\n        mterms = new String[1];\n      } else if (t < mterms.length) {\n        // if there are less terms than documents,\n        // trim off the dead array space\n        String[] terms = new String[t];\n        System.arraycopy (mterms, 0, terms, 0, t);\n        mterms = terms;\n      }\n\n      StringIndex value = new StringIndex (retArray, mterms);\n      return value;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"]},"commit2Childs":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}