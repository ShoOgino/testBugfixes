{"path":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","pathOld":"modules/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random(), 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n\n        assertEquals(expectedResult, actualResult);\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random(), 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n\n        assertEquals(expectedResult, actualResult);\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"77855215e331ce146763531cb9b0c050726f6ae5","date":1338323851,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random(), 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return topScoreDocCollector.acceptsDocsOutOfOrder();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random(), 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n\n        assertEquals(expectedResult, actualResult);\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random(), 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return topScoreDocCollector.acceptsDocsOutOfOrder();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random(), 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return topScoreDocCollector.acceptsDocsOutOfOrder();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":["76ea4531bf2fa6dd07ba0b7fb4bb86881bbe5f62"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9c70cdb81dc660d90f9d0664dd91b473b7e66563","date":1341679310,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random(), 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return topScoreDocCollector.acceptsDocsOutOfOrder();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random(), 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return topScoreDocCollector.acceptsDocsOutOfOrder();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2acf500f78aa12b92e371fd89c719291986b6b90","date":1341846236,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random(), 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return topScoreDocCollector.acceptsDocsOutOfOrder();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random(), 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return topScoreDocCollector.acceptsDocsOutOfOrder();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46d8ada1fff8d18cb197c38c7983225162599948","date":1341853497,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random(), 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return topScoreDocCollector.acceptsDocsOutOfOrder();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random(), 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return topScoreDocCollector.acceptsDocsOutOfOrder();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e0533284bccacfa05d7087da7a815efed9d20212","date":1342444866,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int,int).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter, int numberOfDocumentsToIndex) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return topScoreDocCollector.acceptsDocsOutOfOrder();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random(), 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return topScoreDocCollector.acceptsDocsOutOfOrder();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","sourceNew":null,"sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random(), 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return topScoreDocCollector.acceptsDocsOutOfOrder();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":4,"author":"Uwe Schindler","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","sourceNew":null,"sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random(), 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        final Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];\n        if (VERBOSE) {\n          System.out.println(\"scoreMode=\" + scoreMode);\n        }\n\n        final Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher, scoreMode);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher, scoreMode);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        final TopScoreDocCollector topScoreDocCollector = TopScoreDocCollector.create(10, false);\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n            topScoreDocCollector.collect(doc);\n          }\n\n          public void setNextReader(AtomicReaderContext context) {\n            docBase = context.docBase;\n            topScoreDocCollector.setNextReader(context);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            topScoreDocCollector.setScorer(scorer);\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return topScoreDocCollector.acceptsDocsOutOfOrder();\n          }\n        });\n        // Asserting bit set...\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(Locale.ROOT, \"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n        assertEquals(expectedResult, actualResult);\n\n        // Asserting TopDocs...\n        TopDocs expectedTopDocs = createExpectedTopDocs(randomValue, from, scoreMode, context);\n        TopDocs actualTopDocs = topScoreDocCollector.topDocs();\n        assertEquals(expectedTopDocs.totalHits, actualTopDocs.totalHits);\n        assertEquals(expectedTopDocs.scoreDocs.length, actualTopDocs.scoreDocs.length);\n        if (scoreMode == ScoreMode.None) {\n          continue;\n        }\n\n        assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);\n        for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {\n          if (VERBOSE) {\n            System.out.printf(\"Expected doc: %d | Actual doc: %d\\n\", expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n            System.out.printf(\"Expected score: %f | Actual score: %f\\n\", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);\n          }\n          assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score, 0.0f);\n          Explanation explanation = indexSearcher.explain(joinQuery, expectedTopDocs.scoreDocs[i].doc);\n          assertEquals(expectedTopDocs.scoreDocs[i].score, explanation.getValue(), 0.0f);\n        }\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e0533284bccacfa05d7087da7a815efed9d20212":["2acf500f78aa12b92e371fd89c719291986b6b90"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"aba371508186796cc6151d8223a5b4e16d02e26e":["46d8ada1fff8d18cb197c38c7983225162599948","e0533284bccacfa05d7087da7a815efed9d20212"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["77855215e331ce146763531cb9b0c050726f6ae5","e0533284bccacfa05d7087da7a815efed9d20212"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"77855215e331ce146763531cb9b0c050726f6ae5":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["77855215e331ce146763531cb9b0c050726f6ae5"],"2acf500f78aa12b92e371fd89c719291986b6b90":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","9c70cdb81dc660d90f9d0664dd91b473b7e66563"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e0533284bccacfa05d7087da7a815efed9d20212"],"9c70cdb81dc660d90f9d0664dd91b473b7e66563":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"46d8ada1fff8d18cb197c38c7983225162599948":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","2acf500f78aa12b92e371fd89c719291986b6b90"]},"commit2Childs":{"e0533284bccacfa05d7087da7a815efed9d20212":["aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["77855215e331ce146763531cb9b0c050726f6ae5"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"77855215e331ce146763531cb9b0c050726f6ae5":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"2acf500f78aa12b92e371fd89c719291986b6b90":["e0533284bccacfa05d7087da7a815efed9d20212","46d8ada1fff8d18cb197c38c7983225162599948"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["2acf500f78aa12b92e371fd89c719291986b6b90","9c70cdb81dc660d90f9d0664dd91b473b7e66563","46d8ada1fff8d18cb197c38c7983225162599948"],"46d8ada1fff8d18cb197c38c7983225162599948":["aba371508186796cc6151d8223a5b4e16d02e26e"],"9c70cdb81dc660d90f9d0664dd91b473b7e66563":["2acf500f78aa12b92e371fd89c719291986b6b90"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}