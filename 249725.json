{"path":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansPayloadOrdered#shrinkToAfterShortestMatch().mjava","commits":[{"id":"30de45e50bdc1a79a6797f34dca6271c8866cb6e","date":1427790465,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansPayloadOrdered#shrinkToAfterShortestMatch().mjava","pathOld":"/dev/null","sourceNew":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by using nextStartPosition\n   * on all subSpans, except the last one, in reverse order.\n   * Also collect the payloads.\n   */\n  protected boolean shrinkToAfterShortestMatch() throws IOException {\n    Spans lastSubSpans = subSpans.get(subSpans.size() - 1);\n    matchStart = lastSubSpans.startPosition();\n    matchEnd = lastSubSpans.endPosition();\n\n    matchPayload.clear();\n    possibleMatchPayloads.clear();\n\n    if (lastSubSpans.isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(lastSubSpans.getPayload());\n    }\n\n    Collection<byte[]> possiblePayload = null;\n\n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.size() - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans.get(i);\n\n      if (prevSpans.isPayloadAvailable()) {\n        Collection<byte[]> payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList<>(payload.size());\n        possiblePayload.addAll(payload);\n      }\n\n      int prevStart = prevSpans.startPosition();\n      int prevEnd = prevSpans.endPosition();\n      while (true) { // prevSpans nextStartPosition until after (lastStart, lastEnd)\n        if (prevSpans.nextStartPosition() == NO_MORE_POSITIONS) {\n          oneExhaustedInCurrentDoc = true;\n          break; // Check remaining subSpans for match.\n        }\n        int ppStart = prevSpans.startPosition();\n        int ppEnd = prevSpans.endPosition();\n        if (ppEnd > lastStart) { // if overlapping spans\n          break; // Check remaining subSpans.\n        }\n        // prevSpans still before (lastStart, lastEnd)\n        prevStart = ppStart;\n        prevEnd = ppEnd;\n        if (prevSpans.isPayloadAvailable()) {\n          Collection<byte[]> payload = prevSpans.getPayload();\n          if (possiblePayload == null) {\n            possiblePayload = new ArrayList<>(payload.size());\n          } else {\n            possiblePayload.clear();\n          }\n          possiblePayload.addAll(payload);\n        }\n      }\n\n      if (possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n\n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that on return the first subSpans has nextStartPosition called.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n\n    boolean match = matchSlop <= allowedSlop;\n\n    if (match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fab172655716b96f7e42376116235017a922de3a","date":1427850611,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansPayloadOrdered#shrinkToAfterShortestMatch().mjava","pathOld":"/dev/null","sourceNew":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by using nextStartPosition\n   * on all subSpans, except the last one, in reverse order.\n   * Also collect the payloads.\n   */\n  protected boolean shrinkToAfterShortestMatch() throws IOException {\n    Spans lastSubSpans = subSpans.get(subSpans.size() - 1);\n    matchStart = lastSubSpans.startPosition();\n    matchEnd = lastSubSpans.endPosition();\n\n    matchPayload.clear();\n    possibleMatchPayloads.clear();\n\n    if (lastSubSpans.isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(lastSubSpans.getPayload());\n    }\n\n    Collection<byte[]> possiblePayload = null;\n\n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.size() - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans.get(i);\n\n      if (prevSpans.isPayloadAvailable()) {\n        Collection<byte[]> payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList<>(payload.size());\n        possiblePayload.addAll(payload);\n      }\n\n      int prevStart = prevSpans.startPosition();\n      int prevEnd = prevSpans.endPosition();\n      while (true) { // prevSpans nextStartPosition until after (lastStart, lastEnd)\n        if (prevSpans.nextStartPosition() == NO_MORE_POSITIONS) {\n          oneExhaustedInCurrentDoc = true;\n          break; // Check remaining subSpans for match.\n        }\n        int ppStart = prevSpans.startPosition();\n        int ppEnd = prevSpans.endPosition();\n        if (ppEnd > lastStart) { // if overlapping spans\n          break; // Check remaining subSpans.\n        }\n        // prevSpans still before (lastStart, lastEnd)\n        prevStart = ppStart;\n        prevEnd = ppEnd;\n        if (prevSpans.isPayloadAvailable()) {\n          Collection<byte[]> payload = prevSpans.getPayload();\n          if (possiblePayload == null) {\n            possiblePayload = new ArrayList<>(payload.size());\n          } else {\n            possiblePayload.clear();\n          }\n          possiblePayload.addAll(payload);\n        }\n      }\n\n      if (possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n\n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that on return the first subSpans has nextStartPosition called.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n\n    boolean match = matchSlop <= allowedSlop;\n\n    if (match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d1a832d7282403b4783b9435f19a5ba2e9dbdf7","date":1428071973,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansPayloadOrdered#shrinkToAfterShortestMatch().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansPayloadOrdered#shrinkToAfterShortestMatch().mjava","sourceNew":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by using nextStartPosition\n   * on all subSpans, except the last one, in reverse order.\n   * Also collect the payloads.\n   */\n  protected boolean shrinkToAfterShortestMatch() throws IOException {\n    Spans lastSubSpans = subSpans[subSpans.length - 1];\n    matchStart = lastSubSpans.startPosition();\n    matchEnd = lastSubSpans.endPosition();\n\n    matchPayload.clear();\n    possibleMatchPayloads.clear();\n\n    if (lastSubSpans.isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(lastSubSpans.getPayload());\n    }\n\n    Collection<byte[]> possiblePayload = null;\n\n    int matchSlop = 0;\n    int lastStart = matchStart;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n\n      if (prevSpans.isPayloadAvailable()) {\n        Collection<byte[]> payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList<>(payload.size());\n        possiblePayload.addAll(payload);\n      }\n\n      int prevStart = prevSpans.startPosition();\n      int prevEnd = prevSpans.endPosition();\n      while (true) { // prevSpans nextStartPosition until after (lastStart, lastEnd)\n        if (prevSpans.nextStartPosition() == NO_MORE_POSITIONS) {\n          oneExhaustedInCurrentDoc = true;\n          break; // Check remaining subSpans for match.\n        }\n        int ppStart = prevSpans.startPosition();\n        int ppEnd = prevSpans.endPosition();\n        if (ppEnd > lastStart) { // if overlapping spans\n          break; // Check remaining subSpans.\n        }\n        // prevSpans still before (lastStart, lastEnd)\n        prevStart = ppStart;\n        prevEnd = ppEnd;\n        if (prevSpans.isPayloadAvailable()) {\n          Collection<byte[]> payload = prevSpans.getPayload();\n          if (possiblePayload == null) {\n            possiblePayload = new ArrayList<>(payload.size());\n          } else {\n            possiblePayload.clear();\n          }\n          possiblePayload.addAll(payload);\n        }\n      }\n\n      if (possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n\n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that on return the first subSpans has nextStartPosition called.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n    }\n\n    boolean match = matchSlop <= allowedSlop;\n\n    if (match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","sourceOld":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by using nextStartPosition\n   * on all subSpans, except the last one, in reverse order.\n   * Also collect the payloads.\n   */\n  protected boolean shrinkToAfterShortestMatch() throws IOException {\n    Spans lastSubSpans = subSpans.get(subSpans.size() - 1);\n    matchStart = lastSubSpans.startPosition();\n    matchEnd = lastSubSpans.endPosition();\n\n    matchPayload.clear();\n    possibleMatchPayloads.clear();\n\n    if (lastSubSpans.isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(lastSubSpans.getPayload());\n    }\n\n    Collection<byte[]> possiblePayload = null;\n\n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.size() - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans.get(i);\n\n      if (prevSpans.isPayloadAvailable()) {\n        Collection<byte[]> payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList<>(payload.size());\n        possiblePayload.addAll(payload);\n      }\n\n      int prevStart = prevSpans.startPosition();\n      int prevEnd = prevSpans.endPosition();\n      while (true) { // prevSpans nextStartPosition until after (lastStart, lastEnd)\n        if (prevSpans.nextStartPosition() == NO_MORE_POSITIONS) {\n          oneExhaustedInCurrentDoc = true;\n          break; // Check remaining subSpans for match.\n        }\n        int ppStart = prevSpans.startPosition();\n        int ppEnd = prevSpans.endPosition();\n        if (ppEnd > lastStart) { // if overlapping spans\n          break; // Check remaining subSpans.\n        }\n        // prevSpans still before (lastStart, lastEnd)\n        prevStart = ppStart;\n        prevEnd = ppEnd;\n        if (prevSpans.isPayloadAvailable()) {\n          Collection<byte[]> payload = prevSpans.getPayload();\n          if (possiblePayload == null) {\n            possiblePayload = new ArrayList<>(payload.size());\n          } else {\n            possiblePayload.clear();\n          }\n          possiblePayload.addAll(payload);\n        }\n      }\n\n      if (possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n\n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that on return the first subSpans has nextStartPosition called.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n\n    boolean match = matchSlop <= allowedSlop;\n\n    if (match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","date":1428091986,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansPayloadOrdered#shrinkToAfterShortestMatch().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansPayloadOrdered#shrinkToAfterShortestMatch().mjava","sourceNew":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by using nextStartPosition\n   * on all subSpans, except the last one, in reverse order.\n   * Also collect the payloads.\n   */\n  protected boolean shrinkToAfterShortestMatch() throws IOException {\n    Spans lastSubSpans = subSpans[subSpans.length - 1];\n    matchStart = lastSubSpans.startPosition();\n    matchEnd = lastSubSpans.endPosition();\n\n    matchPayload.clear();\n    possibleMatchPayloads.clear();\n\n    if (lastSubSpans.isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(lastSubSpans.getPayload());\n    }\n\n    Collection<byte[]> possiblePayload = null;\n\n    int matchSlop = 0;\n    int lastStart = matchStart;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n\n      if (prevSpans.isPayloadAvailable()) {\n        Collection<byte[]> payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList<>(payload.size());\n        possiblePayload.addAll(payload);\n      }\n\n      int prevStart = prevSpans.startPosition();\n      int prevEnd = prevSpans.endPosition();\n      while (true) { // prevSpans nextStartPosition until after (lastStart, lastEnd)\n        if (prevSpans.nextStartPosition() == NO_MORE_POSITIONS) {\n          oneExhaustedInCurrentDoc = true;\n          break; // Check remaining subSpans for match.\n        }\n        int ppStart = prevSpans.startPosition();\n        int ppEnd = prevSpans.endPosition();\n        if (ppEnd > lastStart) { // if overlapping spans\n          break; // Check remaining subSpans.\n        }\n        // prevSpans still before (lastStart, lastEnd)\n        prevStart = ppStart;\n        prevEnd = ppEnd;\n        if (prevSpans.isPayloadAvailable()) {\n          Collection<byte[]> payload = prevSpans.getPayload();\n          if (possiblePayload == null) {\n            possiblePayload = new ArrayList<>(payload.size());\n          } else {\n            possiblePayload.clear();\n          }\n          possiblePayload.addAll(payload);\n        }\n      }\n\n      if (possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n\n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that on return the first subSpans has nextStartPosition called.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n    }\n\n    boolean match = matchSlop <= allowedSlop;\n\n    if (match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","sourceOld":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by using nextStartPosition\n   * on all subSpans, except the last one, in reverse order.\n   * Also collect the payloads.\n   */\n  protected boolean shrinkToAfterShortestMatch() throws IOException {\n    Spans lastSubSpans = subSpans.get(subSpans.size() - 1);\n    matchStart = lastSubSpans.startPosition();\n    matchEnd = lastSubSpans.endPosition();\n\n    matchPayload.clear();\n    possibleMatchPayloads.clear();\n\n    if (lastSubSpans.isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(lastSubSpans.getPayload());\n    }\n\n    Collection<byte[]> possiblePayload = null;\n\n    int matchSlop = 0;\n    int lastStart = matchStart;\n    int lastEnd = matchEnd;\n    for (int i = subSpans.size() - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans.get(i);\n\n      if (prevSpans.isPayloadAvailable()) {\n        Collection<byte[]> payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList<>(payload.size());\n        possiblePayload.addAll(payload);\n      }\n\n      int prevStart = prevSpans.startPosition();\n      int prevEnd = prevSpans.endPosition();\n      while (true) { // prevSpans nextStartPosition until after (lastStart, lastEnd)\n        if (prevSpans.nextStartPosition() == NO_MORE_POSITIONS) {\n          oneExhaustedInCurrentDoc = true;\n          break; // Check remaining subSpans for match.\n        }\n        int ppStart = prevSpans.startPosition();\n        int ppEnd = prevSpans.endPosition();\n        if (ppEnd > lastStart) { // if overlapping spans\n          break; // Check remaining subSpans.\n        }\n        // prevSpans still before (lastStart, lastEnd)\n        prevStart = ppStart;\n        prevEnd = ppEnd;\n        if (prevSpans.isPayloadAvailable()) {\n          Collection<byte[]> payload = prevSpans.getPayload();\n          if (possiblePayload == null) {\n            possiblePayload = new ArrayList<>(payload.size());\n          } else {\n            possiblePayload.clear();\n          }\n          possiblePayload.addAll(payload);\n        }\n      }\n\n      if (possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n\n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that on return the first subSpans has nextStartPosition called.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n      lastEnd = prevEnd;\n    }\n\n    boolean match = matchSlop <= allowedSlop;\n\n    if (match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2d530e71ed32ab23b34ca3fc72b080a554a40404","date":1432026158,"type":4,"author":"Alan Woodward","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/NearSpansPayloadOrdered#shrinkToAfterShortestMatch().mjava","sourceNew":null,"sourceOld":"  /** The subSpans are ordered in the same doc, so there is a possible match.\n   * Compute the slop while making the match as short as possible by using nextStartPosition\n   * on all subSpans, except the last one, in reverse order.\n   * Also collect the payloads.\n   */\n  protected boolean shrinkToAfterShortestMatch() throws IOException {\n    Spans lastSubSpans = subSpans[subSpans.length - 1];\n    matchStart = lastSubSpans.startPosition();\n    matchEnd = lastSubSpans.endPosition();\n\n    matchPayload.clear();\n    possibleMatchPayloads.clear();\n\n    if (lastSubSpans.isPayloadAvailable()) {\n      possibleMatchPayloads.addAll(lastSubSpans.getPayload());\n    }\n\n    Collection<byte[]> possiblePayload = null;\n\n    int matchSlop = 0;\n    int lastStart = matchStart;\n    for (int i = subSpans.length - 2; i >= 0; i--) {\n      Spans prevSpans = subSpans[i];\n\n      if (prevSpans.isPayloadAvailable()) {\n        Collection<byte[]> payload = prevSpans.getPayload();\n        possiblePayload = new ArrayList<>(payload.size());\n        possiblePayload.addAll(payload);\n      }\n\n      int prevStart = prevSpans.startPosition();\n      int prevEnd = prevSpans.endPosition();\n      while (true) { // prevSpans nextStartPosition until after (lastStart, lastEnd)\n        if (prevSpans.nextStartPosition() == NO_MORE_POSITIONS) {\n          oneExhaustedInCurrentDoc = true;\n          break; // Check remaining subSpans for match.\n        }\n        int ppStart = prevSpans.startPosition();\n        int ppEnd = prevSpans.endPosition();\n        if (ppEnd > lastStart) { // if overlapping spans\n          break; // Check remaining subSpans.\n        }\n        // prevSpans still before (lastStart, lastEnd)\n        prevStart = ppStart;\n        prevEnd = ppEnd;\n        if (prevSpans.isPayloadAvailable()) {\n          Collection<byte[]> payload = prevSpans.getPayload();\n          if (possiblePayload == null) {\n            possiblePayload = new ArrayList<>(payload.size());\n          } else {\n            possiblePayload.clear();\n          }\n          possiblePayload.addAll(payload);\n        }\n      }\n\n      if (possiblePayload != null) {\n        possibleMatchPayloads.addAll(possiblePayload);\n      }\n\n      assert prevStart <= matchStart;\n      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.\n        matchSlop += (matchStart - prevEnd);\n      }\n\n      /* Do not break on (matchSlop > allowedSlop) here to make sure\n       * that on return the first subSpans has nextStartPosition called.\n       */\n      matchStart = prevStart;\n      lastStart = prevStart;\n    }\n\n    boolean match = matchSlop <= allowedSlop;\n\n    if (match && possibleMatchPayloads.size() > 0) {\n      matchPayload.addAll(possibleMatchPayloads);\n    }\n\n    return match; // ordered and allowed slop\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3d1a832d7282403b4783b9435f19a5ba2e9dbdf7":["30de45e50bdc1a79a6797f34dca6271c8866cb6e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":["fab172655716b96f7e42376116235017a922de3a","3d1a832d7282403b4783b9435f19a5ba2e9dbdf7"],"2d530e71ed32ab23b34ca3fc72b080a554a40404":["3d1a832d7282403b4783b9435f19a5ba2e9dbdf7"],"30de45e50bdc1a79a6797f34dca6271c8866cb6e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fab172655716b96f7e42376116235017a922de3a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","30de45e50bdc1a79a6797f34dca6271c8866cb6e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2d530e71ed32ab23b34ca3fc72b080a554a40404"]},"commit2Childs":{"3d1a832d7282403b4783b9435f19a5ba2e9dbdf7":["6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","2d530e71ed32ab23b34ca3fc72b080a554a40404"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["30de45e50bdc1a79a6797f34dca6271c8866cb6e","fab172655716b96f7e42376116235017a922de3a"],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":[],"2d530e71ed32ab23b34ca3fc72b080a554a40404":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"30de45e50bdc1a79a6797f34dca6271c8866cb6e":["3d1a832d7282403b4783b9435f19a5ba2e9dbdf7","fab172655716b96f7e42376116235017a922de3a"],"fab172655716b96f7e42376116235017a922de3a":["6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}