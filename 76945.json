{"path":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      Directory dir = newFSDirectory(oldIndxeDir);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random)));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      Directory dir = newFSDirectory(oldIndxeDir);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random)));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"21311a17d5c0c14b384b0fe7946ffb3997855720","date":1332342305,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      MockDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random)));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      Directory dir = newFSDirectory(oldIndxeDir);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random)));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":["d19974432be9aed28ee7dca73bdf01d139e763a9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      MockDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      MockDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random)));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","date":1338430031,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      MockDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      MockDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = IndexReader.open(dir);\n        fail(\"IndexReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e2d1edb0d4b63db0ffa514a529fb559609dbcd2","date":1341667852,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      MockDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, \"UTF-8\"));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(\"UTF-8\").contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      MockDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2acf500f78aa12b92e371fd89c719291986b6b90","date":1341846236,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      MockDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, \"UTF-8\"));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(\"UTF-8\").contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      MockDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46d8ada1fff8d18cb197c38c7983225162599948","date":1341853497,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      MockDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, \"UTF-8\"));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(\"UTF-8\").contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      MockDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      MockDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, \"UTF-8\"));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(\"UTF-8\").contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      MockDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d19974432be9aed28ee7dca73bdf01d139e763a9","date":1342822166,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, \"UTF-8\"));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(\"UTF-8\").contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      MockDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, \"UTF-8\"));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(\"UTF-8\").contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":["21311a17d5c0c14b384b0fe7946ffb3997855720"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, \"UTF-8\"));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(\"UTF-8\").contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      MockDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, \"UTF-8\"));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(\"UTF-8\").contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, \"UTF-8\"));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(\"UTF-8\").contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      MockDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, \"UTF-8\"));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(\"UTF-8\").contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = TestUtil.getTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, \"UTF-8\"));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(\"UTF-8\").contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);\n      _TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, \"UTF-8\"));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(\"UTF-8\").contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      _TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0d579490a72f2e6297eaa648940611234c57cf1","date":1395917140,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = TestUtil.createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, \"UTF-8\"));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(\"UTF-8\").contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = TestUtil.getTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, \"UTF-8\"));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(\"UTF-8\").contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7d89d7e4e5101347833eea558851bf4209218619","date":1396265641,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = TestUtil.getTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = TestUtil.getTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, \"UTF-8\"));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(\"UTF-8\").contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = TestUtil.createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rm(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = TestUtil.createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, \"UTF-8\"));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(\"UTF-8\").contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":["cbc3688252d4a8045d69a164236b2cf87b721f17","cbc3688252d4a8045d69a164236b2cf87b721f17"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c","date":1396633078,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rm(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = TestUtil.createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rm(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a0f5bb79c600763ffe7b8141df59a3169d31e48","date":1396689440,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rm(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = TestUtil.getTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rmDir(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.shutdown(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rm(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.close(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rm(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.shutdown(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rm(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(\n          TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.shutdown(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rm(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rm(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          writer.shutdown(false);\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rm(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cc45c615dbb82bf79d5f9550286098367874fbf","date":1409571423,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rm(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rm(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"402ad3ddc9da7b70da1b167667a60ece6a1381fb","date":1409656478,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testUnsupportedOldIndexes().mjava","sourceNew":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rm(oldIndxeDir);\n    }\n  }\n\n","sourceOld":"  /** This test checks that *only* IndexFormatTooOldExceptions are thrown when you open and operate on too old indexes! */\n  public void testUnsupportedOldIndexes() throws Exception {\n    for(int i=0;i<unsupportedNames.length;i++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: index \" + unsupportedNames[i]);\n      }\n      File oldIndxeDir = createTempDir(unsupportedNames[i]);\n      TestUtil.unzip(getDataFile(\"unsupported.\" + unsupportedNames[i] + \".zip\"), oldIndxeDir);\n      BaseDirectoryWrapper dir = newFSDirectory(oldIndxeDir);\n      // don't checkindex, these are intentionally not supported\n      dir.setCheckIndexOnClose(false);\n\n      IndexReader reader = null;\n      IndexWriter writer = null;\n      try {\n        reader = DirectoryReader.open(dir);\n        fail(\"DirectoryReader.open should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n      } finally {\n        if (reader != null) reader.close();\n        reader = null;\n      }\n\n      try {\n        writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())).setCommitOnClose(false));\n        fail(\"IndexWriter creation should not pass for \"+unsupportedNames[i]);\n      } catch (IndexFormatTooOldException e) {\n        // pass\n        if (VERBOSE) {\n          System.out.println(\"TEST: got expected exc:\");\n          e.printStackTrace(System.out);\n        }\n        // Make sure exc message includes a path=\n        assertTrue(\"got exc message: \" + e.getMessage(), e.getMessage().indexOf(\"path=\\\"\") != -1);\n      } finally {\n        // we should fail to open IW, and so it should be null when we get here.\n        // However, if the test fails (i.e., IW did not fail on open), we need\n        // to close IW. However, if merges are run, IW may throw\n        // IndexFormatTooOldException, and we don't want to mask the fail()\n        // above, so close without waiting for merges.\n        if (writer != null) {\n          try {\n            writer.commit();\n          } finally {\n            writer.close();\n          }\n        }\n        writer = null;\n      }\n      \n      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n      CheckIndex checker = new CheckIndex(dir);\n      checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));\n      CheckIndex.Status indexStatus = checker.checkIndex();\n      assertFalse(indexStatus.clean);\n      assertTrue(bos.toString(IOUtils.UTF_8).contains(IndexFormatTooOldException.class.getName()));\n\n      dir.close();\n      TestUtil.rm(oldIndxeDir);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["d0d579490a72f2e6297eaa648940611234c57cf1","7d89d7e4e5101347833eea558851bf4209218619"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["7d89d7e4e5101347833eea558851bf4209218619","a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"6613659748fe4411a7dcf85266e55db1f95f7315":["d19974432be9aed28ee7dca73bdf01d139e763a9"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1e2d1edb0d4b63db0ffa514a529fb559609dbcd2":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"2acf500f78aa12b92e371fd89c719291986b6b90":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","1e2d1edb0d4b63db0ffa514a529fb559609dbcd2"],"7d89d7e4e5101347833eea558851bf4209218619":["6613659748fe4411a7dcf85266e55db1f95f7315"],"d0d579490a72f2e6297eaa648940611234c57cf1":["6613659748fe4411a7dcf85266e55db1f95f7315"],"21311a17d5c0c14b384b0fe7946ffb3997855720":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["d0ef034a4f10871667ae75181537775ddcf8ade4","4cc45c615dbb82bf79d5f9550286098367874fbf"],"46d8ada1fff8d18cb197c38c7983225162599948":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","2acf500f78aa12b92e371fd89c719291986b6b90"],"aba371508186796cc6151d8223a5b4e16d02e26e":["46d8ada1fff8d18cb197c38c7983225162599948","d19974432be9aed28ee7dca73bdf01d139e763a9"],"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"d19974432be9aed28ee7dca73bdf01d139e763a9":["2acf500f78aa12b92e371fd89c719291986b6b90"],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["5eb2511ababf862ea11e10761c70ee560cd84510"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","2acf500f78aa12b92e371fd89c719291986b6b90"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4cc45c615dbb82bf79d5f9550286098367874fbf":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["fe33227f6805edab2036cbb80645cc4e2d1fa424","d19974432be9aed28ee7dca73bdf01d139e763a9"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["21311a17d5c0c14b384b0fe7946ffb3997855720"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":["a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"6613659748fe4411a7dcf85266e55db1f95f7315":["7d89d7e4e5101347833eea558851bf4209218619","d0d579490a72f2e6297eaa648940611234c57cf1"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["21311a17d5c0c14b384b0fe7946ffb3997855720"],"1e2d1edb0d4b63db0ffa514a529fb559609dbcd2":["2acf500f78aa12b92e371fd89c719291986b6b90"],"2acf500f78aa12b92e371fd89c719291986b6b90":["46d8ada1fff8d18cb197c38c7983225162599948","d19974432be9aed28ee7dca73bdf01d139e763a9","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"d0d579490a72f2e6297eaa648940611234c57cf1":["5eb2511ababf862ea11e10761c70ee560cd84510"],"7d89d7e4e5101347833eea558851bf4209218619":["5eb2511ababf862ea11e10761c70ee560cd84510","2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"21311a17d5c0c14b384b0fe7946ffb3997855720":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"46d8ada1fff8d18cb197c38c7983225162599948":["aba371508186796cc6151d8223a5b4e16d02e26e"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["1e2d1edb0d4b63db0ffa514a529fb559609dbcd2","2acf500f78aa12b92e371fd89c719291986b6b90","46d8ada1fff8d18cb197c38c7983225162599948","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"d19974432be9aed28ee7dca73bdf01d139e763a9":["6613659748fe4411a7dcf85266e55db1f95f7315","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"4cc45c615dbb82bf79d5f9550286098367874fbf":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["402ad3ddc9da7b70da1b167667a60ece6a1381fb","4cc45c615dbb82bf79d5f9550286098367874fbf"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":[],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}