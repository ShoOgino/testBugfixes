{"path":"solr/src/java/org/apache/solr/analysis/CommonGramsQueryFilter#process(Token).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/analysis/CommonGramsQueryFilter#process(Token).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Output bigrams whenever possible to optimize queries. Only output unigrams\n   * when they are not a member of a bigram. Example:\n   * <ul>\n   * <li>input: \"the rain in spain falls mainly\"\n   * <li>output:\"the-rain\", \"rain-in\" ,\"in-spain\", \"falls\", \"mainly\"\n   */\n\n  public Token process(Token token) throws IOException {\n    Token next = peek(1);\n    /*\n     * Deal with last token (next=null when current token is the last word) Last\n     * token will be a unigram. If previous token was a bigram, then we already\n     * output the last token as part of the unigram and should not additionally\n     * output the unigram. <p> Example: If the end of the input to the\n     * CommonGramsFilter is \"...the plain\" <ul> <li>current token = \"plain\"</li>\n     * <li>next token = null</li> <li>previous token = \"the-plain\" (bigram)</li>\n     * <li> Since the word \"plain\" was already output as part of the bigram we\n     * don't output it.</li> </ul> Example: If the end of the input to the\n     * CommonGramsFilter is \"falls mainly\" <ul> <li>current token =\n     * \"mainly\"</li> <li>next token = null</li> <li>previous token = \"falls\"\n     * (unigram)</li> <li>Since we haven't yet output the current token, we\n     * output it</li> </ul>\n     */\n\n    // Deal with special case of last token\n    if (next == null) {\n      if (prev == null) {\n        // This is the first and only token i.e. one word query\n        return token;\n      }\n      if (prev != null && prev.type() != \"gram\") {\n        // If previous token was a unigram, output the current token\n        return token;\n      } else {\n        // If previous token was a bigram, we already output it and this token\n        // was output as part of the bigram so we are done.\n        return null;\n      }\n    }\n\n    /*\n     * Possible cases are: |token |next 1|word |gram 2|word |word The\n     * CommonGramsFilter we are wrapping always outputs the unigram word prior\n     * to outputting an optional bigram: \"the sound of\" gets output as |\"the\",\n     * \"the_sound\"|\"sound\", \"sound_of\" For case 1 we consume the gram from the\n     * input stream and output it rather than the current token This means that\n     * the call to super.next() which reads a token from input and passes it on\n     * to this process method will always get a token of type word\n     */\n    if (next != null && next.type() == \"gram\") {\n      // consume \"next\" token from list and output it\n      token = read();\n      // use this to clone the token because clone requires all these args but\n      // won't take the token.type\n      // see\n      // http://hudson.zones.apache.org/hudson/job/Lucene-trunk/javadoc//all/org/apache/lucene/analysis/Token.html\n      prev.reinit(token.termBuffer(), 0, token.termLength(), token\n          .startOffset(), token.endOffset(), token.type());\n      token.setPositionIncrement(1);\n      return token;\n    }\n\n    // if the next token is not a bigram, then output the token\n    // see note above regarding this method of copying token to prev\n    prev.reinit(token.termBuffer(), 0, token.termLength(), token.startOffset(),\n        token.endOffset(), token.type());\n    assert token.type() == \"word\";\n    return token;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/analysis/CommonGramsQueryFilter#process(Token).mjava","sourceNew":null,"sourceOld":"  /**\n   * Output bigrams whenever possible to optimize queries. Only output unigrams\n   * when they are not a member of a bigram. Example:\n   * <ul>\n   * <li>input: \"the rain in spain falls mainly\"\n   * <li>output:\"the-rain\", \"rain-in\" ,\"in-spain\", \"falls\", \"mainly\"\n   */\n\n  public Token process(Token token) throws IOException {\n    Token next = peek(1);\n    /*\n     * Deal with last token (next=null when current token is the last word) Last\n     * token will be a unigram. If previous token was a bigram, then we already\n     * output the last token as part of the unigram and should not additionally\n     * output the unigram. <p> Example: If the end of the input to the\n     * CommonGramsFilter is \"...the plain\" <ul> <li>current token = \"plain\"</li>\n     * <li>next token = null</li> <li>previous token = \"the-plain\" (bigram)</li>\n     * <li> Since the word \"plain\" was already output as part of the bigram we\n     * don't output it.</li> </ul> Example: If the end of the input to the\n     * CommonGramsFilter is \"falls mainly\" <ul> <li>current token =\n     * \"mainly\"</li> <li>next token = null</li> <li>previous token = \"falls\"\n     * (unigram)</li> <li>Since we haven't yet output the current token, we\n     * output it</li> </ul>\n     */\n\n    // Deal with special case of last token\n    if (next == null) {\n      if (prev == null) {\n        // This is the first and only token i.e. one word query\n        return token;\n      }\n      if (prev != null && prev.type() != \"gram\") {\n        // If previous token was a unigram, output the current token\n        return token;\n      } else {\n        // If previous token was a bigram, we already output it and this token\n        // was output as part of the bigram so we are done.\n        return null;\n      }\n    }\n\n    /*\n     * Possible cases are: |token |next 1|word |gram 2|word |word The\n     * CommonGramsFilter we are wrapping always outputs the unigram word prior\n     * to outputting an optional bigram: \"the sound of\" gets output as |\"the\",\n     * \"the_sound\"|\"sound\", \"sound_of\" For case 1 we consume the gram from the\n     * input stream and output it rather than the current token This means that\n     * the call to super.next() which reads a token from input and passes it on\n     * to this process method will always get a token of type word\n     */\n    if (next != null && next.type() == \"gram\") {\n      // consume \"next\" token from list and output it\n      token = read();\n      // use this to clone the token because clone requires all these args but\n      // won't take the token.type\n      // see\n      // http://hudson.zones.apache.org/hudson/job/Lucene-trunk/javadoc//all/org/apache/lucene/analysis/Token.html\n      prev.reinit(token.termBuffer(), 0, token.termLength(), token\n          .startOffset(), token.endOffset(), token.type());\n      token.setPositionIncrement(1);\n      return token;\n    }\n\n    // if the next token is not a bigram, then output the token\n    // see note above regarding this method of copying token to prev\n    prev.reinit(token.termBuffer(), 0, token.termLength(), token.startOffset(),\n        token.endOffset(), token.type());\n    assert token.type() == \"word\";\n    return token;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"]},"commit2Childs":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}