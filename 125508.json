{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TimeDifferencingEvaluator#doWork(Object...).mjava","commits":[{"id":"c263c97cbb80b4388128937ff5a5659f1abaccd8","date":1510337741,"type":0,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TimeDifferencingEvaluator#doWork(Object...).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Object doWork(Object... values) throws IOException {\n    if (!(1 == values.length ||  values.length == 2)){\n      throw new IOException(String.format(Locale.ROOT,\"%s(...) only works with 1 or 2 values but %d were provided\", constructingFactory.getFunctionName(getClass()), values.length));\n    }\n    List<BigDecimal> timeseriesValues = (List<BigDecimal> )values[0];\n    Number lagValue = 1;\n\n    if(1 == values.length) {\n      if (!(timeseriesValues instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the first value, expecting a List\", toExpression(constructingFactory), values[0].getClass().getSimpleName()));\n      }\n      if (!(timeseriesValues.size() > 1)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found list size of %s for the first value, expecting a List of size > 0.\", toExpression(constructingFactory), timeseriesValues.size()));\n      }\n    }\n    if(2 == values.length) {\n      lagValue = (Number) values[1];\n      if(!(lagValue instanceof Number)){\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a Number\", toExpression(constructingFactory), values[1].getClass().getSimpleName()));\n      }\n      if (lagValue.intValue() >  timeseriesValues.size()) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found a lag size of %s for the second value, the first value has a List size of %s, expecting a lag value less than the List size\", toExpression(constructingFactory), lagValue.intValue(), timeseriesValues.size()));\n      }\n    }\n    final int lag = lagValue.intValue();\n    return IntStream.range(lag, timeseriesValues.size())\n        .mapToObj(n -> (timeseriesValues.get(n).doubleValue()-timeseriesValues.get(n-lag).doubleValue()))\n        .collect(Collectors.toList());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bbe7f5e9d90420c7fc8cd235dd8fb33fa9befe54","date":1512439781,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TimeDifferencingEvaluator#doWork(Object...).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TimeDifferencingEvaluator#doWork(Object...).mjava","sourceNew":"  @Override\n  public Object doWork(Object... values) throws IOException {\n    if (!(1 == values.length ||  values.length == 2)){\n      throw new IOException(String.format(Locale.ROOT,\"%s(...) only works with 1 or 2 values but %d were provided\", constructingFactory.getFunctionName(getClass()), values.length));\n    }\n    List<Number> timeseriesValues = (List<Number> )values[0];\n    Number lagValue = 1;\n\n    if(1 == values.length) {\n      if (!(timeseriesValues instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the first value, expecting a List\", toExpression(constructingFactory), values[0].getClass().getSimpleName()));\n      }\n      if (!(timeseriesValues.size() > 1)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found list size of %s for the first value, expecting a List of size > 0.\", toExpression(constructingFactory), timeseriesValues.size()));\n      }\n    }\n    if(2 == values.length) {\n      lagValue = (Number) values[1];\n      if(!(lagValue instanceof Number)){\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a Number\", toExpression(constructingFactory), values[1].getClass().getSimpleName()));\n      }\n      if (lagValue.intValue() >  timeseriesValues.size()) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found a lag size of %s for the second value, the first value has a List size of %s, expecting a lag value less than the List size\", toExpression(constructingFactory), lagValue.intValue(), timeseriesValues.size()));\n      }\n    }\n    final int lag = lagValue.intValue();\n    return IntStream.range(lag, timeseriesValues.size())\n        .mapToObj(n -> (timeseriesValues.get(n).doubleValue()-timeseriesValues.get(n-lag).doubleValue()))\n        .collect(Collectors.toList());\n  }\n\n","sourceOld":"  @Override\n  public Object doWork(Object... values) throws IOException {\n    if (!(1 == values.length ||  values.length == 2)){\n      throw new IOException(String.format(Locale.ROOT,\"%s(...) only works with 1 or 2 values but %d were provided\", constructingFactory.getFunctionName(getClass()), values.length));\n    }\n    List<BigDecimal> timeseriesValues = (List<BigDecimal> )values[0];\n    Number lagValue = 1;\n\n    if(1 == values.length) {\n      if (!(timeseriesValues instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the first value, expecting a List\", toExpression(constructingFactory), values[0].getClass().getSimpleName()));\n      }\n      if (!(timeseriesValues.size() > 1)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found list size of %s for the first value, expecting a List of size > 0.\", toExpression(constructingFactory), timeseriesValues.size()));\n      }\n    }\n    if(2 == values.length) {\n      lagValue = (Number) values[1];\n      if(!(lagValue instanceof Number)){\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a Number\", toExpression(constructingFactory), values[1].getClass().getSimpleName()));\n      }\n      if (lagValue.intValue() >  timeseriesValues.size()) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found a lag size of %s for the second value, the first value has a List size of %s, expecting a lag value less than the List size\", toExpression(constructingFactory), lagValue.intValue(), timeseriesValues.size()));\n      }\n    }\n    final int lag = lagValue.intValue();\n    return IntStream.range(lag, timeseriesValues.size())\n        .mapToObj(n -> (timeseriesValues.get(n).doubleValue()-timeseriesValues.get(n-lag).doubleValue()))\n        .collect(Collectors.toList());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be97db2343d6782775c916433312214085670d50","date":1589464325,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TimeDifferencingEvaluator#doWork(Object...).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TimeDifferencingEvaluator#doWork(Object...).mjava","sourceNew":"  @Override\n  public Object doWork(Object... values) throws IOException {\n    if (!(1 == values.length || values.length == 2)) {\n      throw new IOException(String.format(Locale.ROOT, \"%s(...) only works with 1 or 2 values but %d were provided\", constructingFactory.getFunctionName(getClass()), values.length));\n    }\n    if (values[0] instanceof List) {\n      List<Number> timeseriesValues = (List<Number>) values[0];\n      Number lagValue = 1;\n\n      if (1 == values.length) {\n        if (!(timeseriesValues instanceof List<?>)) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the first value, expecting a List\", toExpression(constructingFactory), values[0].getClass().getSimpleName()));\n        }\n        if (!(timeseriesValues.size() > 1)) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found list size of %s for the first value, expecting a List of size > 0.\", toExpression(constructingFactory), timeseriesValues.size()));\n        }\n      }\n      if (2 == values.length) {\n        lagValue = (Number) values[1];\n        if (!(lagValue instanceof Number)) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a Number\", toExpression(constructingFactory), values[1].getClass().getSimpleName()));\n        }\n        if (lagValue.intValue() > timeseriesValues.size()) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found a lag size of %s for the second value, the first value has a List size of %s, expecting a lag value less than the List size\", toExpression(constructingFactory), lagValue.intValue(), timeseriesValues.size()));\n        }\n      }\n      final int lag = lagValue.intValue();\n      return IntStream.range(lag, timeseriesValues.size())\n          .mapToObj(n -> (timeseriesValues.get(n).doubleValue() - timeseriesValues.get(n - lag).doubleValue()))\n          .collect(Collectors.toList());\n    } else if(values[0] instanceof Matrix) {\n\n      //Diff each row of the matrix\n\n      Matrix matrix = (Matrix)values[0];\n      double[][] data = matrix.getData();\n      double[][] diffedData = new double[data.length][];\n      Number lagValue = 1;\n\n      if (2 == values.length) {\n        lagValue = (Number) values[1];\n        if (!(lagValue instanceof Number)) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a Number\", toExpression(constructingFactory), values[1].getClass().getSimpleName()));\n        }\n      }\n\n      int lag = lagValue.intValue();\n\n      for(int i=0; i<data.length; i++) {\n        double[] row = data[i];\n        List<Double> timeseriesValues = new ArrayList(row.length);\n        for(double d : row) {\n          timeseriesValues.add(d);\n        }\n\n        List<Number> diffedList = IntStream.range(lag, timeseriesValues.size())\n            .mapToObj(n -> (timeseriesValues.get(n).doubleValue() - timeseriesValues.get(n - lag).doubleValue()))\n            .collect(Collectors.toList());\n        double[] diffedRow = new double[diffedList.size()];\n        for(int r=0; r<diffedList.size(); r++) {\n          diffedRow[r] = diffedList.get(r).doubleValue();\n        }\n        diffedData[i] = diffedRow;\n      }\n\n      Matrix diffedMatrix = new Matrix(diffedData);\n      diffedMatrix.setRowLabels(matrix.getRowLabels());\n      List<String> columns = matrix.getColumnLabels();\n      if(columns != null) {\n        List<String> newColumns = new ArrayList(columns.size() - lag);\n\n        for (int i = lag; i < columns.size(); i++) {\n          newColumns.add(columns.get(i));\n        }\n\n        diffedMatrix.setColumnLabels(newColumns);\n      }\n      return diffedMatrix;\n\n    } else {\n      throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - first parameter must be list of matrix\", toExpression(constructingFactory)));\n    }\n  }\n\n","sourceOld":"  @Override\n  public Object doWork(Object... values) throws IOException {\n    if (!(1 == values.length ||  values.length == 2)){\n      throw new IOException(String.format(Locale.ROOT,\"%s(...) only works with 1 or 2 values but %d were provided\", constructingFactory.getFunctionName(getClass()), values.length));\n    }\n    List<Number> timeseriesValues = (List<Number> )values[0];\n    Number lagValue = 1;\n\n    if(1 == values.length) {\n      if (!(timeseriesValues instanceof List<?>)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the first value, expecting a List\", toExpression(constructingFactory), values[0].getClass().getSimpleName()));\n      }\n      if (!(timeseriesValues.size() > 1)) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found list size of %s for the first value, expecting a List of size > 0.\", toExpression(constructingFactory), timeseriesValues.size()));\n      }\n    }\n    if(2 == values.length) {\n      lagValue = (Number) values[1];\n      if(!(lagValue instanceof Number)){\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a Number\", toExpression(constructingFactory), values[1].getClass().getSimpleName()));\n      }\n      if (lagValue.intValue() >  timeseriesValues.size()) {\n        throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found a lag size of %s for the second value, the first value has a List size of %s, expecting a lag value less than the List size\", toExpression(constructingFactory), lagValue.intValue(), timeseriesValues.size()));\n      }\n    }\n    final int lag = lagValue.intValue();\n    return IntStream.range(lag, timeseriesValues.size())\n        .mapToObj(n -> (timeseriesValues.get(n).doubleValue()-timeseriesValues.get(n-lag).doubleValue()))\n        .collect(Collectors.toList());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885","date":1591579911,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TimeDifferencingEvaluator#doWork(Object...).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/TimeDifferencingEvaluator#doWork(Object...).mjava","sourceNew":"  @Override\n  public Object doWork(Object... values) throws IOException {\n    if (!(1 == values.length || values.length == 2)) {\n      throw new IOException(String.format(Locale.ROOT, \"%s(...) only works with 1 or 2 values but %d were provided\", constructingFactory.getFunctionName(getClass()), values.length));\n    }\n    if (values[0] instanceof List) {\n      @SuppressWarnings({\"unchecked\"})\n      List<Number> timeseriesValues = (List<Number>) values[0];\n      Number lagValue = 1;\n\n      if (1 == values.length) {\n        if (!(timeseriesValues instanceof List<?>)) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the first value, expecting a List\", toExpression(constructingFactory), values[0].getClass().getSimpleName()));\n        }\n        if (!(timeseriesValues.size() > 1)) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found list size of %s for the first value, expecting a List of size > 0.\", toExpression(constructingFactory), timeseriesValues.size()));\n        }\n      }\n      if (2 == values.length) {\n        lagValue = (Number) values[1];\n        if (!(lagValue instanceof Number)) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a Number\", toExpression(constructingFactory), values[1].getClass().getSimpleName()));\n        }\n        if (lagValue.intValue() > timeseriesValues.size()) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found a lag size of %s for the second value, the first value has a List size of %s, expecting a lag value less than the List size\", toExpression(constructingFactory), lagValue.intValue(), timeseriesValues.size()));\n        }\n      }\n      final int lag = lagValue.intValue();\n      return IntStream.range(lag, timeseriesValues.size())\n          .mapToObj(n -> (timeseriesValues.get(n).doubleValue() - timeseriesValues.get(n - lag).doubleValue()))\n          .collect(Collectors.toList());\n    } else if(values[0] instanceof Matrix) {\n\n      //Diff each row of the matrix\n\n      Matrix matrix = (Matrix)values[0];\n      double[][] data = matrix.getData();\n      double[][] diffedData = new double[data.length][];\n      Number lagValue = 1;\n\n      if (2 == values.length) {\n        lagValue = (Number) values[1];\n        if (!(lagValue instanceof Number)) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a Number\", toExpression(constructingFactory), values[1].getClass().getSimpleName()));\n        }\n      }\n\n      int lag = lagValue.intValue();\n\n      for(int i=0; i<data.length; i++) {\n        double[] row = data[i];\n        List<Double> timeseriesValues = new ArrayList<>(row.length);\n        for(double d : row) {\n          timeseriesValues.add(d);\n        }\n\n        List<Number> diffedList = IntStream.range(lag, timeseriesValues.size())\n            .mapToObj(n -> (timeseriesValues.get(n).doubleValue() - timeseriesValues.get(n - lag).doubleValue()))\n            .collect(Collectors.toList());\n        double[] diffedRow = new double[diffedList.size()];\n        for(int r=0; r<diffedList.size(); r++) {\n          diffedRow[r] = diffedList.get(r).doubleValue();\n        }\n        diffedData[i] = diffedRow;\n      }\n\n      Matrix diffedMatrix = new Matrix(diffedData);\n      diffedMatrix.setRowLabels(matrix.getRowLabels());\n      List<String> columns = matrix.getColumnLabels();\n      if(columns != null) {\n        List<String> newColumns = new ArrayList<>(columns.size() - lag);\n\n        for (int i = lag; i < columns.size(); i++) {\n          newColumns.add(columns.get(i));\n        }\n\n        diffedMatrix.setColumnLabels(newColumns);\n      }\n      return diffedMatrix;\n\n    } else {\n      throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - first parameter must be list of matrix\", toExpression(constructingFactory)));\n    }\n  }\n\n","sourceOld":"  @Override\n  public Object doWork(Object... values) throws IOException {\n    if (!(1 == values.length || values.length == 2)) {\n      throw new IOException(String.format(Locale.ROOT, \"%s(...) only works with 1 or 2 values but %d were provided\", constructingFactory.getFunctionName(getClass()), values.length));\n    }\n    if (values[0] instanceof List) {\n      List<Number> timeseriesValues = (List<Number>) values[0];\n      Number lagValue = 1;\n\n      if (1 == values.length) {\n        if (!(timeseriesValues instanceof List<?>)) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the first value, expecting a List\", toExpression(constructingFactory), values[0].getClass().getSimpleName()));\n        }\n        if (!(timeseriesValues.size() > 1)) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found list size of %s for the first value, expecting a List of size > 0.\", toExpression(constructingFactory), timeseriesValues.size()));\n        }\n      }\n      if (2 == values.length) {\n        lagValue = (Number) values[1];\n        if (!(lagValue instanceof Number)) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a Number\", toExpression(constructingFactory), values[1].getClass().getSimpleName()));\n        }\n        if (lagValue.intValue() > timeseriesValues.size()) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found a lag size of %s for the second value, the first value has a List size of %s, expecting a lag value less than the List size\", toExpression(constructingFactory), lagValue.intValue(), timeseriesValues.size()));\n        }\n      }\n      final int lag = lagValue.intValue();\n      return IntStream.range(lag, timeseriesValues.size())\n          .mapToObj(n -> (timeseriesValues.get(n).doubleValue() - timeseriesValues.get(n - lag).doubleValue()))\n          .collect(Collectors.toList());\n    } else if(values[0] instanceof Matrix) {\n\n      //Diff each row of the matrix\n\n      Matrix matrix = (Matrix)values[0];\n      double[][] data = matrix.getData();\n      double[][] diffedData = new double[data.length][];\n      Number lagValue = 1;\n\n      if (2 == values.length) {\n        lagValue = (Number) values[1];\n        if (!(lagValue instanceof Number)) {\n          throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - found type %s for the second value, expecting a Number\", toExpression(constructingFactory), values[1].getClass().getSimpleName()));\n        }\n      }\n\n      int lag = lagValue.intValue();\n\n      for(int i=0; i<data.length; i++) {\n        double[] row = data[i];\n        List<Double> timeseriesValues = new ArrayList(row.length);\n        for(double d : row) {\n          timeseriesValues.add(d);\n        }\n\n        List<Number> diffedList = IntStream.range(lag, timeseriesValues.size())\n            .mapToObj(n -> (timeseriesValues.get(n).doubleValue() - timeseriesValues.get(n - lag).doubleValue()))\n            .collect(Collectors.toList());\n        double[] diffedRow = new double[diffedList.size()];\n        for(int r=0; r<diffedList.size(); r++) {\n          diffedRow[r] = diffedList.get(r).doubleValue();\n        }\n        diffedData[i] = diffedRow;\n      }\n\n      Matrix diffedMatrix = new Matrix(diffedData);\n      diffedMatrix.setRowLabels(matrix.getRowLabels());\n      List<String> columns = matrix.getColumnLabels();\n      if(columns != null) {\n        List<String> newColumns = new ArrayList(columns.size() - lag);\n\n        for (int i = lag; i < columns.size(); i++) {\n          newColumns.add(columns.get(i));\n        }\n\n        diffedMatrix.setColumnLabels(newColumns);\n      }\n      return diffedMatrix;\n\n    } else {\n      throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - first parameter must be list of matrix\", toExpression(constructingFactory)));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885":["be97db2343d6782775c916433312214085670d50"],"bbe7f5e9d90420c7fc8cd235dd8fb33fa9befe54":["c263c97cbb80b4388128937ff5a5659f1abaccd8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"be97db2343d6782775c916433312214085670d50":["bbe7f5e9d90420c7fc8cd235dd8fb33fa9befe54"],"c263c97cbb80b4388128937ff5a5659f1abaccd8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885"]},"commit2Childs":{"df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bbe7f5e9d90420c7fc8cd235dd8fb33fa9befe54":["be97db2343d6782775c916433312214085670d50"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c263c97cbb80b4388128937ff5a5659f1abaccd8"],"be97db2343d6782775c916433312214085670d50":["df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885"],"c263c97cbb80b4388128937ff5a5659f1abaccd8":["bbe7f5e9d90420c7fc8cd235dd8fb33fa9befe54"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}