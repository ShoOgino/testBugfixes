{"path":"src/java/org/apache/lucene/analysis/standard/StandardTokenizer#next(Token).mjava","commits":[{"id":"6864413dbc0c12104c978c05456f3da1d45adb03","date":1186770873,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/standard/StandardTokenizer#next(Token).mjava","pathOld":"src/java/org/apache/lucene/analysis/standard/StandardTokenizer#next().mjava","sourceNew":"    /*\n     * (non-Javadoc)\n     *\n     * @see org.apache.lucene.analysis.TokenStream#next()\n     */\n    public Token next(Token result) throws IOException {\n\tint tokenType = scanner.getNextToken();\n\n\tif (tokenType == StandardTokenizerImpl.YYEOF) {\n\t    return null;\n\t}\n\n        scanner.getText(result);\n        final int start = scanner.yychar();\n        result.setStartOffset(start);\n        result.setEndOffset(start+result.termLength());\n        result.setType(StandardTokenizerImpl.TOKEN_TYPES[tokenType]);\n        return result;\n    }\n\n","sourceOld":"    /*\n     * (non-Javadoc)\n     *\n     * @see org.apache.lucene.analysis.TokenStream#next()\n     */\n    public Token next() throws IOException {\n\tint tokenType = scanner.getNextToken();\n\n\tif (tokenType == StandardTokenizerImpl.YYEOF) {\n\t    return null;\n\t}\n\n\tint startPosition = scanner.yychar();\n\n\tfinal String tokenImage = scanner.yytext();\n\treturn new Token(tokenImage, startPosition, startPosition\n\t\t+ tokenImage.length(),\n\t\tStandardTokenizerImpl.TOKEN_TYPES[tokenType]);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c79a056cc0ebc0f62e4a01c20808260cc4c70074","date":1198809971,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/standard/StandardTokenizer#next(Token).mjava","pathOld":"src/java/org/apache/lucene/analysis/standard/StandardTokenizer#next(Token).mjava","sourceNew":"    public Token next(Token result) throws IOException {\n\tint tokenType = scanner.getNextToken();\n\n\tif (tokenType == StandardTokenizerImpl.YYEOF) {\n\t    return null;\n\t}\n\n        scanner.getText(result);\n        final int start = scanner.yychar();\n        result.setStartOffset(start);\n        result.setEndOffset(start+result.termLength());\n        // This 'if' should be removed in the next release. For now, it converts\n        // invalid acronyms to HOST. When removed, only the 'else' part should\n        // remain.\n        if (tokenType == StandardTokenizerImpl.ACRONYM_DEP) {\n          if (replaceInvalidAcronym) {\n            result.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.HOST]);\n            result.setTermLength(result.termLength() - 1); // remove extra '.'\n          } else {\n            result.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.ACRONYM]);\n          }\n        } else {\n          result.setType(StandardTokenizerImpl.TOKEN_TYPES[tokenType]);\n        }\n        return result;\n    }\n\n","sourceOld":"    /*\n     * (non-Javadoc)\n     *\n     * @see org.apache.lucene.analysis.TokenStream#next()\n     */\n    public Token next(Token result) throws IOException {\n\tint tokenType = scanner.getNextToken();\n\n\tif (tokenType == StandardTokenizerImpl.YYEOF) {\n\t    return null;\n\t}\n\n        scanner.getText(result);\n        final int start = scanner.yychar();\n        result.setStartOffset(start);\n        result.setEndOffset(start+result.termLength());\n        result.setType(StandardTokenizerImpl.TOKEN_TYPES[tokenType]);\n        return result;\n    }\n\n","bugFix":["6864413dbc0c12104c978c05456f3da1d45adb03"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fee44d0bd0b9443ff6068d0ba8458fd103dff4aa","date":1199000070,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/standard/StandardTokenizer#next(Token).mjava","pathOld":"src/java/org/apache/lucene/analysis/standard/StandardTokenizer#next(Token).mjava","sourceNew":"    public Token next(Token result) throws IOException {\n\tint tokenType = scanner.getNextToken();\n\n\tif (tokenType == StandardTokenizerImpl.YYEOF) {\n\t    return null;\n\t}\n\n        result.clear();\n        scanner.getText(result);\n        final int start = scanner.yychar();\n        result.setStartOffset(start);\n        result.setEndOffset(start+result.termLength());\n        // This 'if' should be removed in the next release. For now, it converts\n        // invalid acronyms to HOST. When removed, only the 'else' part should\n        // remain.\n        if (tokenType == StandardTokenizerImpl.ACRONYM_DEP) {\n          if (replaceInvalidAcronym) {\n            result.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.HOST]);\n            result.setTermLength(result.termLength() - 1); // remove extra '.'\n          } else {\n            result.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.ACRONYM]);\n          }\n        } else {\n          result.setType(StandardTokenizerImpl.TOKEN_TYPES[tokenType]);\n        }\n        return result;\n    }\n\n","sourceOld":"    public Token next(Token result) throws IOException {\n\tint tokenType = scanner.getNextToken();\n\n\tif (tokenType == StandardTokenizerImpl.YYEOF) {\n\t    return null;\n\t}\n\n        scanner.getText(result);\n        final int start = scanner.yychar();\n        result.setStartOffset(start);\n        result.setEndOffset(start+result.termLength());\n        // This 'if' should be removed in the next release. For now, it converts\n        // invalid acronyms to HOST. When removed, only the 'else' part should\n        // remain.\n        if (tokenType == StandardTokenizerImpl.ACRONYM_DEP) {\n          if (replaceInvalidAcronym) {\n            result.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.HOST]);\n            result.setTermLength(result.termLength() - 1); // remove extra '.'\n          } else {\n            result.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.ACRONYM]);\n          }\n        } else {\n          result.setType(StandardTokenizerImpl.TOKEN_TYPES[tokenType]);\n        }\n        return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5b54d19e4682ef2b08bd06f76c13a4c8d785386","date":1199633864,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/standard/StandardTokenizer#next(Token).mjava","pathOld":"src/java/org/apache/lucene/analysis/standard/StandardTokenizer#next(Token).mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   *\n   * @see org.apache.lucene.analysis.TokenStream#next()\n   */\n  public Token next(Token result) throws IOException {\n      int posIncr = 1;\n\n      while(true) {\n\tint tokenType = scanner.getNextToken();\n\n\tif (tokenType == StandardTokenizerImpl.YYEOF) {\n\t    return null;\n\t}\n\n        if (scanner.yylength() <= maxTokenLength) {\n          result.clear();\n          result.setPositionIncrement(posIncr);\n          scanner.getText(result);\n          final int start = scanner.yychar();\n          result.setStartOffset(start);\n          result.setEndOffset(start+result.termLength());\n          // This 'if' should be removed in the next release. For now, it converts\n          // invalid acronyms to HOST. When removed, only the 'else' part should\n          // remain.\n          if (tokenType == StandardTokenizerImpl.ACRONYM_DEP) {\n            if (replaceInvalidAcronym) {\n              result.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.HOST]);\n              result.setTermLength(result.termLength() - 1); // remove extra '.'\n            } else {\n              result.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.ACRONYM]);\n            }\n          } else {\n            result.setType(StandardTokenizerImpl.TOKEN_TYPES[tokenType]);\n          }\n          return result;\n        } else\n          // When we skip a too-long term, we still increment the\n          // position increment\n          posIncr++;\n      }\n    }\n\n","sourceOld":"    public Token next(Token result) throws IOException {\n\tint tokenType = scanner.getNextToken();\n\n\tif (tokenType == StandardTokenizerImpl.YYEOF) {\n\t    return null;\n\t}\n\n        result.clear();\n        scanner.getText(result);\n        final int start = scanner.yychar();\n        result.setStartOffset(start);\n        result.setEndOffset(start+result.termLength());\n        // This 'if' should be removed in the next release. For now, it converts\n        // invalid acronyms to HOST. When removed, only the 'else' part should\n        // remain.\n        if (tokenType == StandardTokenizerImpl.ACRONYM_DEP) {\n          if (replaceInvalidAcronym) {\n            result.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.HOST]);\n            result.setTermLength(result.termLength() - 1); // remove extra '.'\n          } else {\n            result.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.ACRONYM]);\n          }\n        } else {\n          result.setType(StandardTokenizerImpl.TOKEN_TYPES[tokenType]);\n        }\n        return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e2cb543b41c145f33390f460ee743d6693c9c6c","date":1219243087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/standard/StandardTokenizer#next(Token).mjava","pathOld":"src/java/org/apache/lucene/analysis/standard/StandardTokenizer#next(Token).mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   *\n   * @see org.apache.lucene.analysis.TokenStream#next()\n   */\n  public Token next(final Token reusableToken) throws IOException {\n      assert reusableToken != null;\n      int posIncr = 1;\n\n      while(true) {\n\tint tokenType = scanner.getNextToken();\n\n\tif (tokenType == StandardTokenizerImpl.YYEOF) {\n\t    return null;\n\t}\n\n        if (scanner.yylength() <= maxTokenLength) {\n          reusableToken.clear();\n          reusableToken.setPositionIncrement(posIncr);\n          scanner.getText(reusableToken);\n          final int start = scanner.yychar();\n          reusableToken.setStartOffset(start);\n          reusableToken.setEndOffset(start+reusableToken.termLength());\n          // This 'if' should be removed in the next release. For now, it converts\n          // invalid acronyms to HOST. When removed, only the 'else' part should\n          // remain.\n          if (tokenType == StandardTokenizerImpl.ACRONYM_DEP) {\n            if (replaceInvalidAcronym) {\n              reusableToken.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.HOST]);\n              reusableToken.setTermLength(reusableToken.termLength() - 1); // remove extra '.'\n            } else {\n              reusableToken.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.ACRONYM]);\n            }\n          } else {\n            reusableToken.setType(StandardTokenizerImpl.TOKEN_TYPES[tokenType]);\n          }\n          return reusableToken;\n        } else\n          // When we skip a too-long term, we still increment the\n          // position increment\n          posIncr++;\n      }\n    }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   *\n   * @see org.apache.lucene.analysis.TokenStream#next()\n   */\n  public Token next(Token result) throws IOException {\n      int posIncr = 1;\n\n      while(true) {\n\tint tokenType = scanner.getNextToken();\n\n\tif (tokenType == StandardTokenizerImpl.YYEOF) {\n\t    return null;\n\t}\n\n        if (scanner.yylength() <= maxTokenLength) {\n          result.clear();\n          result.setPositionIncrement(posIncr);\n          scanner.getText(result);\n          final int start = scanner.yychar();\n          result.setStartOffset(start);\n          result.setEndOffset(start+result.termLength());\n          // This 'if' should be removed in the next release. For now, it converts\n          // invalid acronyms to HOST. When removed, only the 'else' part should\n          // remain.\n          if (tokenType == StandardTokenizerImpl.ACRONYM_DEP) {\n            if (replaceInvalidAcronym) {\n              result.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.HOST]);\n              result.setTermLength(result.termLength() - 1); // remove extra '.'\n            } else {\n              result.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.ACRONYM]);\n            }\n          } else {\n            result.setType(StandardTokenizerImpl.TOKEN_TYPES[tokenType]);\n          }\n          return result;\n        } else\n          // When we skip a too-long term, we still increment the\n          // position increment\n          posIncr++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74a5e7f20b4a444da9df3b2c0f331fa7a1f64223","date":1227051709,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/standard/StandardTokenizer#next(Token).mjava","pathOld":"src/java/org/apache/lucene/analysis/standard/StandardTokenizer#next(Token).mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   *\n   * @see org.apache.lucene.analysis.TokenStream#next()\n   */\n  /** @deprecated */\n  public Token next(final Token reusableToken) throws IOException {\n      assert reusableToken != null;\n      int posIncr = 1;\n\n      while(true) {\n\tint tokenType = scanner.getNextToken();\n\n\tif (tokenType == StandardTokenizerImpl.YYEOF) {\n\t    return null;\n\t}\n\n        if (scanner.yylength() <= maxTokenLength) {\n          reusableToken.clear();\n          reusableToken.setPositionIncrement(posIncr);\n          scanner.getText(reusableToken);\n          final int start = scanner.yychar();\n          reusableToken.setStartOffset(start);\n          reusableToken.setEndOffset(start+reusableToken.termLength());\n          // This 'if' should be removed in the next release. For now, it converts\n          // invalid acronyms to HOST. When removed, only the 'else' part should\n          // remain.\n          if (tokenType == StandardTokenizerImpl.ACRONYM_DEP) {\n            if (replaceInvalidAcronym) {\n              reusableToken.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.HOST]);\n              reusableToken.setTermLength(reusableToken.termLength() - 1); // remove extra '.'\n            } else {\n              reusableToken.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.ACRONYM]);\n            }\n          } else {\n            reusableToken.setType(StandardTokenizerImpl.TOKEN_TYPES[tokenType]);\n          }\n          return reusableToken;\n        } else\n          // When we skip a too-long term, we still increment the\n          // position increment\n          posIncr++;\n      }\n    }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   *\n   * @see org.apache.lucene.analysis.TokenStream#next()\n   */\n  public Token next(final Token reusableToken) throws IOException {\n      assert reusableToken != null;\n      int posIncr = 1;\n\n      while(true) {\n\tint tokenType = scanner.getNextToken();\n\n\tif (tokenType == StandardTokenizerImpl.YYEOF) {\n\t    return null;\n\t}\n\n        if (scanner.yylength() <= maxTokenLength) {\n          reusableToken.clear();\n          reusableToken.setPositionIncrement(posIncr);\n          scanner.getText(reusableToken);\n          final int start = scanner.yychar();\n          reusableToken.setStartOffset(start);\n          reusableToken.setEndOffset(start+reusableToken.termLength());\n          // This 'if' should be removed in the next release. For now, it converts\n          // invalid acronyms to HOST. When removed, only the 'else' part should\n          // remain.\n          if (tokenType == StandardTokenizerImpl.ACRONYM_DEP) {\n            if (replaceInvalidAcronym) {\n              reusableToken.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.HOST]);\n              reusableToken.setTermLength(reusableToken.termLength() - 1); // remove extra '.'\n            } else {\n              reusableToken.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.ACRONYM]);\n            }\n          } else {\n            reusableToken.setType(StandardTokenizerImpl.TOKEN_TYPES[tokenType]);\n          }\n          return reusableToken;\n        } else\n          // When we skip a too-long term, we still increment the\n          // position increment\n          posIncr++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd27af5c226d98a7c6378c388a67a3bff7c0b3a2","date":1245784531,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/standard/StandardTokenizer#next(Token).mjava","pathOld":"src/java/org/apache/lucene/analysis/standard/StandardTokenizer#next(Token).mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   *\n   * @see org.apache.lucene.analysis.TokenStream#next()\n   */\n  /** @deprecated */\n  public Token next(final Token reusableToken) throws IOException {\n      assert reusableToken != null;\n      int posIncr = 1;\n\n      while(true) {\n        int tokenType = scanner.getNextToken();\n\n        if (tokenType == StandardTokenizerImpl.YYEOF) {\n          return null;\n        }\n\n        if (scanner.yylength() <= maxTokenLength) {\n          reusableToken.clear();\n          reusableToken.setPositionIncrement(posIncr);\n          scanner.getText(reusableToken);\n          final int start = scanner.yychar();\n          reusableToken.setStartOffset(input.correctOffset(start));\n          reusableToken.setEndOffset(input.correctOffset(start+reusableToken.termLength()));\n          // This 'if' should be removed in the next release. For now, it converts\n          // invalid acronyms to HOST. When removed, only the 'else' part should\n          // remain.\n          if (tokenType == StandardTokenizerImpl.ACRONYM_DEP) {\n            if (replaceInvalidAcronym) {\n              reusableToken.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.HOST]);\n              reusableToken.setTermLength(reusableToken.termLength() - 1); // remove extra '.'\n            } else {\n              reusableToken.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.ACRONYM]);\n            }\n          } else {\n            reusableToken.setType(StandardTokenizerImpl.TOKEN_TYPES[tokenType]);\n          }\n          return reusableToken;\n        } else\n          // When we skip a too-long term, we still increment the\n          // position increment\n          posIncr++;\n      }\n    }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   *\n   * @see org.apache.lucene.analysis.TokenStream#next()\n   */\n  /** @deprecated */\n  public Token next(final Token reusableToken) throws IOException {\n      assert reusableToken != null;\n      int posIncr = 1;\n\n      while(true) {\n\tint tokenType = scanner.getNextToken();\n\n\tif (tokenType == StandardTokenizerImpl.YYEOF) {\n\t    return null;\n\t}\n\n        if (scanner.yylength() <= maxTokenLength) {\n          reusableToken.clear();\n          reusableToken.setPositionIncrement(posIncr);\n          scanner.getText(reusableToken);\n          final int start = scanner.yychar();\n          reusableToken.setStartOffset(start);\n          reusableToken.setEndOffset(start+reusableToken.termLength());\n          // This 'if' should be removed in the next release. For now, it converts\n          // invalid acronyms to HOST. When removed, only the 'else' part should\n          // remain.\n          if (tokenType == StandardTokenizerImpl.ACRONYM_DEP) {\n            if (replaceInvalidAcronym) {\n              reusableToken.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.HOST]);\n              reusableToken.setTermLength(reusableToken.termLength() - 1); // remove extra '.'\n            } else {\n              reusableToken.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.ACRONYM]);\n            }\n          } else {\n            reusableToken.setType(StandardTokenizerImpl.TOKEN_TYPES[tokenType]);\n          }\n          return reusableToken;\n        } else\n          // When we skip a too-long term, we still increment the\n          // position increment\n          posIncr++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec8b5a20a12931b8d7e616c79c5248ae06cc5568","date":1248471948,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/standard/StandardTokenizer#next(Token).mjava","pathOld":"src/java/org/apache/lucene/analysis/standard/StandardTokenizer#next(Token).mjava","sourceNew":"  /** @deprecated Will be removed in Lucene 3.0. This method is final, as it should\n   * not be overridden. Delegates to the backwards compatibility layer. */\n  public final Token next(final Token reusableToken) throws IOException {\n    return super.next(reusableToken);\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   *\n   * @see org.apache.lucene.analysis.TokenStream#next()\n   */\n  /** @deprecated */\n  public Token next(final Token reusableToken) throws IOException {\n      assert reusableToken != null;\n      int posIncr = 1;\n\n      while(true) {\n        int tokenType = scanner.getNextToken();\n\n        if (tokenType == StandardTokenizerImpl.YYEOF) {\n          return null;\n        }\n\n        if (scanner.yylength() <= maxTokenLength) {\n          reusableToken.clear();\n          reusableToken.setPositionIncrement(posIncr);\n          scanner.getText(reusableToken);\n          final int start = scanner.yychar();\n          reusableToken.setStartOffset(input.correctOffset(start));\n          reusableToken.setEndOffset(input.correctOffset(start+reusableToken.termLength()));\n          // This 'if' should be removed in the next release. For now, it converts\n          // invalid acronyms to HOST. When removed, only the 'else' part should\n          // remain.\n          if (tokenType == StandardTokenizerImpl.ACRONYM_DEP) {\n            if (replaceInvalidAcronym) {\n              reusableToken.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.HOST]);\n              reusableToken.setTermLength(reusableToken.termLength() - 1); // remove extra '.'\n            } else {\n              reusableToken.setType(StandardTokenizerImpl.TOKEN_TYPES[StandardTokenizerImpl.ACRONYM]);\n            }\n          } else {\n            reusableToken.setType(StandardTokenizerImpl.TOKEN_TYPES[tokenType]);\n          }\n          return reusableToken;\n        } else\n          // When we skip a too-long term, we still increment the\n          // position increment\n          posIncr++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"439b0fe2f799d1c722151e88e32bdefad8d34ebe","date":1255282509,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/analysis/standard/StandardTokenizer#next(Token).mjava","sourceNew":null,"sourceOld":"  /** @deprecated Will be removed in Lucene 3.0. This method is final, as it should\n   * not be overridden. Delegates to the backwards compatibility layer. */\n  public final Token next(final Token reusableToken) throws IOException {\n    return super.next(reusableToken);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7e2cb543b41c145f33390f460ee743d6693c9c6c":["a5b54d19e4682ef2b08bd06f76c13a4c8d785386"],"6864413dbc0c12104c978c05456f3da1d45adb03":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"74a5e7f20b4a444da9df3b2c0f331fa7a1f64223":["7e2cb543b41c145f33390f460ee743d6693c9c6c"],"fee44d0bd0b9443ff6068d0ba8458fd103dff4aa":["c79a056cc0ebc0f62e4a01c20808260cc4c70074"],"c79a056cc0ebc0f62e4a01c20808260cc4c70074":["6864413dbc0c12104c978c05456f3da1d45adb03"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"439b0fe2f799d1c722151e88e32bdefad8d34ebe":["ec8b5a20a12931b8d7e616c79c5248ae06cc5568"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["439b0fe2f799d1c722151e88e32bdefad8d34ebe"],"ec8b5a20a12931b8d7e616c79c5248ae06cc5568":["cd27af5c226d98a7c6378c388a67a3bff7c0b3a2"],"cd27af5c226d98a7c6378c388a67a3bff7c0b3a2":["74a5e7f20b4a444da9df3b2c0f331fa7a1f64223"],"a5b54d19e4682ef2b08bd06f76c13a4c8d785386":["fee44d0bd0b9443ff6068d0ba8458fd103dff4aa"]},"commit2Childs":{"7e2cb543b41c145f33390f460ee743d6693c9c6c":["74a5e7f20b4a444da9df3b2c0f331fa7a1f64223"],"6864413dbc0c12104c978c05456f3da1d45adb03":["c79a056cc0ebc0f62e4a01c20808260cc4c70074"],"74a5e7f20b4a444da9df3b2c0f331fa7a1f64223":["cd27af5c226d98a7c6378c388a67a3bff7c0b3a2"],"fee44d0bd0b9443ff6068d0ba8458fd103dff4aa":["a5b54d19e4682ef2b08bd06f76c13a4c8d785386"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6864413dbc0c12104c978c05456f3da1d45adb03"],"c79a056cc0ebc0f62e4a01c20808260cc4c70074":["fee44d0bd0b9443ff6068d0ba8458fd103dff4aa"],"439b0fe2f799d1c722151e88e32bdefad8d34ebe":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a5b54d19e4682ef2b08bd06f76c13a4c8d785386":["7e2cb543b41c145f33390f460ee743d6693c9c6c"],"ec8b5a20a12931b8d7e616c79c5248ae06cc5568":["439b0fe2f799d1c722151e88e32bdefad8d34ebe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"cd27af5c226d98a7c6378c388a67a3bff7c0b3a2":["ec8b5a20a12931b8d7e616c79c5248ae06cc5568"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}