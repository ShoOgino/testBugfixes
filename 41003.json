{"path":"lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean,float).mjava","commits":[{"id":"02e175abd2c4c1611c5a9647486ae8ba249a94c1","date":1468327116,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values must not be null, call rewrite first\");\n    }\n    return new RandomAccessWeight(DocValuesRangeQuery.this, boost) {\n      \n      @Override\n      protected Bits getMatchingDocs(LeafReaderContext context) throws IOException {\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            if ((long) lowerVal == Long.MAX_VALUE) {\n              return null;\n            }\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            if ((long) upperVal == Long.MIN_VALUE) {\n              return null;\n            }\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              values.setDocument(doc);\n              final int count = values.count();\n              for (int i = 0; i < count; ++i) {\n                final long value = values.valueAt(i);\n                if (value >= min && value <= max) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              values.setDocument(doc);\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                if (ord >= minOrd && ord <= maxOrd) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else {\n          throw new AssertionError();\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values must not be null, call rewrite first\");\n    }\n    return new RandomAccessWeight(DocValuesRangeQuery.this) {\n      \n      @Override\n      protected Bits getMatchingDocs(LeafReaderContext context) throws IOException {\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            if ((long) lowerVal == Long.MAX_VALUE) {\n              return null;\n            }\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            if ((long) upperVal == Long.MIN_VALUE) {\n              return null;\n            }\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              values.setDocument(doc);\n              final int count = values.count();\n              for (int i = 0; i < count; ++i) {\n                final long value = values.valueAt(i);\n                if (value >= min && value <= max) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              values.setDocument(doc);\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                if (ord >= minOrd && ord <= maxOrd) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else {\n          throw new AssertionError();\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values must not be null, call rewrite first\");\n    }\n    return new RandomAccessWeight(DocValuesRangeQuery.this, boost) {\n      \n      @Override\n      protected Bits getMatchingDocs(LeafReaderContext context) throws IOException {\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            if ((long) lowerVal == Long.MAX_VALUE) {\n              return null;\n            }\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            if ((long) upperVal == Long.MIN_VALUE) {\n              return null;\n            }\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              try {\n                if (doc > values.docID()) {\n                  values.advance(doc);\n                }\n                if (doc == values.docID()) {\n                  final int count = values.docValueCount();\n                  for (int i = 0; i < count; ++i) {\n                    final long value = values.nextValue();\n                    if (value >= min && value <= max) {\n                      return true;\n                    }\n                  }\n                }\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              try {\n                if (doc > values.docID()) {\n                  values.advance(doc);\n                }\n                if (doc == values.docID()) {\n                  for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                    if (ord >= minOrd && ord <= maxOrd) {\n                      return true;\n                    }\n                  }\n                }\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else {\n          throw new AssertionError();\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values must not be null, call rewrite first\");\n    }\n    return new RandomAccessWeight(DocValuesRangeQuery.this, boost) {\n      \n      @Override\n      protected Bits getMatchingDocs(LeafReaderContext context) throws IOException {\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            if ((long) lowerVal == Long.MAX_VALUE) {\n              return null;\n            }\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            if ((long) upperVal == Long.MIN_VALUE) {\n              return null;\n            }\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              values.setDocument(doc);\n              final int count = values.count();\n              for (int i = 0; i < count; ++i) {\n                final long value = values.valueAt(i);\n                if (value >= min && value <= max) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              values.setDocument(doc);\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                if (ord >= minOrd && ord <= maxOrd) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else {\n          throw new AssertionError();\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values must not be null, call rewrite first\");\n    }\n    return new RandomAccessWeight(DocValuesRangeQuery.this, boost) {\n      \n      @Override\n      protected Bits getMatchingDocs(LeafReaderContext context) throws IOException {\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            if ((long) lowerVal == Long.MAX_VALUE) {\n              return null;\n            }\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            if ((long) upperVal == Long.MIN_VALUE) {\n              return null;\n            }\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              try {\n                if (doc > values.docID()) {\n                  values.advance(doc);\n                }\n                if (doc == values.docID()) {\n                  final int count = values.docValueCount();\n                  for (int i = 0; i < count; ++i) {\n                    final long value = values.nextValue();\n                    if (value >= min && value <= max) {\n                      return true;\n                    }\n                  }\n                }\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              try {\n                if (doc > values.docID()) {\n                  values.advance(doc);\n                }\n                if (doc == values.docID()) {\n                  for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                    if (ord >= minOrd && ord <= maxOrd) {\n                      return true;\n                    }\n                  }\n                }\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else {\n          throw new AssertionError();\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values must not be null, call rewrite first\");\n    }\n    return new RandomAccessWeight(DocValuesRangeQuery.this, boost) {\n      \n      @Override\n      protected Bits getMatchingDocs(LeafReaderContext context) throws IOException {\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            if ((long) lowerVal == Long.MAX_VALUE) {\n              return null;\n            }\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            if ((long) upperVal == Long.MIN_VALUE) {\n              return null;\n            }\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              values.setDocument(doc);\n              final int count = values.count();\n              for (int i = 0; i < count; ++i) {\n                final long value = values.valueAt(i);\n                if (value >= min && value <= max) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              values.setDocument(doc);\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                if (ord >= minOrd && ord <= maxOrd) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else {\n          throw new AssertionError();\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values must not be null, call rewrite first\");\n    }\n    return new RandomAccessWeight(DocValuesRangeQuery.this, boost) {\n      \n      @Override\n      protected Bits getMatchingDocs(LeafReaderContext context) throws IOException {\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            if ((long) lowerVal == Long.MAX_VALUE) {\n              return null;\n            }\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            if ((long) upperVal == Long.MIN_VALUE) {\n              return null;\n            }\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              try {\n                if (doc > values.docID()) {\n                  values.advance(doc);\n                }\n                if (doc == values.docID()) {\n                  final int count = values.docValueCount();\n                  for (int i = 0; i < count; ++i) {\n                    final long value = values.nextValue();\n                    if (value >= min && value <= max) {\n                      return true;\n                    }\n                  }\n                }\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              try {\n                if (doc > values.docID()) {\n                  values.advance(doc);\n                }\n                if (doc == values.docID()) {\n                  for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                    if (ord >= minOrd && ord <= maxOrd) {\n                      return true;\n                    }\n                  }\n                }\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else {\n          throw new AssertionError();\n        }\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e59d3612d24b4c29c5affe50a48f7fa0e342d4ec","date":1479218146,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values must not be null, call rewrite first\");\n    }\n\n    return new ConstantScoreWeight(DocValuesRangeQuery.this, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        final TwoPhaseIterator iterator = createTwoPhaseIterator(context);\n        if (iterator == null) {\n          return null;\n        }\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      private TwoPhaseIterator createTwoPhaseIterator(LeafReaderContext context) throws IOException {\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            if ((long) lowerVal == Long.MAX_VALUE) {\n              return null;\n            }\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            if ((long) upperVal == Long.MIN_VALUE) {\n              return null;\n            }\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          return new TwoPhaseIterator(values) {\n\n            @Override\n            public boolean matches() throws IOException {\n              final int count = values.docValueCount();\n              assert count > 0;\n              for (int i = 0; i < count; ++i) {\n                final long value = values.nextValue();\n                if (value >= min && value <= max) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public float matchCost() {\n              return 2; // 2 comparisons\n            }\n\n          };\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          return new TwoPhaseIterator(values) {\n\n            @Override\n            public boolean matches() throws IOException {\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                if (ord >= minOrd && ord <= maxOrd) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public float matchCost() {\n              return 2; // 2 comparisons\n            }\n          };\n\n        } else {\n          throw new AssertionError();\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values must not be null, call rewrite first\");\n    }\n    return new RandomAccessWeight(DocValuesRangeQuery.this, boost) {\n      \n      @Override\n      protected Bits getMatchingDocs(LeafReaderContext context) throws IOException {\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            if ((long) lowerVal == Long.MAX_VALUE) {\n              return null;\n            }\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            if ((long) upperVal == Long.MIN_VALUE) {\n              return null;\n            }\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              try {\n                if (doc > values.docID()) {\n                  values.advance(doc);\n                }\n                if (doc == values.docID()) {\n                  final int count = values.docValueCount();\n                  for (int i = 0; i < count; ++i) {\n                    final long value = values.nextValue();\n                    if (value >= min && value <= max) {\n                      return true;\n                    }\n                  }\n                }\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              try {\n                if (doc > values.docID()) {\n                  values.advance(doc);\n                }\n                if (doc == values.docID()) {\n                  for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                    if (ord >= minOrd && ord <= maxOrd) {\n                      return true;\n                    }\n                  }\n                }\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else {\n          throw new AssertionError();\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"21019aa828c8c9b0153877543a8b3f200bf2ca19","date":1479224450,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean,float).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values must not be null, call rewrite first\");\n    }\n\n    return new ConstantScoreWeight(DocValuesRangeQuery.this, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        final TwoPhaseIterator iterator = createTwoPhaseIterator(context);\n        if (iterator == null) {\n          return null;\n        }\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      private TwoPhaseIterator createTwoPhaseIterator(LeafReaderContext context) throws IOException {\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            if ((long) lowerVal == Long.MAX_VALUE) {\n              return null;\n            }\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            if ((long) upperVal == Long.MIN_VALUE) {\n              return null;\n            }\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          return new TwoPhaseIterator(values) {\n\n            @Override\n            public boolean matches() throws IOException {\n              final int count = values.docValueCount();\n              assert count > 0;\n              for (int i = 0; i < count; ++i) {\n                final long value = values.nextValue();\n                if (value >= min && value <= max) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public float matchCost() {\n              return 2; // 2 comparisons\n            }\n\n          };\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          return new TwoPhaseIterator(values) {\n\n            @Override\n            public boolean matches() throws IOException {\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                if (ord >= minOrd && ord <= maxOrd) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public float matchCost() {\n              return 2; // 2 comparisons\n            }\n          };\n\n        } else {\n          throw new AssertionError();\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values must not be null, call rewrite first\");\n    }\n    return new RandomAccessWeight(DocValuesRangeQuery.this, boost) {\n      \n      @Override\n      protected Bits getMatchingDocs(LeafReaderContext context) throws IOException {\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            if ((long) lowerVal == Long.MAX_VALUE) {\n              return null;\n            }\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            if ((long) upperVal == Long.MIN_VALUE) {\n              return null;\n            }\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              try {\n                if (doc > values.docID()) {\n                  values.advance(doc);\n                }\n                if (doc == values.docID()) {\n                  final int count = values.docValueCount();\n                  for (int i = 0; i < count; ++i) {\n                    final long value = values.nextValue();\n                    if (value >= min && value <= max) {\n                      return true;\n                    }\n                  }\n                }\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          return new Bits() {\n\n            @Override\n            public boolean get(int doc) {\n              try {\n                if (doc > values.docID()) {\n                  values.advance(doc);\n                }\n                if (doc == values.docID()) {\n                  for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                    if (ord >= minOrd && ord <= maxOrd) {\n                      return true;\n                    }\n                  }\n                }\n              } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n              }\n              return false;\n            }\n\n            @Override\n            public int length() {\n              return context.reader().maxDoc();\n            }\n\n          };\n\n        } else {\n          throw new AssertionError();\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a412a7808b2815566cb17117ebe6638112b9a31","date":1484916151,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":null,"sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values must not be null, call rewrite first\");\n    }\n\n    return new ConstantScoreWeight(DocValuesRangeQuery.this, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        final TwoPhaseIterator iterator = createTwoPhaseIterator(context);\n        if (iterator == null) {\n          return null;\n        }\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      private TwoPhaseIterator createTwoPhaseIterator(LeafReaderContext context) throws IOException {\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            if ((long) lowerVal == Long.MAX_VALUE) {\n              return null;\n            }\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            if ((long) upperVal == Long.MIN_VALUE) {\n              return null;\n            }\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          return new TwoPhaseIterator(values) {\n\n            @Override\n            public boolean matches() throws IOException {\n              final int count = values.docValueCount();\n              assert count > 0;\n              for (int i = 0; i < count; ++i) {\n                final long value = values.nextValue();\n                if (value >= min && value <= max) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public float matchCost() {\n              return 2; // 2 comparisons\n            }\n\n          };\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          return new TwoPhaseIterator(values) {\n\n            @Override\n            public boolean matches() throws IOException {\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                if (ord >= minOrd && ord <= maxOrd) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public float matchCost() {\n              return 2; // 2 comparisons\n            }\n          };\n\n        } else {\n          throw new AssertionError();\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/DocValuesRangeQuery#createWeight(IndexSearcher,boolean,float).mjava","sourceNew":null,"sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {\n    if (lowerVal == null && upperVal == null) {\n      throw new IllegalStateException(\"Both min and max values must not be null, call rewrite first\");\n    }\n\n    return new ConstantScoreWeight(DocValuesRangeQuery.this, boost) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        final TwoPhaseIterator iterator = createTwoPhaseIterator(context);\n        if (iterator == null) {\n          return null;\n        }\n        return new ConstantScoreScorer(this, score(), iterator);\n      }\n\n      private TwoPhaseIterator createTwoPhaseIterator(LeafReaderContext context) throws IOException {\n        if (lowerVal instanceof Long || upperVal instanceof Long) {\n\n          final SortedNumericDocValues values = DocValues.getSortedNumeric(context.reader(), field);\n\n          final long min;\n          if (lowerVal == null) {\n            min = Long.MIN_VALUE;\n          } else if (includeLower) {\n            min = (long) lowerVal;\n          } else {\n            if ((long) lowerVal == Long.MAX_VALUE) {\n              return null;\n            }\n            min = 1 + (long) lowerVal;\n          }\n\n          final long max;\n          if (upperVal == null) {\n            max = Long.MAX_VALUE;\n          } else if (includeUpper) {\n            max = (long) upperVal;\n          } else {\n            if ((long) upperVal == Long.MIN_VALUE) {\n              return null;\n            }\n            max = -1 + (long) upperVal;\n          }\n\n          if (min > max) {\n            return null;\n          }\n\n          return new TwoPhaseIterator(values) {\n\n            @Override\n            public boolean matches() throws IOException {\n              final int count = values.docValueCount();\n              assert count > 0;\n              for (int i = 0; i < count; ++i) {\n                final long value = values.nextValue();\n                if (value >= min && value <= max) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public float matchCost() {\n              return 2; // 2 comparisons\n            }\n\n          };\n\n        } else if (lowerVal instanceof BytesRef || upperVal instanceof BytesRef) {\n\n          final SortedSetDocValues values = DocValues.getSortedSet(context.reader(), field);\n\n          final long minOrd;\n          if (lowerVal == null) {\n            minOrd = 0;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) lowerVal);\n            if (ord < 0) {\n              minOrd = -1 - ord;\n            } else if (includeLower) {\n              minOrd = ord;\n            } else {\n              minOrd = ord + 1;\n            }\n          }\n\n          final long maxOrd;\n          if (upperVal == null) {\n            maxOrd = values.getValueCount() - 1;\n          } else {\n            final long ord = values.lookupTerm((BytesRef) upperVal);\n            if (ord < 0) {\n              maxOrd = -2 - ord;\n            } else if (includeUpper) {\n              maxOrd = ord;\n            } else {\n              maxOrd = ord - 1;\n            }\n          }\n\n          if (minOrd > maxOrd) {\n            return null;\n          }\n\n          return new TwoPhaseIterator(values) {\n\n            @Override\n            public boolean matches() throws IOException {\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                if (ord >= minOrd && ord <= maxOrd) {\n                  return true;\n                }\n              }\n              return false;\n            }\n\n            @Override\n            public float matchCost() {\n              return 2; // 2 comparisons\n            }\n          };\n\n        } else {\n          throw new AssertionError();\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e59d3612d24b4c29c5affe50a48f7fa0e342d4ec":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"21019aa828c8c9b0153877543a8b3f200bf2ca19":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e59d3612d24b4c29c5affe50a48f7fa0e342d4ec"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["02e175abd2c4c1611c5a9647486ae8ba249a94c1","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["02e175abd2c4c1611c5a9647486ae8ba249a94c1"],"02e175abd2c4c1611c5a9647486ae8ba249a94c1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5a412a7808b2815566cb17117ebe6638112b9a31":["e59d3612d24b4c29c5affe50a48f7fa0e342d4ec"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["21019aa828c8c9b0153877543a8b3f200bf2ca19","5a412a7808b2815566cb17117ebe6638112b9a31"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5a412a7808b2815566cb17117ebe6638112b9a31"]},"commit2Childs":{"e59d3612d24b4c29c5affe50a48f7fa0e342d4ec":["21019aa828c8c9b0153877543a8b3f200bf2ca19","5a412a7808b2815566cb17117ebe6638112b9a31"],"21019aa828c8c9b0153877543a8b3f200bf2ca19":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["e59d3612d24b4c29c5affe50a48f7fa0e342d4ec","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["02e175abd2c4c1611c5a9647486ae8ba249a94c1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"02e175abd2c4c1611c5a9647486ae8ba249a94c1":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"5a412a7808b2815566cb17117ebe6638112b9a31":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["21019aa828c8c9b0153877543a8b3f200bf2ca19"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}