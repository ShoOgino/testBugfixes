{"path":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(String,boolean).mjava","commits":[{"id":"3aecf04c2d454cf9e42c4dc50241a8df41f8e6ab","date":1324934316,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(String,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(String).mjava","sourceNew":"  /**\n   * Create a new LevenshteinAutomata for some input String.\n   * Optionally count transpositions as a primitive edit.\n   */\n  public LevenshteinAutomata(String input, boolean withTranspositions) {\n    this.input = input;\n    int length = Character.codePointCount(input, 0, input.length());\n    word = new int[length];\n    for (int i = 0, j = 0, cp = 0; i < input.length(); i += Character.charCount(cp)) {\n      word[j++] = cp = input.codePointAt(i);\n    }\n    \n    // calculate the alphabet\n    SortedSet<Integer> set = new TreeSet<Integer>();\n    for (int i = 0; i < word.length; i++)\n      set.add(word[i]);\n    alphabet = new int[set.size()];\n    Iterator<Integer> iterator = set.iterator();\n    for (int i = 0; i < alphabet.length; i++)\n      alphabet[i] = iterator.next();\n      \n    rangeLower = new int[alphabet.length + 2];\n    rangeUpper = new int[alphabet.length + 2];\n    // calculate the unicode range intervals that exclude the alphabet\n    // these are the ranges for all unicode characters not in the alphabet\n    int lower = 0;\n    for (int i = 0; i < alphabet.length; i++) {\n      int higher = alphabet[i];\n      if (higher > lower) {\n        rangeLower[numRanges] = lower;\n        rangeUpper[numRanges] = higher - 1;\n        numRanges++;\n      }\n      lower = higher + 1;\n    }\n    /* add the final endpoint */\n    if (lower <= Character.MAX_CODE_POINT) {\n      rangeLower[numRanges] = lower;\n      rangeUpper[numRanges] = Character.MAX_CODE_POINT;\n      numRanges++;\n    }\n\n    descriptions = new ParametricDescription[] {\n        null, /* for n=0, we do not need to go through the trouble */\n        withTranspositions ? new Lev1TParametricDescription(word.length) : new Lev1ParametricDescription(word.length),\n        withTranspositions ? new Lev2TParametricDescription(word.length) : new Lev2ParametricDescription(word.length),\n    };\n  }\n\n","sourceOld":"  /**\n   * Create a new LevenshteinAutomata for some input String.\n   */\n  public LevenshteinAutomata(String input) {\n    this.input = input;\n    int length = Character.codePointCount(input, 0, input.length());\n    word = new int[length];\n    for (int i = 0, j = 0, cp = 0; i < input.length(); i += Character.charCount(cp)) {\n      word[j++] = cp = input.codePointAt(i);\n    }\n    \n    // calculate the alphabet\n    SortedSet<Integer> set = new TreeSet<Integer>();\n    for (int i = 0; i < word.length; i++)\n      set.add(word[i]);\n    alphabet = new int[set.size()];\n    Iterator<Integer> iterator = set.iterator();\n    for (int i = 0; i < alphabet.length; i++)\n      alphabet[i] = iterator.next();\n      \n    rangeLower = new int[alphabet.length + 2];\n    rangeUpper = new int[alphabet.length + 2];\n    // calculate the unicode range intervals that exclude the alphabet\n    // these are the ranges for all unicode characters not in the alphabet\n    int lower = 0;\n    for (int i = 0; i < alphabet.length; i++) {\n      int higher = alphabet[i];\n      if (higher > lower) {\n        rangeLower[numRanges] = lower;\n        rangeUpper[numRanges] = higher - 1;\n        numRanges++;\n      }\n      lower = higher + 1;\n    }\n    /* add the final endpoint */\n    if (lower <= Character.MAX_CODE_POINT) {\n      rangeLower[numRanges] = lower;\n      rangeUpper[numRanges] = Character.MAX_CODE_POINT;\n      numRanges++;\n    }\n\n    descriptions = new ParametricDescription[] {\n        null, /* for n=0, we do not need to go through the trouble */\n        new Lev1ParametricDescription(word.length),\n        new Lev2ParametricDescription(word.length),\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(String,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(String,boolean).mjava","sourceNew":"  /**\n   * Create a new LevenshteinAutomata for some input String.\n   * Optionally count transpositions as a primitive edit.\n   */\n  public LevenshteinAutomata(String input, boolean withTranspositions) {\n    this.input = input;\n    int length = Character.codePointCount(input, 0, input.length());\n    word = new int[length];\n    for (int i = 0, j = 0, cp = 0; i < input.length(); i += Character.charCount(cp)) {\n      word[j++] = cp = input.codePointAt(i);\n    }\n    \n    // calculate the alphabet\n    SortedSet<Integer> set = new TreeSet<Integer>();\n    for (int i = 0; i < word.length; i++)\n      set.add(word[i]);\n    alphabet = new int[set.size()];\n    Iterator<Integer> iterator = set.iterator();\n    for (int i = 0; i < alphabet.length; i++)\n      alphabet[i] = iterator.next();\n      \n    rangeLower = new int[alphabet.length + 2];\n    rangeUpper = new int[alphabet.length + 2];\n    // calculate the unicode range intervals that exclude the alphabet\n    // these are the ranges for all unicode characters not in the alphabet\n    int lower = 0;\n    for (int i = 0; i < alphabet.length; i++) {\n      int higher = alphabet[i];\n      if (higher > lower) {\n        rangeLower[numRanges] = lower;\n        rangeUpper[numRanges] = higher - 1;\n        numRanges++;\n      }\n      lower = higher + 1;\n    }\n    /* add the final endpoint */\n    if (lower <= Character.MAX_CODE_POINT) {\n      rangeLower[numRanges] = lower;\n      rangeUpper[numRanges] = Character.MAX_CODE_POINT;\n      numRanges++;\n    }\n\n    descriptions = new ParametricDescription[] {\n        null, /* for n=0, we do not need to go through the trouble */\n        withTranspositions ? new Lev1TParametricDescription(word.length) : new Lev1ParametricDescription(word.length),\n        withTranspositions ? new Lev2TParametricDescription(word.length) : new Lev2ParametricDescription(word.length),\n    };\n  }\n\n","sourceOld":"  /**\n   * Create a new LevenshteinAutomata for some input String.\n   * Optionally count transpositions as a primitive edit.\n   */\n  public LevenshteinAutomata(String input, boolean withTranspositions) {\n    this.input = input;\n    int length = Character.codePointCount(input, 0, input.length());\n    word = new int[length];\n    for (int i = 0, j = 0, cp = 0; i < input.length(); i += Character.charCount(cp)) {\n      word[j++] = cp = input.codePointAt(i);\n    }\n    \n    // calculate the alphabet\n    SortedSet<Integer> set = new TreeSet<Integer>();\n    for (int i = 0; i < word.length; i++)\n      set.add(word[i]);\n    alphabet = new int[set.size()];\n    Iterator<Integer> iterator = set.iterator();\n    for (int i = 0; i < alphabet.length; i++)\n      alphabet[i] = iterator.next();\n      \n    rangeLower = new int[alphabet.length + 2];\n    rangeUpper = new int[alphabet.length + 2];\n    // calculate the unicode range intervals that exclude the alphabet\n    // these are the ranges for all unicode characters not in the alphabet\n    int lower = 0;\n    for (int i = 0; i < alphabet.length; i++) {\n      int higher = alphabet[i];\n      if (higher > lower) {\n        rangeLower[numRanges] = lower;\n        rangeUpper[numRanges] = higher - 1;\n        numRanges++;\n      }\n      lower = higher + 1;\n    }\n    /* add the final endpoint */\n    if (lower <= Character.MAX_CODE_POINT) {\n      rangeLower[numRanges] = lower;\n      rangeUpper[numRanges] = Character.MAX_CODE_POINT;\n      numRanges++;\n    }\n\n    descriptions = new ParametricDescription[] {\n        null, /* for n=0, we do not need to go through the trouble */\n        withTranspositions ? new Lev1TParametricDescription(word.length) : new Lev1ParametricDescription(word.length),\n        withTranspositions ? new Lev2TParametricDescription(word.length) : new Lev2ParametricDescription(word.length),\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["3aecf04c2d454cf9e42c4dc50241a8df41f8e6ab"],"3aecf04c2d454cf9e42c4dc50241a8df41f8e6ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3aecf04c2d454cf9e42c4dc50241a8df41f8e6ab":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3aecf04c2d454cf9e42c4dc50241a8df41f8e6ab"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}