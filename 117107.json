{"path":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","commits":[{"id":"7f32ed90e12610550e1363aea43afe3d6e292cf9","date":1418230105,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n          arc.node = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(getNodeAddress(follow.target));\n\n    arc.node = follow.target;\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    if (in.readByte() == ARCS_AS_FIXED_ARRAY) {\n      // Arcs are full array; do binary search:\n      arc.numArcs = in.readVInt();\n      if (packed || version >= VERSION_VINT_TARGET) {\n        arc.bytesPerArc = in.readVInt();\n      } else {\n        arc.bytesPerArc = in.readInt();\n      }\n      arc.posArcsStart = in.getPosition();\n      int low = 0;\n      int high = arc.numArcs-1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc*mid + 1);\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target, arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6244579a467d5f2673ac98265d74bddbea1a8114","date":1478786509,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","sourceNew":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n          arc.node = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target);\n\n    arc.node = follow.target;\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    if (in.readByte() == ARCS_AS_FIXED_ARRAY) {\n      // Arcs are full array; do binary search:\n      arc.numArcs = in.readVInt();\n      if (version >= VERSION_VINT_TARGET) {\n        arc.bytesPerArc = in.readVInt();\n      } else {\n        arc.bytesPerArc = in.readInt();\n      }\n      arc.posArcsStart = in.getPosition();\n      int low = 0;\n      int high = arc.numArcs-1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc*mid + 1);\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target, arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n          arc.node = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(getNodeAddress(follow.target));\n\n    arc.node = follow.target;\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    if (in.readByte() == ARCS_AS_FIXED_ARRAY) {\n      // Arcs are full array; do binary search:\n      arc.numArcs = in.readVInt();\n      if (packed || version >= VERSION_VINT_TARGET) {\n        arc.bytesPerArc = in.readVInt();\n      } else {\n        arc.bytesPerArc = in.readInt();\n      }\n      arc.posArcsStart = in.getPosition();\n      int low = 0;\n      int high = arc.numArcs-1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc*mid + 1);\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target, arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","sourceNew":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n          arc.node = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target);\n\n    arc.node = follow.target;\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    if (in.readByte() == ARCS_AS_FIXED_ARRAY) {\n      // Arcs are full array; do binary search:\n      arc.numArcs = in.readVInt();\n      if (version >= VERSION_VINT_TARGET) {\n        arc.bytesPerArc = in.readVInt();\n      } else {\n        arc.bytesPerArc = in.readInt();\n      }\n      arc.posArcsStart = in.getPosition();\n      int low = 0;\n      int high = arc.numArcs-1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc*mid + 1);\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target, arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n          arc.node = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(getNodeAddress(follow.target));\n\n    arc.node = follow.target;\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    if (in.readByte() == ARCS_AS_FIXED_ARRAY) {\n      // Arcs are full array; do binary search:\n      arc.numArcs = in.readVInt();\n      if (packed || version >= VERSION_VINT_TARGET) {\n        arc.bytesPerArc = in.readVInt();\n      } else {\n        arc.bytesPerArc = in.readInt();\n      }\n      arc.posArcsStart = in.getPosition();\n      int low = 0;\n      int high = arc.numArcs-1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc*mid + 1);\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target, arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9cbc4730743fac2e69e7d622848778d3ad9f2151","date":1502282443,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","sourceNew":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target);\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    if (in.readByte() == ARCS_AS_FIXED_ARRAY) {\n      // Arcs are full array; do binary search:\n      arc.numArcs = in.readVInt();\n      if (version >= VERSION_VINT_TARGET) {\n        arc.bytesPerArc = in.readVInt();\n      } else {\n        arc.bytesPerArc = in.readInt();\n      }\n      arc.posArcsStart = in.getPosition();\n      int low = 0;\n      int high = arc.numArcs-1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc*mid + 1);\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target, arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n          arc.node = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target);\n\n    arc.node = follow.target;\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    if (in.readByte() == ARCS_AS_FIXED_ARRAY) {\n      // Arcs are full array; do binary search:\n      arc.numArcs = in.readVInt();\n      if (version >= VERSION_VINT_TARGET) {\n        arc.bytesPerArc = in.readVInt();\n      } else {\n        arc.bytesPerArc = in.readInt();\n      }\n      arc.posArcsStart = in.getPosition();\n      int low = 0;\n      int high = arc.numArcs-1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc*mid + 1);\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target, arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58884af1f68e9d61c217c753fbd6266d86a63b14","date":1502363401,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","sourceNew":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target);\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    if (in.readByte() == ARCS_AS_FIXED_ARRAY) {\n      // Arcs are full array; do binary search:\n      arc.numArcs = in.readVInt();\n      if (version >= VERSION_VINT_TARGET) {\n        arc.bytesPerArc = in.readVInt();\n      } else {\n        arc.bytesPerArc = in.readInt();\n      }\n      arc.posArcsStart = in.getPosition();\n      int low = 0;\n      int high = arc.numArcs-1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc*mid + 1);\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target, arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n          arc.node = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target);\n\n    arc.node = follow.target;\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    if (in.readByte() == ARCS_AS_FIXED_ARRAY) {\n      // Arcs are full array; do binary search:\n      arc.numArcs = in.readVInt();\n      if (version >= VERSION_VINT_TARGET) {\n        arc.bytesPerArc = in.readVInt();\n      } else {\n        arc.bytesPerArc = in.readInt();\n      }\n      arc.posArcsStart = in.getPosition();\n      int low = 0;\n      int high = arc.numArcs-1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc*mid + 1);\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target, arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","date":1502692251,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","sourceNew":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target);\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    if (in.readByte() == ARCS_AS_FIXED_ARRAY) {\n      // Arcs are full array; do binary search:\n      arc.numArcs = in.readVInt();\n      if (version >= VERSION_VINT_TARGET) {\n        arc.bytesPerArc = in.readVInt();\n      } else {\n        arc.bytesPerArc = in.readInt();\n      }\n      arc.posArcsStart = in.getPosition();\n      int low = 0;\n      int high = arc.numArcs-1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc*mid + 1);\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target, arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n          arc.node = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target);\n\n    arc.node = follow.target;\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    if (in.readByte() == ARCS_AS_FIXED_ARRAY) {\n      // Arcs are full array; do binary search:\n      arc.numArcs = in.readVInt();\n      if (version >= VERSION_VINT_TARGET) {\n        arc.bytesPerArc = in.readVInt();\n      } else {\n        arc.bytesPerArc = in.readInt();\n      }\n      arc.posArcsStart = in.getPosition();\n      int low = 0;\n      int high = arc.numArcs-1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc*mid + 1);\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target, arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0e7448656541edc407546460641f47950451b16","date":1519150500,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","sourceNew":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target);\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    if (in.readByte() == ARCS_AS_FIXED_ARRAY) {\n      // Arcs are full array; do binary search:\n      arc.numArcs = in.readVInt();\n      arc.bytesPerArc = in.readVInt();\n      arc.posArcsStart = in.getPosition();\n      int low = 0;\n      int high = arc.numArcs-1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc*mid + 1);\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target, arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target);\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    if (in.readByte() == ARCS_AS_FIXED_ARRAY) {\n      // Arcs are full array; do binary search:\n      arc.numArcs = in.readVInt();\n      if (version >= VERSION_VINT_TARGET) {\n        arc.bytesPerArc = in.readVInt();\n      } else {\n        arc.bytesPerArc = in.readInt();\n      }\n      arc.posArcsStart = in.getPosition();\n      int low = 0;\n      int high = arc.numArcs-1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc*mid + 1);\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target, arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae67e1f82a53594208ca929f382ee861dad3d7a8","date":1557134375,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","sourceNew":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target);\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    byte flags = in.readByte();\n    if (flags == ARCS_AS_ARRAY_WITH_GAPS) {\n      arc.numArcs = in.readVInt();\n      arc.bytesPerArc = in.readVInt();\n      arc.posArcsStart = in.getPosition();\n\n      // Array is direct; address by label\n      in.skipBytes(1);\n      int firstLabel = readLabel(in);\n      int arcPos = labelToMatch - firstLabel;\n      if (arcPos == 0) {\n        arc.nextArc = arc.posArcsStart;\n      } else if (arcPos > 0) {\n        if (arcPos >= arc.numArcs) {\n          return null;\n        }\n        in.setPosition(arc.posArcsStart - arc.bytesPerArc * arcPos);\n        flags = in.readByte();\n        if (flag(flags, BIT_MISSING_ARC)) {\n          return null;\n        }\n        // point to flags that we just read\n        arc.nextArc = in.getPosition() + 1;\n      } else {\n        return null;\n      }\n      arc.arcIdx = Integer.MIN_VALUE;\n      return readNextRealArc(arc, in);\n    } else if (flags == ARCS_AS_ARRAY_PACKED) {\n      arc.numArcs = in.readVInt();\n      arc.bytesPerArc = in.readVInt();\n      arc.posArcsStart = in.getPosition();\n\n      // Array is sparse; do binary search:\n      int low = 0;\n      int high = arc.numArcs - 1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        // +1 to skip over flags\n        in.setPosition(arc.posArcsStart - (arc.bytesPerArc * mid + 1));\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid - 1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target, arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target);\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    if (in.readByte() == ARCS_AS_FIXED_ARRAY) {\n      // Arcs are full array; do binary search:\n      arc.numArcs = in.readVInt();\n      arc.bytesPerArc = in.readVInt();\n      arc.posArcsStart = in.getPosition();\n      int low = 0;\n      int high = arc.numArcs-1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        in.setPosition(arc.posArcsStart);\n        in.skipBytes(arc.bytesPerArc*mid + 1);\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid-1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target, arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54204c8a3ca26aeafd273139fc29baf70d0f6786","date":1564170395,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","sourceNew":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target() <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target();\n        }\n        arc.output = follow.nextFinalOutput();\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target() == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target());\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    byte flags = in.readByte();\n    if (flags == ARCS_AS_ARRAY_WITH_GAPS) {\n      arc.numArcs = in.readVInt();\n      arc.bytesPerArc = in.readVInt();\n      arc.posArcsStart = in.getPosition();\n\n      // Array is direct; address by label\n      in.skipBytes(1);\n      int firstLabel = readLabel(in);\n      int arcPos = labelToMatch - firstLabel;\n      if (arcPos == 0) {\n        arc.nextArc = arc.posArcsStart();\n      } else if (arcPos > 0) {\n        if (arcPos >= arc.numArcs()) {\n          return null;\n        }\n        in.setPosition(arc.posArcsStart() - arc.bytesPerArc() * arcPos);\n        flags = in.readByte();\n        if (flag(flags, BIT_MISSING_ARC)) {\n          return null;\n        }\n        // point to flags that we just read\n        arc.nextArc = in.getPosition() + 1;\n      } else {\n        return null;\n      }\n      arc.arcIdx = Integer.MIN_VALUE;\n      return readNextRealArc(arc, in);\n    } else if (flags == ARCS_AS_ARRAY_PACKED) {\n      arc.numArcs = in.readVInt();\n      arc.bytesPerArc = in.readVInt();\n      arc.posArcsStart = in.getPosition();\n\n      // Array is sparse; do binary search:\n      int low = 0;\n      int high = arc.numArcs() - 1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        // +1 to skip over flags\n        in.setPosition(arc.posArcsStart() - (arc.bytesPerArc() * mid + 1));\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid - 1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target(), arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label() == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label() > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target);\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    byte flags = in.readByte();\n    if (flags == ARCS_AS_ARRAY_WITH_GAPS) {\n      arc.numArcs = in.readVInt();\n      arc.bytesPerArc = in.readVInt();\n      arc.posArcsStart = in.getPosition();\n\n      // Array is direct; address by label\n      in.skipBytes(1);\n      int firstLabel = readLabel(in);\n      int arcPos = labelToMatch - firstLabel;\n      if (arcPos == 0) {\n        arc.nextArc = arc.posArcsStart;\n      } else if (arcPos > 0) {\n        if (arcPos >= arc.numArcs) {\n          return null;\n        }\n        in.setPosition(arc.posArcsStart - arc.bytesPerArc * arcPos);\n        flags = in.readByte();\n        if (flag(flags, BIT_MISSING_ARC)) {\n          return null;\n        }\n        // point to flags that we just read\n        arc.nextArc = in.getPosition() + 1;\n      } else {\n        return null;\n      }\n      arc.arcIdx = Integer.MIN_VALUE;\n      return readNextRealArc(arc, in);\n    } else if (flags == ARCS_AS_ARRAY_PACKED) {\n      arc.numArcs = in.readVInt();\n      arc.bytesPerArc = in.readVInt();\n      arc.posArcsStart = in.getPosition();\n\n      // Array is sparse; do binary search:\n      int low = 0;\n      int high = arc.numArcs - 1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        // +1 to skip over flags\n        in.setPosition(arc.posArcsStart - (arc.bytesPerArc * mid + 1));\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid - 1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target, arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","sourceNew":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target() <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target();\n        }\n        arc.output = follow.nextFinalOutput();\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target() == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target());\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    byte flags = in.readByte();\n    if (flags == ARCS_AS_ARRAY_WITH_GAPS) {\n      arc.numArcs = in.readVInt();\n      arc.bytesPerArc = in.readVInt();\n      arc.posArcsStart = in.getPosition();\n\n      // Array is direct; address by label\n      in.skipBytes(1);\n      int firstLabel = readLabel(in);\n      int arcPos = labelToMatch - firstLabel;\n      if (arcPos == 0) {\n        arc.nextArc = arc.posArcsStart();\n      } else if (arcPos > 0) {\n        if (arcPos >= arc.numArcs()) {\n          return null;\n        }\n        in.setPosition(arc.posArcsStart() - arc.bytesPerArc() * arcPos);\n        flags = in.readByte();\n        if (flag(flags, BIT_MISSING_ARC)) {\n          return null;\n        }\n        // point to flags that we just read\n        arc.nextArc = in.getPosition() + 1;\n      } else {\n        return null;\n      }\n      arc.arcIdx = Integer.MIN_VALUE;\n      return readNextRealArc(arc, in);\n    } else if (flags == ARCS_AS_ARRAY_PACKED) {\n      arc.numArcs = in.readVInt();\n      arc.bytesPerArc = in.readVInt();\n      arc.posArcsStart = in.getPosition();\n\n      // Array is sparse; do binary search:\n      int low = 0;\n      int high = arc.numArcs() - 1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        // +1 to skip over flags\n        in.setPosition(arc.posArcsStart() - (arc.bytesPerArc() * mid + 1));\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid - 1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target(), arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label() == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label() > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target;\n        }\n        arc.output = follow.nextFinalOutput;\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target);\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    byte flags = in.readByte();\n    if (flags == ARCS_AS_ARRAY_WITH_GAPS) {\n      arc.numArcs = in.readVInt();\n      arc.bytesPerArc = in.readVInt();\n      arc.posArcsStart = in.getPosition();\n\n      // Array is direct; address by label\n      in.skipBytes(1);\n      int firstLabel = readLabel(in);\n      int arcPos = labelToMatch - firstLabel;\n      if (arcPos == 0) {\n        arc.nextArc = arc.posArcsStart;\n      } else if (arcPos > 0) {\n        if (arcPos >= arc.numArcs) {\n          return null;\n        }\n        in.setPosition(arc.posArcsStart - arc.bytesPerArc * arcPos);\n        flags = in.readByte();\n        if (flag(flags, BIT_MISSING_ARC)) {\n          return null;\n        }\n        // point to flags that we just read\n        arc.nextArc = in.getPosition() + 1;\n      } else {\n        return null;\n      }\n      arc.arcIdx = Integer.MIN_VALUE;\n      return readNextRealArc(arc, in);\n    } else if (flags == ARCS_AS_ARRAY_PACKED) {\n      arc.numArcs = in.readVInt();\n      arc.bytesPerArc = in.readVInt();\n      arc.posArcsStart = in.getPosition();\n\n      // Array is sparse; do binary search:\n      int low = 0;\n      int high = arc.numArcs - 1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        // +1 to skip over flags\n        in.setPosition(arc.posArcsStart - (arc.bytesPerArc * mid + 1));\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid - 1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target, arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e19a701ad1d5fd2dd25e0f79bb5d81df864116b","date":1571070636,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","sourceNew":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target() <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target();\n        }\n        arc.output = follow.nextFinalOutput();\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target() == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target());\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    byte flags = in.readByte();\n    if (flags == ARCS_AS_ARRAY_PACKED) {\n      arc.numArcs = in.readVInt();\n      arc.bytesPerArc = in.readVInt();\n      arc.posArcsStart = in.getPosition();\n\n      // Array is sparse; do binary search:\n      int low = 0;\n      int high = arc.numArcs() - 1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        // +1 to skip over flags\n        in.setPosition(arc.posArcsStart() - (arc.bytesPerArc() * mid + 1));\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid - 1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target(), arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label() == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label() > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target() <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target();\n        }\n        arc.output = follow.nextFinalOutput();\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target() == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target());\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    byte flags = in.readByte();\n    if (flags == ARCS_AS_ARRAY_WITH_GAPS) {\n      arc.numArcs = in.readVInt();\n      arc.bytesPerArc = in.readVInt();\n      arc.posArcsStart = in.getPosition();\n\n      // Array is direct; address by label\n      in.skipBytes(1);\n      int firstLabel = readLabel(in);\n      int arcPos = labelToMatch - firstLabel;\n      if (arcPos == 0) {\n        arc.nextArc = arc.posArcsStart();\n      } else if (arcPos > 0) {\n        if (arcPos >= arc.numArcs()) {\n          return null;\n        }\n        in.setPosition(arc.posArcsStart() - arc.bytesPerArc() * arcPos);\n        flags = in.readByte();\n        if (flag(flags, BIT_MISSING_ARC)) {\n          return null;\n        }\n        // point to flags that we just read\n        arc.nextArc = in.getPosition() + 1;\n      } else {\n        return null;\n      }\n      arc.arcIdx = Integer.MIN_VALUE;\n      return readNextRealArc(arc, in);\n    } else if (flags == ARCS_AS_ARRAY_PACKED) {\n      arc.numArcs = in.readVInt();\n      arc.bytesPerArc = in.readVInt();\n      arc.posArcsStart = in.getPosition();\n\n      // Array is sparse; do binary search:\n      int low = 0;\n      int high = arc.numArcs() - 1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        // +1 to skip over flags\n        in.setPosition(arc.posArcsStart() - (arc.bytesPerArc() * mid + 1));\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid - 1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target(), arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label() == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label() > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","sourceNew":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target() <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target();\n        }\n        arc.output = follow.nextFinalOutput();\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target() == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target());\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    byte flags = in.readByte();\n    if (flags == ARCS_AS_ARRAY_PACKED) {\n      arc.numArcs = in.readVInt();\n      arc.bytesPerArc = in.readVInt();\n      arc.posArcsStart = in.getPosition();\n\n      // Array is sparse; do binary search:\n      int low = 0;\n      int high = arc.numArcs() - 1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        // +1 to skip over flags\n        in.setPosition(arc.posArcsStart() - (arc.bytesPerArc() * mid + 1));\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid - 1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target(), arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label() == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label() > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target() <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target();\n        }\n        arc.output = follow.nextFinalOutput();\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target() == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target());\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    byte flags = in.readByte();\n    if (flags == ARCS_AS_ARRAY_WITH_GAPS) {\n      arc.numArcs = in.readVInt();\n      arc.bytesPerArc = in.readVInt();\n      arc.posArcsStart = in.getPosition();\n\n      // Array is direct; address by label\n      in.skipBytes(1);\n      int firstLabel = readLabel(in);\n      int arcPos = labelToMatch - firstLabel;\n      if (arcPos == 0) {\n        arc.nextArc = arc.posArcsStart();\n      } else if (arcPos > 0) {\n        if (arcPos >= arc.numArcs()) {\n          return null;\n        }\n        in.setPosition(arc.posArcsStart() - arc.bytesPerArc() * arcPos);\n        flags = in.readByte();\n        if (flag(flags, BIT_MISSING_ARC)) {\n          return null;\n        }\n        // point to flags that we just read\n        arc.nextArc = in.getPosition() + 1;\n      } else {\n        return null;\n      }\n      arc.arcIdx = Integer.MIN_VALUE;\n      return readNextRealArc(arc, in);\n    } else if (flags == ARCS_AS_ARRAY_PACKED) {\n      arc.numArcs = in.readVInt();\n      arc.bytesPerArc = in.readVInt();\n      arc.posArcsStart = in.getPosition();\n\n      // Array is sparse; do binary search:\n      int low = 0;\n      int high = arc.numArcs() - 1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        // +1 to skip over flags\n        in.setPosition(arc.posArcsStart() - (arc.bytesPerArc() * mid + 1));\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid - 1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target(), arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label() == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label() > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71d31a7d5773508492505519bb5230b87c8937ad","date":1573681693,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","sourceNew":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target() <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target();\n        }\n        arc.output = follow.nextFinalOutput();\n        arc.label = END_LABEL;\n        arc.nodeFlags = arc.flags;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target() == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target());\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    byte flags = arc.nodeFlags = in.readByte();\n    if (flags == ARCS_FOR_DIRECT_ADDRESSING) {\n      arc.numArcs = in.readVInt(); // This is in fact the label range.\n      arc.bytesPerArc = in.readVInt();\n      readPresenceBytes(arc, in);\n      arc.firstLabel = readLabel(in);\n      arc.posArcsStart = in.getPosition();\n\n      int arcIndex = labelToMatch - arc.firstLabel();\n      if (arcIndex < 0 || arcIndex >= arc.numArcs()) {\n        return null; // Before or after label range.\n      } else if (!arc.bitTable().isBitSet(arcIndex)) {\n        return null; // Arc missing in the range.\n      }\n      return readArcByDirectAddressing(arc, in, arcIndex);\n    } else if (flags == ARCS_FOR_BINARY_SEARCH) {\n      arc.numArcs = in.readVInt();\n      arc.bytesPerArc = in.readVInt();\n      arc.posArcsStart = in.getPosition();\n\n      // Array is sparse; do binary search:\n      int low = 0;\n      int high = arc.numArcs() - 1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        // +1 to skip over flags\n        in.setPosition(arc.posArcsStart() - (arc.bytesPerArc() * mid + 1));\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid - 1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target(), arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label() == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label() > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target() <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target();\n        }\n        arc.output = follow.nextFinalOutput();\n        arc.label = END_LABEL;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target() == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target());\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    byte flags = in.readByte();\n    if (flags == ARCS_AS_ARRAY_PACKED) {\n      arc.numArcs = in.readVInt();\n      arc.bytesPerArc = in.readVInt();\n      arc.posArcsStart = in.getPosition();\n\n      // Array is sparse; do binary search:\n      int low = 0;\n      int high = arc.numArcs() - 1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        // +1 to skip over flags\n        in.setPosition(arc.posArcsStart() - (arc.bytesPerArc() * mid + 1));\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid - 1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target(), arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label() == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label() > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cfe04a006c42318f41df58bdd061cc1065b5f688","date":1574780842,"type":4,"author":"Bruno Roustant","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#findTargetArc(int,Arc[T],Arc[T],BytesReader,boolean).mjava","sourceNew":null,"sourceOld":"  /** Finds an arc leaving the incoming arc, replacing the arc in place.\n   *  This returns null if the arc was not found, else the incoming arc. */\n  private Arc<T> findTargetArc(int labelToMatch, Arc<T> follow, Arc<T> arc, BytesReader in, boolean useRootArcCache) throws IOException {\n\n    if (labelToMatch == END_LABEL) {\n      if (follow.isFinal()) {\n        if (follow.target() <= 0) {\n          arc.flags = BIT_LAST_ARC;\n        } else {\n          arc.flags = 0;\n          // NOTE: nextArc is a node (not an address!) in this case:\n          arc.nextArc = follow.target();\n        }\n        arc.output = follow.nextFinalOutput();\n        arc.label = END_LABEL;\n        arc.nodeFlags = arc.flags;\n        return arc;\n      } else {\n        return null;\n      }\n    }\n\n    // Short-circuit if this arc is in the root arc cache:\n    if (useRootArcCache && cachedRootArcs != null && follow.target() == startNode && labelToMatch < cachedRootArcs.length) {\n      final Arc<T> result = cachedRootArcs[labelToMatch];\n\n      // LUCENE-5152: detect tricky cases where caller\n      // modified previously returned cached root-arcs:\n      assert assertRootCachedArc(labelToMatch, result);\n\n      if (result == null) {\n        return null;\n      } else {\n        arc.copyFrom(result);\n        return arc;\n      }\n    }\n\n    if (!targetHasArcs(follow)) {\n      return null;\n    }\n\n    in.setPosition(follow.target());\n\n    // System.out.println(\"fta label=\" + (char) labelToMatch);\n\n    byte flags = arc.nodeFlags = in.readByte();\n    if (flags == ARCS_FOR_DIRECT_ADDRESSING) {\n      arc.numArcs = in.readVInt(); // This is in fact the label range.\n      arc.bytesPerArc = in.readVInt();\n      readPresenceBytes(arc, in);\n      arc.firstLabel = readLabel(in);\n      arc.posArcsStart = in.getPosition();\n\n      int arcIndex = labelToMatch - arc.firstLabel();\n      if (arcIndex < 0 || arcIndex >= arc.numArcs()) {\n        return null; // Before or after label range.\n      } else if (!arc.bitTable().isBitSet(arcIndex)) {\n        return null; // Arc missing in the range.\n      }\n      return readArcByDirectAddressing(arc, in, arcIndex);\n    } else if (flags == ARCS_FOR_BINARY_SEARCH) {\n      arc.numArcs = in.readVInt();\n      arc.bytesPerArc = in.readVInt();\n      arc.posArcsStart = in.getPosition();\n\n      // Array is sparse; do binary search:\n      int low = 0;\n      int high = arc.numArcs() - 1;\n      while (low <= high) {\n        //System.out.println(\"    cycle\");\n        int mid = (low + high) >>> 1;\n        // +1 to skip over flags\n        in.setPosition(arc.posArcsStart() - (arc.bytesPerArc() * mid + 1));\n        int midLabel = readLabel(in);\n        final int cmp = midLabel - labelToMatch;\n        if (cmp < 0) {\n          low = mid + 1;\n        } else if (cmp > 0) {\n          high = mid - 1;\n        } else {\n          arc.arcIdx = mid - 1;\n          //System.out.println(\"    found!\");\n          return readNextRealArc(arc, in);\n        }\n      }\n      return null;\n    }\n\n    // Linear scan\n    readFirstRealTargetArc(follow.target(), arc, in);\n\n    while(true) {\n      //System.out.println(\"  non-bs cycle\");\n      // TODO: we should fix this code to not have to create\n      // object for the output of every arc we scan... only\n      // for the matching arc, if found\n      if (arc.label() == labelToMatch) {\n        //System.out.println(\"    found!\");\n        return arc;\n      } else if (arc.label() > labelToMatch) {\n        return null;\n      } else if (arc.isLast()) {\n        return null;\n      } else {\n        readNextRealArc(arc, in);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c0e7448656541edc407546460641f47950451b16":["9cbc4730743fac2e69e7d622848778d3ad9f2151"],"9cbc4730743fac2e69e7d622848778d3ad9f2151":["6244579a467d5f2673ac98265d74bddbea1a8114"],"6244579a467d5f2673ac98265d74bddbea1a8114":["7f32ed90e12610550e1363aea43afe3d6e292cf9"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["7f32ed90e12610550e1363aea43afe3d6e292cf9","6244579a467d5f2673ac98265d74bddbea1a8114"],"71d31a7d5773508492505519bb5230b87c8937ad":["3e19a701ad1d5fd2dd25e0f79bb5d81df864116b"],"ae67e1f82a53594208ca929f382ee861dad3d7a8":["c0e7448656541edc407546460641f47950451b16"],"f8061ddd97f3352007d927dae445884a6f3d857b":["ae67e1f82a53594208ca929f382ee861dad3d7a8","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"cfe04a006c42318f41df58bdd061cc1065b5f688":["71d31a7d5773508492505519bb5230b87c8937ad"],"54204c8a3ca26aeafd273139fc29baf70d0f6786":["ae67e1f82a53594208ca929f382ee861dad3d7a8"],"58884af1f68e9d61c217c753fbd6266d86a63b14":["6244579a467d5f2673ac98265d74bddbea1a8114","9cbc4730743fac2e69e7d622848778d3ad9f2151"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":["6244579a467d5f2673ac98265d74bddbea1a8114","9cbc4730743fac2e69e7d622848778d3ad9f2151"],"3e19a701ad1d5fd2dd25e0f79bb5d81df864116b":["54204c8a3ca26aeafd273139fc29baf70d0f6786"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cfe04a006c42318f41df58bdd061cc1065b5f688"],"7f32ed90e12610550e1363aea43afe3d6e292cf9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b0b597c65628ca9e73913a07e81691f8229bae35":["54204c8a3ca26aeafd273139fc29baf70d0f6786","3e19a701ad1d5fd2dd25e0f79bb5d81df864116b"]},"commit2Childs":{"c0e7448656541edc407546460641f47950451b16":["ae67e1f82a53594208ca929f382ee861dad3d7a8"],"9cbc4730743fac2e69e7d622848778d3ad9f2151":["c0e7448656541edc407546460641f47950451b16","58884af1f68e9d61c217c753fbd6266d86a63b14","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be"],"6244579a467d5f2673ac98265d74bddbea1a8114":["9cbc4730743fac2e69e7d622848778d3ad9f2151","199dfa410f1fdbfd3294106b04096cce5ed34b21","58884af1f68e9d61c217c753fbd6266d86a63b14","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"71d31a7d5773508492505519bb5230b87c8937ad":["cfe04a006c42318f41df58bdd061cc1065b5f688"],"ae67e1f82a53594208ca929f382ee861dad3d7a8":["f8061ddd97f3352007d927dae445884a6f3d857b","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"cfe04a006c42318f41df58bdd061cc1065b5f688":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"54204c8a3ca26aeafd273139fc29baf70d0f6786":["f8061ddd97f3352007d927dae445884a6f3d857b","3e19a701ad1d5fd2dd25e0f79bb5d81df864116b","b0b597c65628ca9e73913a07e81691f8229bae35"],"58884af1f68e9d61c217c753fbd6266d86a63b14":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7f32ed90e12610550e1363aea43afe3d6e292cf9"],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":[],"3e19a701ad1d5fd2dd25e0f79bb5d81df864116b":["71d31a7d5773508492505519bb5230b87c8937ad","b0b597c65628ca9e73913a07e81691f8229bae35"],"7f32ed90e12610550e1363aea43afe3d6e292cf9":["6244579a467d5f2673ac98265d74bddbea1a8114","199dfa410f1fdbfd3294106b04096cce5ed34b21"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["199dfa410f1fdbfd3294106b04096cce5ed34b21","f8061ddd97f3352007d927dae445884a6f3d857b","58884af1f68e9d61c217c753fbd6266d86a63b14","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}