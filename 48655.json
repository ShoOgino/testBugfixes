{"path":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","commits":[{"id":"5ebb742ffd3fae76a577a68de595d711f43e6944","date":1305546231,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","pathOld":"/dev/null","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final PerDocValues perDocValues = reader.perDocValues();\n          final DocValues docValues = perDocValues.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final DocValuesEnum values = docValues.getEnum();\n          while (values.nextDoc() != DocValuesEnum.NO_MORE_DOCS) {\n            switch (fieldInfo.docValues) {\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_SORTED:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_SORTED:\n            case BYTES_VAR_STRAIGHT:\n              values.bytes();\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat();\n              break;\n            case INTS:\n              values.getInt();\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                  + \" - no such DocValues type: \" + fieldInfo.docValues);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["381d580ec52adb3c6976ebe95b15943af3af7dcb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"41e5bbad683f7546e96f08ffe8bc50cf447f2586","date":1307113213,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final PerDocValues perDocValues = reader.perDocValues();\n          final IndexDocValues docValues = perDocValues.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final DocValuesEnum values = docValues.getEnum();\n          while (values.nextDoc() != DocValuesEnum.NO_MORE_DOCS) {\n            switch (fieldInfo.docValues) {\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_SORTED:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_SORTED:\n            case BYTES_VAR_STRAIGHT:\n              values.bytes();\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat();\n              break;\n            case INTS:\n              values.getInt();\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                  + \" - no such DocValues type: \" + fieldInfo.docValues);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final PerDocValues perDocValues = reader.perDocValues();\n          final DocValues docValues = perDocValues.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final DocValuesEnum values = docValues.getEnum();\n          while (values.nextDoc() != DocValuesEnum.NO_MORE_DOCS) {\n            switch (fieldInfo.docValues) {\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_SORTED:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_SORTED:\n            case BYTES_VAR_STRAIGHT:\n              values.bytes();\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat();\n              break;\n            case INTS:\n              values.getInt();\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                  + \" - no such DocValues type: \" + fieldInfo.docValues);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"605b061fadf71aa6458c0005eaae83a98350c403","date":1307117658,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final PerDocValues perDocValues = reader.perDocValues();\n          final IndexDocValues docValues = perDocValues.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final ValuesEnum values = docValues.getEnum();\n          while (values.nextDoc() != ValuesEnum.NO_MORE_DOCS) {\n            switch (fieldInfo.docValues) {\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_SORTED:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_SORTED:\n            case BYTES_VAR_STRAIGHT:\n              values.bytes();\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat();\n              break;\n            case INTS:\n              values.getInt();\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                  + \" - no such DocValues type: \" + fieldInfo.docValues);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final PerDocValues perDocValues = reader.perDocValues();\n          final IndexDocValues docValues = perDocValues.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final DocValuesEnum values = docValues.getEnum();\n          while (values.nextDoc() != DocValuesEnum.NO_MORE_DOCS) {\n            switch (fieldInfo.docValues) {\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_SORTED:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_SORTED:\n            case BYTES_VAR_STRAIGHT:\n              values.bytes();\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat();\n              break;\n            case INTS:\n              values.getInt();\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                  + \" - no such DocValues type: \" + fieldInfo.docValues);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2e8d7ba2175f47e280231533f7d3016249cea88b","date":1307711934,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","pathOld":"/dev/null","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final PerDocValues perDocValues = reader.perDocValues();\n          final IndexDocValues docValues = perDocValues.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final ValuesEnum values = docValues.getEnum();\n          while (values.nextDoc() != ValuesEnum.NO_MORE_DOCS) {\n            switch (fieldInfo.docValues) {\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_SORTED:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_SORTED:\n            case BYTES_VAR_STRAIGHT:\n              values.bytes();\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat();\n              break;\n            case INTS:\n              values.getInt();\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                  + \" - no such DocValues type: \" + fieldInfo.docValues);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","pathOld":"/dev/null","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final PerDocValues perDocValues = reader.perDocValues();\n          final IndexDocValues docValues = perDocValues.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final ValuesEnum values = docValues.getEnum();\n          while (values.nextDoc() != ValuesEnum.NO_MORE_DOCS) {\n            switch (fieldInfo.docValues) {\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_SORTED:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_SORTED:\n            case BYTES_VAR_STRAIGHT:\n              values.bytes();\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat();\n              break;\n            case INTS:\n              values.getInt();\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                  + \" - no such DocValues type: \" + fieldInfo.docValues);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93c59ad5034eecd863f267bd75e1df7b8a51e427","date":1309162882,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final PerDocValues perDocValues = reader.perDocValues();\n          final IndexDocValues docValues = perDocValues.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final ValuesEnum values = docValues.getEnum();\n          while (values.nextDoc() != ValuesEnum.NO_MORE_DOCS) {\n            switch (fieldInfo.docValues) {\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_SORTED:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_SORTED:\n            case BYTES_VAR_STRAIGHT:\n              values.bytes();\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat();\n              break;\n            case VAR_INTS:\n            case FIXED_INTS_16:\n            case FIXED_INTS_32:\n            case FIXED_INTS_64:\n            case FIXED_INTS_8:\n              values.getInt();\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                  + \" - no such DocValues type: \" + fieldInfo.docValues);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final PerDocValues perDocValues = reader.perDocValues();\n          final IndexDocValues docValues = perDocValues.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final ValuesEnum values = docValues.getEnum();\n          while (values.nextDoc() != ValuesEnum.NO_MORE_DOCS) {\n            switch (fieldInfo.docValues) {\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_SORTED:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_SORTED:\n            case BYTES_VAR_STRAIGHT:\n              values.bytes();\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat();\n              break;\n            case INTS:\n              values.getInt();\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                  + \" - no such DocValues type: \" + fieldInfo.docValues);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","bugFix":null,"bugIntro":["381d580ec52adb3c6976ebe95b15943af3af7dcb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final PerDocValues perDocValues = reader.perDocValues();\n          final IndexDocValues docValues = perDocValues.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final ValuesEnum values = docValues.getEnum();\n          while (values.nextDoc() != ValuesEnum.NO_MORE_DOCS) {\n            switch (fieldInfo.docValues) {\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_SORTED:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_SORTED:\n            case BYTES_VAR_STRAIGHT:\n              values.bytes();\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat();\n              break;\n            case VAR_INTS:\n            case FIXED_INTS_16:\n            case FIXED_INTS_32:\n            case FIXED_INTS_64:\n            case FIXED_INTS_8:\n              values.getInt();\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                  + \" - no such DocValues type: \" + fieldInfo.docValues);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final PerDocValues perDocValues = reader.perDocValues();\n          final IndexDocValues docValues = perDocValues.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final ValuesEnum values = docValues.getEnum();\n          while (values.nextDoc() != ValuesEnum.NO_MORE_DOCS) {\n            switch (fieldInfo.docValues) {\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_SORTED:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_SORTED:\n            case BYTES_VAR_STRAIGHT:\n              values.bytes();\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat();\n              break;\n            case INTS:\n              values.getInt();\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                  + \" - no such DocValues type: \" + fieldInfo.docValues);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final PerDocValues perDocValues = reader.perDocValues();\n          final IndexDocValues docValues = perDocValues.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final ValuesEnum values = docValues.getEnum();\n          while (values.nextDoc() != ValuesEnum.NO_MORE_DOCS) {\n            switch (fieldInfo.docValues) {\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_SORTED:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_SORTED:\n            case BYTES_VAR_STRAIGHT:\n              values.bytes();\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat();\n              break;\n            case VAR_INTS:\n            case FIXED_INTS_16:\n            case FIXED_INTS_32:\n            case FIXED_INTS_64:\n            case FIXED_INTS_8:\n              values.getInt();\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                  + \" - no such DocValues type: \" + fieldInfo.docValues);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final PerDocValues perDocValues = reader.perDocValues();\n          final IndexDocValues docValues = perDocValues.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final ValuesEnum values = docValues.getEnum();\n          while (values.nextDoc() != ValuesEnum.NO_MORE_DOCS) {\n            switch (fieldInfo.docValues) {\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_SORTED:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_SORTED:\n            case BYTES_VAR_STRAIGHT:\n              values.bytes();\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat();\n              break;\n            case INTS:\n              values.getInt();\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                  + \" - no such DocValues type: \" + fieldInfo.docValues);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e128967bca58657bc0039d4bfe631e63e81f1977","date":1317978310,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final PerDocValues perDocValues = reader.perDocValues();\n          final IndexDocValues docValues = perDocValues.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final Source values = docValues.getDirectSource();\n          final int maxDoc = reader.maxDoc();\n          for (int i = 0; i < maxDoc; i++) {\n            switch (fieldInfo.docValues) {\n            case BYTES_FIXED_SORTED:\n            case BYTES_VAR_SORTED:\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_STRAIGHT:\n              values.getBytes(i, new BytesRef());\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat(i);\n              break;\n            case VAR_INTS:\n            case FIXED_INTS_16:\n            case FIXED_INTS_32:\n            case FIXED_INTS_64:\n            case FIXED_INTS_8:\n              values.getInt(i);\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                  + \" - no such DocValues type: \" + fieldInfo.docValues);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final PerDocValues perDocValues = reader.perDocValues();\n          final IndexDocValues docValues = perDocValues.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final ValuesEnum values = docValues.getEnum();\n          while (values.nextDoc() != ValuesEnum.NO_MORE_DOCS) {\n            switch (fieldInfo.docValues) {\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_SORTED:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_SORTED:\n            case BYTES_VAR_STRAIGHT:\n              values.bytes();\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat();\n              break;\n            case VAR_INTS:\n            case FIXED_INTS_16:\n            case FIXED_INTS_32:\n            case FIXED_INTS_64:\n            case FIXED_INTS_8:\n              values.getInt();\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                  + \" - no such DocValues type: \" + fieldInfo.docValues);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","bugFix":null,"bugIntro":["381d580ec52adb3c6976ebe95b15943af3af7dcb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ecd41ba3cdd1b4d825aa53d1987e4360cf45cb05","date":1323284809,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final PerDocValues perDocValues = reader.perDocValues();\n          final IndexDocValues docValues = perDocValues.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final Source values = docValues.getDirectSource();\n          final int maxDoc = reader.maxDoc();\n          for (int i = 0; i < maxDoc; i++) {\n            switch (fieldInfo.getDocValuesType()) {\n            case BYTES_FIXED_SORTED:\n            case BYTES_VAR_SORTED:\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_STRAIGHT:\n              values.getBytes(i, new BytesRef());\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat(i);\n              break;\n            case VAR_INTS:\n            case FIXED_INTS_16:\n            case FIXED_INTS_32:\n            case FIXED_INTS_64:\n            case FIXED_INTS_8:\n              values.getInt(i);\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                          + \" - no such DocValues type: \" + fieldInfo.getDocValuesType());\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final PerDocValues perDocValues = reader.perDocValues();\n          final IndexDocValues docValues = perDocValues.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final Source values = docValues.getDirectSource();\n          final int maxDoc = reader.maxDoc();\n          for (int i = 0; i < maxDoc; i++) {\n            switch (fieldInfo.docValues) {\n            case BYTES_FIXED_SORTED:\n            case BYTES_VAR_SORTED:\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_STRAIGHT:\n              values.getBytes(i, new BytesRef());\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat(i);\n              break;\n            case VAR_INTS:\n            case FIXED_INTS_16:\n            case FIXED_INTS_32:\n            case FIXED_INTS_64:\n            case FIXED_INTS_8:\n              values.getInt(i);\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                  + \" - no such DocValues type: \" + fieldInfo.docValues);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","bugFix":null,"bugIntro":["381d580ec52adb3c6976ebe95b15943af3af7dcb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe","date":1323449025,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final PerDocValues perDocValues = reader.perDocValues();\n          final DocValues docValues = perDocValues.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final Source values = docValues.getDirectSource();\n          final int maxDoc = reader.maxDoc();\n          for (int i = 0; i < maxDoc; i++) {\n            switch (fieldInfo.getDocValuesType()) {\n            case BYTES_FIXED_SORTED:\n            case BYTES_VAR_SORTED:\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_STRAIGHT:\n              values.getBytes(i, new BytesRef());\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat(i);\n              break;\n            case VAR_INTS:\n            case FIXED_INTS_16:\n            case FIXED_INTS_32:\n            case FIXED_INTS_64:\n            case FIXED_INTS_8:\n              values.getInt(i);\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                          + \" - no such DocValues type: \" + fieldInfo.getDocValuesType());\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final PerDocValues perDocValues = reader.perDocValues();\n          final IndexDocValues docValues = perDocValues.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final Source values = docValues.getDirectSource();\n          final int maxDoc = reader.maxDoc();\n          for (int i = 0; i < maxDoc; i++) {\n            switch (fieldInfo.getDocValuesType()) {\n            case BYTES_FIXED_SORTED:\n            case BYTES_VAR_SORTED:\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_STRAIGHT:\n              values.getBytes(i, new BytesRef());\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat(i);\n              break;\n            case VAR_INTS:\n            case FIXED_INTS_16:\n            case FIXED_INTS_32:\n            case FIXED_INTS_64:\n            case FIXED_INTS_8:\n              values.getInt(i);\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                          + \" - no such DocValues type: \" + fieldInfo.getDocValuesType());\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cac4d5fa6c305b94f6232a70bda07f096ad0348c","date":1323538980,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final DocValues docValues = reader.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final Source values = docValues.getDirectSource();\n          final int maxDoc = reader.maxDoc();\n          for (int i = 0; i < maxDoc; i++) {\n            switch (fieldInfo.getDocValuesType()) {\n            case BYTES_FIXED_SORTED:\n            case BYTES_VAR_SORTED:\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_STRAIGHT:\n              values.getBytes(i, new BytesRef());\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat(i);\n              break;\n            case VAR_INTS:\n            case FIXED_INTS_16:\n            case FIXED_INTS_32:\n            case FIXED_INTS_64:\n            case FIXED_INTS_8:\n              values.getInt(i);\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                          + \" - no such DocValues type: \" + fieldInfo.getDocValuesType());\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final PerDocValues perDocValues = reader.perDocValues();\n          final DocValues docValues = perDocValues.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final Source values = docValues.getDirectSource();\n          final int maxDoc = reader.maxDoc();\n          for (int i = 0; i < maxDoc; i++) {\n            switch (fieldInfo.getDocValuesType()) {\n            case BYTES_FIXED_SORTED:\n            case BYTES_VAR_SORTED:\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_STRAIGHT:\n              values.getBytes(i, new BytesRef());\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat(i);\n              break;\n            case VAR_INTS:\n            case FIXED_INTS_16:\n            case FIXED_INTS_32:\n            case FIXED_INTS_64:\n            case FIXED_INTS_8:\n              values.getInt(i);\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                          + \" - no such DocValues type: \" + fieldInfo.getDocValuesType());\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a1c385b88a2532c3fbcb9082d04be2a1433f2762","date":1323553474,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final DocValues docValues = reader.docValues(fieldInfo.name);\n          if (docValues == null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" omits docvalues but should have them!\");\n          }\n          DocValues.Type type = docValues.type();\n          if (type != fieldInfo.getDocValuesType()) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has type: \" + type + \" but fieldInfos says:\" + fieldInfo.getDocValuesType());\n          }\n          final Source values = docValues.getDirectSource();\n          final int maxDoc = reader.maxDoc();\n          int size = docValues.getValueSize();\n          for (int i = 0; i < maxDoc; i++) {\n            switch (fieldInfo.getDocValuesType()) {\n            case BYTES_FIXED_SORTED:\n            case BYTES_VAR_SORTED:\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_STRAIGHT:\n              BytesRef bytes = new BytesRef();\n              values.getBytes(i, bytes);\n              if (size != -1 && size != bytes.length) {\n                throw new RuntimeException(\"field: \" + fieldInfo.name + \" returned wrongly sized bytes, was: \" + bytes.length + \" should be: \" + size);\n              }\n              break;\n            case FLOAT_32:\n              assert size == 4;\n              values.getFloat(i);\n              break;\n            case FLOAT_64:\n              assert size == 8;\n              values.getFloat(i);\n              break;\n            case VAR_INTS:\n              assert size == -1;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_16:\n              assert size == 2;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_32:\n              assert size == 4;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_64:\n              assert size == 8;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_8:\n              assert size == 1;\n              values.getInt(i);\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                          + \" - no such DocValues type: \" + fieldInfo.getDocValuesType());\n            }\n          }\n          if (type == DocValues.Type.BYTES_FIXED_SORTED || type == DocValues.Type.BYTES_VAR_SORTED) {\n            // check sorted bytes\n            SortedSource sortedValues = values.asSortedSource();\n            Comparator<BytesRef> comparator = sortedValues.getComparator();\n            int lastOrd = -1;\n            BytesRef lastBytes = new BytesRef();\n            for (int i = 0; i < maxDoc; i++) {\n              int ord = sortedValues.ord(i);\n              if (ord < 0 || ord > maxDoc) {\n                throw new RuntimeException(\"field: \" + fieldInfo.name + \" ord is out of bounds: \" + ord);\n              }\n              BytesRef bytes = new BytesRef();\n              sortedValues.getByOrd(ord, bytes);\n              if (lastOrd != -1) {\n                int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));\n                int bytesComp = Integer.signum(comparator.compare(bytes, lastBytes));\n                if (ordComp != bytesComp) {\n                  throw new RuntimeException(\"field: \" + fieldInfo.name + \" ord comparison is wrong: \" + ordComp + \" comparator claims: \" + bytesComp);\n                }\n              }\n              lastOrd = ord;\n              lastBytes = bytes;\n            }\n          }\n        } else {\n          if (reader.docValues(fieldInfo.name) != null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has docvalues but should omit them!\");\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final DocValues docValues = reader.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final Source values = docValues.getDirectSource();\n          final int maxDoc = reader.maxDoc();\n          for (int i = 0; i < maxDoc; i++) {\n            switch (fieldInfo.getDocValuesType()) {\n            case BYTES_FIXED_SORTED:\n            case BYTES_VAR_SORTED:\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_STRAIGHT:\n              values.getBytes(i, new BytesRef());\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat(i);\n              break;\n            case VAR_INTS:\n            case FIXED_INTS_16:\n            case FIXED_INTS_32:\n            case FIXED_INTS_64:\n            case FIXED_INTS_8:\n              values.getInt(i);\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                          + \" - no such DocValues type: \" + fieldInfo.getDocValuesType());\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","bugFix":null,"bugIntro":["381d580ec52adb3c6976ebe95b15943af3af7dcb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d638301ad1cfcae567b681b893bc8781f0ee48a5","date":1323801546,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final DocValues docValues = reader.docValues(fieldInfo.name);\n          if (docValues == null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" omits docvalues but should have them!\");\n          }\n          DocValues.Type type = docValues.type();\n          if (type != fieldInfo.getDocValuesType()) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has type: \" + type + \" but fieldInfos says:\" + fieldInfo.getDocValuesType());\n          }\n          final Source values = docValues.getDirectSource();\n          final int maxDoc = reader.maxDoc();\n          int size = docValues.getValueSize();\n          for (int i = 0; i < maxDoc; i++) {\n            switch (fieldInfo.getDocValuesType()) {\n            case BYTES_FIXED_SORTED:\n            case BYTES_VAR_SORTED:\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_STRAIGHT:\n              BytesRef bytes = new BytesRef();\n              values.getBytes(i, bytes);\n              if (size != -1 && size != bytes.length) {\n                throw new RuntimeException(\"field: \" + fieldInfo.name + \" returned wrongly sized bytes, was: \" + bytes.length + \" should be: \" + size);\n              }\n              break;\n            case FLOAT_32:\n              assert size == 4;\n              values.getFloat(i);\n              break;\n            case FLOAT_64:\n              assert size == 8;\n              values.getFloat(i);\n              break;\n            case VAR_INTS:\n              assert size == -1;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_16:\n              assert size == 2;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_32:\n              assert size == 4;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_64:\n              assert size == 8;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_8:\n              assert size == 1;\n              values.getInt(i);\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                          + \" - no such DocValues type: \" + fieldInfo.getDocValuesType());\n            }\n          }\n          if (type == DocValues.Type.BYTES_FIXED_SORTED || type == DocValues.Type.BYTES_VAR_SORTED) {\n            // check sorted bytes\n            SortedSource sortedValues = values.asSortedSource();\n            Comparator<BytesRef> comparator = sortedValues.getComparator();\n            int lastOrd = -1;\n            BytesRef lastBytes = new BytesRef();\n            for (int i = 0; i < maxDoc; i++) {\n              int ord = sortedValues.ord(i);\n              if (ord < 0 || ord > maxDoc) {\n                throw new RuntimeException(\"field: \" + fieldInfo.name + \" ord is out of bounds: \" + ord);\n              }\n              BytesRef bytes = new BytesRef();\n              sortedValues.getByOrd(ord, bytes);\n              if (lastOrd != -1) {\n                int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));\n                int bytesComp = Integer.signum(comparator.compare(bytes, lastBytes));\n                if (ordComp != bytesComp) {\n                  throw new RuntimeException(\"field: \" + fieldInfo.name + \" ord comparison is wrong: \" + ordComp + \" comparator claims: \" + bytesComp);\n                }\n              }\n              lastOrd = ord;\n              lastBytes = bytes;\n            }\n          }\n        } else {\n          if (reader.docValues(fieldInfo.name) != null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has docvalues but should omit them!\");\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final PerDocValues perDocValues = reader.perDocValues();\n          final IndexDocValues docValues = perDocValues.docValues(fieldInfo.name);\n          if (docValues == null) {\n            continue;\n          }\n          final Source values = docValues.getDirectSource();\n          final int maxDoc = reader.maxDoc();\n          for (int i = 0; i < maxDoc; i++) {\n            switch (fieldInfo.docValues) {\n            case BYTES_FIXED_SORTED:\n            case BYTES_VAR_SORTED:\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_STRAIGHT:\n              values.getBytes(i, new BytesRef());\n              break;\n            case FLOAT_32:\n            case FLOAT_64:\n              values.getFloat(i);\n              break;\n            case VAR_INTS:\n            case FIXED_INTS_16:\n            case FIXED_INTS_32:\n            case FIXED_INTS_64:\n            case FIXED_INTS_8:\n              values.getInt(i);\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                  + \" - no such DocValues type: \" + fieldInfo.docValues);\n            }\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#testDocValues(SegmentInfo,SegmentReader).mjava","sourceNew":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final DocValues docValues = reader.docValues(fieldInfo.name);\n          if (docValues == null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" omits docvalues but should have them!\");\n          }\n          DocValues.Type type = docValues.type();\n          if (type != fieldInfo.getDocValuesType()) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has type: \" + type + \" but fieldInfos says:\" + fieldInfo.getDocValuesType());\n          }\n          final Source values = docValues.getDirectSource();\n          final int maxDoc = reader.maxDoc();\n          int size = docValues.getValueSize();\n          for (int i = 0; i < maxDoc; i++) {\n            switch (fieldInfo.getDocValuesType()) {\n            case BYTES_FIXED_SORTED:\n            case BYTES_VAR_SORTED:\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_STRAIGHT:\n              BytesRef bytes = new BytesRef();\n              values.getBytes(i, bytes);\n              if (size != -1 && size != bytes.length) {\n                throw new RuntimeException(\"field: \" + fieldInfo.name + \" returned wrongly sized bytes, was: \" + bytes.length + \" should be: \" + size);\n              }\n              break;\n            case FLOAT_32:\n              assert size == 4;\n              values.getFloat(i);\n              break;\n            case FLOAT_64:\n              assert size == 8;\n              values.getFloat(i);\n              break;\n            case VAR_INTS:\n              assert size == -1;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_16:\n              assert size == 2;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_32:\n              assert size == 4;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_64:\n              assert size == 8;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_8:\n              assert size == 1;\n              values.getInt(i);\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                          + \" - no such DocValues type: \" + fieldInfo.getDocValuesType());\n            }\n          }\n          if (type == DocValues.Type.BYTES_FIXED_SORTED || type == DocValues.Type.BYTES_VAR_SORTED) {\n            // check sorted bytes\n            SortedSource sortedValues = values.asSortedSource();\n            Comparator<BytesRef> comparator = sortedValues.getComparator();\n            int lastOrd = -1;\n            BytesRef lastBytes = new BytesRef();\n            for (int i = 0; i < maxDoc; i++) {\n              int ord = sortedValues.ord(i);\n              if (ord < 0 || ord > maxDoc) {\n                throw new RuntimeException(\"field: \" + fieldInfo.name + \" ord is out of bounds: \" + ord);\n              }\n              BytesRef bytes = new BytesRef();\n              sortedValues.getByOrd(ord, bytes);\n              if (lastOrd != -1) {\n                int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));\n                int bytesComp = Integer.signum(comparator.compare(bytes, lastBytes));\n                if (ordComp != bytesComp) {\n                  throw new RuntimeException(\"field: \" + fieldInfo.name + \" ord comparison is wrong: \" + ordComp + \" comparator claims: \" + bytesComp);\n                }\n              }\n              lastOrd = ord;\n              lastBytes = bytes;\n            }\n          }\n        } else {\n          if (reader.docValues(fieldInfo.name) != null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has docvalues but should omit them!\");\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","sourceOld":"  private Status.DocValuesStatus testDocValues(SegmentInfo info,\n      SegmentReader reader) {\n    final Status.DocValuesStatus status = new Status.DocValuesStatus();\n    try {\n      if (infoStream != null) {\n        infoStream.print(\"    test: DocValues........\");\n      }\n      final FieldInfos fieldInfos = info.getFieldInfos();\n      for (FieldInfo fieldInfo : fieldInfos) {\n        if (fieldInfo.hasDocValues()) {\n          status.totalValueFields++;\n          final DocValues docValues = reader.docValues(fieldInfo.name);\n          if (docValues == null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" omits docvalues but should have them!\");\n          }\n          DocValues.Type type = docValues.type();\n          if (type != fieldInfo.getDocValuesType()) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has type: \" + type + \" but fieldInfos says:\" + fieldInfo.getDocValuesType());\n          }\n          final Source values = docValues.getDirectSource();\n          final int maxDoc = reader.maxDoc();\n          int size = docValues.getValueSize();\n          for (int i = 0; i < maxDoc; i++) {\n            switch (fieldInfo.getDocValuesType()) {\n            case BYTES_FIXED_SORTED:\n            case BYTES_VAR_SORTED:\n            case BYTES_FIXED_DEREF:\n            case BYTES_FIXED_STRAIGHT:\n            case BYTES_VAR_DEREF:\n            case BYTES_VAR_STRAIGHT:\n              BytesRef bytes = new BytesRef();\n              values.getBytes(i, bytes);\n              if (size != -1 && size != bytes.length) {\n                throw new RuntimeException(\"field: \" + fieldInfo.name + \" returned wrongly sized bytes, was: \" + bytes.length + \" should be: \" + size);\n              }\n              break;\n            case FLOAT_32:\n              assert size == 4;\n              values.getFloat(i);\n              break;\n            case FLOAT_64:\n              assert size == 8;\n              values.getFloat(i);\n              break;\n            case VAR_INTS:\n              assert size == -1;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_16:\n              assert size == 2;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_32:\n              assert size == 4;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_64:\n              assert size == 8;\n              values.getInt(i);\n              break;\n            case FIXED_INTS_8:\n              assert size == 1;\n              values.getInt(i);\n              break;\n            default:\n              throw new IllegalArgumentException(\"Field: \" + fieldInfo.name\n                          + \" - no such DocValues type: \" + fieldInfo.getDocValuesType());\n            }\n          }\n          if (type == DocValues.Type.BYTES_FIXED_SORTED || type == DocValues.Type.BYTES_VAR_SORTED) {\n            // check sorted bytes\n            SortedSource sortedValues = values.asSortedSource();\n            Comparator<BytesRef> comparator = sortedValues.getComparator();\n            int lastOrd = -1;\n            BytesRef lastBytes = new BytesRef();\n            for (int i = 0; i < maxDoc; i++) {\n              int ord = sortedValues.ord(i);\n              if (ord < 0 || ord > maxDoc) {\n                throw new RuntimeException(\"field: \" + fieldInfo.name + \" ord is out of bounds: \" + ord);\n              }\n              BytesRef bytes = new BytesRef();\n              sortedValues.getByOrd(ord, bytes);\n              if (lastOrd != -1) {\n                int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));\n                int bytesComp = Integer.signum(comparator.compare(bytes, lastBytes));\n                if (ordComp != bytesComp) {\n                  throw new RuntimeException(\"field: \" + fieldInfo.name + \" ord comparison is wrong: \" + ordComp + \" comparator claims: \" + bytesComp);\n                }\n              }\n              lastOrd = ord;\n              lastBytes = bytes;\n            }\n          }\n        } else {\n          if (reader.docValues(fieldInfo.name) != null) {\n            throw new RuntimeException(\"field: \" + fieldInfo.name + \" has docvalues but should omit them!\");\n          }\n        }\n      }\n\n      msg(\"OK [\" + status.docCount + \" total doc Count; Num DocValues Fields \"\n          + status.totalValueFields);\n    } catch (Throwable e) {\n      msg(\"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n      status.error = e;\n      if (infoStream != null) {\n        e.printStackTrace(infoStream);\n      }\n    }\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2e8d7ba2175f47e280231533f7d3016249cea88b"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"a1c385b88a2532c3fbcb9082d04be2a1433f2762":["cac4d5fa6c305b94f6232a70bda07f096ad0348c"],"2553b00f699380c64959ccb27991289aae87be2e":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","93c59ad5034eecd863f267bd75e1df7b8a51e427"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["2e8d7ba2175f47e280231533f7d3016249cea88b","93c59ad5034eecd863f267bd75e1df7b8a51e427"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["e128967bca58657bc0039d4bfe631e63e81f1977","a1c385b88a2532c3fbcb9082d04be2a1433f2762"],"5ebb742ffd3fae76a577a68de595d711f43e6944":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2e8d7ba2175f47e280231533f7d3016249cea88b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","605b061fadf71aa6458c0005eaae83a98350c403"],"605b061fadf71aa6458c0005eaae83a98350c403":["41e5bbad683f7546e96f08ffe8bc50cf447f2586"],"93c59ad5034eecd863f267bd75e1df7b8a51e427":["2e8d7ba2175f47e280231533f7d3016249cea88b"],"cac4d5fa6c305b94f6232a70bda07f096ad0348c":["1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["ecd41ba3cdd1b4d825aa53d1987e4360cf45cb05"],"e128967bca58657bc0039d4bfe631e63e81f1977":["93c59ad5034eecd863f267bd75e1df7b8a51e427"],"41e5bbad683f7546e96f08ffe8bc50cf447f2586":["5ebb742ffd3fae76a577a68de595d711f43e6944"],"ecd41ba3cdd1b4d825aa53d1987e4360cf45cb05":["e128967bca58657bc0039d4bfe631e63e81f1977"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["2553b00f699380c64959ccb27991289aae87be2e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a1c385b88a2532c3fbcb9082d04be2a1433f2762":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"2553b00f699380c64959ccb27991289aae87be2e":[],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"5ebb742ffd3fae76a577a68de595d711f43e6944":["41e5bbad683f7546e96f08ffe8bc50cf447f2586"],"2e8d7ba2175f47e280231533f7d3016249cea88b":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","d083e83f225b11e5fdd900e83d26ddb385b6955c","93c59ad5034eecd863f267bd75e1df7b8a51e427"],"605b061fadf71aa6458c0005eaae83a98350c403":["2e8d7ba2175f47e280231533f7d3016249cea88b"],"cac4d5fa6c305b94f6232a70bda07f096ad0348c":["a1c385b88a2532c3fbcb9082d04be2a1433f2762"],"93c59ad5034eecd863f267bd75e1df7b8a51e427":["2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","e128967bca58657bc0039d4bfe631e63e81f1977"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","5ebb742ffd3fae76a577a68de595d711f43e6944","2e8d7ba2175f47e280231533f7d3016249cea88b"],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["cac4d5fa6c305b94f6232a70bda07f096ad0348c"],"e128967bca58657bc0039d4bfe631e63e81f1977":["d638301ad1cfcae567b681b893bc8781f0ee48a5","ecd41ba3cdd1b4d825aa53d1987e4360cf45cb05"],"41e5bbad683f7546e96f08ffe8bc50cf447f2586":["605b061fadf71aa6458c0005eaae83a98350c403"],"ecd41ba3cdd1b4d825aa53d1987e4360cf45cb05":["1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}