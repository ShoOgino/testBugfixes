{"path":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int,boolean).mjava","commits":[{"id":"eeba0a4d0845889a402dd225793d62f009d029c9","date":1527938093,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes, boolean isSoftDeletesField) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab548c8f96022b4780f7500a30b19b4f4a5feeb6","date":1527940044,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int,boolean).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes, boolean isSoftDeletesField) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7e4ca6dc9612ff741d8713743e2bccfae5eadac","date":1528093718,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes, boolean isSoftDeletesField) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":1,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes, boolean isSoftDeletesField) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":1,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes, boolean isSoftDeletesField) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":5,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int,boolean).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dataDimensionCount, int indexDimensionCount, int dimensionNumBytes,\n                                          boolean isSoftDeletesField) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dataDimensionCount, indexDimensionCount, dimensionNumBytes, isSoftDeletesField);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dataDimensionCount, indexDimensionCount, dimensionNumBytes, isSoftDeletesField);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dataDimensionCount, indexDimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes, boolean isSoftDeletesField) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f6652c943595e92c187ee904c382863013eae28f":["b7e4ca6dc9612ff741d8713743e2bccfae5eadac"],"ab548c8f96022b4780f7500a30b19b4f4a5feeb6":["eeba0a4d0845889a402dd225793d62f009d029c9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b7e4ca6dc9612ff741d8713743e2bccfae5eadac"],"b7e4ca6dc9612ff741d8713743e2bccfae5eadac":["ab548c8f96022b4780f7500a30b19b4f4a5feeb6"],"eeba0a4d0845889a402dd225793d62f009d029c9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f592209545c71895260367152601e9200399776d":["ab548c8f96022b4780f7500a30b19b4f4a5feeb6","b7e4ca6dc9612ff741d8713743e2bccfae5eadac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f6652c943595e92c187ee904c382863013eae28f"]},"commit2Childs":{"f6652c943595e92c187ee904c382863013eae28f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ab548c8f96022b4780f7500a30b19b4f4a5feeb6":["b7e4ca6dc9612ff741d8713743e2bccfae5eadac","f592209545c71895260367152601e9200399776d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b70042a8a492f7054d480ccdd2be9796510d4327","eeba0a4d0845889a402dd225793d62f009d029c9"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"b7e4ca6dc9612ff741d8713743e2bccfae5eadac":["f6652c943595e92c187ee904c382863013eae28f","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"eeba0a4d0845889a402dd225793d62f009d029c9":["ab548c8f96022b4780f7500a30b19b4f4a5feeb6"],"f592209545c71895260367152601e9200399776d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}