{"path":"contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","commits":[{"id":"d41c10b9c61bc826acd344f499e062fb46bc42ae","date":1249408917,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","pathOld":"contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,int).mjava","sourceNew":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    Rectangle box = DistanceUtils.getInstance().getBoundary(latitude, longitude, miles);\n    double latY = box.getMaxPoint().getY();//box.getY();\n    double latX = box.getMinPoint().getY() ; //box.getMaxY();\n    \n    double longY = box.getMaxPoint().getX(); ///box.getX();\n    double longX = box.getMinPoint().getX();//box.getMaxX();\n    \n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n    \n    log.info(\"Best Fit is : \" + bestFit);\n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n    \n   \n    double beginAt = ctp.getTierBoxId(latX, longX);\n    double endAt = ctp.getTierBoxId(latY, longY);\n    \n    double tierVert = ctp.getTierVerticalPosDivider();\n    log.fine(\" | \"+ beginAt+\" | \"+ endAt);\n    \n    double startX = beginAt - (beginAt %1);\n    double startY = beginAt - startX ; //should give a whole number\n    \n    double endX = endAt - (endAt %1);\n    double endY = endAt -endX; //should give a whole number\n    \n    int scale = (int)Math.log10(tierVert);\n    endY = new BigDecimal(endY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    startY = new BigDecimal(startY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    log.fine(\"scale \"+scale+\" startX \"+ startX + \" endX \"+endX +\" startY \"+ startY + \" endY \"+ endY +\" tierVert \"+ tierVert);\n    \n    double xInc = 1.0d / tierVert;\n    xInc = new BigDecimal(xInc).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    \n    for (; startX <= endX; startX++){\n      \n      double itY = startY;\n      while (itY <= endY){\n        //create a boxId\n        // startX.startY\n        double boxId = startX + itY ;\n        shape.addBox(boxId);\n        //System.out.println(\"----\"+boxId);\n        itY += xInc;\n        \n        // java keeps 0.0001 as 1.0E-1\n        // which ends up as 0.00011111\n        itY = new BigDecimal(itY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n      }\n    }\n    return shape;\n  }\n\n","sourceOld":"  public Shape getBoxShape(double latitude, double longitude, int miles)\n  {  \n    Rectangle box = DistanceUtils.getInstance().getBoundary(latitude, longitude, miles);\n    \n    double latY = box.getMaxPoint().getY();//box.getY();\n    double latX = box.getMinPoint().getY() ; //box.getMaxY();\n    \n    double longY = box.getMaxPoint().getX(); ///box.getX();\n    double longX = box.getMinPoint().getX();//box.getMaxX();\n    \n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n    \n    log.info(\"Best Fit is : \" + bestFit);\n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n    \n   \n    double beginAt = ctp.getTierBoxId(latX, longX);\n    double endAt = ctp.getTierBoxId(latY, longY);\n    \n    double tierVert = ctp.getTierVerticalPosDivider();\n    log.fine(\" | \"+ beginAt+\" | \"+ endAt);\n    \n    double startX = beginAt - (beginAt %1);\n    double startY = beginAt - startX ; //should give a whole number\n    \n    double endX = endAt - (endAt %1);\n    double endY = endAt -endX; //should give a whole number\n    \n    int scale = (int)Math.log10(tierVert);\n    endY = new BigDecimal(endY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    startY = new BigDecimal(startY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    log.fine(\"scale \"+scale+\" startX \"+ startX + \" endX \"+endX +\" startY \"+ startY + \" endY \"+ endY +\" tierVert \"+ tierVert);\n    \n    double xInc = 1.0d / tierVert;\n    xInc = new BigDecimal(xInc).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    \n    for (; startX <= endX; startX++){\n      \n      double itY = startY;\n      while (itY <= endY){\n        //create a boxId\n        // startX.startY\n        double boxId = startX + itY ;\n        shape.addBox(boxId);\n        //System.out.println(\"----\"+boxId);\n        itY += xInc;\n        \n        // java keeps 0.0001 as 1.0E-1\n        // which ends up as 0.00011111\n        itY = new BigDecimal(itY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n      }\n    }\n    return shape;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c2ae53cd6aaa1f611cd392de6193cfbb2483eaf","date":1252289524,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","pathOld":"contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","sourceNew":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    Rectangle box = DistanceUtils.getInstance().getBoundary(latitude, longitude, miles);\n    double latY = box.getMaxPoint().getY();//box.getY();\n    double latX = box.getMinPoint().getY() ; //box.getMaxY();\n    \n    double longY = box.getMaxPoint().getX(); ///box.getX();\n    double longX = box.getMinPoint().getX();//box.getMaxX();\n    \n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n    \n    log.info(\"Best Fit is : \" + bestFit);\n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n    \n   \n    double beginAt = ctp.getTierBoxId(latX, longX);\n    double endAt = ctp.getTierBoxId(latY, longY);\n    \n    double tierVert = ctp.getTierVerticalPosDivider();\n    log.fine(\" | \"+ beginAt+\" | \"+ endAt);\n    \n    double startX = beginAt - (beginAt %1);\n    double startY = beginAt - startX ; //should give a whole number\n    \n    double endX = endAt - (endAt %1);\n    double endY = endAt -endX; //should give a whole number\n    \n    int scale = (int)Math.log10(tierVert);\n    endY = new BigDecimal(endY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    startY = new BigDecimal(startY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    if(log.isLoggable(Level.FINE)) {\n      log.fine(\"scale \"+scale+\" startX \"+ startX + \" endX \"+endX +\" startY \"+ startY + \" endY \"+ endY +\" tierVert \"+ tierVert);\n    }\n    double xInc = 1.0d / tierVert;\n    xInc = new BigDecimal(xInc).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    \n    for (; startX <= endX; startX++){\n      \n      double itY = startY;\n      while (itY <= endY){\n        //create a boxId\n        // startX.startY\n        double boxId = startX + itY ;\n        shape.addBox(boxId);\n        //System.out.println(\"----\"+boxId);\n        itY += xInc;\n        \n        // java keeps 0.0001 as 1.0E-1\n        // which ends up as 0.00011111\n        itY = new BigDecimal(itY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n      }\n    }\n    return shape;\n  }\n\n","sourceOld":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    Rectangle box = DistanceUtils.getInstance().getBoundary(latitude, longitude, miles);\n    double latY = box.getMaxPoint().getY();//box.getY();\n    double latX = box.getMinPoint().getY() ; //box.getMaxY();\n    \n    double longY = box.getMaxPoint().getX(); ///box.getX();\n    double longX = box.getMinPoint().getX();//box.getMaxX();\n    \n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n    \n    log.info(\"Best Fit is : \" + bestFit);\n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n    \n   \n    double beginAt = ctp.getTierBoxId(latX, longX);\n    double endAt = ctp.getTierBoxId(latY, longY);\n    \n    double tierVert = ctp.getTierVerticalPosDivider();\n    log.fine(\" | \"+ beginAt+\" | \"+ endAt);\n    \n    double startX = beginAt - (beginAt %1);\n    double startY = beginAt - startX ; //should give a whole number\n    \n    double endX = endAt - (endAt %1);\n    double endY = endAt -endX; //should give a whole number\n    \n    int scale = (int)Math.log10(tierVert);\n    endY = new BigDecimal(endY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    startY = new BigDecimal(startY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    log.fine(\"scale \"+scale+\" startX \"+ startX + \" endX \"+endX +\" startY \"+ startY + \" endY \"+ endY +\" tierVert \"+ tierVert);\n    \n    double xInc = 1.0d / tierVert;\n    xInc = new BigDecimal(xInc).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    \n    for (; startX <= endX; startX++){\n      \n      double itY = startY;\n      while (itY <= endY){\n        //create a boxId\n        // startX.startY\n        double boxId = startX + itY ;\n        shape.addBox(boxId);\n        //System.out.println(\"----\"+boxId);\n        itY += xInc;\n        \n        // java keeps 0.0001 as 1.0E-1\n        // which ends up as 0.00011111\n        itY = new BigDecimal(itY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n      }\n    }\n    return shape;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a04035855bf53c50aaef580f2ec794acf73029e","date":1253578101,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","pathOld":"contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","sourceNew":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    Rectangle box = DistanceUtils.getInstance().getBoundary(latitude, longitude, miles);\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng ll = box1.getLowerLeft();\n    LatLng ur = box1.getUpperRight();\n\n    double latY = ur.getLat();\n    double latX = ll.getLat();\n    double longY = ur.getLng();\n    double longX = ll.getLng();\n    double longX2 = 0.0;\n\n    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = -180.0;\t\n    }\n    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = 0.0;\t\n    }\n    \n    //System.err.println(\"getBoxShape:\"+latY+\",\" + longY);\n    //System.err.println(\"getBoxShape:\"+latX+\",\" + longX);\n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n    \n    log.info(\"Best Fit is : \" + bestFit);\n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n\n    shape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n    if (longX2 != 0.0) {\n\tif (longX2 != 0.0) {\n\t\tif (longX == 0.0) {\n\t\t\tlongX = longX2;\n\t\t\tlongY = 0.0;\n        \t\tshape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\t\t} else {\n\t\t\tlongX = longX2;\n\t\t\tlongY = -180.0;\n        \t\tshape = getShapeLoop(shape,ctp,latY,longY,latX,longX);\n\t\t}\n\t}\n        //System.err.println(\"getBoxShape2:\"+latY+\",\" + longY);\n        //System.err.println(\"getBoxShape2:\"+latX+\",\" + longX);\n    }\n \n    return shape; \n  } \n\n","sourceOld":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    Rectangle box = DistanceUtils.getInstance().getBoundary(latitude, longitude, miles);\n    double latY = box.getMaxPoint().getY();//box.getY();\n    double latX = box.getMinPoint().getY() ; //box.getMaxY();\n    \n    double longY = box.getMaxPoint().getX(); ///box.getX();\n    double longX = box.getMinPoint().getX();//box.getMaxX();\n    \n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n    \n    log.info(\"Best Fit is : \" + bestFit);\n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n    \n   \n    double beginAt = ctp.getTierBoxId(latX, longX);\n    double endAt = ctp.getTierBoxId(latY, longY);\n    \n    double tierVert = ctp.getTierVerticalPosDivider();\n    log.fine(\" | \"+ beginAt+\" | \"+ endAt);\n    \n    double startX = beginAt - (beginAt %1);\n    double startY = beginAt - startX ; //should give a whole number\n    \n    double endX = endAt - (endAt %1);\n    double endY = endAt -endX; //should give a whole number\n    \n    int scale = (int)Math.log10(tierVert);\n    endY = new BigDecimal(endY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    startY = new BigDecimal(startY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    if(log.isLoggable(Level.FINE)) {\n      log.fine(\"scale \"+scale+\" startX \"+ startX + \" endX \"+endX +\" startY \"+ startY + \" endY \"+ endY +\" tierVert \"+ tierVert);\n    }\n    double xInc = 1.0d / tierVert;\n    xInc = new BigDecimal(xInc).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n    \n    for (; startX <= endX; startX++){\n      \n      double itY = startY;\n      while (itY <= endY){\n        //create a boxId\n        // startX.startY\n        double boxId = startX + itY ;\n        shape.addBox(boxId);\n        //System.out.println(\"----\"+boxId);\n        itY += xInc;\n        \n        // java keeps 0.0001 as 1.0E-1\n        // which ends up as 0.00011111\n        itY = new BigDecimal(itY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();\n      }\n    }\n    return shape;\n  }\n\n","bugFix":null,"bugIntro":["3b6f51785c57651e9e1864b7b883037f24541c76"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e59cead675ff912b2ffdac41ca1a2fa7d905b8fa","date":1257446961,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","pathOld":"contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","sourceNew":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng ll = box1.getLowerLeft();\n    LatLng ur = box1.getUpperRight();\n\n    double latY = ur.getLat();\n    double latX = ll.getLat();\n    double longY = ur.getLng();\n    double longX = ll.getLng();\n    double longX2 = 0.0;\n\n    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = -180.0;\t\n    }\n    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = 0.0;\t\n    }\n    \n    //System.err.println(\"getBoxShape:\"+latY+\",\" + longY);\n    //System.err.println(\"getBoxShape:\"+latX+\",\" + longX);\n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n    \n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n\n    shape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n    if (longX2 != 0.0) {\n\tif (longX2 != 0.0) {\n\t\tif (longX == 0.0) {\n\t\t\tlongX = longX2;\n\t\t\tlongY = 0.0;\n        \t\tshape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\t\t} else {\n\t\t\tlongX = longX2;\n\t\t\tlongY = -180.0;\n        \t\tshape = getShapeLoop(shape,ctp,latY,longY,latX,longX);\n\t\t}\n\t}\n        //System.err.println(\"getBoxShape2:\"+latY+\",\" + longY);\n        //System.err.println(\"getBoxShape2:\"+latX+\",\" + longX);\n    }\n \n    return shape; \n  } \n\n","sourceOld":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    Rectangle box = DistanceUtils.getInstance().getBoundary(latitude, longitude, miles);\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng ll = box1.getLowerLeft();\n    LatLng ur = box1.getUpperRight();\n\n    double latY = ur.getLat();\n    double latX = ll.getLat();\n    double longY = ur.getLng();\n    double longX = ll.getLng();\n    double longX2 = 0.0;\n\n    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = -180.0;\t\n    }\n    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = 0.0;\t\n    }\n    \n    //System.err.println(\"getBoxShape:\"+latY+\",\" + longY);\n    //System.err.println(\"getBoxShape:\"+latX+\",\" + longX);\n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n    \n    log.info(\"Best Fit is : \" + bestFit);\n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n\n    shape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n    if (longX2 != 0.0) {\n\tif (longX2 != 0.0) {\n\t\tif (longX == 0.0) {\n\t\t\tlongX = longX2;\n\t\t\tlongY = 0.0;\n        \t\tshape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\t\t} else {\n\t\t\tlongX = longX2;\n\t\t\tlongY = -180.0;\n        \t\tshape = getShapeLoop(shape,ctp,latY,longY,latX,longX);\n\t\t}\n\t}\n        //System.err.println(\"getBoxShape2:\"+latY+\",\" + longY);\n        //System.err.println(\"getBoxShape2:\"+latX+\",\" + longX);\n    }\n \n    return shape; \n  } \n\n","bugFix":["04a4a94db1eb59c8583adb166acfe686a031bedc"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","pathOld":"contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","sourceNew":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng ll = box1.getLowerLeft();\n    LatLng ur = box1.getUpperRight();\n\n    double latY = ur.getLat();\n    double latX = ll.getLat();\n    double longY = ur.getLng();\n    double longX = ll.getLng();\n    double longX2 = 0.0;\n\n    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = -180.0;\t\n    }\n    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = 0.0;\t\n    }\n    \n    //System.err.println(\"getBoxShape:\"+latY+\",\" + longY);\n    //System.err.println(\"getBoxShape:\"+latX+\",\" + longX);\n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n    \n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n\n    shape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n    if (longX2 != 0.0) {\n\tif (longX2 != 0.0) {\n\t\tif (longX == 0.0) {\n\t\t\tlongX = longX2;\n\t\t\tlongY = 0.0;\n        \t\tshape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\t\t} else {\n\t\t\tlongX = longX2;\n\t\t\tlongY = -180.0;\n        \t\tshape = getShapeLoop(shape,ctp,latY,longY,latX,longX);\n\t\t}\n\t}\n        //System.err.println(\"getBoxShape2:\"+latY+\",\" + longY);\n        //System.err.println(\"getBoxShape2:\"+latX+\",\" + longX);\n    }\n \n    return shape; \n  } \n\n","sourceOld":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng ll = box1.getLowerLeft();\n    LatLng ur = box1.getUpperRight();\n\n    double latY = ur.getLat();\n    double latX = ll.getLat();\n    double longY = ur.getLng();\n    double longX = ll.getLng();\n    double longX2 = 0.0;\n\n    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = -180.0;\t\n    }\n    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = 0.0;\t\n    }\n    \n    //System.err.println(\"getBoxShape:\"+latY+\",\" + longY);\n    //System.err.println(\"getBoxShape:\"+latX+\",\" + longX);\n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n    \n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n\n    shape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n    if (longX2 != 0.0) {\n\tif (longX2 != 0.0) {\n\t\tif (longX == 0.0) {\n\t\t\tlongX = longX2;\n\t\t\tlongY = 0.0;\n        \t\tshape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\t\t} else {\n\t\t\tlongX = longX2;\n\t\t\tlongY = -180.0;\n        \t\tshape = getShapeLoop(shape,ctp,latY,longY,latX,longX);\n\t\t}\n\t}\n        //System.err.println(\"getBoxShape2:\"+latY+\",\" + longY);\n        //System.err.println(\"getBoxShape2:\"+latX+\",\" + longX);\n    }\n \n    return shape; \n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"e59cead675ff912b2ffdac41ca1a2fa7d905b8fa":["0a04035855bf53c50aaef580f2ec794acf73029e"],"0a04035855bf53c50aaef580f2ec794acf73029e":["2c2ae53cd6aaa1f611cd392de6193cfbb2483eaf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d41c10b9c61bc826acd344f499e062fb46bc42ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2c2ae53cd6aaa1f611cd392de6193cfbb2483eaf":["d41c10b9c61bc826acd344f499e062fb46bc42ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["e59cead675ff912b2ffdac41ca1a2fa7d905b8fa"]},"commit2Childs":{"e59cead675ff912b2ffdac41ca1a2fa7d905b8fa":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"0a04035855bf53c50aaef580f2ec794acf73029e":["e59cead675ff912b2ffdac41ca1a2fa7d905b8fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d41c10b9c61bc826acd344f499e062fb46bc42ae"],"d41c10b9c61bc826acd344f499e062fb46bc42ae":["2c2ae53cd6aaa1f611cd392de6193cfbb2483eaf"],"2c2ae53cd6aaa1f611cd392de6193cfbb2483eaf":["0a04035855bf53c50aaef580f2ec794acf73029e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}