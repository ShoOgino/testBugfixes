{"path":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","sourceNew":"  public NamedSPILoader(Class<S> clazz) {\n    this.clazz = clazz;\n    final ServiceLoader<S> loader = ServiceLoader.load(clazz);\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>();\n    for (final S service : loader) {\n      final String name = service.getName();\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":"  public NamedSPILoader(Class<S> clazz) {\n    this.clazz = clazz;\n    final ServiceLoader<S> loader = ServiceLoader.load(clazz);\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>();\n    for (final S service : loader) {\n      final String name = service.getName();\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5cf17bea86a5acbc573c72be7efa0e720bd44b3a","date":1332840630,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","sourceNew":"  public NamedSPILoader(Class<S> clazz) {\n    this.clazz = clazz;\n    final ServiceLoader<S> loader = ServiceLoader.load(clazz);\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>();\n    for (final S service : loader) {\n      final String name = service.getName();\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n      }\n    }\n    this.modifiableServices = services; // hack, remove when IBM J9 is fixed!\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":"  public NamedSPILoader(Class<S> clazz) {\n    this.clazz = clazz;\n    final ServiceLoader<S> loader = ServiceLoader.load(clazz);\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>();\n    for (final S service : loader) {\n      final String name = service.getName();\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"818ed34f5bd799741cc36ac29a92dfcfce9c6950","date":1337699165,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","sourceNew":"  public NamedSPILoader(Class<S> clazz) {\n    this.clazz = clazz;\n    final ServiceLoader<S> loader = ServiceLoader.load(clazz);\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>();\n    for (final S service : loader) {\n      final String name = service.getName();\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      if (!services.containsKey(name)) {\n        assert checkServiceName(name);\n        services.put(name, service);\n      }\n    }\n    this.modifiableServices = services; // hack, remove when IBM J9 is fixed!\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":"  public NamedSPILoader(Class<S> clazz) {\n    this.clazz = clazz;\n    final ServiceLoader<S> loader = ServiceLoader.load(clazz);\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>();\n    for (final S service : loader) {\n      final String name = service.getName();\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n      }\n    }\n    this.modifiableServices = services; // hack, remove when IBM J9 is fixed!\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","sourceNew":"  public NamedSPILoader(Class<S> clazz) {\n    this.clazz = clazz;\n    final ServiceLoader<S> loader = ServiceLoader.load(clazz);\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>();\n    for (final S service : loader) {\n      final String name = service.getName();\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      if (!services.containsKey(name)) {\n        assert checkServiceName(name);\n        services.put(name, service);\n      }\n    }\n    this.modifiableServices = services; // hack, remove when IBM J9 is fixed!\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":"  public NamedSPILoader(Class<S> clazz) {\n    this.clazz = clazz;\n    final ServiceLoader<S> loader = ServiceLoader.load(clazz);\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>();\n    for (final S service : loader) {\n      final String name = service.getName();\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      if (!services.containsKey(name)) {\n        services.put(name, service);\n      }\n    }\n    this.modifiableServices = services; // hack, remove when IBM J9 is fixed!\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e5974da97d735dd78f13f46406caf64c9448e4f4","date":1343143368,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","sourceNew":"  public NamedSPILoader(Class<S> clazz) {\n    this.clazz = clazz;\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz);\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>();\n    while (loader.hasNext()) {\n      final Class<? extends S> c = loader.next();\n      final S service;\n      try {\n        service = c.newInstance();\n      } catch (InstantiationException ie) {\n        throw new ServiceConfigurationError(\"Cannot instantiate SPI class: \" + c.getName(), ie); \n      } catch (IllegalAccessException iae) {\n        throw new ServiceConfigurationError(\"Cannot instantiate SPI class: \" + c.getName(), iae); \n      }\n      final String name = service.getName();\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      if (!services.containsKey(name)) {\n        assert checkServiceName(name);\n        services.put(name, service);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":"  public NamedSPILoader(Class<S> clazz) {\n    this.clazz = clazz;\n    final ServiceLoader<S> loader = ServiceLoader.load(clazz);\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>();\n    for (final S service : loader) {\n      final String name = service.getName();\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      if (!services.containsKey(name)) {\n        assert checkServiceName(name);\n        services.put(name, service);\n      }\n    }\n    this.modifiableServices = services; // hack, remove when IBM J9 is fixed!\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"718655a894a765091a6c32c07c934cec9d30a6e8","date":1343172487,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","sourceNew":"  public NamedSPILoader(Class<S> clazz) {\n    this.clazz = clazz;\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz);\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>();\n    while (loader.hasNext()) {\n      final Class<? extends S> c = loader.next();\n      try {\n        final S service = c.newInstance();\n        final String name = service.getName();\n        // only add the first one for each name, later services will be ignored\n        // this allows to place services before others in classpath to make \n        // them used instead of others\n        if (!services.containsKey(name)) {\n          checkServiceName(name);\n          services.put(name, service);\n        }\n      } catch (Exception e) {\n        throw new ServiceConfigurationError(\"Cannot instantiate SPI class: \" + c.getName(), e);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":"  public NamedSPILoader(Class<S> clazz) {\n    this.clazz = clazz;\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz);\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>();\n    while (loader.hasNext()) {\n      final Class<? extends S> c = loader.next();\n      final S service;\n      try {\n        service = c.newInstance();\n      } catch (InstantiationException ie) {\n        throw new ServiceConfigurationError(\"Cannot instantiate SPI class: \" + c.getName(), ie); \n      } catch (IllegalAccessException iae) {\n        throw new ServiceConfigurationError(\"Cannot instantiate SPI class: \" + c.getName(), iae); \n      }\n      final String name = service.getName();\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      if (!services.containsKey(name)) {\n        assert checkServiceName(name);\n        services.put(name, service);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a1a22b1ad88b436661458df567f3fdb446392a4","date":1343224444,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","sourceNew":"  public NamedSPILoader(Class<S> clazz) {\n    this.clazz = clazz;\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz);\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>();\n    while (loader.hasNext()) {\n      final Class<? extends S> c = loader.next();\n      try {\n        final S service = c.newInstance();\n        final String name = service.getName();\n        // only add the first one for each name, later services will be ignored\n        // this allows to place services before others in classpath to make \n        // them used instead of others\n        if (!services.containsKey(name)) {\n          checkServiceName(name);\n          services.put(name, service);\n        }\n      } catch (Exception e) {\n        throw new ServiceConfigurationError(\"Cannot instantiate SPI class: \" + c.getName(), e);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","sourceOld":"  public NamedSPILoader(Class<S> clazz) {\n    this.clazz = clazz;\n    final ServiceLoader<S> loader = ServiceLoader.load(clazz);\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>();\n    for (final S service : loader) {\n      final String name = service.getName();\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      if (!services.containsKey(name)) {\n        assert checkServiceName(name);\n        services.put(name, service);\n      }\n    }\n    this.modifiableServices = services; // hack, remove when IBM J9 is fixed!\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9499b09dd7d06d975f31e59a9b00653a86f9cad2","date":1343325589,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","sourceNew":"  public NamedSPILoader(Class<S> clazz) {\n    this(clazz, Thread.currentThread().getContextClassLoader());\n  }\n\n","sourceOld":"  public NamedSPILoader(Class<S> clazz) {\n    this.clazz = clazz;\n    final SPIClassIterator<S> loader = SPIClassIterator.get(clazz);\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>();\n    while (loader.hasNext()) {\n      final Class<? extends S> c = loader.next();\n      try {\n        final S service = c.newInstance();\n        final String name = service.getName();\n        // only add the first one for each name, later services will be ignored\n        // this allows to place services before others in classpath to make \n        // them used instead of others\n        if (!services.containsKey(name)) {\n          checkServiceName(name);\n          services.put(name, service);\n        }\n      } catch (Exception e) {\n        throw new ServiceConfigurationError(\"Cannot instantiate SPI class: \" + c.getName(), e);\n      }\n    }\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","sourceNew":"  public NamedSPILoader(Class<S> clazz) {\n    this(clazz, Thread.currentThread().getContextClassLoader());\n  }\n\n","sourceOld":"  public NamedSPILoader(Class<S> clazz) {\n    this.clazz = clazz;\n    final ServiceLoader<S> loader = ServiceLoader.load(clazz);\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>();\n    for (final S service : loader) {\n      final String name = service.getName();\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      if (!services.containsKey(name)) {\n        assert checkServiceName(name);\n        services.put(name, service);\n      }\n    }\n    this.modifiableServices = services; // hack, remove when IBM J9 is fixed!\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","sourceNew":"  public NamedSPILoader(Class<S> clazz) {\n    this(clazz, Thread.currentThread().getContextClassLoader());\n  }\n\n","sourceOld":"  public NamedSPILoader(Class<S> clazz) {\n    this.clazz = clazz;\n    final ServiceLoader<S> loader = ServiceLoader.load(clazz);\n    final LinkedHashMap<String,S> services = new LinkedHashMap<String,S>();\n    for (final S service : loader) {\n      final String name = service.getName();\n      // only add the first one for each name, later services will be ignored\n      // this allows to place services before others in classpath to make \n      // them used instead of others\n      if (!services.containsKey(name)) {\n        assert checkServiceName(name);\n        services.put(name, service);\n      }\n    }\n    this.modifiableServices = services; // hack, remove when IBM J9 is fixed!\n    this.services = Collections.unmodifiableMap(services);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"409fbcbea5146d19c121f029071d605b1b68bb25","date":1497969834,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","sourceNew":"  public NamedSPILoader(Class<S> clazz) {\n    this(clazz, null);\n  }\n\n","sourceOld":"  public NamedSPILoader(Class<S> clazz) {\n    this(clazz, Thread.currentThread().getContextClassLoader());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","sourceNew":"  public NamedSPILoader(Class<S> clazz) {\n    this(clazz, null);\n  }\n\n","sourceOld":"  public NamedSPILoader(Class<S> clazz) {\n    this(clazz, Thread.currentThread().getContextClassLoader());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/NamedSPILoader#NamedSPILoader(Class[S]).mjava","sourceNew":"  public NamedSPILoader(Class<S> clazz) {\n    this(clazz, null);\n  }\n\n","sourceOld":"  public NamedSPILoader(Class<S> clazz) {\n    this(clazz, Thread.currentThread().getContextClassLoader());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5cf17bea86a5acbc573c72be7efa0e720bd44b3a":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"818ed34f5bd799741cc36ac29a92dfcfce9c6950":["5cf17bea86a5acbc573c72be7efa0e720bd44b3a"],"718655a894a765091a6c32c07c934cec9d30a6e8":["e5974da97d735dd78f13f46406caf64c9448e4f4"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e5974da97d735dd78f13f46406caf64c9448e4f4":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"5a1a22b1ad88b436661458df567f3fdb446392a4":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","718655a894a765091a6c32c07c934cec9d30a6e8"],"28288370235ed02234a64753cdbf0c6ec096304a":["9499b09dd7d06d975f31e59a9b00653a86f9cad2","409fbcbea5146d19c121f029071d605b1b68bb25"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["5cf17bea86a5acbc573c72be7efa0e720bd44b3a","818ed34f5bd799741cc36ac29a92dfcfce9c6950"],"aba371508186796cc6151d8223a5b4e16d02e26e":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","9499b09dd7d06d975f31e59a9b00653a86f9cad2"],"9499b09dd7d06d975f31e59a9b00653a86f9cad2":["5a1a22b1ad88b436661458df567f3fdb446392a4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","9499b09dd7d06d975f31e59a9b00653a86f9cad2"],"409fbcbea5146d19c121f029071d605b1b68bb25":["9499b09dd7d06d975f31e59a9b00653a86f9cad2"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["9499b09dd7d06d975f31e59a9b00653a86f9cad2","409fbcbea5146d19c121f029071d605b1b68bb25"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"5cf17bea86a5acbc573c72be7efa0e720bd44b3a":["818ed34f5bd799741cc36ac29a92dfcfce9c6950","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"818ed34f5bd799741cc36ac29a92dfcfce9c6950":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"718655a894a765091a6c32c07c934cec9d30a6e8":["5a1a22b1ad88b436661458df567f3fdb446392a4"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5cf17bea86a5acbc573c72be7efa0e720bd44b3a"],"e5974da97d735dd78f13f46406caf64c9448e4f4":["718655a894a765091a6c32c07c934cec9d30a6e8"],"5a1a22b1ad88b436661458df567f3fdb446392a4":["9499b09dd7d06d975f31e59a9b00653a86f9cad2"],"28288370235ed02234a64753cdbf0c6ec096304a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["e5974da97d735dd78f13f46406caf64c9448e4f4","5a1a22b1ad88b436661458df567f3fdb446392a4","aba371508186796cc6151d8223a5b4e16d02e26e","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"9499b09dd7d06d975f31e59a9b00653a86f9cad2":["28288370235ed02234a64753cdbf0c6ec096304a","aba371508186796cc6151d8223a5b4e16d02e26e","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","409fbcbea5146d19c121f029071d605b1b68bb25","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"409fbcbea5146d19c121f029071d605b1b68bb25":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aba371508186796cc6151d8223a5b4e16d02e26e","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}