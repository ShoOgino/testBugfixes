{"path":"solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster#MiniSolrCloudCluster(int,Path,String,JettyConfig,ZkTestServer,Optional[String]).mjava","commits":[{"id":"29887daf839649150d96855b142b76f5c45d60d2","date":1482160504,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster#MiniSolrCloudCluster(int,Path,String,JettyConfig,ZkTestServer,Optional[String]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a MiniSolrCloudCluster.\n   * Note - this constructor visibility is changed to package protected so as to\n   * discourage its usage. Ideally *new* functionality should use {@linkplain SolrCloudTestCase}\n   * to configure any additional parameters.\n   *\n   * @param numServers number of Solr servers to start\n   * @param baseDir base directory that the mini cluster should be run from\n   * @param solrXml solr.xml file to be uploaded to ZooKeeper\n   * @param jettyConfig Jetty configuration\n   * @param zkTestServer ZkTestServer to use.  If null, one will be created\n   * @param securityJson A string representation of security.json file (optional).\n   *\n   * @throws Exception if there was an error starting the cluster\n   */\n   MiniSolrCloudCluster(int numServers, Path baseDir, String solrXml, JettyConfig jettyConfig,\n      ZkTestServer zkTestServer, Optional<String> securityJson) throws Exception {\n\n    Objects.requireNonNull(securityJson);\n    this.baseDir = Objects.requireNonNull(baseDir);\n    this.jettyConfig = Objects.requireNonNull(jettyConfig);\n\n    log.info(\"Starting cluster of {} servers in {}\", numServers, baseDir);\n\n    Files.createDirectories(baseDir);\n\n    this.externalZkServer = zkTestServer != null;\n    if (!externalZkServer) {\n      String zkDir = baseDir.resolve(\"zookeeper/server1/data\").toString();\n      zkTestServer = new ZkTestServer(zkDir);\n      zkTestServer.run();\n    }\n    this.zkServer = zkTestServer;\n\n    try (SolrZkClient zkClient = new SolrZkClient(zkServer.getZkHost(), AbstractZkTestCase.TIMEOUT)) {\n      zkClient.makePath(\"/solr/solr.xml\", solrXml.getBytes(Charset.defaultCharset()), true);\n      if (jettyConfig.sslConfig != null && jettyConfig.sslConfig.isSSLMode()) {\n        zkClient.makePath(\"/solr\" + ZkStateReader.CLUSTER_PROPS, \"{'urlScheme':'https'}\".getBytes(StandardCharsets.UTF_8), true);\n      }\n      if (securityJson.isPresent()) { // configure Solr security\n        zkClient.makePath(\"/solr/security.json\", securityJson.get().getBytes(Charset.defaultCharset()), true);\n      }\n    }\n\n    // tell solr to look in zookeeper for solr.xml\n    System.setProperty(\"zkHost\", zkServer.getZkAddress());\n\n    List<Callable<JettySolrRunner>> startups = new ArrayList<>(numServers);\n    for (int i = 0; i < numServers; ++i) {\n      startups.add(() -> startJettySolrRunner(newNodeName(), jettyConfig.context, jettyConfig));\n    }\n\n    Collection<Future<JettySolrRunner>> futures = executor.invokeAll(startups);\n    Exception startupError = checkForExceptions(\"Error starting up MiniSolrCloudCluster\", futures);\n    if (startupError != null) {\n      try {\n        this.shutdown();\n      }\n      catch (Throwable t) {\n        startupError.addSuppressed(t);\n      }\n      throw startupError;\n    }\n\n    waitForAllNodes(numServers, 60);\n\n    solrClient = buildSolrClient();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","a3584d3db8b472772e3329d9d95d584b68ae997e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","date":1482251961,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster#MiniSolrCloudCluster(int,Path,String,JettyConfig,ZkTestServer,Optional[String]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a MiniSolrCloudCluster.\n   * Note - this constructor visibility is changed to package protected so as to\n   * discourage its usage. Ideally *new* functionality should use {@linkplain SolrCloudTestCase}\n   * to configure any additional parameters.\n   *\n   * @param numServers number of Solr servers to start\n   * @param baseDir base directory that the mini cluster should be run from\n   * @param solrXml solr.xml file to be uploaded to ZooKeeper\n   * @param jettyConfig Jetty configuration\n   * @param zkTestServer ZkTestServer to use.  If null, one will be created\n   * @param securityJson A string representation of security.json file (optional).\n   *\n   * @throws Exception if there was an error starting the cluster\n   */\n   MiniSolrCloudCluster(int numServers, Path baseDir, String solrXml, JettyConfig jettyConfig,\n      ZkTestServer zkTestServer, Optional<String> securityJson) throws Exception {\n\n    Objects.requireNonNull(securityJson);\n    this.baseDir = Objects.requireNonNull(baseDir);\n    this.jettyConfig = Objects.requireNonNull(jettyConfig);\n\n    log.info(\"Starting cluster of {} servers in {}\", numServers, baseDir);\n\n    Files.createDirectories(baseDir);\n\n    this.externalZkServer = zkTestServer != null;\n    if (!externalZkServer) {\n      String zkDir = baseDir.resolve(\"zookeeper/server1/data\").toString();\n      zkTestServer = new ZkTestServer(zkDir);\n      zkTestServer.run();\n    }\n    this.zkServer = zkTestServer;\n\n    try (SolrZkClient zkClient = new SolrZkClient(zkServer.getZkHost(), AbstractZkTestCase.TIMEOUT)) {\n      zkClient.makePath(\"/solr/solr.xml\", solrXml.getBytes(Charset.defaultCharset()), true);\n      if (jettyConfig.sslConfig != null && jettyConfig.sslConfig.isSSLMode()) {\n        zkClient.makePath(\"/solr\" + ZkStateReader.CLUSTER_PROPS, \"{'urlScheme':'https'}\".getBytes(StandardCharsets.UTF_8), true);\n      }\n      if (securityJson.isPresent()) { // configure Solr security\n        zkClient.makePath(\"/solr/security.json\", securityJson.get().getBytes(Charset.defaultCharset()), true);\n      }\n    }\n\n    // tell solr to look in zookeeper for solr.xml\n    System.setProperty(\"zkHost\", zkServer.getZkAddress());\n\n    List<Callable<JettySolrRunner>> startups = new ArrayList<>(numServers);\n    for (int i = 0; i < numServers; ++i) {\n      startups.add(() -> startJettySolrRunner(newNodeName(), jettyConfig.context, jettyConfig));\n    }\n\n    Collection<Future<JettySolrRunner>> futures = executor.invokeAll(startups);\n    Exception startupError = checkForExceptions(\"Error starting up MiniSolrCloudCluster\", futures);\n    if (startupError != null) {\n      try {\n        this.shutdown();\n      }\n      catch (Throwable t) {\n        startupError.addSuppressed(t);\n      }\n      throw startupError;\n    }\n\n    waitForAllNodes(numServers, 60);\n\n    solrClient = buildSolrClient();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d32e632a4641366d674c7dbfd8fd155b0f96dc31","date":1487797092,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster#MiniSolrCloudCluster(int,Path,String,JettyConfig,ZkTestServer,Optional[String]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster#MiniSolrCloudCluster(int,Path,String,JettyConfig,ZkTestServer,Optional[String]).mjava","sourceNew":"  /**\n   * Create a MiniSolrCloudCluster.\n   * Note - this constructor visibility is changed to package protected so as to\n   * discourage its usage. Ideally *new* functionality should use {@linkplain SolrCloudTestCase}\n   * to configure any additional parameters.\n   *\n   * @param numServers number of Solr servers to start\n   * @param baseDir base directory that the mini cluster should be run from\n   * @param solrXml solr.xml file to be uploaded to ZooKeeper\n   * @param jettyConfig Jetty configuration\n   * @param zkTestServer ZkTestServer to use.  If null, one will be created\n   * @param securityJson A string representation of security.json file (optional).\n   *\n   * @throws Exception if there was an error starting the cluster\n   */\n   MiniSolrCloudCluster(int numServers, Path baseDir, String solrXml, JettyConfig jettyConfig,\n      ZkTestServer zkTestServer, Optional<String> securityJson) throws Exception {\n\n    Objects.requireNonNull(securityJson);\n    this.baseDir = Objects.requireNonNull(baseDir);\n    this.jettyConfig = Objects.requireNonNull(jettyConfig);\n\n    log.info(\"Starting cluster of {} servers in {}\", numServers, baseDir);\n\n    Files.createDirectories(baseDir);\n\n    this.externalZkServer = zkTestServer != null;\n    if (!externalZkServer) {\n      String zkDir = baseDir.resolve(\"zookeeper/server1/data\").toString();\n      zkTestServer = new ZkTestServer(zkDir);\n      zkTestServer.run();\n    }\n    this.zkServer = zkTestServer;\n\n    try (SolrZkClient zkClient = new SolrZkClient(zkServer.getZkHost(), AbstractZkTestCase.TIMEOUT)) {\n      zkClient.makePath(\"/solr/solr.xml\", solrXml.getBytes(Charset.defaultCharset()), true);\n      if (jettyConfig.sslConfig != null && jettyConfig.sslConfig.isSSLMode()) {\n        zkClient.makePath(\"/solr\" + ZkStateReader.CLUSTER_PROPS, \"{'urlScheme':'https'}\".getBytes(StandardCharsets.UTF_8), true);\n      }\n      if (securityJson.isPresent()) { // configure Solr security\n        zkClient.makePath(\"/solr/security.json\", securityJson.get().getBytes(Charset.defaultCharset()), true);\n      }\n    }\n\n    // tell solr to look in zookeeper for solr.xml\n    System.setProperty(\"zkHost\", zkServer.getZkAddress());\n\n    List<Callable<JettySolrRunner>> startups = new ArrayList<>(numServers);\n    for (int i = 0; i < numServers; ++i) {\n      startups.add(() -> startJettySolrRunner(newNodeName(), jettyConfig.context, jettyConfig));\n    }\n\n    Collection<Future<JettySolrRunner>> futures = executorLauncher.invokeAll(startups);\n    Exception startupError = checkForExceptions(\"Error starting up MiniSolrCloudCluster\", futures);\n    if (startupError != null) {\n      try {\n        this.shutdown();\n      }\n      catch (Throwable t) {\n        startupError.addSuppressed(t);\n      }\n      throw startupError;\n    }\n\n    waitForAllNodes(numServers, 60);\n\n    solrClient = buildSolrClient();\n  }\n\n","sourceOld":"  /**\n   * Create a MiniSolrCloudCluster.\n   * Note - this constructor visibility is changed to package protected so as to\n   * discourage its usage. Ideally *new* functionality should use {@linkplain SolrCloudTestCase}\n   * to configure any additional parameters.\n   *\n   * @param numServers number of Solr servers to start\n   * @param baseDir base directory that the mini cluster should be run from\n   * @param solrXml solr.xml file to be uploaded to ZooKeeper\n   * @param jettyConfig Jetty configuration\n   * @param zkTestServer ZkTestServer to use.  If null, one will be created\n   * @param securityJson A string representation of security.json file (optional).\n   *\n   * @throws Exception if there was an error starting the cluster\n   */\n   MiniSolrCloudCluster(int numServers, Path baseDir, String solrXml, JettyConfig jettyConfig,\n      ZkTestServer zkTestServer, Optional<String> securityJson) throws Exception {\n\n    Objects.requireNonNull(securityJson);\n    this.baseDir = Objects.requireNonNull(baseDir);\n    this.jettyConfig = Objects.requireNonNull(jettyConfig);\n\n    log.info(\"Starting cluster of {} servers in {}\", numServers, baseDir);\n\n    Files.createDirectories(baseDir);\n\n    this.externalZkServer = zkTestServer != null;\n    if (!externalZkServer) {\n      String zkDir = baseDir.resolve(\"zookeeper/server1/data\").toString();\n      zkTestServer = new ZkTestServer(zkDir);\n      zkTestServer.run();\n    }\n    this.zkServer = zkTestServer;\n\n    try (SolrZkClient zkClient = new SolrZkClient(zkServer.getZkHost(), AbstractZkTestCase.TIMEOUT)) {\n      zkClient.makePath(\"/solr/solr.xml\", solrXml.getBytes(Charset.defaultCharset()), true);\n      if (jettyConfig.sslConfig != null && jettyConfig.sslConfig.isSSLMode()) {\n        zkClient.makePath(\"/solr\" + ZkStateReader.CLUSTER_PROPS, \"{'urlScheme':'https'}\".getBytes(StandardCharsets.UTF_8), true);\n      }\n      if (securityJson.isPresent()) { // configure Solr security\n        zkClient.makePath(\"/solr/security.json\", securityJson.get().getBytes(Charset.defaultCharset()), true);\n      }\n    }\n\n    // tell solr to look in zookeeper for solr.xml\n    System.setProperty(\"zkHost\", zkServer.getZkAddress());\n\n    List<Callable<JettySolrRunner>> startups = new ArrayList<>(numServers);\n    for (int i = 0; i < numServers; ++i) {\n      startups.add(() -> startJettySolrRunner(newNodeName(), jettyConfig.context, jettyConfig));\n    }\n\n    Collection<Future<JettySolrRunner>> futures = executor.invokeAll(startups);\n    Exception startupError = checkForExceptions(\"Error starting up MiniSolrCloudCluster\", futures);\n    if (startupError != null) {\n      try {\n        this.shutdown();\n      }\n      catch (Throwable t) {\n        startupError.addSuppressed(t);\n      }\n      throw startupError;\n    }\n\n    waitForAllNodes(numServers, 60);\n\n    solrClient = buildSolrClient();\n  }\n\n","bugFix":null,"bugIntro":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster#MiniSolrCloudCluster(int,Path,String,JettyConfig,ZkTestServer,Optional[String]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster#MiniSolrCloudCluster(int,Path,String,JettyConfig,ZkTestServer,Optional[String]).mjava","sourceNew":"  /**\n   * Create a MiniSolrCloudCluster.\n   * Note - this constructor visibility is changed to package protected so as to\n   * discourage its usage. Ideally *new* functionality should use {@linkplain SolrCloudTestCase}\n   * to configure any additional parameters.\n   *\n   * @param numServers number of Solr servers to start\n   * @param baseDir base directory that the mini cluster should be run from\n   * @param solrXml solr.xml file to be uploaded to ZooKeeper\n   * @param jettyConfig Jetty configuration\n   * @param zkTestServer ZkTestServer to use.  If null, one will be created\n   * @param securityJson A string representation of security.json file (optional).\n   *\n   * @throws Exception if there was an error starting the cluster\n   */\n   MiniSolrCloudCluster(int numServers, Path baseDir, String solrXml, JettyConfig jettyConfig,\n      ZkTestServer zkTestServer, Optional<String> securityJson) throws Exception {\n\n    Objects.requireNonNull(securityJson);\n    this.baseDir = Objects.requireNonNull(baseDir);\n    this.jettyConfig = Objects.requireNonNull(jettyConfig);\n\n    log.info(\"Starting cluster of {} servers in {}\", numServers, baseDir);\n\n    Files.createDirectories(baseDir);\n\n    this.externalZkServer = zkTestServer != null;\n    if (!externalZkServer) {\n      String zkDir = baseDir.resolve(\"zookeeper/server1/data\").toString();\n      zkTestServer = new ZkTestServer(zkDir);\n      try {\n        zkTestServer.run();\n      } catch (Exception e) {\n        log.error(\"Error starting Zk Test Server, trying again ...\");\n        zkTestServer.shutdown();\n        zkTestServer = new ZkTestServer(zkDir);\n        zkTestServer.run();\n      }\n    }\n    this.zkServer = zkTestServer;\n\n    try (SolrZkClient zkClient = new SolrZkClient(zkServer.getZkHost(), AbstractZkTestCase.TIMEOUT)) {\n      zkClient.makePath(\"/solr/solr.xml\", solrXml.getBytes(Charset.defaultCharset()), true);\n      if (jettyConfig.sslConfig != null && jettyConfig.sslConfig.isSSLMode()) {\n        zkClient.makePath(\"/solr\" + ZkStateReader.CLUSTER_PROPS, \"{'urlScheme':'https'}\".getBytes(StandardCharsets.UTF_8), true);\n      }\n      if (securityJson.isPresent()) { // configure Solr security\n        zkClient.makePath(\"/solr/security.json\", securityJson.get().getBytes(Charset.defaultCharset()), true);\n      }\n    }\n\n    // tell solr to look in zookeeper for solr.xml\n    System.setProperty(\"zkHost\", zkServer.getZkAddress());\n\n    List<Callable<JettySolrRunner>> startups = new ArrayList<>(numServers);\n    for (int i = 0; i < numServers; ++i) {\n      startups.add(() -> startJettySolrRunner(newNodeName(), jettyConfig.context, jettyConfig));\n    }\n\n    Collection<Future<JettySolrRunner>> futures = executorLauncher.invokeAll(startups);\n    Exception startupError = checkForExceptions(\"Error starting up MiniSolrCloudCluster\", futures);\n    if (startupError != null) {\n      try {\n        this.shutdown();\n      }\n      catch (Throwable t) {\n        startupError.addSuppressed(t);\n      }\n      throw startupError;\n    }\n\n    solrClient = buildSolrClient();\n    \n    if (numServers > 0) {\n      waitForAllNodes(numServers, 60);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Create a MiniSolrCloudCluster.\n   * Note - this constructor visibility is changed to package protected so as to\n   * discourage its usage. Ideally *new* functionality should use {@linkplain SolrCloudTestCase}\n   * to configure any additional parameters.\n   *\n   * @param numServers number of Solr servers to start\n   * @param baseDir base directory that the mini cluster should be run from\n   * @param solrXml solr.xml file to be uploaded to ZooKeeper\n   * @param jettyConfig Jetty configuration\n   * @param zkTestServer ZkTestServer to use.  If null, one will be created\n   * @param securityJson A string representation of security.json file (optional).\n   *\n   * @throws Exception if there was an error starting the cluster\n   */\n   MiniSolrCloudCluster(int numServers, Path baseDir, String solrXml, JettyConfig jettyConfig,\n      ZkTestServer zkTestServer, Optional<String> securityJson) throws Exception {\n\n    Objects.requireNonNull(securityJson);\n    this.baseDir = Objects.requireNonNull(baseDir);\n    this.jettyConfig = Objects.requireNonNull(jettyConfig);\n\n    log.info(\"Starting cluster of {} servers in {}\", numServers, baseDir);\n\n    Files.createDirectories(baseDir);\n\n    this.externalZkServer = zkTestServer != null;\n    if (!externalZkServer) {\n      String zkDir = baseDir.resolve(\"zookeeper/server1/data\").toString();\n      zkTestServer = new ZkTestServer(zkDir);\n      zkTestServer.run();\n    }\n    this.zkServer = zkTestServer;\n\n    try (SolrZkClient zkClient = new SolrZkClient(zkServer.getZkHost(), AbstractZkTestCase.TIMEOUT)) {\n      zkClient.makePath(\"/solr/solr.xml\", solrXml.getBytes(Charset.defaultCharset()), true);\n      if (jettyConfig.sslConfig != null && jettyConfig.sslConfig.isSSLMode()) {\n        zkClient.makePath(\"/solr\" + ZkStateReader.CLUSTER_PROPS, \"{'urlScheme':'https'}\".getBytes(StandardCharsets.UTF_8), true);\n      }\n      if (securityJson.isPresent()) { // configure Solr security\n        zkClient.makePath(\"/solr/security.json\", securityJson.get().getBytes(Charset.defaultCharset()), true);\n      }\n    }\n\n    // tell solr to look in zookeeper for solr.xml\n    System.setProperty(\"zkHost\", zkServer.getZkAddress());\n\n    List<Callable<JettySolrRunner>> startups = new ArrayList<>(numServers);\n    for (int i = 0; i < numServers; ++i) {\n      startups.add(() -> startJettySolrRunner(newNodeName(), jettyConfig.context, jettyConfig));\n    }\n\n    Collection<Future<JettySolrRunner>> futures = executorLauncher.invokeAll(startups);\n    Exception startupError = checkForExceptions(\"Error starting up MiniSolrCloudCluster\", futures);\n    if (startupError != null) {\n      try {\n        this.shutdown();\n      }\n      catch (Throwable t) {\n        startupError.addSuppressed(t);\n      }\n      throw startupError;\n    }\n\n    waitForAllNodes(numServers, 60);\n\n    solrClient = buildSolrClient();\n  }\n\n","bugFix":["29887daf839649150d96855b142b76f5c45d60d2"],"bugIntro":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"040bf6d317e5bde94816bd7fe6eb0ed324306e2a","date":1544756375,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster#MiniSolrCloudCluster(int,Path,String,JettyConfig,ZkTestServer,Optional[String]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster#MiniSolrCloudCluster(int,Path,String,JettyConfig,ZkTestServer,Optional[String]).mjava","sourceNew":"  /**\n   * Create a MiniSolrCloudCluster.\n   * Note - this constructor visibility is changed to package protected so as to\n   * discourage its usage. Ideally *new* functionality should use {@linkplain SolrCloudTestCase}\n   * to configure any additional parameters.\n   *\n   * @param numServers number of Solr servers to start\n   * @param baseDir base directory that the mini cluster should be run from\n   * @param solrXml solr.xml file to be uploaded to ZooKeeper\n   * @param jettyConfig Jetty configuration\n   * @param zkTestServer ZkTestServer to use.  If null, one will be created\n   * @param securityJson A string representation of security.json file (optional).\n   *\n   * @throws Exception if there was an error starting the cluster\n   */\n   MiniSolrCloudCluster(int numServers, Path baseDir, String solrXml, JettyConfig jettyConfig,\n      ZkTestServer zkTestServer, Optional<String> securityJson) throws Exception {\n\n    Objects.requireNonNull(securityJson);\n    this.baseDir = Objects.requireNonNull(baseDir);\n    this.jettyConfig = Objects.requireNonNull(jettyConfig);\n\n    log.info(\"Starting cluster of {} servers in {}\", numServers, baseDir);\n\n    Files.createDirectories(baseDir);\n\n    this.externalZkServer = zkTestServer != null;\n    if (!externalZkServer) {\n      String zkDir = baseDir.resolve(\"zookeeper/server1/data\").toString();\n      zkTestServer = new ZkTestServer(zkDir);\n      try {\n        zkTestServer.run();\n      } catch (Exception e) {\n        log.error(\"Error starting Zk Test Server, trying again ...\");\n        zkTestServer.shutdown();\n        zkTestServer = new ZkTestServer(zkDir);\n        zkTestServer.run();\n      }\n    }\n    this.zkServer = zkTestServer;\n\n    try (SolrZkClient zkClient = new SolrZkClient(zkServer.getZkHost(), AbstractZkTestCase.TIMEOUT)) {\n      zkClient.makePath(\"/solr/solr.xml\", solrXml.getBytes(Charset.defaultCharset()), true);\n      if (jettyConfig.sslConfig != null && jettyConfig.sslConfig.isSSLMode()) {\n        zkClient.makePath(\"/solr\" + ZkStateReader.CLUSTER_PROPS, \"{'urlScheme':'https'}\".getBytes(StandardCharsets.UTF_8), true);\n      }\n      if (securityJson.isPresent()) { // configure Solr security\n        zkClient.makePath(\"/solr/security.json\", securityJson.get().getBytes(Charset.defaultCharset()), true);\n      }\n    }\n\n    // tell solr to look in zookeeper for solr.xml\n    System.setProperty(\"zkHost\", zkServer.getZkAddress());\n\n    List<Callable<JettySolrRunner>> startups = new ArrayList<>(numServers);\n    for (int i = 0; i < numServers; ++i) {\n      startups.add(() -> startJettySolrRunner(newNodeName(), jettyConfig.context, jettyConfig));\n    }\n\n    final ExecutorService executorLauncher = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"jetty-launcher\"));\n    Collection<Future<JettySolrRunner>> futures = executorLauncher.invokeAll(startups);\n    ExecutorUtil.shutdownAndAwaitTermination(executorLauncher);\n    Exception startupError = checkForExceptions(\"Error starting up MiniSolrCloudCluster\", futures);\n    if (startupError != null) {\n      try {\n        this.shutdown();\n      }\n      catch (Throwable t) {\n        startupError.addSuppressed(t);\n      }\n      throw startupError;\n    }\n\n    solrClient = buildSolrClient();\n    \n    if (numServers > 0) {\n      waitForAllNodes(numServers, 60);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Create a MiniSolrCloudCluster.\n   * Note - this constructor visibility is changed to package protected so as to\n   * discourage its usage. Ideally *new* functionality should use {@linkplain SolrCloudTestCase}\n   * to configure any additional parameters.\n   *\n   * @param numServers number of Solr servers to start\n   * @param baseDir base directory that the mini cluster should be run from\n   * @param solrXml solr.xml file to be uploaded to ZooKeeper\n   * @param jettyConfig Jetty configuration\n   * @param zkTestServer ZkTestServer to use.  If null, one will be created\n   * @param securityJson A string representation of security.json file (optional).\n   *\n   * @throws Exception if there was an error starting the cluster\n   */\n   MiniSolrCloudCluster(int numServers, Path baseDir, String solrXml, JettyConfig jettyConfig,\n      ZkTestServer zkTestServer, Optional<String> securityJson) throws Exception {\n\n    Objects.requireNonNull(securityJson);\n    this.baseDir = Objects.requireNonNull(baseDir);\n    this.jettyConfig = Objects.requireNonNull(jettyConfig);\n\n    log.info(\"Starting cluster of {} servers in {}\", numServers, baseDir);\n\n    Files.createDirectories(baseDir);\n\n    this.externalZkServer = zkTestServer != null;\n    if (!externalZkServer) {\n      String zkDir = baseDir.resolve(\"zookeeper/server1/data\").toString();\n      zkTestServer = new ZkTestServer(zkDir);\n      try {\n        zkTestServer.run();\n      } catch (Exception e) {\n        log.error(\"Error starting Zk Test Server, trying again ...\");\n        zkTestServer.shutdown();\n        zkTestServer = new ZkTestServer(zkDir);\n        zkTestServer.run();\n      }\n    }\n    this.zkServer = zkTestServer;\n\n    try (SolrZkClient zkClient = new SolrZkClient(zkServer.getZkHost(), AbstractZkTestCase.TIMEOUT)) {\n      zkClient.makePath(\"/solr/solr.xml\", solrXml.getBytes(Charset.defaultCharset()), true);\n      if (jettyConfig.sslConfig != null && jettyConfig.sslConfig.isSSLMode()) {\n        zkClient.makePath(\"/solr\" + ZkStateReader.CLUSTER_PROPS, \"{'urlScheme':'https'}\".getBytes(StandardCharsets.UTF_8), true);\n      }\n      if (securityJson.isPresent()) { // configure Solr security\n        zkClient.makePath(\"/solr/security.json\", securityJson.get().getBytes(Charset.defaultCharset()), true);\n      }\n    }\n\n    // tell solr to look in zookeeper for solr.xml\n    System.setProperty(\"zkHost\", zkServer.getZkAddress());\n\n    List<Callable<JettySolrRunner>> startups = new ArrayList<>(numServers);\n    for (int i = 0; i < numServers; ++i) {\n      startups.add(() -> startJettySolrRunner(newNodeName(), jettyConfig.context, jettyConfig));\n    }\n\n    Collection<Future<JettySolrRunner>> futures = executorLauncher.invokeAll(startups);\n    Exception startupError = checkForExceptions(\"Error starting up MiniSolrCloudCluster\", futures);\n    if (startupError != null) {\n      try {\n        this.shutdown();\n      }\n      catch (Throwable t) {\n        startupError.addSuppressed(t);\n      }\n      throw startupError;\n    }\n\n    solrClient = buildSolrClient();\n    \n    if (numServers > 0) {\n      waitForAllNodes(numServers, 60);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c1f2dfc9523bc98b4548d58a9f81ad16872cd9","date":1544802186,"type":3,"author":"Erick Erickson","isMerge":true,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster#MiniSolrCloudCluster(int,Path,String,JettyConfig,ZkTestServer,Optional[String]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster#MiniSolrCloudCluster(int,Path,String,JettyConfig,ZkTestServer,Optional[String]).mjava","sourceNew":"  /**\n   * Create a MiniSolrCloudCluster.\n   * Note - this constructor visibility is changed to package protected so as to\n   * discourage its usage. Ideally *new* functionality should use {@linkplain SolrCloudTestCase}\n   * to configure any additional parameters.\n   *\n   * @param numServers number of Solr servers to start\n   * @param baseDir base directory that the mini cluster should be run from\n   * @param solrXml solr.xml file to be uploaded to ZooKeeper\n   * @param jettyConfig Jetty configuration\n   * @param zkTestServer ZkTestServer to use.  If null, one will be created\n   * @param securityJson A string representation of security.json file (optional).\n   *\n   * @throws Exception if there was an error starting the cluster\n   */\n   MiniSolrCloudCluster(int numServers, Path baseDir, String solrXml, JettyConfig jettyConfig,\n      ZkTestServer zkTestServer, Optional<String> securityJson) throws Exception {\n\n    Objects.requireNonNull(securityJson);\n    this.baseDir = Objects.requireNonNull(baseDir);\n    this.jettyConfig = Objects.requireNonNull(jettyConfig);\n\n    log.info(\"Starting cluster of {} servers in {}\", numServers, baseDir);\n\n    Files.createDirectories(baseDir);\n\n    this.externalZkServer = zkTestServer != null;\n    if (!externalZkServer) {\n      String zkDir = baseDir.resolve(\"zookeeper/server1/data\").toString();\n      zkTestServer = new ZkTestServer(zkDir);\n      try {\n        zkTestServer.run();\n      } catch (Exception e) {\n        log.error(\"Error starting Zk Test Server, trying again ...\");\n        zkTestServer.shutdown();\n        zkTestServer = new ZkTestServer(zkDir);\n        zkTestServer.run();\n      }\n    }\n    this.zkServer = zkTestServer;\n\n    try (SolrZkClient zkClient = new SolrZkClient(zkServer.getZkHost(), AbstractZkTestCase.TIMEOUT)) {\n      zkClient.makePath(\"/solr/solr.xml\", solrXml.getBytes(Charset.defaultCharset()), true);\n      if (jettyConfig.sslConfig != null && jettyConfig.sslConfig.isSSLMode()) {\n        zkClient.makePath(\"/solr\" + ZkStateReader.CLUSTER_PROPS, \"{'urlScheme':'https'}\".getBytes(StandardCharsets.UTF_8), true);\n      }\n      if (securityJson.isPresent()) { // configure Solr security\n        zkClient.makePath(\"/solr/security.json\", securityJson.get().getBytes(Charset.defaultCharset()), true);\n      }\n    }\n\n    // tell solr to look in zookeeper for solr.xml\n    System.setProperty(\"zkHost\", zkServer.getZkAddress());\n\n    List<Callable<JettySolrRunner>> startups = new ArrayList<>(numServers);\n    for (int i = 0; i < numServers; ++i) {\n      startups.add(() -> startJettySolrRunner(newNodeName(), jettyConfig.context, jettyConfig));\n    }\n\n    final ExecutorService executorLauncher = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"jetty-launcher\"));\n    Collection<Future<JettySolrRunner>> futures = executorLauncher.invokeAll(startups);\n    ExecutorUtil.shutdownAndAwaitTermination(executorLauncher);\n    Exception startupError = checkForExceptions(\"Error starting up MiniSolrCloudCluster\", futures);\n    if (startupError != null) {\n      try {\n        this.shutdown();\n      }\n      catch (Throwable t) {\n        startupError.addSuppressed(t);\n      }\n      throw startupError;\n    }\n\n    solrClient = buildSolrClient();\n    \n    if (numServers > 0) {\n      waitForAllNodes(numServers, 60);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Create a MiniSolrCloudCluster.\n   * Note - this constructor visibility is changed to package protected so as to\n   * discourage its usage. Ideally *new* functionality should use {@linkplain SolrCloudTestCase}\n   * to configure any additional parameters.\n   *\n   * @param numServers number of Solr servers to start\n   * @param baseDir base directory that the mini cluster should be run from\n   * @param solrXml solr.xml file to be uploaded to ZooKeeper\n   * @param jettyConfig Jetty configuration\n   * @param zkTestServer ZkTestServer to use.  If null, one will be created\n   * @param securityJson A string representation of security.json file (optional).\n   *\n   * @throws Exception if there was an error starting the cluster\n   */\n   MiniSolrCloudCluster(int numServers, Path baseDir, String solrXml, JettyConfig jettyConfig,\n      ZkTestServer zkTestServer, Optional<String> securityJson) throws Exception {\n\n    Objects.requireNonNull(securityJson);\n    this.baseDir = Objects.requireNonNull(baseDir);\n    this.jettyConfig = Objects.requireNonNull(jettyConfig);\n\n    log.info(\"Starting cluster of {} servers in {}\", numServers, baseDir);\n\n    Files.createDirectories(baseDir);\n\n    this.externalZkServer = zkTestServer != null;\n    if (!externalZkServer) {\n      String zkDir = baseDir.resolve(\"zookeeper/server1/data\").toString();\n      zkTestServer = new ZkTestServer(zkDir);\n      try {\n        zkTestServer.run();\n      } catch (Exception e) {\n        log.error(\"Error starting Zk Test Server, trying again ...\");\n        zkTestServer.shutdown();\n        zkTestServer = new ZkTestServer(zkDir);\n        zkTestServer.run();\n      }\n    }\n    this.zkServer = zkTestServer;\n\n    try (SolrZkClient zkClient = new SolrZkClient(zkServer.getZkHost(), AbstractZkTestCase.TIMEOUT)) {\n      zkClient.makePath(\"/solr/solr.xml\", solrXml.getBytes(Charset.defaultCharset()), true);\n      if (jettyConfig.sslConfig != null && jettyConfig.sslConfig.isSSLMode()) {\n        zkClient.makePath(\"/solr\" + ZkStateReader.CLUSTER_PROPS, \"{'urlScheme':'https'}\".getBytes(StandardCharsets.UTF_8), true);\n      }\n      if (securityJson.isPresent()) { // configure Solr security\n        zkClient.makePath(\"/solr/security.json\", securityJson.get().getBytes(Charset.defaultCharset()), true);\n      }\n    }\n\n    // tell solr to look in zookeeper for solr.xml\n    System.setProperty(\"zkHost\", zkServer.getZkAddress());\n\n    List<Callable<JettySolrRunner>> startups = new ArrayList<>(numServers);\n    for (int i = 0; i < numServers; ++i) {\n      startups.add(() -> startJettySolrRunner(newNodeName(), jettyConfig.context, jettyConfig));\n    }\n\n    Collection<Future<JettySolrRunner>> futures = executorLauncher.invokeAll(startups);\n    Exception startupError = checkForExceptions(\"Error starting up MiniSolrCloudCluster\", futures);\n    if (startupError != null) {\n      try {\n        this.shutdown();\n      }\n      catch (Throwable t) {\n        startupError.addSuppressed(t);\n      }\n      throw startupError;\n    }\n\n    solrClient = buildSolrClient();\n    \n    if (numServers > 0) {\n      waitForAllNodes(numServers, 60);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3584d3db8b472772e3329d9d95d584b68ae997e","date":1551710517,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster#MiniSolrCloudCluster(int,Path,String,JettyConfig,ZkTestServer,Optional[String]).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster#MiniSolrCloudCluster(int,Path,String,JettyConfig,ZkTestServer,Optional[String]).mjava","sourceNew":"  /**\n   * Create a MiniSolrCloudCluster.\n   * Note - this constructor visibility is changed to package protected so as to\n   * discourage its usage. Ideally *new* functionality should use {@linkplain SolrCloudTestCase}\n   * to configure any additional parameters.\n   *\n   * @param numServers number of Solr servers to start\n   * @param baseDir base directory that the mini cluster should be run from\n   * @param solrXml solr.xml file to be uploaded to ZooKeeper\n   * @param jettyConfig Jetty configuration\n   * @param zkTestServer ZkTestServer to use.  If null, one will be created\n   * @param securityJson A string representation of security.json file (optional).\n   *\n   * @throws Exception if there was an error starting the cluster\n   */\n   MiniSolrCloudCluster(int numServers, Path baseDir, String solrXml, JettyConfig jettyConfig,\n      ZkTestServer zkTestServer, Optional<String> securityJson) throws Exception {\n     this(numServers, baseDir, solrXml, jettyConfig,\n         zkTestServer,securityJson, false);\n   }\n\n","sourceOld":"  /**\n   * Create a MiniSolrCloudCluster.\n   * Note - this constructor visibility is changed to package protected so as to\n   * discourage its usage. Ideally *new* functionality should use {@linkplain SolrCloudTestCase}\n   * to configure any additional parameters.\n   *\n   * @param numServers number of Solr servers to start\n   * @param baseDir base directory that the mini cluster should be run from\n   * @param solrXml solr.xml file to be uploaded to ZooKeeper\n   * @param jettyConfig Jetty configuration\n   * @param zkTestServer ZkTestServer to use.  If null, one will be created\n   * @param securityJson A string representation of security.json file (optional).\n   *\n   * @throws Exception if there was an error starting the cluster\n   */\n   MiniSolrCloudCluster(int numServers, Path baseDir, String solrXml, JettyConfig jettyConfig,\n      ZkTestServer zkTestServer, Optional<String> securityJson) throws Exception {\n\n    Objects.requireNonNull(securityJson);\n    this.baseDir = Objects.requireNonNull(baseDir);\n    this.jettyConfig = Objects.requireNonNull(jettyConfig);\n\n    log.info(\"Starting cluster of {} servers in {}\", numServers, baseDir);\n\n    Files.createDirectories(baseDir);\n\n    this.externalZkServer = zkTestServer != null;\n    if (!externalZkServer) {\n      String zkDir = baseDir.resolve(\"zookeeper/server1/data\").toString();\n      zkTestServer = new ZkTestServer(zkDir);\n      try {\n        zkTestServer.run();\n      } catch (Exception e) {\n        log.error(\"Error starting Zk Test Server, trying again ...\");\n        zkTestServer.shutdown();\n        zkTestServer = new ZkTestServer(zkDir);\n        zkTestServer.run();\n      }\n    }\n    this.zkServer = zkTestServer;\n\n    try (SolrZkClient zkClient = new SolrZkClient(zkServer.getZkHost(), AbstractZkTestCase.TIMEOUT)) {\n      zkClient.makePath(\"/solr/solr.xml\", solrXml.getBytes(Charset.defaultCharset()), true);\n      if (jettyConfig.sslConfig != null && jettyConfig.sslConfig.isSSLMode()) {\n        zkClient.makePath(\"/solr\" + ZkStateReader.CLUSTER_PROPS, \"{'urlScheme':'https'}\".getBytes(StandardCharsets.UTF_8), true);\n      }\n      if (securityJson.isPresent()) { // configure Solr security\n        zkClient.makePath(\"/solr/security.json\", securityJson.get().getBytes(Charset.defaultCharset()), true);\n      }\n    }\n\n    // tell solr to look in zookeeper for solr.xml\n    System.setProperty(\"zkHost\", zkServer.getZkAddress());\n\n    List<Callable<JettySolrRunner>> startups = new ArrayList<>(numServers);\n    for (int i = 0; i < numServers; ++i) {\n      startups.add(() -> startJettySolrRunner(newNodeName(), jettyConfig.context, jettyConfig));\n    }\n\n    final ExecutorService executorLauncher = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"jetty-launcher\"));\n    Collection<Future<JettySolrRunner>> futures = executorLauncher.invokeAll(startups);\n    ExecutorUtil.shutdownAndAwaitTermination(executorLauncher);\n    Exception startupError = checkForExceptions(\"Error starting up MiniSolrCloudCluster\", futures);\n    if (startupError != null) {\n      try {\n        this.shutdown();\n      }\n      catch (Throwable t) {\n        startupError.addSuppressed(t);\n      }\n      throw startupError;\n    }\n\n    solrClient = buildSolrClient();\n    \n    if (numServers > 0) {\n      waitForAllNodes(numServers, 60);\n    }\n\n  }\n\n","bugFix":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","29887daf839649150d96855b142b76f5c45d60d2","040bf6d317e5bde94816bd7fe6eb0ed324306e2a","d32e632a4641366d674c7dbfd8fd155b0f96dc31"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a3c1f2dfc9523bc98b4548d58a9f81ad16872cd9":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","040bf6d317e5bde94816bd7fe6eb0ed324306e2a"],"29887daf839649150d96855b142b76f5c45d60d2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","29887daf839649150d96855b142b76f5c45d60d2"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["d32e632a4641366d674c7dbfd8fd155b0f96dc31"],"040bf6d317e5bde94816bd7fe6eb0ed324306e2a":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d32e632a4641366d674c7dbfd8fd155b0f96dc31":["29887daf839649150d96855b142b76f5c45d60d2"],"a3584d3db8b472772e3329d9d95d584b68ae997e":["a3c1f2dfc9523bc98b4548d58a9f81ad16872cd9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a3584d3db8b472772e3329d9d95d584b68ae997e"]},"commit2Childs":{"a3c1f2dfc9523bc98b4548d58a9f81ad16872cd9":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"29887daf839649150d96855b142b76f5c45d60d2":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","d32e632a4641366d674c7dbfd8fd155b0f96dc31"],"5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf":[],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["a3c1f2dfc9523bc98b4548d58a9f81ad16872cd9","040bf6d317e5bde94816bd7fe6eb0ed324306e2a"],"040bf6d317e5bde94816bd7fe6eb0ed324306e2a":["a3c1f2dfc9523bc98b4548d58a9f81ad16872cd9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["29887daf839649150d96855b142b76f5c45d60d2","5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf"],"d32e632a4641366d674c7dbfd8fd155b0f96dc31":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"a3584d3db8b472772e3329d9d95d584b68ae997e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5acd68c5f07f7ee604c2eeffe801f4a2d7a1a5bf","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}