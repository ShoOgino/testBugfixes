{"path":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionIntegrationTest#testLeaderElectionAfterClientTimeout().mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionIntegrationTest#testLeaderElectionAfterClientTimeout().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testLeaderElectionAfterClientTimeout() throws Exception {\n    // TODO: work out the best timing here...\n    System.setProperty(\"zkClientTimeout\", \"500\");\n    // timeout the leader\n    String leader = getLeader();\n    int leaderPort = getLeaderPort(leader);\n    containerMap.get(leaderPort).getZkController().getZkClient().getSolrZooKeeper().pauseCnxn(2000);\n    \n    for (int i = 0; i < 60; i++) { // wait till leader is changed\n      if (leaderPort != getLeaderPort(getLeader())) {\n        break;\n      }\n      Thread.sleep(100);\n    }\n    \n    if (VERBOSE) System.out.println(\"kill everyone\");\n    // kill everyone but the first leader that should have reconnected by now\n    for (Map.Entry<Integer,CoreContainer> entry : containerMap.entrySet()) {\n      if (entry.getKey() != leaderPort) {\n        entry.getValue().shutdown();\n      }\n    }\n\n    for (int i = 0; i < 60; i++) { // wait till leader is changed\n      if (leaderPort == getLeaderPort(getLeader())) {\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    // the original leader should be leader again now - everyone else is down\n    // TODO: I saw this fail once...expected:<7000> but was:<7004>\n    assertEquals(leaderPort, getLeaderPort(getLeader()));\n    //printLayout(zkServer.getZkAddress());\n    //Thread.sleep(100000);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["a6378064655e76cd7b908b1cab4ce425b384b508"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionIntegrationTest#testLeaderElectionAfterClientTimeout().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testLeaderElectionAfterClientTimeout() throws Exception {\n    // TODO: work out the best timing here...\n    System.setProperty(\"zkClientTimeout\", \"500\");\n    // timeout the leader\n    String leader = getLeader();\n    int leaderPort = getLeaderPort(leader);\n    containerMap.get(leaderPort).getZkController().getZkClient().getSolrZooKeeper().pauseCnxn(2000);\n    \n    for (int i = 0; i < 60; i++) { // wait till leader is changed\n      if (leaderPort != getLeaderPort(getLeader())) {\n        break;\n      }\n      Thread.sleep(100);\n    }\n    \n    if (VERBOSE) System.out.println(\"kill everyone\");\n    // kill everyone but the first leader that should have reconnected by now\n    for (Map.Entry<Integer,CoreContainer> entry : containerMap.entrySet()) {\n      if (entry.getKey() != leaderPort) {\n        entry.getValue().shutdown();\n      }\n    }\n\n    for (int i = 0; i < 60; i++) { // wait till leader is changed\n      if (leaderPort == getLeaderPort(getLeader())) {\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    // the original leader should be leader again now - everyone else is down\n    // TODO: I saw this fail once...expected:<7000> but was:<7004>\n    assertEquals(leaderPort, getLeaderPort(getLeader()));\n    //printLayout(zkServer.getZkAddress());\n    //Thread.sleep(100000);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionIntegrationTest#testLeaderElectionAfterClientTimeout().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testLeaderElectionAfterClientTimeout() throws Exception {\n    // TODO: work out the best timing here...\n    System.setProperty(\"zkClientTimeout\", \"500\");\n    // timeout the leader\n    String leader = getLeader();\n    int leaderPort = getLeaderPort(leader);\n    containerMap.get(leaderPort).getZkController().getZkClient().getSolrZooKeeper().pauseCnxn(2000);\n    \n    for (int i = 0; i < 60; i++) { // wait till leader is changed\n      if (leaderPort != getLeaderPort(getLeader())) {\n        break;\n      }\n      Thread.sleep(100);\n    }\n    \n    if (VERBOSE) System.out.println(\"kill everyone\");\n    // kill everyone but the first leader that should have reconnected by now\n    for (Map.Entry<Integer,CoreContainer> entry : containerMap.entrySet()) {\n      if (entry.getKey() != leaderPort) {\n        entry.getValue().shutdown();\n      }\n    }\n\n    for (int i = 0; i < 60; i++) { // wait till leader is changed\n      if (leaderPort == getLeaderPort(getLeader())) {\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    // the original leader should be leader again now - everyone else is down\n    // TODO: I saw this fail once...expected:<7000> but was:<7004>\n    assertEquals(leaderPort, getLeaderPort(getLeader()));\n    //printLayout(zkServer.getZkAddress());\n    //Thread.sleep(100000);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6378064655e76cd7b908b1cab4ce425b384b508","date":1347656715,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionIntegrationTest#testLeaderElectionAfterClientTimeout().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionIntegrationTest#testLeaderElectionAfterClientTimeout().mjava","sourceNew":"  @Test\n  public void testLeaderElectionAfterClientTimeout() throws Exception {\n    // TODO: work out the best timing here...\n    System.setProperty(\"zkClientTimeout\", Integer.toString(ZkTestServer.TICK_TIME * 2 + 100));\n    // timeout the leader\n    String leader = getLeader();\n    int leaderPort = getLeaderPort(leader);\n    ZkController zkController = containerMap.get(leaderPort).getZkController();\n    zkController.getZkClient().getSolrZooKeeper().pauseCnxn(zkController.getClientTimeout() + 100);\n    \n    for (int i = 0; i < 60; i++) { // wait till leader is changed\n      if (leaderPort != getLeaderPort(getLeader())) {\n        break;\n      }\n      Thread.sleep(100);\n    }\n    \n    // make sure we have waited long enough for the first leader to have come back\n    Thread.sleep(ZkTestServer.TICK_TIME * 2 + 100);\n    \n    if (VERBOSE) System.out.println(\"kill everyone\");\n    // kill everyone but the first leader that should have reconnected by now\n    for (Map.Entry<Integer,CoreContainer> entry : containerMap.entrySet()) {\n      if (entry.getKey() != leaderPort) {\n        entry.getValue().shutdown();\n      }\n    }\n\n    for (int i = 0; i < 320; i++) { // wait till leader is changed\n      try {\n        if (leaderPort == getLeaderPort(getLeader())) {\n          break;\n        }\n        Thread.sleep(100);\n      } catch (Exception e) {\n        continue;\n      }\n    }\n\n    // the original leader should be leader again now - everyone else is down\n    // TODO: I saw this fail once...expected:<7000> but was:<7004>\n    assertEquals(leaderPort, getLeaderPort(getLeader()));\n    //printLayout(zkServer.getZkAddress());\n    //Thread.sleep(100000);\n  }\n\n","sourceOld":"  @Test\n  public void testLeaderElectionAfterClientTimeout() throws Exception {\n    // TODO: work out the best timing here...\n    System.setProperty(\"zkClientTimeout\", \"500\");\n    // timeout the leader\n    String leader = getLeader();\n    int leaderPort = getLeaderPort(leader);\n    containerMap.get(leaderPort).getZkController().getZkClient().getSolrZooKeeper().pauseCnxn(2000);\n    \n    for (int i = 0; i < 60; i++) { // wait till leader is changed\n      if (leaderPort != getLeaderPort(getLeader())) {\n        break;\n      }\n      Thread.sleep(100);\n    }\n    \n    if (VERBOSE) System.out.println(\"kill everyone\");\n    // kill everyone but the first leader that should have reconnected by now\n    for (Map.Entry<Integer,CoreContainer> entry : containerMap.entrySet()) {\n      if (entry.getKey() != leaderPort) {\n        entry.getValue().shutdown();\n      }\n    }\n\n    for (int i = 0; i < 60; i++) { // wait till leader is changed\n      if (leaderPort == getLeaderPort(getLeader())) {\n        break;\n      }\n      Thread.sleep(100);\n    }\n\n    // the original leader should be leader again now - everyone else is down\n    // TODO: I saw this fail once...expected:<7000> but was:<7004>\n    assertEquals(leaderPort, getLeaderPort(getLeader()));\n    //printLayout(zkServer.getZkAddress());\n    //Thread.sleep(100000);\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":["be9f7175e1703e31f8d8de32612b7212db6acf76"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"be9f7175e1703e31f8d8de32612b7212db6acf76","date":1408660152,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionIntegrationTest#testLeaderElectionAfterClientTimeout().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionIntegrationTest#testLeaderElectionAfterClientTimeout().mjava","sourceNew":"  @Test\n  public void testLeaderElectionAfterClientTimeout() throws Exception {\n    // TODO: work out the best timing here...\n    System.setProperty(\"zkClientTimeout\", Integer.toString(ZkTestServer.TICK_TIME * 2 + 100));\n    // timeout the leader\n    String leader = getLeader();\n    int leaderPort = getLeaderPort(leader);\n    ZkController zkController = containerMap.get(leaderPort).getZkController();\n\n    zkController.getZkClient().getSolrZooKeeper().closeCnxn();\n    long sessionId = zkClient.getSolrZooKeeper().getSessionId();\n    zkServer.expire(sessionId);\n    \n    for (int i = 0; i < 60; i++) { // wait till leader is changed\n      if (leaderPort != getLeaderPort(getLeader())) {\n        break;\n      }\n      Thread.sleep(100);\n    }\n    \n    // make sure we have waited long enough for the first leader to have come back\n    Thread.sleep(ZkTestServer.TICK_TIME * 2 + 100);\n    \n    if (VERBOSE) System.out.println(\"kill everyone\");\n    // kill everyone but the first leader that should have reconnected by now\n    for (Map.Entry<Integer,CoreContainer> entry : containerMap.entrySet()) {\n      if (entry.getKey() != leaderPort) {\n        entry.getValue().shutdown();\n      }\n    }\n\n    for (int i = 0; i < 320; i++) { // wait till leader is changed\n      try {\n        if (leaderPort == getLeaderPort(getLeader())) {\n          break;\n        }\n        Thread.sleep(100);\n      } catch (Exception e) {\n        continue;\n      }\n    }\n\n    // the original leader should be leader again now - everyone else is down\n    // TODO: I saw this fail once...expected:<7000> but was:<7004>\n    assertEquals(leaderPort, getLeaderPort(getLeader()));\n    //printLayout(zkServer.getZkAddress());\n    //Thread.sleep(100000);\n  }\n\n","sourceOld":"  @Test\n  public void testLeaderElectionAfterClientTimeout() throws Exception {\n    // TODO: work out the best timing here...\n    System.setProperty(\"zkClientTimeout\", Integer.toString(ZkTestServer.TICK_TIME * 2 + 100));\n    // timeout the leader\n    String leader = getLeader();\n    int leaderPort = getLeaderPort(leader);\n    ZkController zkController = containerMap.get(leaderPort).getZkController();\n    zkController.getZkClient().getSolrZooKeeper().pauseCnxn(zkController.getClientTimeout() + 100);\n    \n    for (int i = 0; i < 60; i++) { // wait till leader is changed\n      if (leaderPort != getLeaderPort(getLeader())) {\n        break;\n      }\n      Thread.sleep(100);\n    }\n    \n    // make sure we have waited long enough for the first leader to have come back\n    Thread.sleep(ZkTestServer.TICK_TIME * 2 + 100);\n    \n    if (VERBOSE) System.out.println(\"kill everyone\");\n    // kill everyone but the first leader that should have reconnected by now\n    for (Map.Entry<Integer,CoreContainer> entry : containerMap.entrySet()) {\n      if (entry.getKey() != leaderPort) {\n        entry.getValue().shutdown();\n      }\n    }\n\n    for (int i = 0; i < 320; i++) { // wait till leader is changed\n      try {\n        if (leaderPort == getLeaderPort(getLeader())) {\n          break;\n        }\n        Thread.sleep(100);\n      } catch (Exception e) {\n        continue;\n      }\n    }\n\n    // the original leader should be leader again now - everyone else is down\n    // TODO: I saw this fail once...expected:<7000> but was:<7004>\n    assertEquals(leaderPort, getLeaderPort(getLeader()));\n    //printLayout(zkServer.getZkAddress());\n    //Thread.sleep(100000);\n  }\n\n","bugFix":["a6378064655e76cd7b908b1cab4ce425b384b508"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"82fbc9a4af34a68002cd5cf8bbac6b604aeef413","date":1474634253,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionIntegrationTest#testLeaderElectionAfterClientTimeout().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionIntegrationTest#testLeaderElectionAfterClientTimeout().mjava","sourceNew":"  @Test\n  public void testLeaderElectionAfterClientTimeout() throws Exception {\n    // TODO: work out the best timing here...\n    System.setProperty(\"zkClientTimeout\", Integer.toString(ZkTestServer.TICK_TIME * 2 + 100));\n    // timeout the leader\n    String leader = getLeader();\n    int leaderPort = getLeaderPort(leader);\n    ZkController zkController = containerMap.get(leaderPort).getZkController();\n\n    zkController.getZkClient().getSolrZooKeeper().closeCnxn();\n    long sessionId = zkClient.getSolrZooKeeper().getSessionId();\n    zkServer.expire(sessionId);\n    \n    for (int i = 0; i < 60; i++) { // wait till leader is changed\n      if (leaderPort != getLeaderPort(getLeader())) {\n        break;\n      }\n      Thread.sleep(100);\n    }\n    \n    // make sure we have waited long enough for the first leader to have come back\n    Thread.sleep(ZkTestServer.TICK_TIME * 2 + 100);\n    \n    // kill everyone but the first leader that should have reconnected by now\n    for (Map.Entry<Integer,CoreContainer> entry : containerMap.entrySet()) {\n      if (entry.getKey() != leaderPort) {\n        entry.getValue().shutdown();\n      }\n    }\n\n    for (int i = 0; i < 320; i++) { // wait till leader is changed\n      try {\n        if (leaderPort == getLeaderPort(getLeader())) {\n          break;\n        }\n        Thread.sleep(100);\n      } catch (Exception e) {\n        continue;\n      }\n    }\n\n    // the original leader should be leader again now - everyone else is down\n    // TODO: I saw this fail once...expected:<7000> but was:<7004>\n    assertEquals(leaderPort, getLeaderPort(getLeader()));\n    //printLayout(zkServer.getZkAddress());\n    //Thread.sleep(100000);\n  }\n\n","sourceOld":"  @Test\n  public void testLeaderElectionAfterClientTimeout() throws Exception {\n    // TODO: work out the best timing here...\n    System.setProperty(\"zkClientTimeout\", Integer.toString(ZkTestServer.TICK_TIME * 2 + 100));\n    // timeout the leader\n    String leader = getLeader();\n    int leaderPort = getLeaderPort(leader);\n    ZkController zkController = containerMap.get(leaderPort).getZkController();\n\n    zkController.getZkClient().getSolrZooKeeper().closeCnxn();\n    long sessionId = zkClient.getSolrZooKeeper().getSessionId();\n    zkServer.expire(sessionId);\n    \n    for (int i = 0; i < 60; i++) { // wait till leader is changed\n      if (leaderPort != getLeaderPort(getLeader())) {\n        break;\n      }\n      Thread.sleep(100);\n    }\n    \n    // make sure we have waited long enough for the first leader to have come back\n    Thread.sleep(ZkTestServer.TICK_TIME * 2 + 100);\n    \n    if (VERBOSE) System.out.println(\"kill everyone\");\n    // kill everyone but the first leader that should have reconnected by now\n    for (Map.Entry<Integer,CoreContainer> entry : containerMap.entrySet()) {\n      if (entry.getKey() != leaderPort) {\n        entry.getValue().shutdown();\n      }\n    }\n\n    for (int i = 0; i < 320; i++) { // wait till leader is changed\n      try {\n        if (leaderPort == getLeaderPort(getLeader())) {\n          break;\n        }\n        Thread.sleep(100);\n      } catch (Exception e) {\n        continue;\n      }\n    }\n\n    // the original leader should be leader again now - everyone else is down\n    // TODO: I saw this fail once...expected:<7000> but was:<7004>\n    assertEquals(leaderPort, getLeaderPort(getLeader()));\n    //printLayout(zkServer.getZkAddress());\n    //Thread.sleep(100000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionIntegrationTest#testLeaderElectionAfterClientTimeout().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionIntegrationTest#testLeaderElectionAfterClientTimeout().mjava","sourceNew":"  @Test\n  public void testLeaderElectionAfterClientTimeout() throws Exception {\n    // TODO: work out the best timing here...\n    System.setProperty(\"zkClientTimeout\", Integer.toString(ZkTestServer.TICK_TIME * 2 + 100));\n    // timeout the leader\n    String leader = getLeader();\n    int leaderPort = getLeaderPort(leader);\n    ZkController zkController = containerMap.get(leaderPort).getZkController();\n\n    zkController.getZkClient().getSolrZooKeeper().closeCnxn();\n    long sessionId = zkClient.getSolrZooKeeper().getSessionId();\n    zkServer.expire(sessionId);\n    \n    for (int i = 0; i < 60; i++) { // wait till leader is changed\n      if (leaderPort != getLeaderPort(getLeader())) {\n        break;\n      }\n      Thread.sleep(100);\n    }\n    \n    // make sure we have waited long enough for the first leader to have come back\n    Thread.sleep(ZkTestServer.TICK_TIME * 2 + 100);\n    \n    // kill everyone but the first leader that should have reconnected by now\n    for (Map.Entry<Integer,CoreContainer> entry : containerMap.entrySet()) {\n      if (entry.getKey() != leaderPort) {\n        entry.getValue().shutdown();\n      }\n    }\n\n    for (int i = 0; i < 320; i++) { // wait till leader is changed\n      try {\n        if (leaderPort == getLeaderPort(getLeader())) {\n          break;\n        }\n        Thread.sleep(100);\n      } catch (Exception e) {\n        continue;\n      }\n    }\n\n    // the original leader should be leader again now - everyone else is down\n    // TODO: I saw this fail once...expected:<7000> but was:<7004>\n    assertEquals(leaderPort, getLeaderPort(getLeader()));\n    //printLayout(zkServer.getZkAddress());\n    //Thread.sleep(100000);\n  }\n\n","sourceOld":"  @Test\n  public void testLeaderElectionAfterClientTimeout() throws Exception {\n    // TODO: work out the best timing here...\n    System.setProperty(\"zkClientTimeout\", Integer.toString(ZkTestServer.TICK_TIME * 2 + 100));\n    // timeout the leader\n    String leader = getLeader();\n    int leaderPort = getLeaderPort(leader);\n    ZkController zkController = containerMap.get(leaderPort).getZkController();\n\n    zkController.getZkClient().getSolrZooKeeper().closeCnxn();\n    long sessionId = zkClient.getSolrZooKeeper().getSessionId();\n    zkServer.expire(sessionId);\n    \n    for (int i = 0; i < 60; i++) { // wait till leader is changed\n      if (leaderPort != getLeaderPort(getLeader())) {\n        break;\n      }\n      Thread.sleep(100);\n    }\n    \n    // make sure we have waited long enough for the first leader to have come back\n    Thread.sleep(ZkTestServer.TICK_TIME * 2 + 100);\n    \n    if (VERBOSE) System.out.println(\"kill everyone\");\n    // kill everyone but the first leader that should have reconnected by now\n    for (Map.Entry<Integer,CoreContainer> entry : containerMap.entrySet()) {\n      if (entry.getKey() != leaderPort) {\n        entry.getValue().shutdown();\n      }\n    }\n\n    for (int i = 0; i < 320; i++) { // wait till leader is changed\n      try {\n        if (leaderPort == getLeaderPort(getLeader())) {\n          break;\n        }\n        Thread.sleep(100);\n      } catch (Exception e) {\n        continue;\n      }\n    }\n\n    // the original leader should be leader again now - everyone else is down\n    // TODO: I saw this fail once...expected:<7000> but was:<7004>\n    assertEquals(leaderPort, getLeaderPort(getLeader()));\n    //printLayout(zkServer.getZkAddress());\n    //Thread.sleep(100000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionIntegrationTest#testLeaderElectionAfterClientTimeout().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionIntegrationTest#testLeaderElectionAfterClientTimeout().mjava","sourceNew":"  @Test\n  public void testLeaderElectionAfterClientTimeout() throws Exception {\n    // TODO: work out the best timing here...\n    System.setProperty(\"zkClientTimeout\", Integer.toString(ZkTestServer.TICK_TIME * 2 + 100));\n    // timeout the leader\n    String leader = getLeader();\n    int leaderPort = getLeaderPort(leader);\n    ZkController zkController = containerMap.get(leaderPort).getZkController();\n\n    zkController.getZkClient().getSolrZooKeeper().closeCnxn();\n    long sessionId = zkClient.getSolrZooKeeper().getSessionId();\n    zkServer.expire(sessionId);\n    \n    for (int i = 0; i < 60; i++) { // wait till leader is changed\n      if (leaderPort != getLeaderPort(getLeader())) {\n        break;\n      }\n      Thread.sleep(100);\n    }\n    \n    // make sure we have waited long enough for the first leader to have come back\n    Thread.sleep(ZkTestServer.TICK_TIME * 2 + 100);\n    \n    // kill everyone but the first leader that should have reconnected by now\n    for (Map.Entry<Integer,CoreContainer> entry : containerMap.entrySet()) {\n      if (entry.getKey() != leaderPort) {\n        entry.getValue().shutdown();\n      }\n    }\n\n    for (int i = 0; i < 320; i++) { // wait till leader is changed\n      try {\n        if (leaderPort == getLeaderPort(getLeader())) {\n          break;\n        }\n        Thread.sleep(100);\n      } catch (Exception e) {\n        continue;\n      }\n    }\n\n    // the original leader should be leader again now - everyone else is down\n    // TODO: I saw this fail once...expected:<7000> but was:<7004>\n    assertEquals(leaderPort, getLeaderPort(getLeader()));\n    //printLayout(zkServer.getZkAddress());\n    //Thread.sleep(100000);\n  }\n\n","sourceOld":"  @Test\n  public void testLeaderElectionAfterClientTimeout() throws Exception {\n    // TODO: work out the best timing here...\n    System.setProperty(\"zkClientTimeout\", Integer.toString(ZkTestServer.TICK_TIME * 2 + 100));\n    // timeout the leader\n    String leader = getLeader();\n    int leaderPort = getLeaderPort(leader);\n    ZkController zkController = containerMap.get(leaderPort).getZkController();\n\n    zkController.getZkClient().getSolrZooKeeper().closeCnxn();\n    long sessionId = zkClient.getSolrZooKeeper().getSessionId();\n    zkServer.expire(sessionId);\n    \n    for (int i = 0; i < 60; i++) { // wait till leader is changed\n      if (leaderPort != getLeaderPort(getLeader())) {\n        break;\n      }\n      Thread.sleep(100);\n    }\n    \n    // make sure we have waited long enough for the first leader to have come back\n    Thread.sleep(ZkTestServer.TICK_TIME * 2 + 100);\n    \n    if (VERBOSE) System.out.println(\"kill everyone\");\n    // kill everyone but the first leader that should have reconnected by now\n    for (Map.Entry<Integer,CoreContainer> entry : containerMap.entrySet()) {\n      if (entry.getKey() != leaderPort) {\n        entry.getValue().shutdown();\n      }\n    }\n\n    for (int i = 0; i < 320; i++) { // wait till leader is changed\n      try {\n        if (leaderPort == getLeaderPort(getLeader())) {\n          break;\n        }\n        Thread.sleep(100);\n      } catch (Exception e) {\n        continue;\n      }\n    }\n\n    // the original leader should be leader again now - everyone else is down\n    // TODO: I saw this fail once...expected:<7000> but was:<7004>\n    assertEquals(leaderPort, getLeaderPort(getLeader()));\n    //printLayout(zkServer.getZkAddress());\n    //Thread.sleep(100000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a9b4296bd51ca61b482138791478afdd0f7d3a3d","date":1498058739,"type":4,"author":"Cao Manh Dat","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionIntegrationTest#testLeaderElectionAfterClientTimeout().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testLeaderElectionAfterClientTimeout() throws Exception {\n    // TODO: work out the best timing here...\n    System.setProperty(\"zkClientTimeout\", Integer.toString(ZkTestServer.TICK_TIME * 2 + 100));\n    // timeout the leader\n    String leader = getLeader();\n    int leaderPort = getLeaderPort(leader);\n    ZkController zkController = containerMap.get(leaderPort).getZkController();\n\n    zkController.getZkClient().getSolrZooKeeper().closeCnxn();\n    long sessionId = zkClient.getSolrZooKeeper().getSessionId();\n    zkServer.expire(sessionId);\n    \n    for (int i = 0; i < 60; i++) { // wait till leader is changed\n      if (leaderPort != getLeaderPort(getLeader())) {\n        break;\n      }\n      Thread.sleep(100);\n    }\n    \n    // make sure we have waited long enough for the first leader to have come back\n    Thread.sleep(ZkTestServer.TICK_TIME * 2 + 100);\n    \n    // kill everyone but the first leader that should have reconnected by now\n    for (Map.Entry<Integer,CoreContainer> entry : containerMap.entrySet()) {\n      if (entry.getKey() != leaderPort) {\n        entry.getValue().shutdown();\n      }\n    }\n\n    for (int i = 0; i < 320; i++) { // wait till leader is changed\n      try {\n        if (leaderPort == getLeaderPort(getLeader())) {\n          break;\n        }\n        Thread.sleep(100);\n      } catch (Exception e) {\n        continue;\n      }\n    }\n\n    // the original leader should be leader again now - everyone else is down\n    // TODO: I saw this fail once...expected:<7000> but was:<7004>\n    assertEquals(leaderPort, getLeaderPort(getLeader()));\n    //printLayout(zkServer.getZkAddress());\n    //Thread.sleep(100000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":4,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionIntegrationTest#testLeaderElectionAfterClientTimeout().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testLeaderElectionAfterClientTimeout() throws Exception {\n    // TODO: work out the best timing here...\n    System.setProperty(\"zkClientTimeout\", Integer.toString(ZkTestServer.TICK_TIME * 2 + 100));\n    // timeout the leader\n    String leader = getLeader();\n    int leaderPort = getLeaderPort(leader);\n    ZkController zkController = containerMap.get(leaderPort).getZkController();\n\n    zkController.getZkClient().getSolrZooKeeper().closeCnxn();\n    long sessionId = zkClient.getSolrZooKeeper().getSessionId();\n    zkServer.expire(sessionId);\n    \n    for (int i = 0; i < 60; i++) { // wait till leader is changed\n      if (leaderPort != getLeaderPort(getLeader())) {\n        break;\n      }\n      Thread.sleep(100);\n    }\n    \n    // make sure we have waited long enough for the first leader to have come back\n    Thread.sleep(ZkTestServer.TICK_TIME * 2 + 100);\n    \n    // kill everyone but the first leader that should have reconnected by now\n    for (Map.Entry<Integer,CoreContainer> entry : containerMap.entrySet()) {\n      if (entry.getKey() != leaderPort) {\n        entry.getValue().shutdown();\n      }\n    }\n\n    for (int i = 0; i < 320; i++) { // wait till leader is changed\n      try {\n        if (leaderPort == getLeaderPort(getLeader())) {\n          break;\n        }\n        Thread.sleep(100);\n      } catch (Exception e) {\n        continue;\n      }\n    }\n\n    // the original leader should be leader again now - everyone else is down\n    // TODO: I saw this fail once...expected:<7000> but was:<7004>\n    assertEquals(leaderPort, getLeaderPort(getLeader()));\n    //printLayout(zkServer.getZkAddress());\n    //Thread.sleep(100000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/LeaderElectionIntegrationTest#testLeaderElectionAfterClientTimeout().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testLeaderElectionAfterClientTimeout() throws Exception {\n    // TODO: work out the best timing here...\n    System.setProperty(\"zkClientTimeout\", Integer.toString(ZkTestServer.TICK_TIME * 2 + 100));\n    // timeout the leader\n    String leader = getLeader();\n    int leaderPort = getLeaderPort(leader);\n    ZkController zkController = containerMap.get(leaderPort).getZkController();\n\n    zkController.getZkClient().getSolrZooKeeper().closeCnxn();\n    long sessionId = zkClient.getSolrZooKeeper().getSessionId();\n    zkServer.expire(sessionId);\n    \n    for (int i = 0; i < 60; i++) { // wait till leader is changed\n      if (leaderPort != getLeaderPort(getLeader())) {\n        break;\n      }\n      Thread.sleep(100);\n    }\n    \n    // make sure we have waited long enough for the first leader to have come back\n    Thread.sleep(ZkTestServer.TICK_TIME * 2 + 100);\n    \n    // kill everyone but the first leader that should have reconnected by now\n    for (Map.Entry<Integer,CoreContainer> entry : containerMap.entrySet()) {\n      if (entry.getKey() != leaderPort) {\n        entry.getValue().shutdown();\n      }\n    }\n\n    for (int i = 0; i < 320; i++) { // wait till leader is changed\n      try {\n        if (leaderPort == getLeaderPort(getLeader())) {\n          break;\n        }\n        Thread.sleep(100);\n      } catch (Exception e) {\n        continue;\n      }\n    }\n\n    // the original leader should be leader again now - everyone else is down\n    // TODO: I saw this fail once...expected:<7000> but was:<7004>\n    assertEquals(leaderPort, getLeaderPort(getLeader()));\n    //printLayout(zkServer.getZkAddress());\n    //Thread.sleep(100000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"82fbc9a4af34a68002cd5cf8bbac6b604aeef413":["be9f7175e1703e31f8d8de32612b7212db6acf76"],"a9b4296bd51ca61b482138791478afdd0f7d3a3d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","a9b4296bd51ca61b482138791478afdd0f7d3a3d"],"be9f7175e1703e31f8d8de32612b7212db6acf76":["a6378064655e76cd7b908b1cab4ce425b384b508"],"28288370235ed02234a64753cdbf0c6ec096304a":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","a9b4296bd51ca61b482138791478afdd0f7d3a3d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["be9f7175e1703e31f8d8de32612b7212db6acf76","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a6378064655e76cd7b908b1cab4ce425b384b508":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["be9f7175e1703e31f8d8de32612b7212db6acf76","82fbc9a4af34a68002cd5cf8bbac6b604aeef413"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"82fbc9a4af34a68002cd5cf8bbac6b604aeef413":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a9b4296bd51ca61b482138791478afdd0f7d3a3d":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"be9f7175e1703e31f8d8de32612b7212db6acf76":["82fbc9a4af34a68002cd5cf8bbac6b604aeef413","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"28288370235ed02234a64753cdbf0c6ec096304a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"a6378064655e76cd7b908b1cab4ce425b384b508":["be9f7175e1703e31f8d8de32612b7212db6acf76"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["a9b4296bd51ca61b482138791478afdd0f7d3a3d","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","a6378064655e76cd7b908b1cab4ce425b384b508"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0d22ac6a4146774c1bc8400160fc0b6150294e92","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}