{"path":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimplePrimaryNode#handleFetchFiles(Random,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimplePrimaryNode#handleFetchFiles(Random,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","pathOld":"/dev/null","sourceNew":"  /** Called when another node (replica) wants to copy files from us */\n  private boolean handleFetchFiles(Random random, Socket socket, DataInput destIn, DataOutput destOut, BufferedOutputStream bos) throws IOException {\n    Thread.currentThread().setName(\"send\");\n\n    int replicaID = destIn.readVInt();\n    message(\"top: start fetch for R\" + replicaID + \" socket=\" + socket);\n    byte b = destIn.readByte();\n    CopyState copyState;\n    if (b == 0) {\n      // Caller already has CopyState\n      copyState = null;\n    } else if (b == 1) {\n      // Caller does not have CopyState; we pull the latest one:\n      copyState = getCopyState();\n      Thread.currentThread().setName(\"send-R\" + replicaID + \"-\" + copyState.version);\n    } else {\n      // Protocol error:\n      throw new IllegalArgumentException(\"invalid CopyState byte=\" + b);\n    }\n\n    try {\n      if (copyState != null) {\n        // Serialize CopyState on the wire to the client:\n        writeCopyState(copyState, destOut);\n        bos.flush();\n      }\n\n      byte[] buffer = new byte[16384];\n      int fileCount = 0;\n      long totBytesSent = 0;\n      while (true) {\n        byte done = destIn.readByte();\n        if (done == 1) {\n          break;\n        } else if (done != 0) {\n          throw new IllegalArgumentException(\"expected 0 or 1 byte but got \" + done);\n        }\n\n        // Name of the file the replica wants us to send:\n        String fileName = destIn.readString();\n\n        // Starting offset in the file we should start sending bytes from:\n        long fpStart = destIn.readVLong();\n\n        try (IndexInput in = dir.openInput(fileName, IOContext.DEFAULT)) {\n          long len = in.length();\n          //message(\"fetch \" + fileName + \": send len=\" + len);\n          destOut.writeVLong(len);\n          in.seek(fpStart);\n          long upto = fpStart;\n          while (upto < len) {\n            int chunk = (int) Math.min(buffer.length, (len-upto));\n            in.readBytes(buffer, 0, chunk);\n            if (TestNRTReplication.DO_BIT_FLIPS_DURING_COPY) {\n              if (random.nextInt(3000) == 17 && bitFlipped.contains(fileName) == false) {\n                bitFlipped.add(fileName);\n                message(\"file \" + fileName + \" to R\" + replicaID + \": now randomly flipping a bit at byte=\" + upto);\n                int x = random.nextInt(chunk);\n                int bit = random.nextInt(8);\n                buffer[x] ^= 1 << bit;\n              }\n            }\n            destOut.writeBytes(buffer, 0, chunk);\n            upto += chunk;\n            totBytesSent += chunk;\n          }\n        }\n\n        fileCount++;\n      }\n\n      message(\"top: done fetch files for R\" + replicaID + \": sent \" + fileCount + \" files; sent \" + totBytesSent + \" bytes\");\n    } catch (Throwable t) {\n      message(\"top: exception during fetch: \" + t.getMessage() + \"; now close socket\");\n      socket.close();\n      return false;\n    } finally {\n      if (copyState != null) {\n        message(\"top: fetch: now release CopyState\");\n        releaseCopyState(copyState);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9","date":1453892412,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimplePrimaryNode#handleFetchFiles(Random,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimplePrimaryNode#handleFetchFiles(Random,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","sourceNew":"  /** Called when another node (replica) wants to copy files from us */\n  private boolean handleFetchFiles(Random random, Socket socket, DataInput destIn, DataOutput destOut, BufferedOutputStream bos) throws IOException {\n    Thread.currentThread().setName(\"send\");\n\n    int replicaID = destIn.readVInt();\n    message(\"top: start fetch for R\" + replicaID + \" socket=\" + socket);\n    byte b = destIn.readByte();\n    CopyState copyState;\n    if (b == 0) {\n      // Caller already has CopyState\n      copyState = null;\n    } else if (b == 1) {\n      // Caller does not have CopyState; we pull the latest one:\n      copyState = getCopyState();\n      Thread.currentThread().setName(\"send-R\" + replicaID + \"-\" + copyState.version);\n    } else {\n      // Protocol error:\n      throw new IllegalArgumentException(\"invalid CopyState byte=\" + b);\n    }\n\n    try {\n      if (copyState != null) {\n        // Serialize CopyState on the wire to the client:\n        writeCopyState(copyState, destOut);\n        bos.flush();\n      }\n\n      byte[] buffer = new byte[16384];\n      int fileCount = 0;\n      long totBytesSent = 0;\n      while (true) {\n        byte done = destIn.readByte();\n        if (done == 1) {\n          break;\n        } else if (done != 0) {\n          throw new IllegalArgumentException(\"expected 0 or 1 byte but got \" + done);\n        }\n\n        // Name of the file the replica wants us to send:\n        String fileName = destIn.readString();\n\n        // Starting offset in the file we should start sending bytes from:\n        long fpStart = destIn.readVLong();\n\n        try (IndexInput in = dir.openInput(fileName, IOContext.DEFAULT)) {\n          long len = in.length();\n          //message(\"fetch \" + fileName + \": send len=\" + len);\n          destOut.writeVLong(len);\n          in.seek(fpStart);\n          long upto = fpStart;\n          while (upto < len) {\n            int chunk = (int) Math.min(buffer.length, (len-upto));\n            in.readBytes(buffer, 0, chunk);\n            if (doFlipBitsDuringCopy) {\n              if (random.nextInt(3000) == 17 && bitFlipped.contains(fileName) == false) {\n                bitFlipped.add(fileName);\n                message(\"file \" + fileName + \" to R\" + replicaID + \": now randomly flipping a bit at byte=\" + upto);\n                int x = random.nextInt(chunk);\n                int bit = random.nextInt(8);\n                buffer[x] ^= 1 << bit;\n              }\n            }\n            destOut.writeBytes(buffer, 0, chunk);\n            upto += chunk;\n            totBytesSent += chunk;\n          }\n        }\n\n        fileCount++;\n      }\n\n      message(\"top: done fetch files for R\" + replicaID + \": sent \" + fileCount + \" files; sent \" + totBytesSent + \" bytes\");\n    } catch (Throwable t) {\n      message(\"top: exception during fetch: \" + t.getMessage() + \"; now close socket\");\n      socket.close();\n      return false;\n    } finally {\n      if (copyState != null) {\n        message(\"top: fetch: now release CopyState\");\n        releaseCopyState(copyState);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  /** Called when another node (replica) wants to copy files from us */\n  private boolean handleFetchFiles(Random random, Socket socket, DataInput destIn, DataOutput destOut, BufferedOutputStream bos) throws IOException {\n    Thread.currentThread().setName(\"send\");\n\n    int replicaID = destIn.readVInt();\n    message(\"top: start fetch for R\" + replicaID + \" socket=\" + socket);\n    byte b = destIn.readByte();\n    CopyState copyState;\n    if (b == 0) {\n      // Caller already has CopyState\n      copyState = null;\n    } else if (b == 1) {\n      // Caller does not have CopyState; we pull the latest one:\n      copyState = getCopyState();\n      Thread.currentThread().setName(\"send-R\" + replicaID + \"-\" + copyState.version);\n    } else {\n      // Protocol error:\n      throw new IllegalArgumentException(\"invalid CopyState byte=\" + b);\n    }\n\n    try {\n      if (copyState != null) {\n        // Serialize CopyState on the wire to the client:\n        writeCopyState(copyState, destOut);\n        bos.flush();\n      }\n\n      byte[] buffer = new byte[16384];\n      int fileCount = 0;\n      long totBytesSent = 0;\n      while (true) {\n        byte done = destIn.readByte();\n        if (done == 1) {\n          break;\n        } else if (done != 0) {\n          throw new IllegalArgumentException(\"expected 0 or 1 byte but got \" + done);\n        }\n\n        // Name of the file the replica wants us to send:\n        String fileName = destIn.readString();\n\n        // Starting offset in the file we should start sending bytes from:\n        long fpStart = destIn.readVLong();\n\n        try (IndexInput in = dir.openInput(fileName, IOContext.DEFAULT)) {\n          long len = in.length();\n          //message(\"fetch \" + fileName + \": send len=\" + len);\n          destOut.writeVLong(len);\n          in.seek(fpStart);\n          long upto = fpStart;\n          while (upto < len) {\n            int chunk = (int) Math.min(buffer.length, (len-upto));\n            in.readBytes(buffer, 0, chunk);\n            if (TestNRTReplication.DO_BIT_FLIPS_DURING_COPY) {\n              if (random.nextInt(3000) == 17 && bitFlipped.contains(fileName) == false) {\n                bitFlipped.add(fileName);\n                message(\"file \" + fileName + \" to R\" + replicaID + \": now randomly flipping a bit at byte=\" + upto);\n                int x = random.nextInt(chunk);\n                int bit = random.nextInt(8);\n                buffer[x] ^= 1 << bit;\n              }\n            }\n            destOut.writeBytes(buffer, 0, chunk);\n            upto += chunk;\n            totBytesSent += chunk;\n          }\n        }\n\n        fileCount++;\n      }\n\n      message(\"top: done fetch files for R\" + replicaID + \": sent \" + fileCount + \" files; sent \" + totBytesSent + \" bytes\");\n    } catch (Throwable t) {\n      message(\"top: exception during fetch: \" + t.getMessage() + \"; now close socket\");\n      socket.close();\n      return false;\n    } finally {\n      if (copyState != null) {\n        message(\"top: fetch: now release CopyState\");\n        releaseCopyState(copyState);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/nrt/SimplePrimaryNode#handleFetchFiles(Random,Socket,DataInput,DataOutput,BufferedOutputStream).mjava","pathOld":"/dev/null","sourceNew":"  /** Called when another node (replica) wants to copy files from us */\n  private boolean handleFetchFiles(Random random, Socket socket, DataInput destIn, DataOutput destOut, BufferedOutputStream bos) throws IOException {\n    Thread.currentThread().setName(\"send\");\n\n    int replicaID = destIn.readVInt();\n    message(\"top: start fetch for R\" + replicaID + \" socket=\" + socket);\n    byte b = destIn.readByte();\n    CopyState copyState;\n    if (b == 0) {\n      // Caller already has CopyState\n      copyState = null;\n    } else if (b == 1) {\n      // Caller does not have CopyState; we pull the latest one:\n      copyState = getCopyState();\n      Thread.currentThread().setName(\"send-R\" + replicaID + \"-\" + copyState.version);\n    } else {\n      // Protocol error:\n      throw new IllegalArgumentException(\"invalid CopyState byte=\" + b);\n    }\n\n    try {\n      if (copyState != null) {\n        // Serialize CopyState on the wire to the client:\n        writeCopyState(copyState, destOut);\n        bos.flush();\n      }\n\n      byte[] buffer = new byte[16384];\n      int fileCount = 0;\n      long totBytesSent = 0;\n      while (true) {\n        byte done = destIn.readByte();\n        if (done == 1) {\n          break;\n        } else if (done != 0) {\n          throw new IllegalArgumentException(\"expected 0 or 1 byte but got \" + done);\n        }\n\n        // Name of the file the replica wants us to send:\n        String fileName = destIn.readString();\n\n        // Starting offset in the file we should start sending bytes from:\n        long fpStart = destIn.readVLong();\n\n        try (IndexInput in = dir.openInput(fileName, IOContext.DEFAULT)) {\n          long len = in.length();\n          //message(\"fetch \" + fileName + \": send len=\" + len);\n          destOut.writeVLong(len);\n          in.seek(fpStart);\n          long upto = fpStart;\n          while (upto < len) {\n            int chunk = (int) Math.min(buffer.length, (len-upto));\n            in.readBytes(buffer, 0, chunk);\n            if (doFlipBitsDuringCopy) {\n              if (random.nextInt(3000) == 17 && bitFlipped.contains(fileName) == false) {\n                bitFlipped.add(fileName);\n                message(\"file \" + fileName + \" to R\" + replicaID + \": now randomly flipping a bit at byte=\" + upto);\n                int x = random.nextInt(chunk);\n                int bit = random.nextInt(8);\n                buffer[x] ^= 1 << bit;\n              }\n            }\n            destOut.writeBytes(buffer, 0, chunk);\n            upto += chunk;\n            totBytesSent += chunk;\n          }\n        }\n\n        fileCount++;\n      }\n\n      message(\"top: done fetch files for R\" + replicaID + \": sent \" + fileCount + \" files; sent \" + totBytesSent + \" bytes\");\n    } catch (Throwable t) {\n      message(\"top: exception during fetch: \" + t.getMessage() + \"; now close socket\");\n      socket.close();\n      return false;\n    } finally {\n      if (copyState != null) {\n        message(\"top: fetch: now release CopyState\");\n        releaseCopyState(copyState);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["68496c2200e559fb7802f7575427b7a482659afb"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9":["68496c2200e559fb7802f7575427b7a482659afb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"68496c2200e559fb7802f7575427b7a482659afb":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["1baa9aa50ea2e3bb6e5c03f150789720fbcedbc9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}