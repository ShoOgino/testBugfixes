{"path":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p/>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // constant score mode is now enabled per default\n    return TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p/>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // constant score mode is now enabled per default\n    return TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p/>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // constant score mode is now enabled per default\n    return TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p/>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // constant score mode is now enabled per default\n    return TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p/>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // constant score mode is now enabled per default\n    return TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p/>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // constant score mode is now enabled per default\n    return TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","date":1348430063,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p/>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // constant score mode is now enabled per default\n    return TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p/>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // constant score mode is now enabled per default\n    return TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ffced88b5e83e2ec0a42723404a647e766d96b8c","date":1361398349,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p/>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // constant score mode is now enabled per default\n    if (field.hasDocValues() && !field.indexed()) {\n      return new ConstantScoreQuery(FieldCacheRangeFilter.newStringRange(\n            field.getName(), \n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive));\n    } else {\n      MultiTermQuery rangeQuery = TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n      rangeQuery.setRewriteMethod(getRewriteMethod(parser, field));\n      return rangeQuery;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p/>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // constant score mode is now enabled per default\n    return TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3","date":1361894345,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p/>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    if (field.hasDocValues() && !field.indexed()) {\n      if (field.multiValued()) {\n        return new ConstantScoreQuery(DocTermOrdsRangeFilter.newBytesRefRange(\n            field.getName(),\n            part1 == null ? null : new BytesRef(toInternal(part1)),\n            part2 == null ? null : new BytesRef(toInternal(part2)),\n            minInclusive, maxInclusive));\n      } else {\n        return new ConstantScoreQuery(FieldCacheRangeFilter.newStringRange(\n            field.getName(), \n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive));\n      }\n    } else {\n      MultiTermQuery rangeQuery = TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n      rangeQuery.setRewriteMethod(getRewriteMethod(parser, field));\n      return rangeQuery;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p/>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // constant score mode is now enabled per default\n    if (field.hasDocValues() && !field.indexed()) {\n      return new ConstantScoreQuery(FieldCacheRangeFilter.newStringRange(\n            field.getName(), \n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive));\n    } else {\n      MultiTermQuery rangeQuery = TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n      rangeQuery.setRewriteMethod(getRewriteMethod(parser, field));\n      return rangeQuery;\n    }\n  }\n\n","bugFix":null,"bugIntro":["9274621789ce990dbfef455dabdf026bb3184821"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"08970e5b8411182a29412c177eff67ec1110095b","date":1366640815,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p/>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    if (field.hasDocValues() && !field.indexed()) {\n      if (field.multiValued()) {\n        return new ConstantScoreQuery(DocTermOrdsRangeFilter.newBytesRefRange(\n            field.getName(),\n            part1 == null ? null : new BytesRef(toInternal(part1)),\n            part2 == null ? null : new BytesRef(toInternal(part2)),\n            minInclusive, maxInclusive));\n      } else {\n        return new ConstantScoreQuery(FieldCacheRangeFilter.newStringRange(\n            field.getName(), \n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive));\n      }\n    } else {\n      MultiTermQuery rangeQuery = TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n      rangeQuery.setRewriteMethod(getRewriteMethod(parser, field));\n      return rangeQuery;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p/>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    if (field.hasDocValues() && !field.indexed()) {\n      if (field.multiValued()) {\n        return new ConstantScoreQuery(DocTermOrdsRangeFilter.newBytesRefRange(\n            field.getName(),\n            part1 == null ? null : new BytesRef(toInternal(part1)),\n            part2 == null ? null : new BytesRef(toInternal(part2)),\n            minInclusive, maxInclusive));\n      } else {\n        return new ConstantScoreQuery(FieldCacheRangeFilter.newStringRange(\n            field.getName(), \n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive));\n      }\n    } else {\n      MultiTermQuery rangeQuery = TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n      rangeQuery.setRewriteMethod(getRewriteMethod(parser, field));\n      return rangeQuery;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9274621789ce990dbfef455dabdf026bb3184821","date":1400046684,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p/>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    if (field.hasDocValues() && !field.indexed()) {\n      if (field.multiValued()) {\n        return new ConstantScoreQuery(DocTermOrdsRangeFilter.newBytesRefRange(\n            field.getName(),\n            part1 == null ? null : new BytesRef(toInternal(part1)),\n            part2 == null ? null : new BytesRef(toInternal(part2)),\n            minInclusive, maxInclusive));\n      } else {\n        return new ConstantScoreQuery(DocValuesRangeFilter.newStringRange(\n            field.getName(), \n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive));\n      }\n    } else {\n      MultiTermQuery rangeQuery = TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n      rangeQuery.setRewriteMethod(getRewriteMethod(parser, field));\n      return rangeQuery;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p/>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    if (field.hasDocValues() && !field.indexed()) {\n      if (field.multiValued()) {\n        return new ConstantScoreQuery(DocTermOrdsRangeFilter.newBytesRefRange(\n            field.getName(),\n            part1 == null ? null : new BytesRef(toInternal(part1)),\n            part2 == null ? null : new BytesRef(toInternal(part2)),\n            minInclusive, maxInclusive));\n      } else {\n        return new ConstantScoreQuery(FieldCacheRangeFilter.newStringRange(\n            field.getName(), \n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive));\n      }\n    } else {\n      MultiTermQuery rangeQuery = TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n      rangeQuery.setRewriteMethod(getRewriteMethod(parser, field));\n      return rangeQuery;\n    }\n  }\n\n","bugFix":["a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p/>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    if (field.hasDocValues() && !field.indexed()) {\n      if (field.multiValued()) {\n        return new ConstantScoreQuery(DocTermOrdsRangeFilter.newBytesRefRange(\n            field.getName(),\n            part1 == null ? null : new BytesRef(toInternal(part1)),\n            part2 == null ? null : new BytesRef(toInternal(part2)),\n            minInclusive, maxInclusive));\n      } else {\n        return new ConstantScoreQuery(DocValuesRangeFilter.newStringRange(\n            field.getName(), \n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive));\n      }\n    } else {\n      MultiTermQuery rangeQuery = TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n      rangeQuery.setRewriteMethod(getRewriteMethod(parser, field));\n      return rangeQuery;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p/>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    if (field.hasDocValues() && !field.indexed()) {\n      if (field.multiValued()) {\n        return new ConstantScoreQuery(DocTermOrdsRangeFilter.newBytesRefRange(\n            field.getName(),\n            part1 == null ? null : new BytesRef(toInternal(part1)),\n            part2 == null ? null : new BytesRef(toInternal(part2)),\n            minInclusive, maxInclusive));\n      } else {\n        return new ConstantScoreQuery(FieldCacheRangeFilter.newStringRange(\n            field.getName(), \n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive));\n      }\n    } else {\n      MultiTermQuery rangeQuery = TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n      rangeQuery.setRewriteMethod(getRewriteMethod(parser, field));\n      return rangeQuery;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p/>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    if (field.hasDocValues() && !field.indexed()) {\n      if (field.multiValued()) {\n        return new ConstantScoreQuery(DocTermOrdsRangeFilter.newBytesRefRange(\n            field.getName(),\n            part1 == null ? null : new BytesRef(toInternal(part1)),\n            part2 == null ? null : new BytesRef(toInternal(part2)),\n            minInclusive, maxInclusive));\n      } else {\n        return new ConstantScoreQuery(DocValuesRangeFilter.newStringRange(\n            field.getName(), \n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive));\n      }\n    } else {\n      MultiTermQuery rangeQuery = TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n      rangeQuery.setRewriteMethod(getRewriteMethod(parser, field));\n      return rangeQuery;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p/>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    if (field.hasDocValues() && !field.indexed()) {\n      if (field.multiValued()) {\n        return new ConstantScoreQuery(DocTermOrdsRangeFilter.newBytesRefRange(\n            field.getName(),\n            part1 == null ? null : new BytesRef(toInternal(part1)),\n            part2 == null ? null : new BytesRef(toInternal(part2)),\n            minInclusive, maxInclusive));\n      } else {\n        return new ConstantScoreQuery(FieldCacheRangeFilter.newStringRange(\n            field.getName(), \n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive));\n      }\n    } else {\n      MultiTermQuery rangeQuery = TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n      rangeQuery.setRewriteMethod(getRewriteMethod(parser, field));\n      return rangeQuery;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e210ae1e604402eb4eeff2a52e56d189cd4f2f1","date":1423508552,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    if (field.hasDocValues() && !field.indexed()) {\n      if (field.multiValued()) {\n        return new ConstantScoreQuery(DocTermOrdsRangeFilter.newBytesRefRange(\n            field.getName(),\n            part1 == null ? null : new BytesRef(toInternal(part1)),\n            part2 == null ? null : new BytesRef(toInternal(part2)),\n            minInclusive, maxInclusive));\n      } else {\n        return new ConstantScoreQuery(DocValuesRangeFilter.newStringRange(\n            field.getName(), \n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive));\n      }\n    } else {\n      MultiTermQuery rangeQuery = TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n      rangeQuery.setRewriteMethod(getRewriteMethod(parser, field));\n      return rangeQuery;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p/>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    if (field.hasDocValues() && !field.indexed()) {\n      if (field.multiValued()) {\n        return new ConstantScoreQuery(DocTermOrdsRangeFilter.newBytesRefRange(\n            field.getName(),\n            part1 == null ? null : new BytesRef(toInternal(part1)),\n            part2 == null ? null : new BytesRef(toInternal(part2)),\n            minInclusive, maxInclusive));\n      } else {\n        return new ConstantScoreQuery(DocValuesRangeFilter.newStringRange(\n            field.getName(), \n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive));\n      }\n    } else {\n      MultiTermQuery rangeQuery = TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n      rangeQuery.setRewriteMethod(getRewriteMethod(parser, field));\n      return rangeQuery;\n    }\n  }\n\n","bugFix":["c6607c2e2193cd450f258dfc01588ecbb25a75ae"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"484e80062d7ab2729bc82f0311d6a97dd913961a","date":1424450206,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    if (field.hasDocValues() && !field.indexed()) {\n      return DocValuesRangeQuery.newBytesRefRange(\n          field.getName(),\n          part1 == null ? null : new BytesRef(toInternal(part1)),\n          part2 == null ? null : new BytesRef(toInternal(part2)),\n          minInclusive, maxInclusive);\n    } else {\n      MultiTermQuery rangeQuery = TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n      rangeQuery.setRewriteMethod(getRewriteMethod(parser, field));\n      return rangeQuery;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    if (field.hasDocValues() && !field.indexed()) {\n      if (field.multiValued()) {\n        return new ConstantScoreQuery(DocTermOrdsRangeFilter.newBytesRefRange(\n            field.getName(),\n            part1 == null ? null : new BytesRef(toInternal(part1)),\n            part2 == null ? null : new BytesRef(toInternal(part2)),\n            minInclusive, maxInclusive));\n      } else {\n        return new ConstantScoreQuery(DocValuesRangeFilter.newStringRange(\n            field.getName(), \n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive));\n      }\n    } else {\n      MultiTermQuery rangeQuery = TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n      rangeQuery.setRewriteMethod(getRewriteMethod(parser, field));\n      return rangeQuery;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16b25963ad38ed289ebf0f7af31269fa1ce80a11","date":1442083896,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    if (field.hasDocValues() && !field.indexed()) {\n      return DocValuesRangeQuery.newBytesRefRange(\n          field.getName(),\n          part1 == null ? null : new BytesRef(toInternal(part1)),\n          part2 == null ? null : new BytesRef(toInternal(part2)),\n          minInclusive, maxInclusive);\n    } else {\n      SolrRangeQuery rangeQuery = new SolrRangeQuery(\n            field.getName(),\n            part1 == null ? null : new BytesRef(toInternal(part1)),\n            part2 == null ? null : new BytesRef(toInternal(part2)),\n            minInclusive, maxInclusive);\n      return rangeQuery;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    if (field.hasDocValues() && !field.indexed()) {\n      return DocValuesRangeQuery.newBytesRefRange(\n          field.getName(),\n          part1 == null ? null : new BytesRef(toInternal(part1)),\n          part2 == null ? null : new BytesRef(toInternal(part2)),\n          minInclusive, maxInclusive);\n    } else {\n      MultiTermQuery rangeQuery = TermRangeQuery.newStringRange(\n            field.getName(),\n            part1 == null ? null : toInternal(part1),\n            part2 == null ? null : toInternal(part2),\n            minInclusive, maxInclusive);\n      rangeQuery.setRewriteMethod(getRewriteMethod(parser, field));\n      return rangeQuery;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a412a7808b2815566cb17117ebe6638112b9a31","date":1484916151,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    final BytesRef miValue = part1 == null ? null : new BytesRef(toInternal(part1));\n    final BytesRef maxValue = part2 == null ? null : new BytesRef(toInternal(part2));\n    if (field.hasDocValues() && !field.indexed()) {\n      return SortedSetDocValuesField.newRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n    } else {\n      SolrRangeQuery rangeQuery = new SolrRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n      return rangeQuery;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    if (field.hasDocValues() && !field.indexed()) {\n      return DocValuesRangeQuery.newBytesRefRange(\n          field.getName(),\n          part1 == null ? null : new BytesRef(toInternal(part1)),\n          part2 == null ? null : new BytesRef(toInternal(part2)),\n          minInclusive, maxInclusive);\n    } else {\n      SolrRangeQuery rangeQuery = new SolrRangeQuery(\n            field.getName(),\n            part1 == null ? null : new BytesRef(toInternal(part1)),\n            part2 == null ? null : new BytesRef(toInternal(part2)),\n            minInclusive, maxInclusive);\n      return rangeQuery;\n    }\n  }\n\n","bugFix":null,"bugIntro":["b22152b9e1a55aed5f1510ecb2312a0be7056400"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    final BytesRef miValue = part1 == null ? null : new BytesRef(toInternal(part1));\n    final BytesRef maxValue = part2 == null ? null : new BytesRef(toInternal(part2));\n    if (field.hasDocValues() && !field.indexed()) {\n      return SortedSetDocValuesField.newRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n    } else {\n      SolrRangeQuery rangeQuery = new SolrRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n      return rangeQuery;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    if (field.hasDocValues() && !field.indexed()) {\n      return DocValuesRangeQuery.newBytesRefRange(\n          field.getName(),\n          part1 == null ? null : new BytesRef(toInternal(part1)),\n          part2 == null ? null : new BytesRef(toInternal(part2)),\n          minInclusive, maxInclusive);\n    } else {\n      SolrRangeQuery rangeQuery = new SolrRangeQuery(\n            field.getName(),\n            part1 == null ? null : new BytesRef(toInternal(part1)),\n            part2 == null ? null : new BytesRef(toInternal(part2)),\n            minInclusive, maxInclusive);\n      return rangeQuery;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b22152b9e1a55aed5f1510ecb2312a0be7056400","date":1500556211,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    final BytesRef miValue = part1 == null ? null : new BytesRef(toInternal(part1));\n    final BytesRef maxValue = part2 == null ? null : new BytesRef(toInternal(part2));\n    if (field.hasDocValues() && !field.indexed()) {\n      return SortedSetDocValuesField.newSlowRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n    } else {\n      SolrRangeQuery rangeQuery = new SolrRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n      return rangeQuery;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    final BytesRef miValue = part1 == null ? null : new BytesRef(toInternal(part1));\n    final BytesRef maxValue = part2 == null ? null : new BytesRef(toInternal(part2));\n    if (field.hasDocValues() && !field.indexed()) {\n      return SortedSetDocValuesField.newRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n    } else {\n      SolrRangeQuery rangeQuery = new SolrRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n      return rangeQuery;\n    }\n  }\n\n","bugFix":["5a412a7808b2815566cb17117ebe6638112b9a31"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"936cdd5882761db3b844afd6f84ab81cbb011a75","date":1500973524,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    final BytesRef miValue = part1 == null ? null : new BytesRef(toInternal(part1));\n    final BytesRef maxValue = part2 == null ? null : new BytesRef(toInternal(part2));\n    if (field.hasDocValues() && !field.indexed()) {\n      return SortedSetDocValuesField.newSlowRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n    } else {\n      SolrRangeQuery rangeQuery = new SolrRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n      return rangeQuery;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    final BytesRef miValue = part1 == null ? null : new BytesRef(toInternal(part1));\n    final BytesRef maxValue = part2 == null ? null : new BytesRef(toInternal(part2));\n    if (field.hasDocValues() && !field.indexed()) {\n      return SortedSetDocValuesField.newRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n    } else {\n      SolrRangeQuery rangeQuery = new SolrRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n      return rangeQuery;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c81907bd971f786e378654d32b80da32b0e950d","date":1578330742,"type":3,"author":"Houston Putman","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * If the field has docValues enabled, and the range query has '*'s or nulls on either side, then a {@link org.apache.lucene.search.DocValuesFieldExistsQuery} is returned.\n   *\n   * Sub-classes should override the \"getSpecializedRangeQuery\" method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    if (field.hasDocValues() && part1 == null && part2 == null) {\n      return new DocValuesFieldExistsQuery(field.getName());\n    } else {\n      return getSpecializedRangeQuery(parser, field, part1, part2, minInclusive, maxInclusive);\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    final BytesRef miValue = part1 == null ? null : new BytesRef(toInternal(part1));\n    final BytesRef maxValue = part2 == null ? null : new BytesRef(toInternal(part2));\n    if (field.hasDocValues() && !field.indexed()) {\n      return SortedSetDocValuesField.newSlowRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n    } else {\n      SolrRangeQuery rangeQuery = new SolrRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n      return rangeQuery;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca62564055241632cd20d65b5ecb8c8e93bd60c4","date":1578383112,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * If the field has docValues enabled, and the range query has '*'s or nulls on either side, then a {@link org.apache.lucene.search.DocValuesFieldExistsQuery} is returned.\n   *\n   * Sub-classes should override the \"getSpecializedRangeQuery\" method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    if (field.hasDocValues() && part1 == null && part2 == null) {\n      return new DocValuesFieldExistsQuery(field.getName());\n    } else {\n      return getSpecializedRangeQuery(parser, field, part1, part2, minInclusive, maxInclusive);\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    final BytesRef miValue = part1 == null ? null : new BytesRef(toInternal(part1));\n    final BytesRef maxValue = part2 == null ? null : new BytesRef(toInternal(part2));\n    if (field.hasDocValues() && !field.indexed()) {\n      return SortedSetDocValuesField.newSlowRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n    } else {\n      SolrRangeQuery rangeQuery = new SolrRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n      return rangeQuery;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8381df1a98f2a399bf06d747fc8cea1b2a17ae38","date":1578526395,"type":3,"author":"Houston Putman","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    final BytesRef miValue = part1 == null ? null : new BytesRef(toInternal(part1));\n    final BytesRef maxValue = part2 == null ? null : new BytesRef(toInternal(part2));\n    if (field.hasDocValues() && !field.indexed()) {\n      return SortedSetDocValuesField.newSlowRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n    } else {\n      SolrRangeQuery rangeQuery = new SolrRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n      return rangeQuery;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * If the field has docValues enabled, and the range query has '*'s or nulls on either side, then a {@link org.apache.lucene.search.DocValuesFieldExistsQuery} is returned.\n   *\n   * Sub-classes should override the \"getSpecializedRangeQuery\" method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    if (field.hasDocValues() && part1 == null && part2 == null) {\n      return new DocValuesFieldExistsQuery(field.getName());\n    } else {\n      return getSpecializedRangeQuery(parser, field, part1, part2, minInclusive, maxInclusive);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da93834e39ce341a13e42b611d0a83bd3114bba","date":1578567362,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    final BytesRef miValue = part1 == null ? null : new BytesRef(toInternal(part1));\n    final BytesRef maxValue = part2 == null ? null : new BytesRef(toInternal(part2));\n    if (field.hasDocValues() && !field.indexed()) {\n      return SortedSetDocValuesField.newSlowRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n    } else {\n      SolrRangeQuery rangeQuery = new SolrRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n      return rangeQuery;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * If the field has docValues enabled, and the range query has '*'s or nulls on either side, then a {@link org.apache.lucene.search.DocValuesFieldExistsQuery} is returned.\n   *\n   * Sub-classes should override the \"getSpecializedRangeQuery\" method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    if (field.hasDocValues() && part1 == null && part2 == null) {\n      return new DocValuesFieldExistsQuery(field.getName());\n    } else {\n      return getSpecializedRangeQuery(parser, field, part1, part2, minInclusive, maxInclusive);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c7ba457c7f2595139254fab54362be336c5c355","date":1579734055,"type":3,"author":"Houston Putman","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/schema/FieldType#getRangeQuery(QParser,SchemaField,String,String,boolean,boolean).mjava","sourceNew":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes <code>part1</code> and <code>part2</code> as null if they are '*' respectively. <code>minInclusive</code> and <code>maxInclusive</code> are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * By default range queries with '*'s or nulls on either side are treated as existence queries and are created with {@link #getExistenceQuery}.\n   * If unbounded range queries should not be treated as existence queries for a certain fieldType, then {@link #treatUnboundedRangeAsExistence} should be overriden.\n   * <p>\n   * Sub-classes should override the {@link #getSpecializedRangeQuery} method to provide their own range query implementation.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowe\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   * @return a Query instance to perform range search according to given parameters\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    if (part1 == null && part2 == null && treatUnboundedRangeAsExistence(field)) {\n      return getExistenceQuery(parser, field);\n    }\n    return getSpecializedRangeQuery(parser, field, part1, part2, minInclusive, maxInclusive);\n  }\n\n","sourceOld":"  /**\n   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}\n   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true\n   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have\n   * different semantics.\n   * <p>\n   * Sub-classes should override this method to provide their own range query implementation. They should strive to\n   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.\n   *\n   * @param parser       the {@link org.apache.solr.search.QParser} calling the method\n   * @param field        the schema field\n   * @param part1        the lower boundary of the range, nulls are allowed.\n   * @param part2        the upper boundary of the range, nulls are allowed\n   * @param minInclusive whether the minimum of the range is inclusive or not\n   * @param maxInclusive whether the maximum of the range is inclusive or not\n   *  @return a Query instance to perform range search according to given parameters\n   *\n   */\n  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {\n    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)\n    final BytesRef miValue = part1 == null ? null : new BytesRef(toInternal(part1));\n    final BytesRef maxValue = part2 == null ? null : new BytesRef(toInternal(part2));\n    if (field.hasDocValues() && !field.indexed()) {\n      return SortedSetDocValuesField.newSlowRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n    } else {\n      SolrRangeQuery rangeQuery = new SolrRangeQuery(\n            field.getName(),\n            miValue, maxValue,\n            minInclusive, maxInclusive);\n      return rangeQuery;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3":["ffced88b5e83e2ec0a42723404a647e766d96b8c"],"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["c26f00b574427b55127e869b935845554afde1fa"],"8381df1a98f2a399bf06d747fc8cea1b2a17ae38":["0c81907bd971f786e378654d32b80da32b0e950d"],"16b25963ad38ed289ebf0f7af31269fa1ce80a11":["484e80062d7ab2729bc82f0311d6a97dd913961a"],"9274621789ce990dbfef455dabdf026bb3184821":["08970e5b8411182a29412c177eff67ec1110095b"],"484e80062d7ab2729bc82f0311d6a97dd913961a":["1e210ae1e604402eb4eeff2a52e56d189cd4f2f1"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"1da93834e39ce341a13e42b611d0a83bd3114bba":["ca62564055241632cd20d65b5ecb8c8e93bd60c4","8381df1a98f2a399bf06d747fc8cea1b2a17ae38"],"936cdd5882761db3b844afd6f84ab81cbb011a75":["5a412a7808b2815566cb17117ebe6638112b9a31","b22152b9e1a55aed5f1510ecb2312a0be7056400"],"56572ec06f1407c066d6b7399413178b33176cd8":["08970e5b8411182a29412c177eff67ec1110095b","93dd449115a9247533e44bab47e8429e5dccbc6d"],"ca62564055241632cd20d65b5ecb8c8e93bd60c4":["b22152b9e1a55aed5f1510ecb2312a0be7056400","0c81907bd971f786e378654d32b80da32b0e950d"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["16b25963ad38ed289ebf0f7af31269fa1ce80a11","5a412a7808b2815566cb17117ebe6638112b9a31"],"08970e5b8411182a29412c177eff67ec1110095b":["a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3"],"b22152b9e1a55aed5f1510ecb2312a0be7056400":["5a412a7808b2815566cb17117ebe6638112b9a31"],"0c81907bd971f786e378654d32b80da32b0e950d":["b22152b9e1a55aed5f1510ecb2312a0be7056400"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["08970e5b8411182a29412c177eff67ec1110095b","9274621789ce990dbfef455dabdf026bb3184821"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5c7ba457c7f2595139254fab54362be336c5c355":["8381df1a98f2a399bf06d747fc8cea1b2a17ae38"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5a412a7808b2815566cb17117ebe6638112b9a31":["16b25963ad38ed289ebf0f7af31269fa1ce80a11"],"ffced88b5e83e2ec0a42723404a647e766d96b8c":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"1e210ae1e604402eb4eeff2a52e56d189cd4f2f1":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5c7ba457c7f2595139254fab54362be336c5c355"]},"commit2Childs":{"a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3":["08970e5b8411182a29412c177eff67ec1110095b"],"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["ffced88b5e83e2ec0a42723404a647e766d96b8c"],"8381df1a98f2a399bf06d747fc8cea1b2a17ae38":["1da93834e39ce341a13e42b611d0a83bd3114bba","5c7ba457c7f2595139254fab54362be336c5c355"],"16b25963ad38ed289ebf0f7af31269fa1ce80a11":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","5a412a7808b2815566cb17117ebe6638112b9a31"],"9274621789ce990dbfef455dabdf026bb3184821":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"c26f00b574427b55127e869b935845554afde1fa":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"484e80062d7ab2729bc82f0311d6a97dd913961a":["16b25963ad38ed289ebf0f7af31269fa1ce80a11"],"1da93834e39ce341a13e42b611d0a83bd3114bba":[],"936cdd5882761db3b844afd6f84ab81cbb011a75":[],"56572ec06f1407c066d6b7399413178b33176cd8":[],"ca62564055241632cd20d65b5ecb8c8e93bd60c4":["1da93834e39ce341a13e42b611d0a83bd3114bba"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"08970e5b8411182a29412c177eff67ec1110095b":["9274621789ce990dbfef455dabdf026bb3184821","56572ec06f1407c066d6b7399413178b33176cd8","93dd449115a9247533e44bab47e8429e5dccbc6d"],"b22152b9e1a55aed5f1510ecb2312a0be7056400":["936cdd5882761db3b844afd6f84ab81cbb011a75","ca62564055241632cd20d65b5ecb8c8e93bd60c4","0c81907bd971f786e378654d32b80da32b0e950d"],"0c81907bd971f786e378654d32b80da32b0e950d":["8381df1a98f2a399bf06d747fc8cea1b2a17ae38","ca62564055241632cd20d65b5ecb8c8e93bd60c4"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["56572ec06f1407c066d6b7399413178b33176cd8","1e210ae1e604402eb4eeff2a52e56d189cd4f2f1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"5c7ba457c7f2595139254fab54362be336c5c355":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"5a412a7808b2815566cb17117ebe6638112b9a31":["936cdd5882761db3b844afd6f84ab81cbb011a75","90a682dc1bfd188ef61cc28373c7f5d700b4ac75","b22152b9e1a55aed5f1510ecb2312a0be7056400"],"ffced88b5e83e2ec0a42723404a647e766d96b8c":["a9cc184ce59bfe09f739d9aaa34fdb28ddc738c3"],"1e210ae1e604402eb4eeff2a52e56d189cd4f2f1":["484e80062d7ab2729bc82f0311d6a97dd913961a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1da93834e39ce341a13e42b611d0a83bd3114bba","936cdd5882761db3b844afd6f84ab81cbb011a75","56572ec06f1407c066d6b7399413178b33176cd8","90a682dc1bfd188ef61cc28373c7f5d700b4ac75","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}