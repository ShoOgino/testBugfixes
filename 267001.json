{"path":"lucene/src/test/org/apache/lucene/analysis/tokenattributes/TestCharTermAttributeImpl#testAppendableInterfaceWithLongSequences().mjava","commits":[{"id":"b298ec7eee064feb32314fd646a95e38f1152835","date":1271673925,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/analysis/tokenattributes/TestCharTermAttributeImpl#testAppendableInterfaceWithLongSequences().mjava","pathOld":"/dev/null","sourceNew":"  public void testAppendableInterfaceWithLongSequences() {\n    CharTermAttributeImpl t = new CharTermAttributeImpl();\n    t.append((CharSequence) \"01234567890123456789012345678901234567890123456789\");\n    t.append((CharSequence) CharBuffer.wrap(\"01234567890123456789012345678901234567890123456789\".toCharArray()), 3, 50);\n    assertEquals(\"0123456789012345678901234567890123456789012345678934567890123456789012345678901234567890123456789\", t.toString());\n    t.setEmpty().append((CharSequence) new StringBuilder(\"01234567890123456789\"), 5, 17);\n    assertEquals((CharSequence) \"567890123456\", t.toString());\n    t.append(new StringBuffer(t));\n    assertEquals((CharSequence) \"567890123456567890123456\", t.toString());\n    // very wierd, to test if a subSlice is wrapped correct :)\n    CharBuffer buf = CharBuffer.wrap(\"012345678901234567890123456789\".toCharArray(), 3, 15);\n    assertEquals(\"345678901234567\", buf.toString());\n    t.setEmpty().append(buf, 1, 14);\n    assertEquals(\"4567890123456\", t.toString());\n    \n    // finally use a completely custom CharSequence that is not catched by instanceof checks\n    final String longTestString = \"012345678901234567890123456789\";\n    t.append(new CharSequence() {\n      public char charAt(int i) { return longTestString.charAt(i); }\n      public int length() { return longTestString.length(); }\n      public CharSequence subSequence(int start, int end) { return longTestString.subSequence(start, end); }\n      public String toString() { return longTestString; }\n    });\n    assertEquals(\"4567890123456\"+longTestString, t.toString());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01","date":1296400215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/analysis/tokenattributes/TestCharTermAttributeImpl#testAppendableInterfaceWithLongSequences().mjava","pathOld":"lucene/src/test/org/apache/lucene/analysis/tokenattributes/TestCharTermAttributeImpl#testAppendableInterfaceWithLongSequences().mjava","sourceNew":"  public void testAppendableInterfaceWithLongSequences() {\n    CharTermAttributeImpl t = new CharTermAttributeImpl();\n    t.append((CharSequence) \"01234567890123456789012345678901234567890123456789\");\n    t.append((CharSequence) CharBuffer.wrap(\"01234567890123456789012345678901234567890123456789\".toCharArray()), 3, 50);\n    assertEquals(\"0123456789012345678901234567890123456789012345678934567890123456789012345678901234567890123456789\", t.toString());\n    t.setEmpty().append((CharSequence) new StringBuilder(\"01234567890123456789\"), 5, 17);\n    assertEquals((CharSequence) \"567890123456\", t.toString());\n    t.append(new StringBuffer(t));\n    assertEquals((CharSequence) \"567890123456567890123456\", t.toString());\n    // very wierd, to test if a subSlice is wrapped correct :)\n    CharBuffer buf = CharBuffer.wrap(\"012345678901234567890123456789\".toCharArray(), 3, 15);\n    assertEquals(\"345678901234567\", buf.toString());\n    t.setEmpty().append(buf, 1, 14);\n    assertEquals(\"4567890123456\", t.toString());\n    \n    // finally use a completely custom CharSequence that is not catched by instanceof checks\n    final String longTestString = \"012345678901234567890123456789\";\n    t.append(new CharSequence() {\n      public char charAt(int i) { return longTestString.charAt(i); }\n      public int length() { return longTestString.length(); }\n      public CharSequence subSequence(int start, int end) { return longTestString.subSequence(start, end); }\n      @Override\n      public String toString() { return longTestString; }\n    });\n    assertEquals(\"4567890123456\"+longTestString, t.toString());\n  }\n\n","sourceOld":"  public void testAppendableInterfaceWithLongSequences() {\n    CharTermAttributeImpl t = new CharTermAttributeImpl();\n    t.append((CharSequence) \"01234567890123456789012345678901234567890123456789\");\n    t.append((CharSequence) CharBuffer.wrap(\"01234567890123456789012345678901234567890123456789\".toCharArray()), 3, 50);\n    assertEquals(\"0123456789012345678901234567890123456789012345678934567890123456789012345678901234567890123456789\", t.toString());\n    t.setEmpty().append((CharSequence) new StringBuilder(\"01234567890123456789\"), 5, 17);\n    assertEquals((CharSequence) \"567890123456\", t.toString());\n    t.append(new StringBuffer(t));\n    assertEquals((CharSequence) \"567890123456567890123456\", t.toString());\n    // very wierd, to test if a subSlice is wrapped correct :)\n    CharBuffer buf = CharBuffer.wrap(\"012345678901234567890123456789\".toCharArray(), 3, 15);\n    assertEquals(\"345678901234567\", buf.toString());\n    t.setEmpty().append(buf, 1, 14);\n    assertEquals(\"4567890123456\", t.toString());\n    \n    // finally use a completely custom CharSequence that is not catched by instanceof checks\n    final String longTestString = \"012345678901234567890123456789\";\n    t.append(new CharSequence() {\n      public char charAt(int i) { return longTestString.charAt(i); }\n      public int length() { return longTestString.length(); }\n      public CharSequence subSequence(int start, int end) { return longTestString.subSequence(start, end); }\n      public String toString() { return longTestString; }\n    });\n    assertEquals(\"4567890123456\"+longTestString, t.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/analysis/tokenattributes/TestCharTermAttributeImpl#testAppendableInterfaceWithLongSequences().mjava","pathOld":"lucene/src/test/org/apache/lucene/analysis/tokenattributes/TestCharTermAttributeImpl#testAppendableInterfaceWithLongSequences().mjava","sourceNew":"  public void testAppendableInterfaceWithLongSequences() {\n    CharTermAttributeImpl t = new CharTermAttributeImpl();\n    t.append((CharSequence) \"01234567890123456789012345678901234567890123456789\");\n    t.append((CharSequence) CharBuffer.wrap(\"01234567890123456789012345678901234567890123456789\".toCharArray()), 3, 50);\n    assertEquals(\"0123456789012345678901234567890123456789012345678934567890123456789012345678901234567890123456789\", t.toString());\n    t.setEmpty().append((CharSequence) new StringBuilder(\"01234567890123456789\"), 5, 17);\n    assertEquals((CharSequence) \"567890123456\", t.toString());\n    t.append(new StringBuffer(t));\n    assertEquals((CharSequence) \"567890123456567890123456\", t.toString());\n    // very wierd, to test if a subSlice is wrapped correct :)\n    CharBuffer buf = CharBuffer.wrap(\"012345678901234567890123456789\".toCharArray(), 3, 15);\n    assertEquals(\"345678901234567\", buf.toString());\n    t.setEmpty().append(buf, 1, 14);\n    assertEquals(\"4567890123456\", t.toString());\n    \n    // finally use a completely custom CharSequence that is not catched by instanceof checks\n    final String longTestString = \"012345678901234567890123456789\";\n    t.append(new CharSequence() {\n      public char charAt(int i) { return longTestString.charAt(i); }\n      public int length() { return longTestString.length(); }\n      public CharSequence subSequence(int start, int end) { return longTestString.subSequence(start, end); }\n      @Override\n      public String toString() { return longTestString; }\n    });\n    assertEquals(\"4567890123456\"+longTestString, t.toString());\n  }\n\n","sourceOld":"  public void testAppendableInterfaceWithLongSequences() {\n    CharTermAttributeImpl t = new CharTermAttributeImpl();\n    t.append((CharSequence) \"01234567890123456789012345678901234567890123456789\");\n    t.append((CharSequence) CharBuffer.wrap(\"01234567890123456789012345678901234567890123456789\".toCharArray()), 3, 50);\n    assertEquals(\"0123456789012345678901234567890123456789012345678934567890123456789012345678901234567890123456789\", t.toString());\n    t.setEmpty().append((CharSequence) new StringBuilder(\"01234567890123456789\"), 5, 17);\n    assertEquals((CharSequence) \"567890123456\", t.toString());\n    t.append(new StringBuffer(t));\n    assertEquals((CharSequence) \"567890123456567890123456\", t.toString());\n    // very wierd, to test if a subSlice is wrapped correct :)\n    CharBuffer buf = CharBuffer.wrap(\"012345678901234567890123456789\".toCharArray(), 3, 15);\n    assertEquals(\"345678901234567\", buf.toString());\n    t.setEmpty().append(buf, 1, 14);\n    assertEquals(\"4567890123456\", t.toString());\n    \n    // finally use a completely custom CharSequence that is not catched by instanceof checks\n    final String longTestString = \"012345678901234567890123456789\";\n    t.append(new CharSequence() {\n      public char charAt(int i) { return longTestString.charAt(i); }\n      public int length() { return longTestString.length(); }\n      public CharSequence subSequence(int start, int end) { return longTestString.subSequence(start, end); }\n      public String toString() { return longTestString; }\n    });\n    assertEquals(\"4567890123456\"+longTestString, t.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/analysis/tokenattributes/TestCharTermAttributeImpl#testAppendableInterfaceWithLongSequences().mjava","pathOld":"lucene/src/test/org/apache/lucene/analysis/tokenattributes/TestCharTermAttributeImpl#testAppendableInterfaceWithLongSequences().mjava","sourceNew":"  public void testAppendableInterfaceWithLongSequences() {\n    CharTermAttributeImpl t = new CharTermAttributeImpl();\n    t.append((CharSequence) \"01234567890123456789012345678901234567890123456789\");\n    t.append((CharSequence) CharBuffer.wrap(\"01234567890123456789012345678901234567890123456789\".toCharArray()), 3, 50);\n    assertEquals(\"0123456789012345678901234567890123456789012345678934567890123456789012345678901234567890123456789\", t.toString());\n    t.setEmpty().append((CharSequence) new StringBuilder(\"01234567890123456789\"), 5, 17);\n    assertEquals((CharSequence) \"567890123456\", t.toString());\n    t.append(new StringBuffer(t));\n    assertEquals((CharSequence) \"567890123456567890123456\", t.toString());\n    // very wierd, to test if a subSlice is wrapped correct :)\n    CharBuffer buf = CharBuffer.wrap(\"012345678901234567890123456789\".toCharArray(), 3, 15);\n    assertEquals(\"345678901234567\", buf.toString());\n    t.setEmpty().append(buf, 1, 14);\n    assertEquals(\"4567890123456\", t.toString());\n    \n    // finally use a completely custom CharSequence that is not catched by instanceof checks\n    final String longTestString = \"012345678901234567890123456789\";\n    t.append(new CharSequence() {\n      public char charAt(int i) { return longTestString.charAt(i); }\n      public int length() { return longTestString.length(); }\n      public CharSequence subSequence(int start, int end) { return longTestString.subSequence(start, end); }\n      @Override\n      public String toString() { return longTestString; }\n    });\n    assertEquals(\"4567890123456\"+longTestString, t.toString());\n  }\n\n","sourceOld":"  public void testAppendableInterfaceWithLongSequences() {\n    CharTermAttributeImpl t = new CharTermAttributeImpl();\n    t.append((CharSequence) \"01234567890123456789012345678901234567890123456789\");\n    t.append((CharSequence) CharBuffer.wrap(\"01234567890123456789012345678901234567890123456789\".toCharArray()), 3, 50);\n    assertEquals(\"0123456789012345678901234567890123456789012345678934567890123456789012345678901234567890123456789\", t.toString());\n    t.setEmpty().append((CharSequence) new StringBuilder(\"01234567890123456789\"), 5, 17);\n    assertEquals((CharSequence) \"567890123456\", t.toString());\n    t.append(new StringBuffer(t));\n    assertEquals((CharSequence) \"567890123456567890123456\", t.toString());\n    // very wierd, to test if a subSlice is wrapped correct :)\n    CharBuffer buf = CharBuffer.wrap(\"012345678901234567890123456789\".toCharArray(), 3, 15);\n    assertEquals(\"345678901234567\", buf.toString());\n    t.setEmpty().append(buf, 1, 14);\n    assertEquals(\"4567890123456\", t.toString());\n    \n    // finally use a completely custom CharSequence that is not catched by instanceof checks\n    final String longTestString = \"012345678901234567890123456789\";\n    t.append(new CharSequence() {\n      public char charAt(int i) { return longTestString.charAt(i); }\n      public int length() { return longTestString.length(); }\n      public CharSequence subSequence(int start, int end) { return longTestString.subSequence(start, end); }\n      public String toString() { return longTestString; }\n    });\n    assertEquals(\"4567890123456\"+longTestString, t.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/analysis/tokenattributes/TestCharTermAttributeImpl#testAppendableInterfaceWithLongSequences().mjava","pathOld":"lucene/src/test/org/apache/lucene/analysis/tokenattributes/TestCharTermAttributeImpl#testAppendableInterfaceWithLongSequences().mjava","sourceNew":"  public void testAppendableInterfaceWithLongSequences() {\n    CharTermAttributeImpl t = new CharTermAttributeImpl();\n    t.append((CharSequence) \"01234567890123456789012345678901234567890123456789\");\n    t.append((CharSequence) CharBuffer.wrap(\"01234567890123456789012345678901234567890123456789\".toCharArray()), 3, 50);\n    assertEquals(\"0123456789012345678901234567890123456789012345678934567890123456789012345678901234567890123456789\", t.toString());\n    t.setEmpty().append((CharSequence) new StringBuilder(\"01234567890123456789\"), 5, 17);\n    assertEquals((CharSequence) \"567890123456\", t.toString());\n    t.append(new StringBuffer(t));\n    assertEquals((CharSequence) \"567890123456567890123456\", t.toString());\n    // very wierd, to test if a subSlice is wrapped correct :)\n    CharBuffer buf = CharBuffer.wrap(\"012345678901234567890123456789\".toCharArray(), 3, 15);\n    assertEquals(\"345678901234567\", buf.toString());\n    t.setEmpty().append(buf, 1, 14);\n    assertEquals(\"4567890123456\", t.toString());\n    \n    // finally use a completely custom CharSequence that is not catched by instanceof checks\n    final String longTestString = \"012345678901234567890123456789\";\n    t.append(new CharSequence() {\n      public char charAt(int i) { return longTestString.charAt(i); }\n      public int length() { return longTestString.length(); }\n      public CharSequence subSequence(int start, int end) { return longTestString.subSequence(start, end); }\n      @Override\n      public String toString() { return longTestString; }\n    });\n    assertEquals(\"4567890123456\"+longTestString, t.toString());\n  }\n\n","sourceOld":"  public void testAppendableInterfaceWithLongSequences() {\n    CharTermAttributeImpl t = new CharTermAttributeImpl();\n    t.append((CharSequence) \"01234567890123456789012345678901234567890123456789\");\n    t.append((CharSequence) CharBuffer.wrap(\"01234567890123456789012345678901234567890123456789\".toCharArray()), 3, 50);\n    assertEquals(\"0123456789012345678901234567890123456789012345678934567890123456789012345678901234567890123456789\", t.toString());\n    t.setEmpty().append((CharSequence) new StringBuilder(\"01234567890123456789\"), 5, 17);\n    assertEquals((CharSequence) \"567890123456\", t.toString());\n    t.append(new StringBuffer(t));\n    assertEquals((CharSequence) \"567890123456567890123456\", t.toString());\n    // very wierd, to test if a subSlice is wrapped correct :)\n    CharBuffer buf = CharBuffer.wrap(\"012345678901234567890123456789\".toCharArray(), 3, 15);\n    assertEquals(\"345678901234567\", buf.toString());\n    t.setEmpty().append(buf, 1, 14);\n    assertEquals(\"4567890123456\", t.toString());\n    \n    // finally use a completely custom CharSequence that is not catched by instanceof checks\n    final String longTestString = \"012345678901234567890123456789\";\n    t.append(new CharSequence() {\n      public char charAt(int i) { return longTestString.charAt(i); }\n      public int length() { return longTestString.length(); }\n      public CharSequence subSequence(int start, int end) { return longTestString.subSequence(start, end); }\n      @Override\n      public String toString() { return longTestString; }\n    });\n    assertEquals(\"4567890123456\"+longTestString, t.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01":["b298ec7eee064feb32314fd646a95e38f1152835"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["b298ec7eee064feb32314fd646a95e38f1152835","70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b298ec7eee064feb32314fd646a95e38f1152835":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["b298ec7eee064feb32314fd646a95e38f1152835","70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b298ec7eee064feb32314fd646a95e38f1152835"],"b298ec7eee064feb32314fd646a95e38f1152835":["70e12dd4a648dadc5999dde1f0fb3a71a6ae4b01","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}