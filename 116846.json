{"path":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","commits":[{"id":"89f15687f60bd49cd3d9de427e85c17fd9397d61","date":1309381327,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator();\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = IndexReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator();\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        Term t = new Term(Consts.FULL, first);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            SeekStatus result = othertes[i].seekCeil(t.bytes(), false);\n            assert result == SeekStatus.FOUND;\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getDeletedDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        Term t = new Term(Consts.FULL, first);\n        // TODO: fix bug in MTE seekExact and use that instead.\n        SeekStatus result = mainte.seekCeil(t.bytes(), false);\n        assert result == SeekStatus.FOUND; // // TODO (Facet): explicit check / throw exception?\n        mainde = mainte.docs(MultiFields.getDeletedDocs(mainreader), mainde);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            result = othertes[i].seekCeil(t.bytes(), false);\n            assert result == SeekStatus.FOUND; // TODO (Facet): explicit check / throw exception?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getDeletedDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0dbc7493b4f3e9c8bfa60028d6a4d82e2e9f0b67","e26e3b5080bfb6fcabdc46d0072efe441de1a21b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0dbc7493b4f3e9c8bfa60028d6a4d82e2e9f0b67","date":1309449942,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","sourceNew":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator();\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = IndexReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator();\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      // TODO: use a pq here\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getDeletedDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        mainde = mainte.docs(MultiFields.getDeletedDocs(mainreader), mainde);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getDeletedDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","sourceOld":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator();\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = IndexReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator();\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        Term t = new Term(Consts.FULL, first);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            SeekStatus result = othertes[i].seekCeil(t.bytes(), false);\n            assert result == SeekStatus.FOUND;\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getDeletedDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        Term t = new Term(Consts.FULL, first);\n        // TODO: fix bug in MTE seekExact and use that instead.\n        SeekStatus result = mainte.seekCeil(t.bytes(), false);\n        assert result == SeekStatus.FOUND; // // TODO (Facet): explicit check / throw exception?\n        mainde = mainte.docs(MultiFields.getDeletedDocs(mainreader), mainde);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            result = othertes[i].seekCeil(t.bytes(), false);\n            assert result == SeekStatus.FOUND; // TODO (Facet): explicit check / throw exception?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getDeletedDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","bugFix":["89f15687f60bd49cd3d9de427e85c17fd9397d61"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb","date":1309960478,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","sourceNew":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator();\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = IndexReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator();\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      // TODO: use a pq here\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        mainde = mainte.docs(MultiFields.getLiveDocs(mainreader), mainde);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","sourceOld":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator();\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = IndexReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator();\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      // TODO: use a pq here\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getDeletedDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        mainde = mainte.docs(MultiFields.getDeletedDocs(mainreader), mainde);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getDeletedDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator();\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = IndexReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator();\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      // TODO: use a pq here\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        mainde = mainte.docs(MultiFields.getLiveDocs(mainreader), mainde);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator();\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = IndexReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator();\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      // TODO: use a pq here\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        mainde = mainte.docs(MultiFields.getLiveDocs(mainreader), mainde);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ea469eab8fd0f3032f4fcde1c644a721e8309d3b","date":1320301582,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/taxonomy/lucene/LuceneTaxonomyWriter#addTaxonomies(Directory[],OrdinalMap[]).mjava","sourceNew":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator();\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = IndexReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator();\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      // TODO: use a pq here\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        mainde = mainte.docs(MultiFields.getLiveDocs(mainreader), mainde);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","sourceOld":"  /**\n   * Take all the categories of one or more given taxonomies, and add them to\n   * the main taxonomy (this), if they are not already there.\n   * <P>\n   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,\n   * mapping its ordinals to the ordinals in the enlarged main taxonomy.\n   * These mapping are saved into an array of OrdinalMap objects given by the\n   * user, one for each of the given taxonomies (not including \"this\", the main\n   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the\n   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. \n   * <P> \n   * Note that the taxonomies to be added are given as Directory objects,\n   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are\n   * currently managed by an open TaxonomyWriter, make sure to commit() (or\n   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,\n   * and does not need to be commit()ed before this call. \n   */\n  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {\n    // To prevent us stepping on the rest of this class's decisions on when\n    // to open a reader, and when not, we'll be opening a new reader instead\n    // of using the existing \"reader\" object:\n    IndexReader mainreader = openReader();\n    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?\n    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);\n    assert terms != null; // TODO (Facet): explicit check / throw exception?\n    TermsEnum mainte = terms.iterator();\n    DocsEnum mainde = null;\n\n    IndexReader[] otherreaders = new IndexReader[taxonomies.length];\n    TermsEnum[] othertes = new TermsEnum[taxonomies.length];\n    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i] = IndexReader.open(taxonomies[i]);\n      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);\n      assert terms != null; // TODO (Facet): explicit check / throw exception?\n      othertes[i] = terms.iterator();\n      // Also tell the ordinal maps their expected sizes:\n      ordinalMaps[i].setSize(otherreaders[i].numDocs());\n    }\n\n    CategoryPath cp = new CategoryPath();\n\n    // We keep a \"current\" cursor over the alphabetically-ordered list of\n    // categories in each taxonomy. We start the cursor on the first\n    // (alphabetically) category of each taxonomy:\n\n    String currentMain;\n    String[] currentOthers = new String[taxonomies.length];\n    currentMain = nextTE(mainte);\n    int otherTaxonomiesLeft = 0;\n    for (int i=0; i<taxonomies.length; i++) {\n      currentOthers[i] = nextTE(othertes[i]);\n      if (currentOthers[i]!=null) {\n        otherTaxonomiesLeft++;\n      }\n    }\n\n    // And then, at each step look at the first (alphabetically) of the\n    // current taxonomies.\n    // NOTE: The most efficient way we could have done this is using a\n    // PriorityQueue. But for simplicity, and assuming that usually we'll\n    // have a very small number of other taxonomies (often just 1), we use\n    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)\n    // per step)\n\n    while (otherTaxonomiesLeft>0) {\n      // TODO: use a pq here\n      String first=null;\n      for (int i=0; i<taxonomies.length; i++) {\n        if (currentOthers[i]==null) continue;\n        if (first==null || first.compareTo(currentOthers[i])>0) {\n          first = currentOthers[i];\n        }\n      }\n      int comp = 0;\n      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {\n        // If 'first' is before currentMain, or currentMain is null,\n        // then 'first' is a new category and we need to add it to the\n        // main taxonomy. Then for all taxonomies with this 'first'\n        // category, we need to add the new category number to their\n        // map, and move to the next category in all of them.\n        cp.clear();\n        cp.add(first, delimiter);\n        // We can call internalAddCategory() instead of addCategory()\n        // because we know the category hasn't been seen yet.\n        int newordinal = internalAddCategory(cp, cp.length());\n        // TODO (Facet): we already had this term in our hands before, in nextTE...\n        // // TODO (Facet): no need to make this term?\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // remember the remapping of this ordinal. Note how\n            // this requires reading a posting list from the index -\n            // but since we do this in lexical order of terms, just\n            // like Lucene's merge works, we hope there are few seeks.\n            // TODO (Facet): is there a quicker way? E.g., not specifying the\n            // next term by name every time?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n            // and move to the next category in the i'th taxonomy \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else if (comp==0) {\n        // 'first' and currentMain are the same, so both the main and some\n        // other taxonomies need to be moved, but a category doesn't need\n        // to be added because it already existed in the main taxonomy.\n\n        // TODO (Facet): Again, is there a quicker way?\n        mainde = mainte.docs(MultiFields.getLiveDocs(mainreader), mainde);\n        mainde.nextDoc(); // TODO (Facet): check?\n        int newordinal = mainde.docID();\n\n        currentMain = nextTE(mainte);\n        for (int i=0; i<taxonomies.length; i++) {\n          if (first.equals(currentOthers[i])) {\n            // TODO (Facet): again, is there a quicker way?\n            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i]);\n            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?\n            int origordinal = otherdocsEnum[i].docID();\n            ordinalMaps[i].addMapping(origordinal, newordinal);\n\n            // and move to the next category \n            currentOthers[i] = nextTE(othertes[i]);\n            if (currentOthers[i]==null) {\n              otherTaxonomiesLeft--;\n            }\n          }\n        }\n      } else /* comp > 0 */ {\n        // The currentMain doesn't appear in any of the other taxonomies -\n        // we don't need to do anything, just continue to the next one\n        currentMain = nextTE(mainte);\n      }\n    }\n\n    // Close all the readers we've opened, and also tell the ordinal maps\n    // we're done adding to them\n    mainreader.close();\n    for (int i=0; i<taxonomies.length; i++) {\n      otherreaders[i].close();\n      // We never actually added a mapping for the root ordinal - let's do\n      // it now, just so that the map is complete (every ordinal between 0\n      // and size-1 is remapped)\n      ordinalMaps[i].addMapping(0, 0);\n      ordinalMaps[i].addDone();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"ea469eab8fd0f3032f4fcde1c644a721e8309d3b":["e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb":["0dbc7493b4f3e9c8bfa60028d6a4d82e2e9f0b67"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0dbc7493b4f3e9c8bfa60028d6a4d82e2e9f0b67":["89f15687f60bd49cd3d9de427e85c17fd9397d61"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"89f15687f60bd49cd3d9de427e85c17fd9397d61":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ea469eab8fd0f3032f4fcde1c644a721e8309d3b"]},"commit2Childs":{"ea469eab8fd0f3032f4fcde1c644a721e8309d3b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb":["ea469eab8fd0f3032f4fcde1c644a721e8309d3b","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d083e83f225b11e5fdd900e83d26ddb385b6955c","89f15687f60bd49cd3d9de427e85c17fd9397d61","817d8435e9135b756f08ce6710ab0baac51bdf88"],"0dbc7493b4f3e9c8bfa60028d6a4d82e2e9f0b67":["e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"89f15687f60bd49cd3d9de427e85c17fd9397d61":["0dbc7493b4f3e9c8bfa60028d6a4d82e2e9f0b67"],"817d8435e9135b756f08ce6710ab0baac51bdf88":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}