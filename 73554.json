{"path":"lucene/core/src/java/org/apache/lucene/index/SortedDocValues#lookupTerm(BytesRef,BytesRef).mjava","commits":[{"id":"9d7e5f3aa5935964617824d1f9b2599ddb334464","date":1353762831,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedDocValues#lookupTerm(BytesRef,BytesRef).mjava","pathOld":"/dev/null","sourceNew":"  // nocommit javadocs\n  public int lookupTerm(BytesRef key, BytesRef spare) {\n    // this special case is the reason that Arrays.binarySearch() isn't useful.\n    if (key == null) {\n      throw new IllegalArgumentException(\"key must not be null\");\n    }\n\n    int low = 0;\n    int high = getValueCount()-1;\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      lookupOrd(mid, spare);\n      int cmp = spare.compareTo(key);\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else if (cmp > 0) {\n        high = mid - 1;\n      } else {\n        return mid; // key found\n      }\n    }\n\n    return -(low + 1);  // key not found.\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2dd9934a49477c83301120ba51827d91eb3606d5","date":1353767072,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedDocValues#lookupTerm(BytesRef,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedDocValues#lookupTerm(BytesRef,BytesRef).mjava","sourceNew":"  // nocommit javadocs\n  public int lookupTerm(BytesRef key, BytesRef spare) {\n\n    int low = 0;\n    int high = getValueCount()-1;\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      lookupOrd(mid, spare);\n      int cmp = spare.compareTo(key);\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else if (cmp > 0) {\n        high = mid - 1;\n      } else {\n        return mid; // key found\n      }\n    }\n\n    return -(low + 1);  // key not found.\n  }\n\n","sourceOld":"  // nocommit javadocs\n  public int lookupTerm(BytesRef key, BytesRef spare) {\n    // this special case is the reason that Arrays.binarySearch() isn't useful.\n    if (key == null) {\n      throw new IllegalArgumentException(\"key must not be null\");\n    }\n\n    int low = 0;\n    int high = getValueCount()-1;\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      lookupOrd(mid, spare);\n      int cmp = spare.compareTo(key);\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else if (cmp > 0) {\n        high = mid - 1;\n      } else {\n        return mid; // key found\n      }\n    }\n\n    return -(low + 1);  // key not found.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7178a82d1134111f4511f28bb9ad57573a57d93","date":1354112608,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedDocValues#lookupTerm(BytesRef,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedDocValues#lookupTerm(BytesRef,BytesRef).mjava","sourceNew":"  /** If {@code key} exists, returns its ordinal, else\n   *  returns {@code -insertionPoint-1}, like {@code\n   *  Arrays.binarySearch}.\n   *\n   *  @param key Key to look up\n   *  @param spare Spare BytesRef\n   **/\n  public int lookupTerm(BytesRef key, BytesRef spare) {\n\n    int low = 0;\n    int high = getValueCount()-1;\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      lookupOrd(mid, spare);\n      int cmp = spare.compareTo(key);\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else if (cmp > 0) {\n        high = mid - 1;\n      } else {\n        return mid; // key found\n      }\n    }\n\n    return -(low + 1);  // key not found.\n  }\n\n","sourceOld":"  // nocommit javadocs\n  public int lookupTerm(BytesRef key, BytesRef spare) {\n\n    int low = 0;\n    int high = getValueCount()-1;\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      lookupOrd(mid, spare);\n      int cmp = spare.compareTo(key);\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else if (cmp > 0) {\n        high = mid - 1;\n      } else {\n        return mid; // key found\n      }\n    }\n\n    return -(low + 1);  // key not found.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46bf1a48fd33bf34430ade646b7dd67b984be2a8","date":1358725746,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedDocValues#lookupTerm(BytesRef,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedDocValues#lookupTerm(BytesRef,BytesRef).mjava","sourceNew":"  /** If {@code key} exists, returns its ordinal, else\n   *  returns {@code -insertionPoint-1}, like {@code\n   *  Arrays.binarySearch}.\n   *\n   *  @param key Key to look up\n   *  @param spare Spare BytesRef\n   **/\n  public int lookupTerm(BytesRef key, BytesRef spare) {\n\n    int low = 0;\n    int high = getValueCount()-1;\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      lookupOrd(mid, spare);\n      int cmp = spare.compareTo(key);\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else if (cmp > 0) {\n        high = mid - 1;\n      } else {\n        // nocommit is this the right way... else caller can\n        // pass this spare down to DiskDV, which will then\n        // \"use\" our byte[] ...\n        spare.bytes = BytesRef.EMPTY_BYTES;\n        return mid; // key found\n      }\n    }\n\n    // nocommit is this the right way...\n    spare.bytes = BytesRef.EMPTY_BYTES;\n    return -(low + 1);  // key not found.\n  }\n\n","sourceOld":"  /** If {@code key} exists, returns its ordinal, else\n   *  returns {@code -insertionPoint-1}, like {@code\n   *  Arrays.binarySearch}.\n   *\n   *  @param key Key to look up\n   *  @param spare Spare BytesRef\n   **/\n  public int lookupTerm(BytesRef key, BytesRef spare) {\n\n    int low = 0;\n    int high = getValueCount()-1;\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      lookupOrd(mid, spare);\n      int cmp = spare.compareTo(key);\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else if (cmp > 0) {\n        high = mid - 1;\n      } else {\n        return mid; // key found\n      }\n    }\n\n    return -(low + 1);  // key not found.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8750a5466b5d1b5eb7ae596d683f85b2f8d6cc70","date":1358730615,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedDocValues#lookupTerm(BytesRef,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedDocValues#lookupTerm(BytesRef,BytesRef).mjava","sourceNew":"  /** If {@code key} exists, returns its ordinal, else\n   *  returns {@code -insertionPoint-1}, like {@code\n   *  Arrays.binarySearch}.\n   *\n   *  @param key Key to look up\n   *  @param spare Spare BytesRef\n   **/\n  // nocommit make this protected so codecs can impl better\n  // version ...\n  public int lookupTerm(BytesRef key, BytesRef spare) {\n\n    int low = 0;\n    int high = getValueCount()-1;\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      lookupOrd(mid, spare);\n      int cmp = spare.compareTo(key);\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else if (cmp > 0) {\n        high = mid - 1;\n      } else {\n        // nocommit is this the right way... else caller can\n        // pass this spare down to DiskDV, which will then\n        // \"use\" our byte[] ...\n        spare.bytes = BytesRef.EMPTY_BYTES;\n        return mid; // key found\n      }\n    }\n\n    // nocommit is this the right way...\n    spare.bytes = BytesRef.EMPTY_BYTES;\n    return -(low + 1);  // key not found.\n  }\n\n","sourceOld":"  /** If {@code key} exists, returns its ordinal, else\n   *  returns {@code -insertionPoint-1}, like {@code\n   *  Arrays.binarySearch}.\n   *\n   *  @param key Key to look up\n   *  @param spare Spare BytesRef\n   **/\n  public int lookupTerm(BytesRef key, BytesRef spare) {\n\n    int low = 0;\n    int high = getValueCount()-1;\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      lookupOrd(mid, spare);\n      int cmp = spare.compareTo(key);\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else if (cmp > 0) {\n        high = mid - 1;\n      } else {\n        // nocommit is this the right way... else caller can\n        // pass this spare down to DiskDV, which will then\n        // \"use\" our byte[] ...\n        spare.bytes = BytesRef.EMPTY_BYTES;\n        return mid; // key found\n      }\n    }\n\n    // nocommit is this the right way...\n    spare.bytes = BytesRef.EMPTY_BYTES;\n    return -(low + 1);  // key not found.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"49bbfc33f80659ba9aa9d301edaae82dd4e01b5a","date":1358789155,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedDocValues#lookupTerm(BytesRef,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedDocValues#lookupTerm(BytesRef,BytesRef).mjava","sourceNew":"  /** If {@code key} exists, returns its ordinal, else\n   *  returns {@code -insertionPoint-1}, like {@code\n   *  Arrays.binarySearch}.\n   *\n   *  @param key Key to look up\n   *  @param spare Spare BytesRef\n   **/\n  public int lookupTerm(BytesRef key, BytesRef spare) {\n\n    int low = 0;\n    int high = getValueCount()-1;\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      lookupOrd(mid, spare);\n      int cmp = spare.compareTo(key);\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else if (cmp > 0) {\n        high = mid - 1;\n      } else {\n        // nocommit is this the right way... else caller can\n        // pass this spare down to DiskDV, which will then\n        // \"use\" our byte[] ...\n        spare.bytes = BytesRef.EMPTY_BYTES;\n        return mid; // key found\n      }\n    }\n\n    // nocommit is this the right way...\n    spare.bytes = BytesRef.EMPTY_BYTES;\n    return -(low + 1);  // key not found.\n  }\n\n","sourceOld":"  /** If {@code key} exists, returns its ordinal, else\n   *  returns {@code -insertionPoint-1}, like {@code\n   *  Arrays.binarySearch}.\n   *\n   *  @param key Key to look up\n   *  @param spare Spare BytesRef\n   **/\n  // nocommit make this protected so codecs can impl better\n  // version ...\n  public int lookupTerm(BytesRef key, BytesRef spare) {\n\n    int low = 0;\n    int high = getValueCount()-1;\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      lookupOrd(mid, spare);\n      int cmp = spare.compareTo(key);\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else if (cmp > 0) {\n        high = mid - 1;\n      } else {\n        // nocommit is this the right way... else caller can\n        // pass this spare down to DiskDV, which will then\n        // \"use\" our byte[] ...\n        spare.bytes = BytesRef.EMPTY_BYTES;\n        return mid; // key found\n      }\n    }\n\n    // nocommit is this the right way...\n    spare.bytes = BytesRef.EMPTY_BYTES;\n    return -(low + 1);  // key not found.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5933c1e50db9e9c0cae38886e1551fe0309b96a9","date":1359352414,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedDocValues#lookupTerm(BytesRef,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedDocValues#lookupTerm(BytesRef,BytesRef).mjava","sourceNew":"  /** If {@code key} exists, returns its ordinal, else\n   *  returns {@code -insertionPoint-1}, like {@code\n   *  Arrays.binarySearch}.\n   *\n   *  @param key Key to look up\n   *  @param spare Spare BytesRef\n   **/\n  public int lookupTerm(BytesRef key, BytesRef spare) {\n\n    int low = 0;\n    int high = getValueCount()-1;\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      lookupOrd(mid, spare);\n      int cmp = spare.compareTo(key);\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else if (cmp > 0) {\n        high = mid - 1;\n      } else {\n        // nocommit is this the right way... else caller can\n        // pass this spare down to DiskDV, which will then\n        // \"use\" our byte[] ...\n        spare.bytes = BytesRef.EMPTY_BYTES;\n        spare.offset = 0;\n        spare.length = 0;\n        return mid; // key found\n      }\n    }\n\n    // nocommit is this the right way...\n    spare.bytes = BytesRef.EMPTY_BYTES;\n    spare.offset = 0;\n    spare.length = 0;\n    return -(low + 1);  // key not found.\n  }\n\n","sourceOld":"  /** If {@code key} exists, returns its ordinal, else\n   *  returns {@code -insertionPoint-1}, like {@code\n   *  Arrays.binarySearch}.\n   *\n   *  @param key Key to look up\n   *  @param spare Spare BytesRef\n   **/\n  public int lookupTerm(BytesRef key, BytesRef spare) {\n\n    int low = 0;\n    int high = getValueCount()-1;\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      lookupOrd(mid, spare);\n      int cmp = spare.compareTo(key);\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else if (cmp > 0) {\n        high = mid - 1;\n      } else {\n        // nocommit is this the right way... else caller can\n        // pass this spare down to DiskDV, which will then\n        // \"use\" our byte[] ...\n        spare.bytes = BytesRef.EMPTY_BYTES;\n        return mid; // key found\n      }\n    }\n\n    // nocommit is this the right way...\n    spare.bytes = BytesRef.EMPTY_BYTES;\n    return -(low + 1);  // key not found.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c62e7afee69a9aa7036185473ffd37ed723755b3","date":1359388738,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedDocValues#lookupTerm(BytesRef,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedDocValues#lookupTerm(BytesRef,BytesRef).mjava","sourceNew":"  /** If {@code key} exists, returns its ordinal, else\n   *  returns {@code -insertionPoint-1}, like {@code\n   *  Arrays.binarySearch}.\n   *\n   *  @param key Key to look up\n   *  @param spare Spare BytesRef\n   **/\n  // nocommit: what does spare mean? its no spare: because people rely upon its return value!\n  // if its 'result' then the parameter and javadoc needs changing, otherwise things need fixing\n  // unconditionally set its value to \"NONSENSE\" bytes to see the bugs!\n  public int lookupTerm(BytesRef key, BytesRef spare) {\n\n    int low = 0;\n    int high = getValueCount()-1;\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      lookupOrd(mid, spare);\n      int cmp = spare.compareTo(key);\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else if (cmp > 0) {\n        high = mid - 1;\n      } else {\n        // nocommit: we shouldnt have to set spare at all if its actually a spare, but its not!\n        // ant test  -Dtestcase=TestFieldCacheRewriteMethod -Dtests.method=testRegexps -Dtests.seed=AFC4A08B212CE143 -Dtests.slow=true -Dtests.locale=th -Dtests.timezone=Canada/Mountain -Dtests.file.encoding=ISO-8859-1\n        spare.bytes = BytesRef.EMPTY_BYTES;\n        spare.offset = 0;\n        spare.length = 0;\n        return mid; // key found\n      }\n    }\n\n    // nocommit: we shouldnt have to set spare at all if its actually a spare, but its not!\n    // ant test  -Dtestcase=TestFieldCacheRewriteMethod -Dtests.method=testRegexps -Dtests.seed=AFC4A08B212CE143 -Dtests.slow=true -Dtests.locale=th -Dtests.timezone=Canada/Mountain -Dtests.file.encoding=ISO-8859-1\n    spare.bytes = BytesRef.EMPTY_BYTES;\n    spare.offset = 0;\n    spare.length = 0;\n    return -(low + 1);  // key not found.\n  }\n\n","sourceOld":"  /** If {@code key} exists, returns its ordinal, else\n   *  returns {@code -insertionPoint-1}, like {@code\n   *  Arrays.binarySearch}.\n   *\n   *  @param key Key to look up\n   *  @param spare Spare BytesRef\n   **/\n  public int lookupTerm(BytesRef key, BytesRef spare) {\n\n    int low = 0;\n    int high = getValueCount()-1;\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      lookupOrd(mid, spare);\n      int cmp = spare.compareTo(key);\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else if (cmp > 0) {\n        high = mid - 1;\n      } else {\n        // nocommit is this the right way... else caller can\n        // pass this spare down to DiskDV, which will then\n        // \"use\" our byte[] ...\n        spare.bytes = BytesRef.EMPTY_BYTES;\n        spare.offset = 0;\n        spare.length = 0;\n        return mid; // key found\n      }\n    }\n\n    // nocommit is this the right way...\n    spare.bytes = BytesRef.EMPTY_BYTES;\n    spare.offset = 0;\n    spare.length = 0;\n    return -(low + 1);  // key not found.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f062bd51bf0f5e04c51d9aa8d5a722d9860421b0","date":1359420014,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedDocValues#lookupTerm(BytesRef,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedDocValues#lookupTerm(BytesRef,BytesRef).mjava","sourceNew":"  /** If {@code key} exists, returns its ordinal, else\n   *  returns {@code -insertionPoint-1}, like {@code\n   *  Arrays.binarySearch}.\n   *\n   *  @param key Key to look up\n   *  @param spare Spare BytesRef\n   **/\n  // nocommit: what does spare mean? its no spare: because people rely upon its return value!\n  // if its 'result' then the parameter and javadoc needs changing, otherwise things need fixing\n  // unconditionally set its value to \"NONSENSE\" bytes to see the bugs!\n  public int lookupTerm(BytesRef key, BytesRef spare) {\n\n    int low = 0;\n    int high = getValueCount()-1;\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      lookupOrd(mid, spare);\n      int cmp = spare.compareTo(key);\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else if (cmp > 0) {\n        high = mid - 1;\n      } else {\n        return mid; // key found\n      }\n    }\n\n    return -(low + 1);  // key not found.\n  }\n\n","sourceOld":"  /** If {@code key} exists, returns its ordinal, else\n   *  returns {@code -insertionPoint-1}, like {@code\n   *  Arrays.binarySearch}.\n   *\n   *  @param key Key to look up\n   *  @param spare Spare BytesRef\n   **/\n  // nocommit: what does spare mean? its no spare: because people rely upon its return value!\n  // if its 'result' then the parameter and javadoc needs changing, otherwise things need fixing\n  // unconditionally set its value to \"NONSENSE\" bytes to see the bugs!\n  public int lookupTerm(BytesRef key, BytesRef spare) {\n\n    int low = 0;\n    int high = getValueCount()-1;\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      lookupOrd(mid, spare);\n      int cmp = spare.compareTo(key);\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else if (cmp > 0) {\n        high = mid - 1;\n      } else {\n        // nocommit: we shouldnt have to set spare at all if its actually a spare, but its not!\n        // ant test  -Dtestcase=TestFieldCacheRewriteMethod -Dtests.method=testRegexps -Dtests.seed=AFC4A08B212CE143 -Dtests.slow=true -Dtests.locale=th -Dtests.timezone=Canada/Mountain -Dtests.file.encoding=ISO-8859-1\n        spare.bytes = BytesRef.EMPTY_BYTES;\n        spare.offset = 0;\n        spare.length = 0;\n        return mid; // key found\n      }\n    }\n\n    // nocommit: we shouldnt have to set spare at all if its actually a spare, but its not!\n    // ant test  -Dtestcase=TestFieldCacheRewriteMethod -Dtests.method=testRegexps -Dtests.seed=AFC4A08B212CE143 -Dtests.slow=true -Dtests.locale=th -Dtests.timezone=Canada/Mountain -Dtests.file.encoding=ISO-8859-1\n    spare.bytes = BytesRef.EMPTY_BYTES;\n    spare.offset = 0;\n    spare.length = 0;\n    return -(low + 1);  // key not found.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d5a5a419065ad4cdc70485f83fa9fe9373aaa8b","date":1359664357,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SortedDocValues#lookupTerm(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SortedDocValues#lookupTerm(BytesRef,BytesRef).mjava","sourceNew":"  /** If {@code key} exists, returns its ordinal, else\n   *  returns {@code -insertionPoint-1}, like {@code\n   *  Arrays.binarySearch}.\n   *\n   *  @param key Key to look up\n   *  @param spare Spare BytesRef\n   **/\n  // nocommit: what does spare mean? its no spare: because people rely upon its return value!\n  // if its 'result' then the parameter and javadoc needs changing, otherwise things need fixing\n  // unconditionally set its value to \"NONSENSE\" bytes to see the bugs!\n  public int lookupTerm(BytesRef key) {\n    BytesRef spare = new BytesRef();\n    int low = 0;\n    int high = getValueCount()-1;\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      lookupOrd(mid, spare);\n      int cmp = spare.compareTo(key);\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else if (cmp > 0) {\n        high = mid - 1;\n      } else {\n        return mid; // key found\n      }\n    }\n\n    return -(low + 1);  // key not found.\n  }\n\n","sourceOld":"  /** If {@code key} exists, returns its ordinal, else\n   *  returns {@code -insertionPoint-1}, like {@code\n   *  Arrays.binarySearch}.\n   *\n   *  @param key Key to look up\n   *  @param spare Spare BytesRef\n   **/\n  // nocommit: what does spare mean? its no spare: because people rely upon its return value!\n  // if its 'result' then the parameter and javadoc needs changing, otherwise things need fixing\n  // unconditionally set its value to \"NONSENSE\" bytes to see the bugs!\n  public int lookupTerm(BytesRef key, BytesRef spare) {\n\n    int low = 0;\n    int high = getValueCount()-1;\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      lookupOrd(mid, spare);\n      int cmp = spare.compareTo(key);\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else if (cmp > 0) {\n        high = mid - 1;\n      } else {\n        return mid; // key found\n      }\n    }\n\n    return -(low + 1);  // key not found.\n  }\n\n","bugFix":null,"bugIntro":["f7558b5077dd4abd457be151475f13b541f4f13e"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"46bf1a48fd33bf34430ade646b7dd67b984be2a8":["f7178a82d1134111f4511f28bb9ad57573a57d93"],"c62e7afee69a9aa7036185473ffd37ed723755b3":["5933c1e50db9e9c0cae38886e1551fe0309b96a9"],"8750a5466b5d1b5eb7ae596d683f85b2f8d6cc70":["46bf1a48fd33bf34430ade646b7dd67b984be2a8"],"2dd9934a49477c83301120ba51827d91eb3606d5":["9d7e5f3aa5935964617824d1f9b2599ddb334464"],"f7178a82d1134111f4511f28bb9ad57573a57d93":["2dd9934a49477c83301120ba51827d91eb3606d5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3d5a5a419065ad4cdc70485f83fa9fe9373aaa8b":["f062bd51bf0f5e04c51d9aa8d5a722d9860421b0"],"5933c1e50db9e9c0cae38886e1551fe0309b96a9":["49bbfc33f80659ba9aa9d301edaae82dd4e01b5a"],"9d7e5f3aa5935964617824d1f9b2599ddb334464":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f062bd51bf0f5e04c51d9aa8d5a722d9860421b0":["c62e7afee69a9aa7036185473ffd37ed723755b3"],"49bbfc33f80659ba9aa9d301edaae82dd4e01b5a":["8750a5466b5d1b5eb7ae596d683f85b2f8d6cc70"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"46bf1a48fd33bf34430ade646b7dd67b984be2a8":["8750a5466b5d1b5eb7ae596d683f85b2f8d6cc70"],"c62e7afee69a9aa7036185473ffd37ed723755b3":["f062bd51bf0f5e04c51d9aa8d5a722d9860421b0"],"8750a5466b5d1b5eb7ae596d683f85b2f8d6cc70":["49bbfc33f80659ba9aa9d301edaae82dd4e01b5a"],"2dd9934a49477c83301120ba51827d91eb3606d5":["f7178a82d1134111f4511f28bb9ad57573a57d93"],"f7178a82d1134111f4511f28bb9ad57573a57d93":["46bf1a48fd33bf34430ade646b7dd67b984be2a8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9d7e5f3aa5935964617824d1f9b2599ddb334464","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3d5a5a419065ad4cdc70485f83fa9fe9373aaa8b":[],"5933c1e50db9e9c0cae38886e1551fe0309b96a9":["c62e7afee69a9aa7036185473ffd37ed723755b3"],"9d7e5f3aa5935964617824d1f9b2599ddb334464":["2dd9934a49477c83301120ba51827d91eb3606d5"],"f062bd51bf0f5e04c51d9aa8d5a722d9860421b0":["3d5a5a419065ad4cdc70485f83fa9fe9373aaa8b"],"49bbfc33f80659ba9aa9d301edaae82dd4e01b5a":["5933c1e50db9e9c0cae38886e1551fe0309b96a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3d5a5a419065ad4cdc70485f83fa9fe9373aaa8b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}